//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox


public struct AssociateAdminAccountOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAppsListOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteNotificationChannelOutput: Swift.Sendable {

    public init() { }
}

public struct DeletePolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteProtocolsListOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteResourceSetOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateAdminAccountOutput: Swift.Sendable {

    public init() { }
}

public struct PutAdminAccountOutput: Swift.Sendable {

    public init() { }
}

public struct PutNotificationChannelOutput: Swift.Sendable {

    public init() { }
}

extension FMSClientTypes {

    public enum AccountRoleStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleted
        case deleting
        case pendingdeletion
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountRoleStatus] {
            return [
                .creating,
                .deleted,
                .deleting,
                .pendingdeletion,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .pendingdeletion: return "PENDING_DELETION"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    /// Configures the accounts within the administrator's Organizations organization that the specified Firewall Manager administrator can apply policies to.
    public struct AccountScope: Swift.Sendable {
        /// The list of accounts within the organization that the specified Firewall Manager administrator either can or cannot apply policies to, based on the value of ExcludeSpecifiedAccounts. If ExcludeSpecifiedAccounts is set to true, then the Firewall Manager administrator can apply policies to all members of the organization except for the accounts in this list. If ExcludeSpecifiedAccounts is set to false, then the Firewall Manager administrator can only apply policies to the accounts in this list.
        public var accounts: [Swift.String]?
        /// A boolean value that indicates if the administrator can apply policies to all accounts within an organization. If true, the administrator can apply policies to all accounts within the organization. You can either enable management of all accounts through this operation, or you can specify a list of accounts to manage in AccountScope$Accounts. You cannot specify both.
        public var allAccountsEnabled: Swift.Bool
        /// A boolean value that excludes the accounts in AccountScope$Accounts from the administrator's scope. If true, the Firewall Manager administrator can apply policies to all members of the organization except for the accounts listed in AccountScope$Accounts. You can either specify a list of accounts to exclude by AccountScope$Accounts, or you can enable management of all accounts by AccountScope$AllAccountsEnabled. You cannot specify both.
        public var excludeSpecifiedAccounts: Swift.Bool

        public init(
            accounts: [Swift.String]? = nil,
            allAccountsEnabled: Swift.Bool = false,
            excludeSpecifiedAccounts: Swift.Bool = false
        )
        {
            self.accounts = accounts
            self.allAccountsEnabled = allAccountsEnabled
            self.excludeSpecifiedAccounts = excludeSpecifiedAccounts
        }
    }
}

extension FMSClientTypes {

    /// Describes a remediation action target.
    public struct ActionTarget: Swift.Sendable {
        /// A description of the remediation action target.
        public var description: Swift.String?
        /// The ID of the remediation target.
        public var resourceId: Swift.String?

        public init(
            description: Swift.String? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.description = description
            self.resourceId = resourceId
        }
    }
}

extension FMSClientTypes {

    public enum OrganizationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case offboarding
        case offboardingcomplete
        case onboarding
        case onboardingcomplete
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationStatus] {
            return [
                .offboarding,
                .offboardingcomplete,
                .onboarding,
                .onboardingcomplete
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .offboarding: return "OFFBOARDING"
            case .offboardingcomplete: return "OFFBOARDING_COMPLETE"
            case .onboarding: return "ONBOARDING"
            case .onboardingcomplete: return "ONBOARDING_COMPLETE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    /// Contains high level information about the Firewall Manager administrator account.
    public struct AdminAccountSummary: Swift.Sendable {
        /// The Amazon Web Services account ID of the Firewall Manager administrator's account.
        public var adminAccount: Swift.String?
        /// A boolean value that indicates if the administrator is the default administrator. If true, then this is the default administrator account. The default administrator can manage third-party firewalls and has full administrative scope. There is only one default administrator account per organization. For information about Firewall Manager default administrator accounts, see [Managing Firewall Manager administrators](https://docs.aws.amazon.com/waf/latest/developerguide/fms-administrators.html) in the Firewall Manager Developer Guide.
        public var defaultAdmin: Swift.Bool
        /// The current status of the request to onboard a member account as an Firewall Manager administrator.
        ///
        /// * ONBOARDING - The account is onboarding to Firewall Manager as an administrator.
        ///
        /// * ONBOARDING_COMPLETE - Firewall Manager The account is onboarded to Firewall Manager as an administrator, and can perform actions on the resources defined in their [AdminScope].
        ///
        /// * OFFBOARDING - The account is being removed as an Firewall Manager administrator.
        ///
        /// * OFFBOARDING_COMPLETE - The account has been removed as an Firewall Manager administrator.
        public var status: FMSClientTypes.OrganizationStatus?

        public init(
            adminAccount: Swift.String? = nil,
            defaultAdmin: Swift.Bool = false,
            status: FMSClientTypes.OrganizationStatus? = nil
        )
        {
            self.adminAccount = adminAccount
            self.defaultAdmin = defaultAdmin
            self.status = status
        }
    }
}

extension FMSClientTypes {

    /// Defines the Organizations organizational units (OUs) that the specified Firewall Manager administrator can apply policies to. For more information about OUs in Organizations, see [Managing organizational units (OUs) ](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_ous.html) in the Organizations User Guide.
    public struct OrganizationalUnitScope: Swift.Sendable {
        /// A boolean value that indicates if the administrator can apply policies to all OUs within an organization. If true, the administrator can manage all OUs within the organization. You can either enable management of all OUs through this operation, or you can specify OUs to manage in OrganizationalUnitScope$OrganizationalUnits. You cannot specify both.
        public var allOrganizationalUnitsEnabled: Swift.Bool
        /// A boolean value that excludes the OUs in OrganizationalUnitScope$OrganizationalUnits from the administrator's scope. If true, the Firewall Manager administrator can apply policies to all OUs in the organization except for the OUs listed in OrganizationalUnitScope$OrganizationalUnits. You can either specify a list of OUs to exclude by OrganizationalUnitScope$OrganizationalUnits, or you can enable management of all OUs by OrganizationalUnitScope$AllOrganizationalUnitsEnabled. You cannot specify both.
        public var excludeSpecifiedOrganizationalUnits: Swift.Bool
        /// The list of OUs within the organization that the specified Firewall Manager administrator either can or cannot apply policies to, based on the value of OrganizationalUnitScope$ExcludeSpecifiedOrganizationalUnits. If OrganizationalUnitScope$ExcludeSpecifiedOrganizationalUnits is set to true, then the Firewall Manager administrator can apply policies to all OUs in the organization except for the OUs in this list. If OrganizationalUnitScope$ExcludeSpecifiedOrganizationalUnits is set to false, then the Firewall Manager administrator can only apply policies to the OUs in this list.
        public var organizationalUnits: [Swift.String]?

        public init(
            allOrganizationalUnitsEnabled: Swift.Bool = false,
            excludeSpecifiedOrganizationalUnits: Swift.Bool = false,
            organizationalUnits: [Swift.String]? = nil
        )
        {
            self.allOrganizationalUnitsEnabled = allOrganizationalUnitsEnabled
            self.excludeSpecifiedOrganizationalUnits = excludeSpecifiedOrganizationalUnits
            self.organizationalUnits = organizationalUnits
        }
    }
}

extension FMSClientTypes {

    public enum SecurityServiceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dnsFirewall
        case importNetworkFirewall
        case networkAclCommon
        case networkFirewall
        case securityGroupsCommon
        case securityGroupsContentAudit
        case securityGroupsUsageAudit
        case shieldAdvanced
        case thirdPartyFirewall
        case waf
        case wafv2
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityServiceType] {
            return [
                .dnsFirewall,
                .importNetworkFirewall,
                .networkAclCommon,
                .networkFirewall,
                .securityGroupsCommon,
                .securityGroupsContentAudit,
                .securityGroupsUsageAudit,
                .shieldAdvanced,
                .thirdPartyFirewall,
                .waf,
                .wafv2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dnsFirewall: return "DNS_FIREWALL"
            case .importNetworkFirewall: return "IMPORT_NETWORK_FIREWALL"
            case .networkAclCommon: return "NETWORK_ACL_COMMON"
            case .networkFirewall: return "NETWORK_FIREWALL"
            case .securityGroupsCommon: return "SECURITY_GROUPS_COMMON"
            case .securityGroupsContentAudit: return "SECURITY_GROUPS_CONTENT_AUDIT"
            case .securityGroupsUsageAudit: return "SECURITY_GROUPS_USAGE_AUDIT"
            case .shieldAdvanced: return "SHIELD_ADVANCED"
            case .thirdPartyFirewall: return "THIRD_PARTY_FIREWALL"
            case .waf: return "WAF"
            case .wafv2: return "WAFV2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    /// Defines the policy types that the specified Firewall Manager administrator can manage.
    public struct PolicyTypeScope: Swift.Sendable {
        /// Allows the specified Firewall Manager administrator to manage all Firewall Manager policy types, except for third-party policy types. Third-party policy types can only be managed by the Firewall Manager default administrator.
        public var allPolicyTypesEnabled: Swift.Bool
        /// The list of policy types that the specified Firewall Manager administrator can manage.
        public var policyTypes: [FMSClientTypes.SecurityServiceType]?

        public init(
            allPolicyTypesEnabled: Swift.Bool = false,
            policyTypes: [FMSClientTypes.SecurityServiceType]? = nil
        )
        {
            self.allPolicyTypesEnabled = allPolicyTypesEnabled
            self.policyTypes = policyTypes
        }
    }
}

extension FMSClientTypes {

    /// Defines the Amazon Web Services Regions that the specified Firewall Manager administrator can manage.
    public struct RegionScope: Swift.Sendable {
        /// Allows the specified Firewall Manager administrator to manage all Amazon Web Services Regions.
        public var allRegionsEnabled: Swift.Bool
        /// The Amazon Web Services Regions that the specified Firewall Manager administrator can perform actions in.
        public var regions: [Swift.String]?

        public init(
            allRegionsEnabled: Swift.Bool = false,
            regions: [Swift.String]? = nil
        )
        {
            self.allRegionsEnabled = allRegionsEnabled
            self.regions = regions
        }
    }
}

extension FMSClientTypes {

    /// Defines the resources that the Firewall Manager administrator can manage. For more information about administrative scope, see [Managing Firewall Manager administrators](https://docs.aws.amazon.com/waf/latest/developerguide/fms-administrators.html) in the Firewall Manager Developer Guide.
    public struct AdminScope: Swift.Sendable {
        /// Defines the accounts that the specified Firewall Manager administrator can apply policies to.
        public var accountScope: FMSClientTypes.AccountScope?
        /// Defines the Organizations organizational units that the specified Firewall Manager administrator can apply policies to. For more information about OUs in Organizations, see [Managing organizational units (OUs) ](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_ous.html) in the Organizations User Guide.
        public var organizationalUnitScope: FMSClientTypes.OrganizationalUnitScope?
        /// Defines the Firewall Manager policy types that the specified Firewall Manager administrator can create and manage.
        public var policyTypeScope: FMSClientTypes.PolicyTypeScope?
        /// Defines the Amazon Web Services Regions that the specified Firewall Manager administrator can perform actions in.
        public var regionScope: FMSClientTypes.RegionScope?

        public init(
            accountScope: FMSClientTypes.AccountScope? = nil,
            organizationalUnitScope: FMSClientTypes.OrganizationalUnitScope? = nil,
            policyTypeScope: FMSClientTypes.PolicyTypeScope? = nil,
            regionScope: FMSClientTypes.RegionScope? = nil
        )
        {
            self.accountScope = accountScope
            self.organizationalUnitScope = organizationalUnitScope
            self.policyTypeScope = policyTypeScope
            self.regionScope = regionScope
        }
    }
}

extension FMSClientTypes {

    /// An individual Firewall Manager application.
    public struct App: Swift.Sendable {
        /// The application's name.
        /// This member is required.
        public var appName: Swift.String?
        /// The application's port number, for example 80.
        /// This member is required.
        public var port: Swift.Int?
        /// The IP protocol name or number. The name can be one of tcp, udp, or icmp. For information on possible numbers, see [Protocol Numbers](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml).
        /// This member is required.
        public var `protocol`: Swift.String?

        public init(
            appName: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: Swift.String? = nil
        )
        {
            self.appName = appName
            self.port = port
            self.`protocol` = `protocol`
        }
    }
}

extension FMSClientTypes {

    /// An Firewall Manager applications list.
    public struct AppsListData: Swift.Sendable {
        /// An array of applications in the Firewall Manager applications list.
        /// This member is required.
        public var appsList: [FMSClientTypes.App]?
        /// The time that the Firewall Manager applications list was created.
        public var createTime: Foundation.Date?
        /// The time that the Firewall Manager applications list was last updated.
        public var lastUpdateTime: Foundation.Date?
        /// The ID of the Firewall Manager applications list.
        public var listId: Swift.String?
        /// The name of the Firewall Manager applications list.
        /// This member is required.
        public var listName: Swift.String?
        /// A unique identifier for each update to the list. When you update the list, the update token must match the token of the current version of the application list. You can retrieve the update token by getting the list.
        public var listUpdateToken: Swift.String?
        /// A map of previous version numbers to their corresponding App object arrays.
        public var previousAppsList: [Swift.String: [FMSClientTypes.App]]?

        public init(
            appsList: [FMSClientTypes.App]? = nil,
            createTime: Foundation.Date? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            listId: Swift.String? = nil,
            listName: Swift.String? = nil,
            listUpdateToken: Swift.String? = nil,
            previousAppsList: [Swift.String: [FMSClientTypes.App]]? = nil
        )
        {
            self.appsList = appsList
            self.createTime = createTime
            self.lastUpdateTime = lastUpdateTime
            self.listId = listId
            self.listName = listName
            self.listUpdateToken = listUpdateToken
            self.previousAppsList = previousAppsList
        }
    }
}

extension FMSClientTypes {

    /// Details of the Firewall Manager applications list.
    public struct AppsListDataSummary: Swift.Sendable {
        /// An array of App objects in the Firewall Manager applications list.
        public var appsList: [FMSClientTypes.App]?
        /// The Amazon Resource Name (ARN) of the applications list.
        public var listArn: Swift.String?
        /// The ID of the applications list.
        public var listId: Swift.String?
        /// The name of the applications list.
        public var listName: Swift.String?

        public init(
            appsList: [FMSClientTypes.App]? = nil,
            listArn: Swift.String? = nil,
            listId: Swift.String? = nil,
            listName: Swift.String? = nil
        )
        {
            self.appsList = appsList
            self.listArn = listArn
            self.listId = listId
            self.listName = listName
        }
    }
}

/// The operation failed because of a system problem, even though the request was valid. Retry your request.
public struct InternalErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The parameters of the request were invalid.
public struct InvalidInputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInputException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The operation failed because there was nothing to do or the operation wasn't possible. For example, you might have submitted an AssociateAdminAccount request for an account ID that was already set as the Firewall Manager administrator. Or you might have tried to access a Region that's disabled by default, and that you need to enable for the Firewall Manager administrator account and for Organizations before you can access it.
public struct InvalidOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOperationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The operation exceeds a resource limit, for example, the maximum number of policy objects that you can create for an Amazon Web Services account. For more information, see [Firewall Manager Limits](https://docs.aws.amazon.com/waf/latest/developerguide/fms-limits.html) in the WAF Developer Guide.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateAdminAccountInput: Swift.Sendable {
    /// The Amazon Web Services account ID to associate with Firewall Manager as the Firewall Manager default administrator account. This account must be a member account of the organization in Organizations whose resources you want to protect. For more information about Organizations, see [Managing the Amazon Web Services Accounts in Your Organization](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_accounts.html).
    /// This member is required.
    public var adminAccount: Swift.String?

    public init(
        adminAccount: Swift.String? = nil
    )
    {
        self.adminAccount = adminAccount
    }
}

extension FMSClientTypes {

    public enum ThirdPartyFirewall: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fortigateCloudNativeFirewall
        case paloAltoNetworksCloudNgfw
        case sdkUnknown(Swift.String)

        public static var allCases: [ThirdPartyFirewall] {
            return [
                .fortigateCloudNativeFirewall,
                .paloAltoNetworksCloudNgfw
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fortigateCloudNativeFirewall: return "FORTIGATE_CLOUD_NATIVE_FIREWALL"
            case .paloAltoNetworksCloudNgfw: return "PALO_ALTO_NETWORKS_CLOUD_NGFW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AssociateThirdPartyFirewallInput: Swift.Sendable {
    /// The name of the third-party firewall vendor.
    /// This member is required.
    public var thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall?

    public init(
        thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall? = nil
    )
    {
        self.thirdPartyFirewall = thirdPartyFirewall
    }
}

extension FMSClientTypes {

    public enum ThirdPartyFirewallAssociationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notExist
        case offboarding
        case offboardComplete
        case onboarding
        case onboardComplete
        case sdkUnknown(Swift.String)

        public static var allCases: [ThirdPartyFirewallAssociationStatus] {
            return [
                .notExist,
                .offboarding,
                .offboardComplete,
                .onboarding,
                .onboardComplete
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notExist: return "NOT_EXIST"
            case .offboarding: return "OFFBOARDING"
            case .offboardComplete: return "OFFBOARD_COMPLETE"
            case .onboarding: return "ONBOARDING"
            case .onboardComplete: return "ONBOARD_COMPLETE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AssociateThirdPartyFirewallOutput: Swift.Sendable {
    /// The current status for setting a Firewall Manager policy administrator's account as an administrator of the third-party firewall tenant.
    ///
    /// * ONBOARDING - The Firewall Manager policy administrator is being designated as a tenant administrator.
    ///
    /// * ONBOARD_COMPLETE - The Firewall Manager policy administrator is designated as a tenant administrator.
    ///
    /// * OFFBOARDING - The Firewall Manager policy administrator is being removed as a tenant administrator.
    ///
    /// * OFFBOARD_COMPLETE - The Firewall Manager policy administrator has been removed as a tenant administrator.
    ///
    /// * NOT_EXIST - The Firewall Manager policy administrator doesn't exist as a tenant administrator.
    public var thirdPartyFirewallStatus: FMSClientTypes.ThirdPartyFirewallAssociationStatus?

    public init(
        thirdPartyFirewallStatus: FMSClientTypes.ThirdPartyFirewallAssociationStatus? = nil
    )
    {
        self.thirdPartyFirewallStatus = thirdPartyFirewallStatus
    }
}

extension FMSClientTypes {

    /// Violation detail for network interfaces associated with an EC2 instance.
    public struct AwsEc2NetworkInterfaceViolation: Swift.Sendable {
        /// List of security groups that violate the rules specified in the primary security group of the Firewall Manager policy.
        public var violatingSecurityGroups: [Swift.String]?
        /// The resource ID of the network interface.
        public var violationTarget: Swift.String?

        public init(
            violatingSecurityGroups: [Swift.String]? = nil,
            violationTarget: Swift.String? = nil
        )
        {
            self.violatingSecurityGroups = violatingSecurityGroups
            self.violationTarget = violationTarget
        }
    }
}

extension FMSClientTypes {

    /// Violation detail for an EC2 instance resource.
    public struct AwsEc2InstanceViolation: Swift.Sendable {
        /// Violation detail for network interfaces associated with the EC2 instance.
        public var awsEc2NetworkInterfaceViolations: [FMSClientTypes.AwsEc2NetworkInterfaceViolation]?
        /// The resource ID of the EC2 instance.
        public var violationTarget: Swift.String?

        public init(
            awsEc2NetworkInterfaceViolations: [FMSClientTypes.AwsEc2NetworkInterfaceViolation]? = nil,
            violationTarget: Swift.String? = nil
        )
        {
            self.awsEc2NetworkInterfaceViolations = awsEc2NetworkInterfaceViolations
            self.violationTarget = violationTarget
        }
    }
}

public struct BatchAssociateResourceInput: Swift.Sendable {
    /// The uniform resource identifiers (URIs) of resources that should be associated to the resource set. The URIs must be Amazon Resource Names (ARNs).
    /// This member is required.
    public var items: [Swift.String]?
    /// A unique identifier for the resource set, used in a request to refer to the resource set.
    /// This member is required.
    public var resourceSetIdentifier: Swift.String?

    public init(
        items: [Swift.String]? = nil,
        resourceSetIdentifier: Swift.String? = nil
    )
    {
        self.items = items
        self.resourceSetIdentifier = resourceSetIdentifier
    }
}

extension FMSClientTypes {

    public enum FailedItemReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notvalidaccountid
        case notvalidarn
        case notvalidpartition
        case notvalidregion
        case notvalidresourcetype
        case notvalidservice
        case sdkUnknown(Swift.String)

        public static var allCases: [FailedItemReason] {
            return [
                .notvalidaccountid,
                .notvalidarn,
                .notvalidpartition,
                .notvalidregion,
                .notvalidresourcetype,
                .notvalidservice
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notvalidaccountid: return "NOT_VALID_ACCOUNT_ID"
            case .notvalidarn: return "NOT_VALID_ARN"
            case .notvalidpartition: return "NOT_VALID_PARTITION"
            case .notvalidregion: return "NOT_VALID_REGION"
            case .notvalidresourcetype: return "NOT_VALID_RESOURCE_TYPE"
            case .notvalidservice: return "NOT_VALID_SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    /// Details of a resource that failed when trying to update it's association to a resource set.
    public struct FailedItem: Swift.Sendable {
        /// The reason the resource's association could not be updated.
        public var reason: FMSClientTypes.FailedItemReason?
        /// The univeral resource indicator (URI) of the resource that failed.
        public var uri: Swift.String?

        public init(
            reason: FMSClientTypes.FailedItemReason? = nil,
            uri: Swift.String? = nil
        )
        {
            self.reason = reason
            self.uri = uri
        }
    }
}

public struct BatchAssociateResourceOutput: Swift.Sendable {
    /// The resources that failed to associate to the resource set.
    /// This member is required.
    public var failedItems: [FMSClientTypes.FailedItem]?
    /// A unique identifier for the resource set, used in a request to refer to the resource set.
    /// This member is required.
    public var resourceSetIdentifier: Swift.String?

    public init(
        failedItems: [FMSClientTypes.FailedItem]? = nil,
        resourceSetIdentifier: Swift.String? = nil
    )
    {
        self.failedItems = failedItems
        self.resourceSetIdentifier = resourceSetIdentifier
    }
}

public struct BatchDisassociateResourceInput: Swift.Sendable {
    /// The uniform resource identifiers (URI) of resources that should be disassociated from the resource set. The URIs must be Amazon Resource Names (ARNs).
    /// This member is required.
    public var items: [Swift.String]?
    /// A unique identifier for the resource set, used in a request to refer to the resource set.
    /// This member is required.
    public var resourceSetIdentifier: Swift.String?

    public init(
        items: [Swift.String]? = nil,
        resourceSetIdentifier: Swift.String? = nil
    )
    {
        self.items = items
        self.resourceSetIdentifier = resourceSetIdentifier
    }
}

public struct BatchDisassociateResourceOutput: Swift.Sendable {
    /// The resources that failed to disassociate from the resource set.
    /// This member is required.
    public var failedItems: [FMSClientTypes.FailedItem]?
    /// A unique identifier for the resource set, used in a request to refer to the resource set.
    /// This member is required.
    public var resourceSetIdentifier: Swift.String?

    public init(
        failedItems: [FMSClientTypes.FailedItem]? = nil,
        resourceSetIdentifier: Swift.String? = nil
    )
    {
        self.failedItems = failedItems
        self.resourceSetIdentifier = resourceSetIdentifier
    }
}

public struct DeleteAppsListInput: Swift.Sendable {
    /// The ID of the applications list that you want to delete. You can retrieve this ID from PutAppsList, ListAppsLists, and GetAppsList.
    /// This member is required.
    public var listId: Swift.String?

    public init(
        listId: Swift.String? = nil
    )
    {
        self.listId = listId
    }
}

public struct DeleteNotificationChannelInput: Swift.Sendable {

    public init() { }
}

public struct DeletePolicyInput: Swift.Sendable {
    /// If True, the request performs cleanup according to the policy type. For WAF and Shield Advanced policies, the cleanup does the following:
    ///
    /// * Deletes rule groups created by Firewall Manager
    ///
    /// * Removes web ACLs from in-scope resources
    ///
    /// * Deletes web ACLs that contain no rules or rule groups
    ///
    ///
    /// For security group policies, the cleanup does the following for each security group in the policy:
    ///
    /// * Disassociates the security group from in-scope resources
    ///
    /// * Deletes the security group if it was created through Firewall Manager and if it's no longer associated with any resources through another policy
    ///
    ///
    /// For security group common policies, even if set to False, Firewall Manager deletes all security groups created by Firewall Manager that aren't associated with any other resources through another policy. After the cleanup, in-scope resources are no longer protected by web ACLs in this policy. Protection of out-of-scope resources remains unchanged. Scope is determined by tags that you create and accounts that you associate with the policy. When creating the policy, if you specify that only resources in specific accounts or with specific tags are in scope of the policy, those accounts and resources are handled by the policy. All others are out of scope. If you don't specify tags or accounts, all resources are in scope.
    public var deleteAllPolicyResources: Swift.Bool?
    /// The ID of the policy that you want to delete. You can retrieve this ID from PutPolicy and ListPolicies.
    /// This member is required.
    public var policyId: Swift.String?

    public init(
        deleteAllPolicyResources: Swift.Bool? = false,
        policyId: Swift.String? = nil
    )
    {
        self.deleteAllPolicyResources = deleteAllPolicyResources
        self.policyId = policyId
    }
}

public struct DeleteProtocolsListInput: Swift.Sendable {
    /// The ID of the protocols list that you want to delete. You can retrieve this ID from PutProtocolsList, ListProtocolsLists, and GetProtocolsLost.
    /// This member is required.
    public var listId: Swift.String?

    public init(
        listId: Swift.String? = nil
    )
    {
        self.listId = listId
    }
}

public struct DeleteResourceSetInput: Swift.Sendable {
    /// A unique identifier for the resource set, used in a request to refer to the resource set.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct DisassociateAdminAccountInput: Swift.Sendable {

    public init() { }
}

public struct DisassociateThirdPartyFirewallInput: Swift.Sendable {
    /// The name of the third-party firewall vendor.
    /// This member is required.
    public var thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall?

    public init(
        thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall? = nil
    )
    {
        self.thirdPartyFirewall = thirdPartyFirewall
    }
}

public struct DisassociateThirdPartyFirewallOutput: Swift.Sendable {
    /// The current status for the disassociation of a Firewall Manager administrators account with a third-party firewall.
    public var thirdPartyFirewallStatus: FMSClientTypes.ThirdPartyFirewallAssociationStatus?

    public init(
        thirdPartyFirewallStatus: FMSClientTypes.ThirdPartyFirewallAssociationStatus? = nil
    )
    {
        self.thirdPartyFirewallStatus = thirdPartyFirewallStatus
    }
}

public struct GetAdminAccountInput: Swift.Sendable {

    public init() { }
}

public struct GetAdminAccountOutput: Swift.Sendable {
    /// The account that is set as the Firewall Manager default administrator.
    public var adminAccount: Swift.String?
    /// The status of the account that you set as the Firewall Manager default administrator.
    public var roleStatus: FMSClientTypes.AccountRoleStatus?

    public init(
        adminAccount: Swift.String? = nil,
        roleStatus: FMSClientTypes.AccountRoleStatus? = nil
    )
    {
        self.adminAccount = adminAccount
        self.roleStatus = roleStatus
    }
}

public struct GetAdminScopeInput: Swift.Sendable {
    /// The administrator account that you want to get the details for.
    /// This member is required.
    public var adminAccount: Swift.String?

    public init(
        adminAccount: Swift.String? = nil
    )
    {
        self.adminAccount = adminAccount
    }
}

public struct GetAdminScopeOutput: Swift.Sendable {
    /// Contains details about the administrative scope of the requested account.
    public var adminScope: FMSClientTypes.AdminScope?
    /// The current status of the request to onboard a member account as an Firewall Manager administrator.
    ///
    /// * ONBOARDING - The account is onboarding to Firewall Manager as an administrator.
    ///
    /// * ONBOARDING_COMPLETE - Firewall Manager The account is onboarded to Firewall Manager as an administrator, and can perform actions on the resources defined in their [AdminScope].
    ///
    /// * OFFBOARDING - The account is being removed as an Firewall Manager administrator.
    ///
    /// * OFFBOARDING_COMPLETE - The account has been removed as an Firewall Manager administrator.
    public var status: FMSClientTypes.OrganizationStatus?

    public init(
        adminScope: FMSClientTypes.AdminScope? = nil,
        status: FMSClientTypes.OrganizationStatus? = nil
    )
    {
        self.adminScope = adminScope
        self.status = status
    }
}

public struct GetAppsListInput: Swift.Sendable {
    /// Specifies whether the list to retrieve is a default list owned by Firewall Manager.
    public var defaultList: Swift.Bool?
    /// The ID of the Firewall Manager applications list that you want the details for.
    /// This member is required.
    public var listId: Swift.String?

    public init(
        defaultList: Swift.Bool? = false,
        listId: Swift.String? = nil
    )
    {
        self.defaultList = defaultList
        self.listId = listId
    }
}

public struct GetAppsListOutput: Swift.Sendable {
    /// Information about the specified Firewall Manager applications list.
    public var appsList: FMSClientTypes.AppsListData?
    /// The Amazon Resource Name (ARN) of the applications list.
    public var appsListArn: Swift.String?

    public init(
        appsList: FMSClientTypes.AppsListData? = nil,
        appsListArn: Swift.String? = nil
    )
    {
        self.appsList = appsList
        self.appsListArn = appsListArn
    }
}

public struct GetComplianceDetailInput: Swift.Sendable {
    /// The Amazon Web Services account that owns the resources that you want to get the details for.
    /// This member is required.
    public var memberAccount: Swift.String?
    /// The ID of the policy that you want to get the details for. PolicyId is returned by PutPolicy and by ListPolicies.
    /// This member is required.
    public var policyId: Swift.String?

    public init(
        memberAccount: Swift.String? = nil,
        policyId: Swift.String? = nil
    )
    {
        self.memberAccount = memberAccount
        self.policyId = policyId
    }
}

extension FMSClientTypes {

    public enum DependentServiceName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsconfig
        case awsshieldadvanced
        case awsvirtualprivatecloud
        case awswaf
        case sdkUnknown(Swift.String)

        public static var allCases: [DependentServiceName] {
            return [
                .awsconfig,
                .awsshieldadvanced,
                .awsvirtualprivatecloud,
                .awswaf
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsconfig: return "AWSCONFIG"
            case .awsshieldadvanced: return "AWSSHIELD_ADVANCED"
            case .awsvirtualprivatecloud: return "AWSVPC"
            case .awswaf: return "AWSWAF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    public enum ViolationReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case blackholeroutedetected
        case blackholeroutedetectedinfirewallsubnet
        case fmscreatedsecuritygroupedited
        case firewallsubnetisoutofscope
        case firewallsubnetmissingexpectedroute
        case firewallsubnetmissingvpcendpoint
        case internetgatewaymissingexpectedroute
        case internettrafficnotinspected
        case invalidnetworkaclentry
        case invalidrouteconfiguration
        case missingexpectedroutetable
        case missingfirewall
        case missingfirewallsubnetinaz
        case missingtargetgateway
        case networkfirewallpolicymodified
        case resourceincorrectwebacl
        case resourcemissingdnsfirewall
        case resourcemissingsecuritygroup
        case resourcemissingshieldprotection
        case resourcemissingwebacl
        case resourcemissingwebaclorshieldprotection
        case resourceviolatesauditsecuritygroup
        case routehasoutofscopeendpoint
        case securitygroupredundant
        case securitygroupunused
        case trafficinspectioncrossesazboundary
        case unexpectedfirewallroutes
        case unexpectedtargetgatewayroutes
        case webaclconfigurationorscopeofuse
        case webaclmissingrulegroup
        case sdkUnknown(Swift.String)

        public static var allCases: [ViolationReason] {
            return [
                .blackholeroutedetected,
                .blackholeroutedetectedinfirewallsubnet,
                .fmscreatedsecuritygroupedited,
                .firewallsubnetisoutofscope,
                .firewallsubnetmissingexpectedroute,
                .firewallsubnetmissingvpcendpoint,
                .internetgatewaymissingexpectedroute,
                .internettrafficnotinspected,
                .invalidnetworkaclentry,
                .invalidrouteconfiguration,
                .missingexpectedroutetable,
                .missingfirewall,
                .missingfirewallsubnetinaz,
                .missingtargetgateway,
                .networkfirewallpolicymodified,
                .resourceincorrectwebacl,
                .resourcemissingdnsfirewall,
                .resourcemissingsecuritygroup,
                .resourcemissingshieldprotection,
                .resourcemissingwebacl,
                .resourcemissingwebaclorshieldprotection,
                .resourceviolatesauditsecuritygroup,
                .routehasoutofscopeendpoint,
                .securitygroupredundant,
                .securitygroupunused,
                .trafficinspectioncrossesazboundary,
                .unexpectedfirewallroutes,
                .unexpectedtargetgatewayroutes,
                .webaclconfigurationorscopeofuse,
                .webaclmissingrulegroup
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blackholeroutedetected: return "BLACK_HOLE_ROUTE_DETECTED"
            case .blackholeroutedetectedinfirewallsubnet: return "BLACK_HOLE_ROUTE_DETECTED_IN_FIREWALL_SUBNET"
            case .fmscreatedsecuritygroupedited: return "FMS_CREATED_SECURITY_GROUP_EDITED"
            case .firewallsubnetisoutofscope: return "FIREWALL_SUBNET_IS_OUT_OF_SCOPE"
            case .firewallsubnetmissingexpectedroute: return "FIREWALL_SUBNET_MISSING_EXPECTED_ROUTE"
            case .firewallsubnetmissingvpcendpoint: return "FIREWALL_SUBNET_MISSING_VPCE_ENDPOINT"
            case .internetgatewaymissingexpectedroute: return "INTERNET_GATEWAY_MISSING_EXPECTED_ROUTE"
            case .internettrafficnotinspected: return "INTERNET_TRAFFIC_NOT_INSPECTED"
            case .invalidnetworkaclentry: return "INVALID_NETWORK_ACL_ENTRY"
            case .invalidrouteconfiguration: return "INVALID_ROUTE_CONFIGURATION"
            case .missingexpectedroutetable: return "MISSING_EXPECTED_ROUTE_TABLE"
            case .missingfirewall: return "MISSING_FIREWALL"
            case .missingfirewallsubnetinaz: return "MISSING_FIREWALL_SUBNET_IN_AZ"
            case .missingtargetgateway: return "MISSING_TARGET_GATEWAY"
            case .networkfirewallpolicymodified: return "NETWORK_FIREWALL_POLICY_MODIFIED"
            case .resourceincorrectwebacl: return "RESOURCE_INCORRECT_WEB_ACL"
            case .resourcemissingdnsfirewall: return "RESOURCE_MISSING_DNS_FIREWALL"
            case .resourcemissingsecuritygroup: return "RESOURCE_MISSING_SECURITY_GROUP"
            case .resourcemissingshieldprotection: return "RESOURCE_MISSING_SHIELD_PROTECTION"
            case .resourcemissingwebacl: return "RESOURCE_MISSING_WEB_ACL"
            case .resourcemissingwebaclorshieldprotection: return "RESOURCE_MISSING_WEB_ACL_OR_SHIELD_PROTECTION"
            case .resourceviolatesauditsecuritygroup: return "RESOURCE_VIOLATES_AUDIT_SECURITY_GROUP"
            case .routehasoutofscopeendpoint: return "ROUTE_HAS_OUT_OF_SCOPE_ENDPOINT"
            case .securitygroupredundant: return "SECURITY_GROUP_REDUNDANT"
            case .securitygroupunused: return "SECURITY_GROUP_UNUSED"
            case .trafficinspectioncrossesazboundary: return "TRAFFIC_INSPECTION_CROSSES_AZ_BOUNDARY"
            case .unexpectedfirewallroutes: return "UNEXPECTED_FIREWALL_ROUTES"
            case .unexpectedtargetgatewayroutes: return "UNEXPECTED_TARGET_GATEWAY_ROUTES"
            case .webaclconfigurationorscopeofuse: return "WEB_ACL_CONFIGURATION_OR_SCOPE_OF_USE"
            case .webaclmissingrulegroup: return "WEB_ACL_MISSING_RULE_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    /// Details of the resource that is not protected by the policy.
    public struct ComplianceViolator: Swift.Sendable {
        /// Metadata about the resource that doesn't comply with the policy scope.
        public var metadata: [Swift.String: Swift.String]?
        /// The resource ID.
        public var resourceId: Swift.String?
        /// The resource type. This is in the format shown in the [Amazon Web Services Resource Types Reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html). For example: AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::CloudFront::Distribution, or AWS::NetworkFirewall::FirewallPolicy.
        public var resourceType: Swift.String?
        /// The reason that the resource is not protected by the policy.
        public var violationReason: FMSClientTypes.ViolationReason?

        public init(
            metadata: [Swift.String: Swift.String]? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            violationReason: FMSClientTypes.ViolationReason? = nil
        )
        {
            self.metadata = metadata
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.violationReason = violationReason
        }
    }
}

extension FMSClientTypes {

    /// Describes the noncompliant resources in a member account for a specific Firewall Manager policy. A maximum of 100 entries are displayed. If more than 100 resources are noncompliant, EvaluationLimitExceeded is set to True.
    public struct PolicyComplianceDetail: Swift.Sendable {
        /// Indicates if over 100 resources are noncompliant with the Firewall Manager policy.
        public var evaluationLimitExceeded: Swift.Bool
        /// A timestamp that indicates when the returned information should be considered out of date.
        public var expiredAt: Foundation.Date?
        /// Details about problems with dependent services, such as WAF or Config, and the error message received that indicates the problem with the service.
        public var issueInfoMap: [Swift.String: Swift.String]?
        /// The Amazon Web Services account ID.
        public var memberAccount: Swift.String?
        /// The ID of the Firewall Manager policy.
        public var policyId: Swift.String?
        /// The Amazon Web Services account that created the Firewall Manager policy.
        public var policyOwner: Swift.String?
        /// An array of resources that aren't protected by the WAF or Shield Advanced policy or that aren't in compliance with the security group policy.
        public var violators: [FMSClientTypes.ComplianceViolator]?

        public init(
            evaluationLimitExceeded: Swift.Bool = false,
            expiredAt: Foundation.Date? = nil,
            issueInfoMap: [Swift.String: Swift.String]? = nil,
            memberAccount: Swift.String? = nil,
            policyId: Swift.String? = nil,
            policyOwner: Swift.String? = nil,
            violators: [FMSClientTypes.ComplianceViolator]? = nil
        )
        {
            self.evaluationLimitExceeded = evaluationLimitExceeded
            self.expiredAt = expiredAt
            self.issueInfoMap = issueInfoMap
            self.memberAccount = memberAccount
            self.policyId = policyId
            self.policyOwner = policyOwner
            self.violators = violators
        }
    }
}

public struct GetComplianceDetailOutput: Swift.Sendable {
    /// Information about the resources and the policy that you specified in the GetComplianceDetail request.
    public var policyComplianceDetail: FMSClientTypes.PolicyComplianceDetail?

    public init(
        policyComplianceDetail: FMSClientTypes.PolicyComplianceDetail? = nil
    )
    {
        self.policyComplianceDetail = policyComplianceDetail
    }
}

public struct GetNotificationChannelInput: Swift.Sendable {

    public init() { }
}

public struct GetNotificationChannelOutput: Swift.Sendable {
    /// The IAM role that is used by Firewall Manager to record activity to SNS.
    public var snsRoleName: Swift.String?
    /// The SNS topic that records Firewall Manager activity.
    public var snsTopicArn: Swift.String?

    public init(
        snsRoleName: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil
    )
    {
        self.snsRoleName = snsRoleName
        self.snsTopicArn = snsTopicArn
    }
}

/// The value of the Type parameter is invalid.
public struct InvalidTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTypeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetPolicyInput: Swift.Sendable {
    /// The ID of the Firewall Manager policy that you want the details for.
    /// This member is required.
    public var policyId: Swift.String?

    public init(
        policyId: Swift.String? = nil
    )
    {
        self.policyId = policyId
    }
}

extension FMSClientTypes {

    public enum CustomerPolicyScopeIdType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case orgUnit
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomerPolicyScopeIdType] {
            return [
                .account,
                .orgUnit
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .orgUnit: return "ORG_UNIT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    public enum CustomerPolicyStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case outOfAdminScope
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomerPolicyStatus] {
            return [
                .active,
                .outOfAdminScope
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .outOfAdminScope: return "OUT_OF_ADMIN_SCOPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    /// The resource tags that Firewall Manager uses to determine if a particular resource should be included or excluded from the Firewall Manager policy. Tags enable you to categorize your Amazon Web Services resources in different ways, for example, by purpose, owner, or environment. Each tag consists of a key and an optional value. Firewall Manager combines the tags with "AND" so that, if you add more than one tag to a policy scope, a resource must have all the specified tags to be included or excluded. For more information, see [Working with Tag Editor](https://docs.aws.amazon.com/awsconsolehelpdocs/latest/gsg/tag-editor.html). Every resource tag must have a string value, either a non-empty string or an empty string. If you don't provide a value for a resource tag, Firewall Manager saves the value as an empty string: "". When Firewall Manager compares tags, it only matches two tags if they have the same key and the same value. A tag with an empty string value only matches with tags that also have an empty string value.
    public struct ResourceTag: Swift.Sendable {
        /// The resource tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The resource tag value. To specify an empty string value, either don't provide this or specify it as "".
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension FMSClientTypes {

    /// ICMP protocol: The ICMP type and code.
    public struct NetworkAclIcmpTypeCode: Swift.Sendable {
        /// ICMP code.
        public var code: Swift.Int?
        /// ICMP type.
        public var type: Swift.Int?

        public init(
            code: Swift.Int? = nil,
            type: Swift.Int? = nil
        )
        {
            self.code = code
            self.type = type
        }
    }
}

extension FMSClientTypes {

    /// TCP or UDP protocols: The range of ports the rule applies to.
    public struct NetworkAclPortRange: Swift.Sendable {
        /// The beginning port number of the range.
        public var from: Swift.Int?
        /// The ending port number of the range.
        public var to: Swift.Int?

        public init(
            from: Swift.Int? = nil,
            to: Swift.Int? = nil
        )
        {
            self.from = from
            self.to = to
        }
    }
}

extension FMSClientTypes {

    public enum NetworkAclRuleAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkAclRuleAction] {
            return [
                .allow,
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allow: return "allow"
            case .deny: return "deny"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    /// Describes a rule in a network ACL. Each network ACL has a set of numbered ingress rules and a separate set of numbered egress rules. When determining whether a packet should be allowed in or out of a subnet associated with the network ACL, Amazon Web Services processes the entries in the network ACL according to the rule numbers, in ascending order. When you manage an individual network ACL, you explicitly specify the rule numbers. When you specify the network ACL rules in a Firewall Manager policy, you provide the rules to run first, in the order that you want them to run, and the rules to run last, in the order that you want them to run. Firewall Manager assigns the rule numbers for you when you save the network ACL policy specification.
    public struct NetworkAclEntry: Swift.Sendable {
        /// The IPv4 network range to allow or deny, in CIDR notation.
        public var cidrBlock: Swift.String?
        /// Indicates whether the rule is an egress, or outbound, rule (applied to traffic leaving the subnet). If it's not an egress rule, then it's an ingress, or inbound, rule.
        /// This member is required.
        public var egress: Swift.Bool?
        /// ICMP protocol: The ICMP type and code.
        public var icmpTypeCode: FMSClientTypes.NetworkAclIcmpTypeCode?
        /// The IPv6 network range to allow or deny, in CIDR notation.
        public var ipv6CidrBlock: Swift.String?
        /// TCP or UDP protocols: The range of ports the rule applies to.
        public var portRange: FMSClientTypes.NetworkAclPortRange?
        /// The protocol number. A value of "-1" means all protocols.
        /// This member is required.
        public var `protocol`: Swift.String?
        /// Indicates whether to allow or deny the traffic that matches the rule.
        /// This member is required.
        public var ruleAction: FMSClientTypes.NetworkAclRuleAction?

        public init(
            cidrBlock: Swift.String? = nil,
            egress: Swift.Bool? = nil,
            icmpTypeCode: FMSClientTypes.NetworkAclIcmpTypeCode? = nil,
            ipv6CidrBlock: Swift.String? = nil,
            portRange: FMSClientTypes.NetworkAclPortRange? = nil,
            `protocol`: Swift.String? = nil,
            ruleAction: FMSClientTypes.NetworkAclRuleAction? = nil
        )
        {
            self.cidrBlock = cidrBlock
            self.egress = egress
            self.icmpTypeCode = icmpTypeCode
            self.ipv6CidrBlock = ipv6CidrBlock
            self.portRange = portRange
            self.`protocol` = `protocol`
            self.ruleAction = ruleAction
        }
    }
}

extension FMSClientTypes {

    /// The configuration of the first and last rules for the network ACL policy, and the remediation settings for each.
    public struct NetworkAclEntrySet: Swift.Sendable {
        /// The rules that you want to run first in the Firewall Manager managed network ACLs. Provide these in the order in which you want them to run. Firewall Manager will assign the specific rule numbers for you, in the network ACLs that it creates. You must specify at least one first entry or one last entry in any network ACL policy.
        public var firstEntries: [FMSClientTypes.NetworkAclEntry]?
        /// Applies only when remediation is enabled for the policy as a whole. Firewall Manager uses this setting when it finds policy violations that involve conflicts between the custom entries and the policy entries. If forced remediation is disabled, Firewall Manager marks the network ACL as noncompliant and does not try to remediate. For more information about the remediation behavior, see [Remediation for managed network ACLs](https://docs.aws.amazon.com/waf/latest/developerguide/network-acl-policies.html#network-acls-remediation) in the Firewall Manager Developer Guide.
        /// This member is required.
        public var forceRemediateForFirstEntries: Swift.Bool?
        /// Applies only when remediation is enabled for the policy as a whole. Firewall Manager uses this setting when it finds policy violations that involve conflicts between the custom entries and the policy entries. If forced remediation is disabled, Firewall Manager marks the network ACL as noncompliant and does not try to remediate. For more information about the remediation behavior, see [Remediation for managed network ACLs](https://docs.aws.amazon.com/waf/latest/developerguide/network-acl-policies.html#network-acls-remediation) in the Firewall Manager Developer Guide.
        /// This member is required.
        public var forceRemediateForLastEntries: Swift.Bool?
        /// The rules that you want to run last in the Firewall Manager managed network ACLs. Provide these in the order in which you want them to run. Firewall Manager will assign the specific rule numbers for you, in the network ACLs that it creates. You must specify at least one first entry or one last entry in any network ACL policy.
        public var lastEntries: [FMSClientTypes.NetworkAclEntry]?

        public init(
            firstEntries: [FMSClientTypes.NetworkAclEntry]? = nil,
            forceRemediateForFirstEntries: Swift.Bool? = nil,
            forceRemediateForLastEntries: Swift.Bool? = nil,
            lastEntries: [FMSClientTypes.NetworkAclEntry]? = nil
        )
        {
            self.firstEntries = firstEntries
            self.forceRemediateForFirstEntries = forceRemediateForFirstEntries
            self.forceRemediateForLastEntries = forceRemediateForLastEntries
            self.lastEntries = lastEntries
        }
    }
}

extension FMSClientTypes {

    /// Defines a Firewall Manager network ACL policy. This is used in the PolicyOption of a SecurityServicePolicyData for a Policy, when the SecurityServicePolicyData type is set to NETWORK_ACL_COMMON. For information about network ACLs, see [Control traffic to subnets using network ACLs](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-network-acls.html) in the Amazon Virtual Private Cloud User Guide.
    public struct NetworkAclCommonPolicy: Swift.Sendable {
        /// The definition of the first and last rules for the network ACL policy.
        /// This member is required.
        public var networkAclEntrySet: FMSClientTypes.NetworkAclEntrySet?

        public init(
            networkAclEntrySet: FMSClientTypes.NetworkAclEntrySet? = nil
        )
        {
            self.networkAclEntrySet = networkAclEntrySet
        }
    }
}

extension FMSClientTypes {

    public enum FirewallDeploymentModel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case centralized
        case distributed
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallDeploymentModel] {
            return [
                .centralized,
                .distributed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .centralized: return "CENTRALIZED"
            case .distributed: return "DISTRIBUTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    /// Configures the firewall policy deployment model of Network Firewall. For information about Network Firewall deployment models, see [Network Firewall example architectures with routing](https://docs.aws.amazon.com/network-firewall/latest/developerguide/architectures.html) in the Network Firewall Developer Guide.
    public struct NetworkFirewallPolicy: Swift.Sendable {
        /// Defines the deployment model to use for the firewall policy. To use a distributed model, set [PolicyOption](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_PolicyOption.html) to NULL.
        public var firewallDeploymentModel: FMSClientTypes.FirewallDeploymentModel?

        public init(
            firewallDeploymentModel: FMSClientTypes.FirewallDeploymentModel? = nil
        )
        {
            self.firewallDeploymentModel = firewallDeploymentModel
        }
    }
}

extension FMSClientTypes {

    /// Configures the deployment model for the third-party firewall.
    public struct ThirdPartyFirewallPolicy: Swift.Sendable {
        /// Defines the deployment model to use for the third-party firewall policy.
        public var firewallDeploymentModel: FMSClientTypes.FirewallDeploymentModel?

        public init(
            firewallDeploymentModel: FMSClientTypes.FirewallDeploymentModel? = nil
        )
        {
            self.firewallDeploymentModel = firewallDeploymentModel
        }
    }
}

extension FMSClientTypes {

    /// Contains the settings to configure a network ACL policy, a Network Firewall firewall policy deployment model, or a third-party firewall policy.
    public struct PolicyOption: Swift.Sendable {
        /// Defines a Firewall Manager network ACL policy.
        public var networkAclCommonPolicy: FMSClientTypes.NetworkAclCommonPolicy?
        /// Defines the deployment model to use for the firewall policy.
        public var networkFirewallPolicy: FMSClientTypes.NetworkFirewallPolicy?
        /// Defines the policy options for a third-party firewall policy.
        public var thirdPartyFirewallPolicy: FMSClientTypes.ThirdPartyFirewallPolicy?

        public init(
            networkAclCommonPolicy: FMSClientTypes.NetworkAclCommonPolicy? = nil,
            networkFirewallPolicy: FMSClientTypes.NetworkFirewallPolicy? = nil,
            thirdPartyFirewallPolicy: FMSClientTypes.ThirdPartyFirewallPolicy? = nil
        )
        {
            self.networkAclCommonPolicy = networkAclCommonPolicy
            self.networkFirewallPolicy = networkFirewallPolicy
            self.thirdPartyFirewallPolicy = thirdPartyFirewallPolicy
        }
    }
}

extension FMSClientTypes {

    /// Details about the security service that is being used to protect the resources.
    public struct SecurityServicePolicyData: Swift.Sendable {
        /// Details about the service that are specific to the service type, in JSON format.
        ///
        /// * Example: DNS_FIREWALL"{\"type\":\"DNS_FIREWALL\",\"preProcessRuleGroups\":[{\"ruleGroupId\":\"rslvr-frg-1\",\"priority\":10}],\"postProcessRuleGroups\":[{\"ruleGroupId\":\"rslvr-frg-2\",\"priority\":9911}]}" Valid values for preProcessRuleGroups are between 1 and 99. Valid values for postProcessRuleGroups are between 9901 and 10000.
        ///
        /// * Example: IMPORT_NETWORK_FIREWALL"{\"type\":\"IMPORT_NETWORK_FIREWALL\",\"awsNetworkFirewallConfig\":{\"networkFirewallStatelessRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-west-2:000000000000:stateless-rulegroup\/rg1\",\"priority\":1}],\"networkFirewallStatelessDefaultActions\":[\"aws:drop\"],\"networkFirewallStatelessFragmentDefaultActions\":[\"aws:pass\"],\"networkFirewallStatelessCustomActions\":[],\"networkFirewallStatefulRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-west-2:aws-managed:stateful-rulegroup\/ThreatSignaturesEmergingEventsStrictOrder\",\"priority\":8}],\"networkFirewallStatefulEngineOptions\":{\"ruleOrder\":\"STRICT_ORDER\"},\"networkFirewallStatefulDefaultActions\":[\"aws:drop_strict\"]}}""{\"type\":\"DNS_FIREWALL\",\"preProcessRuleGroups\":[{\"ruleGroupId\":\"rslvr-frg-1\",\"priority\":10}],\"postProcessRuleGroups\":[{\"ruleGroupId\":\"rslvr-frg-2\",\"priority\":9911}]}" Valid values for preProcessRuleGroups are between 1 and 99. Valid values for postProcessRuleGroups are between 9901 and 10000.
        ///
        /// * Example: NETWORK_FIREWALL - Centralized deployment model "{\"type\":\"NETWORK_FIREWALL\",\"awsNetworkFirewallConfig\":{\"networkFirewallStatelessRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateless-rulegroup/test\",\"priority\":1}],\"networkFirewallStatelessDefaultActions\":[\"aws:forward_to_sfe\",\"customActionName\"],\"networkFirewallStatelessFragmentDefaultActions\":[\"aws:forward_to_sfe\",\"customActionName\"],\"networkFirewallStatelessCustomActions\":[{\"actionName\":\"customActionName\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"metricdimensionvalue\"}]}}}],\"networkFirewallStatefulRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateful-rulegroup/test\"}],\"networkFirewallLoggingConfiguration\":{\"logDestinationConfigs\":[{\"logDestinationType\":\"S3\",\"logType\":\"ALERT\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}},{\"logDestinationType\":\"S3\",\"logType\":\"FLOW\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}}],\"overrideExistingConfig\":true}},\"firewallDeploymentModel\":{\"centralizedFirewallDeploymentModel\":{\"centralizedFirewallOrchestrationConfig\":{\"inspectionVpcIds\":[{\"resourceId\":\"vpc-1234\",\"accountId\":\"123456789011\"}],\"firewallCreationConfig\":{\"endpointLocation\":{\"availabilityZoneConfigList\":[{\"availabilityZoneId\":null,\"availabilityZoneName\":\"us-east-1a\",\"allowedIPV4CidrList\":[\"10.0.0.0/28\"]}]}},\"allowedIPV4CidrList\":[]}}}}" To use the centralized deployment model, you must set [PolicyOption](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_PolicyOption.html) to CENTRALIZED.
        ///
        /// * Example: NETWORK_FIREWALL - Distributed deployment model with automatic Availability Zone configuration  "{\"type\":\"NETWORK_FIREWALL\",\"networkFirewallStatelessRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateless-rulegroup/test\",\"priority\":1}],\"networkFirewallStatelessDefaultActions\":[\"aws:forward_to_sfe\",\"customActionName\"],\"networkFirewallStatelessFragmentDefaultActions\":[\"aws:forward_to_sfe\",\"customActionName\"],\"networkFirewallStatelessCustomActions\":[{\"actionName\":\"customActionName\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"metricdimensionvalue\"}]}}}],\"networkFirewallStatefulRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateful-rulegroup/test\"}],\"networkFirewallOrchestrationConfig\":{\"singleFirewallEndpointPerVPC\":false,\"allowedIPV4CidrList\":[\"10.0.0.0/28\",\"192.168.0.0/28\"],\"routeManagementAction\":\"OFF\"},\"networkFirewallLoggingConfiguration\":{\"logDestinationConfigs\":[{\"logDestinationType\":\"S3\",\"logType\":\"ALERT\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}},{\"logDestinationType\":\"S3\",\"logType\":\"FLOW\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}}],\"overrideExistingConfig\":true}}"  With automatic Availbility Zone configuration, Firewall Manager chooses which Availability Zones to create the endpoints in. To use the distributed deployment model, you must set [PolicyOption](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_PolicyOption.html) to NULL.
        ///
        /// * Example: NETWORK_FIREWALL - Distributed deployment model with automatic Availability Zone configuration and route management  "{\"type\":\"NETWORK_FIREWALL\",\"networkFirewallStatelessRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateless-rulegroup/test\",\"priority\":1}],\"networkFirewallStatelessDefaultActions\":[\"aws:forward_to_sfe\",\"customActionName\"],\"networkFirewallStatelessFragmentDefaultActions\":[\"aws:forward_to_sfe\",\"customActionName\"],\"networkFirewallStatelessCustomActions\":[{\"actionName\":\"customActionName\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"metricdimensionvalue\"}]}}}],\"networkFirewallStatefulRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateful-rulegroup/test\"}],\"networkFirewallOrchestrationConfig\":{\"singleFirewallEndpointPerVPC\":false,\"allowedIPV4CidrList\":[\"10.0.0.0/28\",\"192.168.0.0/28\"],\"routeManagementAction\":\"MONITOR\",\"routeManagementTargetTypes\":[\"InternetGateway\"]},\"networkFirewallLoggingConfiguration\":{\"logDestinationConfigs\":[{\"logDestinationType\":\"S3\",\"logType\":\"ALERT\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}},{\"logDestinationType\":\"S3\",\"logType\": \"FLOW\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}}],\"overrideExistingConfig\":true}}"  To use the distributed deployment model, you must set [PolicyOption](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_PolicyOption.html) to NULL.
        ///
        /// * Example: NETWORK_FIREWALL - Distributed deployment model with custom Availability Zone configuration "{\"type\":\"NETWORK_FIREWALL\",\"networkFirewallStatelessRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateless-rulegroup/test\",\"priority\":1}],\"networkFirewallStatelessDefaultActions\":[\"aws:forward_to_sfe\",\"customActionName\"],\"networkFirewallStatelessFragmentDefaultActions\":[\"aws:forward_to_sfe\",\"fragmentcustomactionname\"],\"networkFirewallStatelessCustomActions\":[{\"actionName\":\"customActionName\", \"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"metricdimensionvalue\"}]}}},{\"actionName\":\"fragmentcustomactionname\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"fragmentmetricdimensionvalue\"}]}}}],\"networkFirewallStatefulRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateful-rulegroup/test\"}],\"networkFirewallOrchestrationConfig\":{\"firewallCreationConfig\":{ \"endpointLocation\":{\"availabilityZoneConfigList\":[{\"availabilityZoneName\":\"us-east-1a\",\"allowedIPV4CidrList\":[\"10.0.0.0/28\"]},{\"availabilityZoneName\":\"us-east-1b\",\"allowedIPV4CidrList\":[ \"10.0.0.0/28\"]}]} },\"singleFirewallEndpointPerVPC\":false,\"allowedIPV4CidrList\":null,\"routeManagementAction\":\"OFF\",\"networkFirewallLoggingConfiguration\":{\"logDestinationConfigs\":[{\"logDestinationType\":\"S3\",\"logType\":\"ALERT\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}},{\"logDestinationType\":\"S3\",\"logType\":\"FLOW\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}}],\"overrideExistingConfig\":boolean}}"  With custom Availability Zone configuration, you define which specific Availability Zones to create endpoints in by configuring firewallCreationConfig. To configure the Availability Zones in firewallCreationConfig, specify either the availabilityZoneName or availabilityZoneId parameter, not both parameters. To use the distributed deployment model, you must set [PolicyOption](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_PolicyOption.html) to NULL.
        ///
        /// * Example: NETWORK_FIREWALL - Distributed deployment model with custom Availability Zone configuration and route management "{\"type\":\"NETWORK_FIREWALL\",\"networkFirewallStatelessRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateless-rulegroup/test\",\"priority\":1}],\"networkFirewallStatelessDefaultActions\":[\"aws:forward_to_sfe\",\"customActionName\"],\"networkFirewallStatelessFragmentDefaultActions\":[\"aws:forward_to_sfe\",\"fragmentcustomactionname\"],\"networkFirewallStatelessCustomActions\":[{\"actionName\":\"customActionName\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"metricdimensionvalue\"}]}}},{\"actionName\":\"fragmentcustomactionname\",\"actionDefinition\":{\"publishMetricAction\":{\"dimensions\":[{\"value\":\"fragmentmetricdimensionvalue\"}]}}}],\"networkFirewallStatefulRuleGroupReferences\":[{\"resourceARN\":\"arn:aws:network-firewall:us-east-1:123456789011:stateful-rulegroup/test\"}],\"networkFirewallOrchestrationConfig\":{\"firewallCreationConfig\":{\"endpointLocation\":{\"availabilityZoneConfigList\":[{\"availabilityZoneName\":\"us-east-1a\",\"allowedIPV4CidrList\":[\"10.0.0.0/28\"]},{\"availabilityZoneName\":\"us-east-1b\",\"allowedIPV4CidrList\":[\"10.0.0.0/28\"]}]}},\"singleFirewallEndpointPerVPC\":false,\"allowedIPV4CidrList\":null,\"routeManagementAction\":\"MONITOR\",\"routeManagementTargetTypes\":[\"InternetGateway\"],\"routeManagementConfig\":{\"allowCrossAZTrafficIfNoEndpoint\":true}},\"networkFirewallLoggingConfiguration\":{\"logDestinationConfigs\":[{\"logDestinationType\":\"S3\",\"logType\":\"ALERT\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}},{\"logDestinationType\":\"S3\",\"logType\":\"FLOW\",\"logDestination\":{\"bucketName\":\"s3-bucket-name\"}}],\"overrideExistingConfig\":boolean}}"  To use the distributed deployment model, you must set [PolicyOption](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_PolicyOption.html) to NULL.
        ///
        /// * Example: SECURITY_GROUPS_COMMON"{\"type\":\"SECURITY_GROUPS_COMMON\",\"securityGroups\":[{\"id\":\"sg-03b1f67d69ed00197\"}],\"revertManualSecurityGroupChanges\":true,\"exclusiveResourceSecurityGroupManagement\":true,\"applyToAllEC2InstanceENIs\":false,\"includeSharedVPC\":true,\"enableSecurityGroupReferencesDistribution\":true}"
        ///
        /// * Example: SECURITY_GROUPS_COMMON - Security group tag distribution ""{\"type\":\"SECURITY_GROUPS_COMMON\",\"securityGroups\":[{\"id\":\"sg-000e55995d61a06bd\"}],\"revertManualSecurityGroupChanges\":true,\"exclusiveResourceSecurityGroupManagement\":false,\"applyToAllEC2InstanceENIs\":false,\"includeSharedVPC\":false,\"enableTagDistribution\":true}"" Firewall Manager automatically distributes tags from the primary group to the security groups created by this policy. To use security group tag distribution, you must also set revertManualSecurityGroupChanges to true, otherwise Firewall Manager won't be able to create the policy. When you enable revertManualSecurityGroupChanges, Firewall Manager identifies and reports when the security groups created by this policy become non-compliant. Firewall Manager won't distribute system tags added by Amazon Web Services services into the replica security groups. System tags begin with the aws: prefix.
        ///
        /// * Example: Shared VPCs. Apply the preceding policy to resources in shared VPCs as well as to those in VPCs that the account owns "{\"type\":\"SECURITY_GROUPS_COMMON\",\"revertManualSecurityGroupChanges\":false,\"exclusiveResourceSecurityGroupManagement\":false, \"applyToAllEC2InstanceENIs\":false,\"includeSharedVPC\":true,\"securityGroups\":[{\"id\":\" sg-000e55995d61a06bd\"}]}"
        ///
        /// * Example: SECURITY_GROUPS_CONTENT_AUDIT"{\"type\":\"SECURITY_GROUPS_CONTENT_AUDIT\",\"preManagedOptions\":[{\"denyProtocolAllValue\":true},{\"auditSgDirection\":{\"type\":\"ALL\"}}],\"securityGroups\":[{\"id\":\"sg-049b2393a25468971\"}],\"securityGroupAction\":{\"type\":\"ALLOW\"}}" The security group action for content audit can be ALLOW or DENY. For ALLOW, all in-scope security group rules must be within the allowed range of the policy's security group rules. For DENY, all in-scope security group rules must not contain a value or a range that matches a rule value or range in the policy security group.
        ///
        /// * Example: SECURITY_GROUPS_USAGE_AUDIT"{\"type\":\"SECURITY_GROUPS_USAGE_AUDIT\",\"deleteUnusedSecurityGroups\":true,\"coalesceRedundantSecurityGroups\":true,\"optionalDelayForUnusedInMinutes\":60}"
        ///
        /// * Example: SHIELD_ADVANCED with web ACL management "{\"type\":\"SHIELD_ADVANCED\",\"optimizeUnassociatedWebACL\":true}" If you set optimizeUnassociatedWebACL to true, Firewall Manager creates web ACLs in accounts within the policy scope if the web ACLs will be used by at least one resource. Firewall Manager creates web ACLs in the accounts within policy scope only if the web ACLs will be used by at least one resource. If at any time an account comes into policy scope, Firewall Manager automatically creates a web ACL in the account if at least one resource will use the web ACL. Upon enablement, Firewall Manager performs a one-time cleanup of unused web ACLs in your account. The cleanup process can take several hours. If a resource leaves policy scope after Firewall Manager creates a web ACL, Firewall Manager doesn't disassociate the resource from the web ACL. If you want Firewall Manager to clean up the web ACL, you must first manually disassociate the resources from the web ACL, and then enable the manage unused web ACLs option in your policy. If you set optimizeUnassociatedWebACL to false, and Firewall Manager automatically creates an empty web ACL in each account that's within policy scope.
        ///
        /// * Specification for SHIELD_ADVANCED for Amazon CloudFront distributions "{\"type\":\"SHIELD_ADVANCED\",\"automaticResponseConfiguration\": {\"automaticResponseStatus\":\"ENABLED|IGNORED|DISABLED\", \"automaticResponseAction\":\"BLOCK|COUNT\"}, \"overrideCustomerWebaclClassic\":true|false, \"optimizeUnassociatedWebACL\":true|false}" For example: "{\"type\":\"SHIELD_ADVANCED\",\"automaticResponseConfiguration\": {\"automaticResponseStatus\":\"ENABLED\", \"automaticResponseAction\":\"COUNT\"}}" The default value for automaticResponseStatus is IGNORED. The value for automaticResponseAction is only required when automaticResponseStatus is set to ENABLED. The default value for overrideCustomerWebaclClassic is false. For other resource types that you can protect with a Shield Advanced policy, this ManagedServiceData configuration is an empty string.
        ///
        /// * Example: THIRD_PARTY_FIREWALL Replace THIRD_PARTY_FIREWALL_NAME with the name of the third-party firewall. "{ "type":"THIRD_PARTY_FIREWALL", "thirdPartyFirewall":"THIRD_PARTY_FIREWALL_NAME", "thirdPartyFirewallConfig":{ "thirdPartyFirewallPolicyList":["global-1"] }, "firewallDeploymentModel":{ "distributedFirewallDeploymentModel":{ "distributedFirewallOrchestrationConfig":{ "firewallCreationConfig":{ "endpointLocation":{ "availabilityZoneConfigList":[ { "availabilityZoneName":"${AvailabilityZone}" } ] } }, "allowedIPV4CidrList":[ ] } } } }"
        ///
        /// * Example: WAFV2 - Account takeover prevention, Bot Control managed rule groups, optimize unassociated web ACL, and rule action override "{\"type\":\"WAFV2\",\"preProcessRuleGroups\":[{\"ruleGroupArn\":null,\"overrideAction\":{\"type\":\"NONE\"},\"managedRuleGroupIdentifier\":{\"versionEnabled\":null,\"version\":null,\"vendorName\":\"AWS\",\"managedRuleGroupName\":\"AWSManagedRulesATPRuleSet\",\"managedRuleGroupConfigs\":[{\"awsmanagedRulesATPRuleSet\":{\"loginPath\":\"/loginpath\",\"requestInspection\":{\"payloadType\":\"FORM_ENCODED|JSON\",\"usernameField\":{\"identifier\":\"/form/username\"},\"passwordField\":{\"identifier\":\"/form/password\"}}}}]},\"ruleGroupType\":\"ManagedRuleGroup\",\"excludeRules\":[],\"sampledRequestsEnabled\":true},{\"ruleGroupArn\":null,\"overrideAction\":{\"type\":\"NONE\"},\"managedRuleGroupIdentifier\":{\"versionEnabled\":null,\"version\":null,\"vendorName\":\"AWS\",\"managedRuleGroupName\":\"AWSManagedRulesBotControlRuleSet\",\"managedRuleGroupConfigs\":[{\"awsmanagedRulesBotControlRuleSet\":{\"inspectionLevel\":\"TARGETED|COMMON\"}}]},\"ruleGroupType\":\"ManagedRuleGroup\",\"excludeRules\":[],\"sampledRequestsEnabled\":true,\"ruleActionOverrides\":[{\"name\":\"Rule1\",\"actionToUse\":{\"allow|block|count|captcha|challenge\":{}}},{\"name\":\"Rule2\",\"actionToUse\":{\"allow|block|count|captcha|challenge\":{}}}]}],\"postProcessRuleGroups\":[],\"defaultAction\":{\"type\":\"ALLOW\"},\"customRequestHandling\":null,\"customResponse\":null,\"overrideCustomerWebACLAssociation\":false,\"loggingConfiguration\":null,\"sampledRequestsEnabledForDefaultActions\":true,\"optimizeUnassociatedWebACL\":true}"
        ///
        /// * Bot Control - For information about AWSManagedRulesBotControlRuleSet managed rule groups, see [AWSManagedRulesBotControlRuleSet](https://docs.aws.amazon.com/waf/latest/APIReference/API_AWSManagedRulesBotControlRuleSet.html) in the WAF API Reference.
        ///
        /// * Fraud Control account takeover prevention (ATP) - For information about the properties available for AWSManagedRulesATPRuleSet managed rule groups, see [AWSManagedRulesATPRuleSet](https://docs.aws.amazon.com/waf/latest/APIReference/API_AWSManagedRulesATPRuleSet.html) in the WAF API Reference.
        ///
        /// * Optimize unassociated web ACL - If you set optimizeUnassociatedWebACL to true, Firewall Manager creates web ACLs in accounts within the policy scope if the web ACLs will be used by at least one resource. Firewall Manager creates web ACLs in the accounts within policy scope only if the web ACLs will be used by at least one resource. If at any time an account comes into policy scope, Firewall Manager automatically creates a web ACL in the account if at least one resource will use the web ACL. Upon enablement, Firewall Manager performs a one-time cleanup of unused web ACLs in your account. The cleanup process can take several hours. If a resource leaves policy scope after Firewall Manager creates a web ACL, Firewall Manager disassociates the resource from the web ACL, but won't clean up the unused web ACL. Firewall Manager only cleans up unused web ACLs when you first enable management of unused web ACLs in a policy. If you set optimizeUnassociatedWebACL to false Firewall Manager doesn't manage unused web ACLs, and Firewall Manager automatically creates an empty web ACL in each account that's within policy scope.
        ///
        /// * Rule action overrides - Firewall Manager supports rule action overrides only for managed rule groups. To configure a RuleActionOverrides add the Name of the rule to override, and ActionToUse, which is the new action to use for the rule. For information about using rule action override, see [RuleActionOverride](https://docs.aws.amazon.com/waf/latest/APIReference/API_RuleActionOverride.html) in the WAF API Reference.
        ///
        ///
        ///
        ///
        /// * Example: WAFV2 - CAPTCHA and Challenge configs "{\"type\":\"WAFV2\",\"preProcessRuleGroups\":[{\"ruleGroupArn\":null,\"overrideAction\":{\"type\":\"NONE\"},\"managedRuleGroupIdentifier\":{\"versionEnabled\":null,\"version\":null,\"vendorName\":\"AWS\",\"managedRuleGroupName\":\"AWSManagedRulesAdminProtectionRuleSet\"},\"ruleGroupType\":\"ManagedRuleGroup\",\"excludeRules\":[],\"sampledRequestsEnabled\":true}],\"postProcessRuleGroups\":[],\"defaultAction\":{\"type\":\"ALLOW\"},\"customRequestHandling\":null,\"customResponse\":null,\"overrideCustomerWebACLAssociation\":false,\"loggingConfiguration\":null,\"sampledRequestsEnabledForDefaultActions\":true,\"captchaConfig\":{\"immunityTimeProperty\":{\"immunityTime\":500}},\"challengeConfig\":{\"immunityTimeProperty\":{\"immunityTime\":800}},\"tokenDomains\":[\"google.com\",\"amazon.com\"],\"associationConfig\":{\"requestBody\":{\"CLOUDFRONT\":{\"defaultSizeInspectionLimit\":\"KB_16\"}}}}"
        ///
        /// * CAPTCHA and Challenge configs - If you update the policy's values for associationConfig, captchaConfig, challengeConfig, or tokenDomains, Firewall Manager will overwrite your local web ACLs to contain the new value(s). However, if you don't update the policy's associationConfig, captchaConfig, challengeConfig, or tokenDomains values, the values in your local web ACLs will remain unchanged. For information about association configs, see [AssociationConfig](https://docs.aws.amazon.com/waf/latest/APIReference/API_AssociationConfig.html). For information about CAPTCHA and Challenge configs, see [CaptchaConfig](https://docs.aws.amazon.com/waf/latest/APIReference/API_CaptchaConfig.html) and [ChallengeConfig](https://docs.aws.amazon.com/waf/latest/APIReference/API_ChallengeConfig.html) in the WAF API Reference.
        ///
        /// * defaultSizeInspectionLimit - Specifies the maximum size of the web request body component that an associated Amazon CloudFront distribution should send to WAF for inspection. For more information, see [DefaultSizeInspectionLimit](https://docs.aws.amazon.com/waf/latest/APIReference/API_RequestBodyAssociatedResourceTypeConfig.html#WAF-Type-RequestBodyAssociatedResourceTypeConfig-DefaultSizeInspectionLimit) in the WAF API Reference.
        ///
        ///
        ///
        ///
        /// * Example: WAFV2 - Firewall Manager support for WAF managed rule group versioning "{\"preProcessRuleGroups\":[{\"ruleGroupType\":\"ManagedRuleGroup\",\"overrideAction\":{\"type\":\"NONE\"},\"sampledRequestsEnabled\":true,\"managedRuleGroupIdentifier\":{\"managedRuleGroupName\":\"AWSManagedRulesAdminProtectionRuleSet\",\"vendorName\":\"AWS\",\"managedRuleGroupConfigs\":null}}],\"postProcessRuleGroups\":[],\"defaultAction\":{\"type\":\"ALLOW\"},\"customRequestHandling\":null,\"tokenDomains\":null,\"customResponse\":null,\"type\":\"WAFV2\",\"overrideCustomerWebACLAssociation\":false,\"sampledRequestsEnabledForDefaultActions\":true,\"optimizeUnassociatedWebACL\":true,\"webACLSource\":\"RETROFIT_EXISTING\"}" To use a specific version of a WAF managed rule group in your Firewall Manager policy, you must set versionEnabled to true, and set version to the version you'd like to use. If you don't set versionEnabled to true, or if you omit versionEnabled, then Firewall Manager uses the default version of the WAF managed rule group.
        ///
        /// * Example: WAFV2 - Logging configurations "{\"type\":\"WAFV2\",\"preProcessRuleGroups\":[{\"ruleGroupArn\":null, \"overrideAction\":{\"type\":\"NONE\"},\"managedRuleGroupIdentifier\": {\"versionEnabled\":null,\"version\":null,\"vendorName\":\"AWS\", \"managedRuleGroupName\":\"AWSManagedRulesAdminProtectionRuleSet\"} ,\"ruleGroupType\":\"ManagedRuleGroup\",\"excludeRules\":[], \"sampledRequestsEnabled\":true}],\"postProcessRuleGroups\":[], \"defaultAction\":{\"type\":\"ALLOW\"},\"customRequestHandling\" :null,\"customResponse\":null,\"overrideCustomerWebACLAssociation\" :false,\"loggingConfiguration\":{\"logDestinationConfigs\": [\"arn:aws:s3:::aws-waf-logs-example-bucket\"] ,\"redactedFields\":[],\"loggingFilterConfigs\":{\"defaultBehavior\":\"KEEP\", \"filters\":[{\"behavior\":\"KEEP\",\"requirement\":\"MEETS_ALL\", \"conditions\":[{\"actionCondition\":\"CAPTCHA\"},{\"actionCondition\": \"CHALLENGE\"}, {\"actionCondition\":\"EXCLUDED_AS_COUNT\"}]}]}},\"sampledRequestsEnabledForDefaultActions\":true}" Firewall Manager supports Amazon Kinesis Data Firehose and Amazon S3 as the logDestinationConfigs in your loggingConfiguration. For information about WAF logging configurations, see [LoggingConfiguration](https://docs.aws.amazon.com/waf/latest/APIReference/API_LoggingConfiguration.html) in the WAF API Reference In the loggingConfiguration, you can specify one logDestinationConfigs. Optionally provide as many as 20 redactedFields. The RedactedFieldType must be one of URI, QUERY_STRING, HEADER, or METHOD.
        ///
        /// * Example: WAF Classic"{\"ruleGroups\":[{\"id\":\"78cb36c0-1b5e-4d7d-82b2-cf48d3ad9659\",\"overrideAction\":{\"type\":\"NONE\"}}],\"overrideCustomerWebACLAssociation\":true,\"defaultAction\":{\"type\":\"ALLOW\"},\"type\":\"WAF\"}"
        public var managedServiceData: Swift.String?
        /// Contains the settings to configure a network ACL policy, a Network Firewall firewall policy deployment model, or a third-party firewall policy.
        public var policyOption: FMSClientTypes.PolicyOption?
        /// The service that the policy is using to protect the resources. This specifies the type of policy that is created, either an WAF policy, a Shield Advanced policy, or a security group policy. For security group policies, Firewall Manager supports one security group for each common policy and for each content audit policy. This is an adjustable limit that you can increase by contacting Amazon Web Services Support.
        /// This member is required.
        public var type: FMSClientTypes.SecurityServiceType?

        public init(
            managedServiceData: Swift.String? = nil,
            policyOption: FMSClientTypes.PolicyOption? = nil,
            type: FMSClientTypes.SecurityServiceType? = nil
        )
        {
            self.managedServiceData = managedServiceData
            self.policyOption = policyOption
            self.type = type
        }
    }
}

extension FMSClientTypes {

    /// An Firewall Manager policy.
    public struct Policy: Swift.Sendable {
        /// Indicates whether Firewall Manager should automatically remove protections from resources that leave the policy scope and clean up resources that Firewall Manager is managing for accounts when those accounts leave policy scope. For example, Firewall Manager will disassociate a Firewall Manager managed web ACL from a protected customer resource when the customer resource leaves policy scope. By default, Firewall Manager doesn't remove protections or delete Firewall Manager managed resources. This option is not available for Shield Advanced or WAF Classic policies.
        public var deleteUnusedFMManagedResources: Swift.Bool
        /// Specifies the Amazon Web Services account IDs and Organizations organizational units (OUs) to exclude from the policy. Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time. You can specify inclusions or exclusions, but not both. If you specify an IncludeMap, Firewall Manager applies the policy to all accounts specified by the IncludeMap, and does not evaluate any ExcludeMap specifications. If you do not specify an IncludeMap, then Firewall Manager applies the policy to all accounts except for those specified by the ExcludeMap. You can specify account IDs, OUs, or a combination:
        ///
        /// * Specify account IDs by setting the key to ACCOUNT. For example, the following is a valid map: {ACCOUNT : [accountID1, accountID2]}.
        ///
        /// * Specify OUs by setting the key to ORG_UNIT. For example, the following is a valid map: {ORG_UNIT : [ouid111, ouid112]}.
        ///
        /// * Specify accounts and OUs together in a single map, separated with a comma. For example, the following is a valid map: {ACCOUNT : [accountID1, accountID2], ORG_UNIT : [ouid111, ouid112]}.
        public var excludeMap: [Swift.String: [Swift.String]]?
        /// If set to True, resources with the tags that are specified in the ResourceTag array are not in scope of the policy. If set to False, and the ResourceTag array is not null, only resources with the specified tags are in scope of the policy.
        /// This member is required.
        public var excludeResourceTags: Swift.Bool
        /// Specifies the Amazon Web Services account IDs and Organizations organizational units (OUs) to include in the policy. Specifying an OU is the equivalent of specifying all accounts in the OU and in any of its child OUs, including any child OUs and accounts that are added at a later time. You can specify inclusions or exclusions, but not both. If you specify an IncludeMap, Firewall Manager applies the policy to all accounts specified by the IncludeMap, and does not evaluate any ExcludeMap specifications. If you do not specify an IncludeMap, then Firewall Manager applies the policy to all accounts except for those specified by the ExcludeMap. You can specify account IDs, OUs, or a combination:
        ///
        /// * Specify account IDs by setting the key to ACCOUNT. For example, the following is a valid map: {ACCOUNT : [accountID1, accountID2]}.
        ///
        /// * Specify OUs by setting the key to ORG_UNIT. For example, the following is a valid map: {ORG_UNIT : [ouid111, ouid112]}.
        ///
        /// * Specify accounts and OUs together in a single map, separated with a comma. For example, the following is a valid map: {ACCOUNT : [accountID1, accountID2], ORG_UNIT : [ouid111, ouid112]}.
        public var includeMap: [Swift.String: [Swift.String]]?
        /// Your description of the Firewall Manager policy.
        public var policyDescription: Swift.String?
        /// The ID of the Firewall Manager policy.
        public var policyId: Swift.String?
        /// The name of the Firewall Manager policy.
        /// This member is required.
        public var policyName: Swift.String?
        /// Indicates whether the policy is in or out of an admin's policy or Region scope.
        ///
        /// * ACTIVE - The administrator can manage and delete the policy.
        ///
        /// * OUT_OF_ADMIN_SCOPE - The administrator can view the policy, but they can't edit or delete the policy. Existing policy protections stay in place. Any new resources that come into scope of the policy won't be protected.
        public var policyStatus: FMSClientTypes.CustomerPolicyStatus?
        /// A unique identifier for each update to the policy. When issuing a PutPolicy request, the PolicyUpdateToken in the request must match the PolicyUpdateToken of the current policy version. To get the PolicyUpdateToken of the current policy version, use a GetPolicy request.
        public var policyUpdateToken: Swift.String?
        /// Indicates if the policy should be automatically applied to new resources.
        /// This member is required.
        public var remediationEnabled: Swift.Bool
        /// The unique identifiers of the resource sets used by the policy.
        public var resourceSetIds: [Swift.String]?
        /// An array of ResourceTag objects.
        public var resourceTags: [FMSClientTypes.ResourceTag]?
        /// The type of resource protected by or in scope of the policy. This is in the format shown in the [Amazon Web Services Resource Types Reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html). To apply this policy to multiple resource types, specify a resource type of ResourceTypeList and then specify the resource types in a ResourceTypeList. The following are valid resource types for each Firewall Manager policy type:
        ///
        /// * Amazon Web Services WAF Classic - AWS::ApiGateway::Stage, AWS::CloudFront::Distribution, and AWS::ElasticLoadBalancingV2::LoadBalancer.
        ///
        /// * WAF - AWS::ApiGateway::Stage, AWS::ElasticLoadBalancingV2::LoadBalancer, and AWS::CloudFront::Distribution.
        ///
        /// * Shield Advanced - AWS::ElasticLoadBalancingV2::LoadBalancer, AWS::ElasticLoadBalancing::LoadBalancer, AWS::EC2::EIP, and AWS::CloudFront::Distribution.
        ///
        /// * Network ACL - AWS::EC2::Subnet.
        ///
        /// * Security group usage audit - AWS::EC2::SecurityGroup.
        ///
        /// * Security group content audit - AWS::EC2::SecurityGroup, AWS::EC2::NetworkInterface, and AWS::EC2::Instance.
        ///
        /// * DNS Firewall, Network Firewall, and third-party firewall - AWS::EC2::VPC.
        /// This member is required.
        public var resourceType: Swift.String?
        /// An array of ResourceType objects. Use this only to specify multiple resource types. To specify a single resource type, use ResourceType.
        public var resourceTypeList: [Swift.String]?
        /// Details about the security service that is being used to protect the resources.
        /// This member is required.
        public var securityServicePolicyData: FMSClientTypes.SecurityServicePolicyData?

        public init(
            deleteUnusedFMManagedResources: Swift.Bool = false,
            excludeMap: [Swift.String: [Swift.String]]? = nil,
            excludeResourceTags: Swift.Bool = false,
            includeMap: [Swift.String: [Swift.String]]? = nil,
            policyDescription: Swift.String? = nil,
            policyId: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyStatus: FMSClientTypes.CustomerPolicyStatus? = nil,
            policyUpdateToken: Swift.String? = nil,
            remediationEnabled: Swift.Bool = false,
            resourceSetIds: [Swift.String]? = nil,
            resourceTags: [FMSClientTypes.ResourceTag]? = nil,
            resourceType: Swift.String? = nil,
            resourceTypeList: [Swift.String]? = nil,
            securityServicePolicyData: FMSClientTypes.SecurityServicePolicyData? = nil
        )
        {
            self.deleteUnusedFMManagedResources = deleteUnusedFMManagedResources
            self.excludeMap = excludeMap
            self.excludeResourceTags = excludeResourceTags
            self.includeMap = includeMap
            self.policyDescription = policyDescription
            self.policyId = policyId
            self.policyName = policyName
            self.policyStatus = policyStatus
            self.policyUpdateToken = policyUpdateToken
            self.remediationEnabled = remediationEnabled
            self.resourceSetIds = resourceSetIds
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.resourceTypeList = resourceTypeList
            self.securityServicePolicyData = securityServicePolicyData
        }
    }
}

public struct GetPolicyOutput: Swift.Sendable {
    /// Information about the specified Firewall Manager policy.
    public var policy: FMSClientTypes.Policy?
    /// The Amazon Resource Name (ARN) of the specified policy.
    public var policyArn: Swift.String?

    public init(
        policy: FMSClientTypes.Policy? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.policyArn = policyArn
    }
}

public struct GetProtectionStatusInput: Swift.Sendable {
    /// The end of the time period to query for the attacks. This is a timestamp type. The request syntax listing indicates a number type because the default used by Firewall Manager is Unix time in seconds. However, any valid timestamp format is allowed.
    public var endTime: Foundation.Date?
    /// Specifies the number of objects that you want Firewall Manager to return for this request. If you have more objects than the number that you specify for MaxResults, the response includes a NextToken value that you can use to get another batch of objects.
    public var maxResults: Swift.Int?
    /// The Amazon Web Services account that is in scope of the policy that you want to get the details for.
    public var memberAccountId: Swift.String?
    /// If you specify a value for MaxResults and you have more objects than the number that you specify for MaxResults, Firewall Manager returns a NextToken value in the response, which you can use to retrieve another group of objects. For the second and subsequent GetProtectionStatus requests, specify the value of NextToken from the previous response to get information about another batch of objects.
    public var nextToken: Swift.String?
    /// The ID of the policy for which you want to get the attack information.
    /// This member is required.
    public var policyId: Swift.String?
    /// The start of the time period to query for the attacks. This is a timestamp type. The request syntax listing indicates a number type because the default used by Firewall Manager is Unix time in seconds. However, any valid timestamp format is allowed.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        memberAccountId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        policyId: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.memberAccountId = memberAccountId
        self.nextToken = nextToken
        self.policyId = policyId
        self.startTime = startTime
    }
}

public struct GetProtectionStatusOutput: Swift.Sendable {
    /// The ID of the Firewall Manager administrator account for this policy.
    public var adminAccountId: Swift.String?
    /// Details about the attack, including the following:
    ///
    /// * Attack type
    ///
    /// * Account ID
    ///
    /// * ARN of the resource attacked
    ///
    /// * Start time of the attack
    ///
    /// * End time of the attack (ongoing attacks will not have an end time)
    ///
    ///
    /// The details are in JSON format.
    public var data: Swift.String?
    /// If you have more objects than the number that you specified for MaxResults in the request, the response includes a NextToken value. To list more objects, submit another GetProtectionStatus request, and specify the NextToken value from the response in the NextToken value in the next request. Amazon Web Services SDKs provide auto-pagination that identify NextToken in a response and make subsequent request calls automatically on your behalf. However, this feature is not supported by GetProtectionStatus. You must submit subsequent requests with NextToken using your own processes.
    public var nextToken: Swift.String?
    /// The service type that is protected by the policy. Currently, this is always SHIELD_ADVANCED.
    public var serviceType: FMSClientTypes.SecurityServiceType?

    public init(
        adminAccountId: Swift.String? = nil,
        data: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        serviceType: FMSClientTypes.SecurityServiceType? = nil
    )
    {
        self.adminAccountId = adminAccountId
        self.data = data
        self.nextToken = nextToken
        self.serviceType = serviceType
    }
}

public struct GetProtocolsListInput: Swift.Sendable {
    /// Specifies whether the list to retrieve is a default list owned by Firewall Manager.
    public var defaultList: Swift.Bool?
    /// The ID of the Firewall Manager protocols list that you want the details for.
    /// This member is required.
    public var listId: Swift.String?

    public init(
        defaultList: Swift.Bool? = false,
        listId: Swift.String? = nil
    )
    {
        self.defaultList = defaultList
        self.listId = listId
    }
}

extension FMSClientTypes {

    /// An Firewall Manager protocols list.
    public struct ProtocolsListData: Swift.Sendable {
        /// The time that the Firewall Manager protocols list was created.
        public var createTime: Foundation.Date?
        /// The time that the Firewall Manager protocols list was last updated.
        public var lastUpdateTime: Foundation.Date?
        /// The ID of the Firewall Manager protocols list.
        public var listId: Swift.String?
        /// The name of the Firewall Manager protocols list.
        /// This member is required.
        public var listName: Swift.String?
        /// A unique identifier for each update to the list. When you update the list, the update token must match the token of the current version of the application list. You can retrieve the update token by getting the list.
        public var listUpdateToken: Swift.String?
        /// A map of previous version numbers to their corresponding protocol arrays.
        public var previousProtocolsList: [Swift.String: [Swift.String]]?
        /// An array of protocols in the Firewall Manager protocols list.
        /// This member is required.
        public var protocolsList: [Swift.String]?

        public init(
            createTime: Foundation.Date? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            listId: Swift.String? = nil,
            listName: Swift.String? = nil,
            listUpdateToken: Swift.String? = nil,
            previousProtocolsList: [Swift.String: [Swift.String]]? = nil,
            protocolsList: [Swift.String]? = nil
        )
        {
            self.createTime = createTime
            self.lastUpdateTime = lastUpdateTime
            self.listId = listId
            self.listName = listName
            self.listUpdateToken = listUpdateToken
            self.previousProtocolsList = previousProtocolsList
            self.protocolsList = protocolsList
        }
    }
}

public struct GetProtocolsListOutput: Swift.Sendable {
    /// Information about the specified Firewall Manager protocols list.
    public var protocolsList: FMSClientTypes.ProtocolsListData?
    /// The Amazon Resource Name (ARN) of the specified protocols list.
    public var protocolsListArn: Swift.String?

    public init(
        protocolsList: FMSClientTypes.ProtocolsListData? = nil,
        protocolsListArn: Swift.String? = nil
    )
    {
        self.protocolsList = protocolsList
        self.protocolsListArn = protocolsListArn
    }
}

public struct GetResourceSetInput: Swift.Sendable {
    /// A unique identifier for the resource set, used in a request to refer to the resource set.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

extension FMSClientTypes {

    public enum ResourceSetStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case outOfAdminScope
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceSetStatus] {
            return [
                .active,
                .outOfAdminScope
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .outOfAdminScope: return "OUT_OF_ADMIN_SCOPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    /// A set of resources to include in a policy.
    public struct ResourceSet: Swift.Sendable {
        /// A description of the resource set.
        public var description: Swift.String?
        /// A unique identifier for the resource set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.
        public var id: Swift.String?
        /// The last time that the resource set was changed.
        public var lastUpdateTime: Foundation.Date?
        /// The descriptive name of the resource set. You can't change the name of a resource set after you create it.
        /// This member is required.
        public var name: Swift.String?
        /// Indicates whether the resource set is in or out of an admin's Region scope.
        ///
        /// * ACTIVE - The administrator can manage and delete the resource set.
        ///
        /// * OUT_OF_ADMIN_SCOPE - The administrator can view the resource set, but they can't edit or delete the resource set. Existing protections stay in place. Any new resource that come into scope of the resource set won't be protected.
        public var resourceSetStatus: FMSClientTypes.ResourceSetStatus?
        /// Determines the resources that can be associated to the resource set. Depending on your setting for max results and the number of resource sets, a single call might not return the full list.
        /// This member is required.
        public var resourceTypeList: [Swift.String]?
        /// An optional token that you can use for optimistic locking. Firewall Manager returns a token to your requests that access the resource set. The token marks the state of the resource set resource at the time of the request. Update tokens are not allowed when creating a resource set. After creation, each subsequent update call to the resource set requires the update token. To make an unconditional change to the resource set, omit the token in your update request. Without the token, Firewall Manager performs your updates regardless of whether the resource set has changed since you last retrieved it. To make a conditional change to the resource set, provide the token in your update request. Firewall Manager uses the token to ensure that the resource set hasn't changed since you last retrieved it. If it has changed, the operation fails with an InvalidTokenException. If this happens, retrieve the resource set again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token.
        public var updateToken: Swift.String?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            resourceSetStatus: FMSClientTypes.ResourceSetStatus? = nil,
            resourceTypeList: [Swift.String]? = nil,
            updateToken: Swift.String? = nil
        )
        {
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.name = name
            self.resourceSetStatus = resourceSetStatus
            self.resourceTypeList = resourceTypeList
            self.updateToken = updateToken
        }
    }
}

public struct GetResourceSetOutput: Swift.Sendable {
    /// Information about the specified resource set.
    /// This member is required.
    public var resourceSet: FMSClientTypes.ResourceSet?
    /// The Amazon Resource Name (ARN) of the resource set.
    /// This member is required.
    public var resourceSetArn: Swift.String?

    public init(
        resourceSet: FMSClientTypes.ResourceSet? = nil,
        resourceSetArn: Swift.String? = nil
    )
    {
        self.resourceSet = resourceSet
        self.resourceSetArn = resourceSetArn
    }
}

public struct GetThirdPartyFirewallAssociationStatusInput: Swift.Sendable {
    /// The name of the third-party firewall vendor.
    /// This member is required.
    public var thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall?

    public init(
        thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall? = nil
    )
    {
        self.thirdPartyFirewall = thirdPartyFirewall
    }
}

extension FMSClientTypes {

    public enum MarketplaceSubscriptionOnboardingStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case notComplete
        case noSubscription
        case sdkUnknown(Swift.String)

        public static var allCases: [MarketplaceSubscriptionOnboardingStatus] {
            return [
                .complete,
                .notComplete,
                .noSubscription
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .notComplete: return "NOT_COMPLETE"
            case .noSubscription: return "NO_SUBSCRIPTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetThirdPartyFirewallAssociationStatusOutput: Swift.Sendable {
    /// The status for subscribing to the third-party firewall vendor in the Amazon Web Services Marketplace.
    ///
    /// * NO_SUBSCRIPTION - The Firewall Manager policy administrator isn't subscribed to the third-party firewall service in the Amazon Web Services Marketplace.
    ///
    /// * NOT_COMPLETE - The Firewall Manager policy administrator is in the process of subscribing to the third-party firewall service in the Amazon Web Services Marketplace, but doesn't yet have an active subscription.
    ///
    /// * COMPLETE - The Firewall Manager policy administrator has an active subscription to the third-party firewall service in the Amazon Web Services Marketplace.
    public var marketplaceOnboardingStatus: FMSClientTypes.MarketplaceSubscriptionOnboardingStatus?
    /// The current status for setting a Firewall Manager policy administrators account as an administrator of the third-party firewall tenant.
    ///
    /// * ONBOARDING - The Firewall Manager policy administrator is being designated as a tenant administrator.
    ///
    /// * ONBOARD_COMPLETE - The Firewall Manager policy administrator is designated as a tenant administrator.
    ///
    /// * OFFBOARDING - The Firewall Manager policy administrator is being removed as a tenant administrator.
    ///
    /// * OFFBOARD_COMPLETE - The Firewall Manager policy administrator has been removed as a tenant administrator.
    ///
    /// * NOT_EXIST - The Firewall Manager policy administrator doesn't exist as a tenant administrator.
    public var thirdPartyFirewallStatus: FMSClientTypes.ThirdPartyFirewallAssociationStatus?

    public init(
        marketplaceOnboardingStatus: FMSClientTypes.MarketplaceSubscriptionOnboardingStatus? = nil,
        thirdPartyFirewallStatus: FMSClientTypes.ThirdPartyFirewallAssociationStatus? = nil
    )
    {
        self.marketplaceOnboardingStatus = marketplaceOnboardingStatus
        self.thirdPartyFirewallStatus = thirdPartyFirewallStatus
    }
}

public struct GetViolationDetailsInput: Swift.Sendable {
    /// The Amazon Web Services account ID that you want the details for.
    /// This member is required.
    public var memberAccount: Swift.String?
    /// The ID of the Firewall Manager policy that you want the details for. You can get violation details for the following policy types:
    ///
    /// * WAF
    ///
    /// * DNS Firewall
    ///
    /// * Imported Network Firewall
    ///
    /// * Network Firewall
    ///
    /// * Security group content audit
    ///
    /// * Network ACL
    ///
    /// * Third-party firewall
    /// This member is required.
    public var policyId: Swift.String?
    /// The ID of the resource that has violations.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource type. This is in the format shown in the [Amazon Web Services Resource Types Reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html). Supported resource types are: AWS::WAFv2::WebACL, AWS::EC2::Instance, AWS::EC2::NetworkInterface, AWS::EC2::SecurityGroup, AWS::NetworkFirewall::FirewallPolicy, and AWS::EC2::Subnet.
    /// This member is required.
    public var resourceType: Swift.String?

    public init(
        memberAccount: Swift.String? = nil,
        policyId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.memberAccount = memberAccount
        self.policyId = policyId
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

extension FMSClientTypes {

    /// A collection of key:value pairs associated with an Amazon Web Services resource. The key:value pair can be anything you define. Typically, the tag key represents a category (such as "environment") and the tag value represents a specific value within that category (such as "test," "development," or "production"). You can add up to 50 tags to each Amazon Web Services resource.
    public struct Tag: Swift.Sendable {
        /// Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.
        /// This member is required.
        public var key: Swift.String?
        /// Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension FMSClientTypes {

    /// The reference rule that partially matches the ViolationTarget rule and violation reason.
    public struct PartialMatch: Swift.Sendable {
        /// The reference rule from the primary security group of the Firewall Manager policy.
        public var reference: Swift.String?
        /// The violation reason.
        public var targetViolationReasons: [Swift.String]?

        public init(
            reference: Swift.String? = nil,
            targetViolationReasons: [Swift.String]? = nil
        )
        {
            self.reference = reference
            self.targetViolationReasons = targetViolationReasons
        }
    }
}

extension FMSClientTypes {

    public enum RemediationActionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case modify
        case remove
        case sdkUnknown(Swift.String)

        public static var allCases: [RemediationActionType] {
            return [
                .modify,
                .remove
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .modify: return "MODIFY"
            case .remove: return "REMOVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    /// Describes a set of permissions for a security group rule.
    public struct SecurityGroupRuleDescription: Swift.Sendable {
        /// The start of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of -1 indicates all ICMP/ICMPv6 types.
        public var fromPort: Swift.Int?
        /// The IPv4 ranges for the security group rule.
        public var ipv4Range: Swift.String?
        /// The IPv6 ranges for the security group rule.
        public var ipv6Range: Swift.String?
        /// The ID of the prefix list for the security group rule.
        public var prefixListId: Swift.String?
        /// The IP protocol name (tcp, udp, icmp, icmpv6) or number.
        public var `protocol`: Swift.String?
        /// The end of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of -1 indicates all ICMP/ICMPv6 codes.
        public var toPort: Swift.Int?

        public init(
            fromPort: Swift.Int? = nil,
            ipv4Range: Swift.String? = nil,
            ipv6Range: Swift.String? = nil,
            prefixListId: Swift.String? = nil,
            `protocol`: Swift.String? = nil,
            toPort: Swift.Int? = nil
        )
        {
            self.fromPort = fromPort
            self.ipv4Range = ipv4Range
            self.ipv6Range = ipv6Range
            self.prefixListId = prefixListId
            self.`protocol` = `protocol`
            self.toPort = toPort
        }
    }
}

extension FMSClientTypes {

    /// Remediation option for the rule specified in the ViolationTarget.
    public struct SecurityGroupRemediationAction: Swift.Sendable {
        /// Brief description of the action that will be performed.
        public var description: Swift.String?
        /// Indicates if the current action is the default action.
        public var isDefaultAction: Swift.Bool
        /// The remediation action that will be performed.
        public var remediationActionType: FMSClientTypes.RemediationActionType?
        /// The final state of the rule specified in the ViolationTarget after it is remediated.
        public var remediationResult: FMSClientTypes.SecurityGroupRuleDescription?

        public init(
            description: Swift.String? = nil,
            isDefaultAction: Swift.Bool = false,
            remediationActionType: FMSClientTypes.RemediationActionType? = nil,
            remediationResult: FMSClientTypes.SecurityGroupRuleDescription? = nil
        )
        {
            self.description = description
            self.isDefaultAction = isDefaultAction
            self.remediationActionType = remediationActionType
            self.remediationResult = remediationResult
        }
    }
}

extension FMSClientTypes {

    /// Violation detail for the rule violation in a security group when compared to the primary security group of the Firewall Manager policy.
    public struct AwsVPCSecurityGroupViolation: Swift.Sendable {
        /// List of rules specified in the security group of the Firewall Manager policy that partially match the ViolationTarget rule.
        public var partialMatches: [FMSClientTypes.PartialMatch]?
        /// Remediation options for the rule specified in the ViolationTarget.
        public var possibleSecurityGroupRemediationActions: [FMSClientTypes.SecurityGroupRemediationAction]?
        /// The security group rule that is being evaluated.
        public var violationTarget: Swift.String?
        /// A description of the security group that violates the policy.
        public var violationTargetDescription: Swift.String?

        public init(
            partialMatches: [FMSClientTypes.PartialMatch]? = nil,
            possibleSecurityGroupRemediationActions: [FMSClientTypes.SecurityGroupRemediationAction]? = nil,
            violationTarget: Swift.String? = nil,
            violationTargetDescription: Swift.String? = nil
        )
        {
            self.partialMatches = partialMatches
            self.possibleSecurityGroupRemediationActions = possibleSecurityGroupRemediationActions
            self.violationTarget = violationTarget
            self.violationTargetDescription = violationTargetDescription
        }
    }
}

extension FMSClientTypes {

    /// A DNS Firewall rule group that Firewall Manager tried to associate with a VPC is already associated with the VPC and can't be associated again.
    public struct DnsDuplicateRuleGroupViolation: Swift.Sendable {
        /// Information about the VPC ID.
        public var violationTarget: Swift.String?
        /// A description of the violation that specifies the rule group and VPC.
        public var violationTargetDescription: Swift.String?

        public init(
            violationTarget: Swift.String? = nil,
            violationTargetDescription: Swift.String? = nil
        )
        {
            self.violationTarget = violationTarget
            self.violationTargetDescription = violationTargetDescription
        }
    }
}

extension FMSClientTypes {

    /// The VPC that Firewall Manager was applying a DNS Fireall policy to reached the limit for associated DNS Firewall rule groups. Firewall Manager tried to associate another rule group with the VPC and failed due to the limit.
    public struct DnsRuleGroupLimitExceededViolation: Swift.Sendable {
        /// The number of rule groups currently associated with the VPC.
        public var numberOfRuleGroupsAlreadyAssociated: Swift.Int
        /// Information about the VPC ID.
        public var violationTarget: Swift.String?
        /// A description of the violation that specifies the rule group and VPC.
        public var violationTargetDescription: Swift.String?

        public init(
            numberOfRuleGroupsAlreadyAssociated: Swift.Int = 0,
            violationTarget: Swift.String? = nil,
            violationTargetDescription: Swift.String? = nil
        )
        {
            self.numberOfRuleGroupsAlreadyAssociated = numberOfRuleGroupsAlreadyAssociated
            self.violationTarget = violationTarget
            self.violationTargetDescription = violationTargetDescription
        }
    }
}

extension FMSClientTypes {

    /// A rule group that Firewall Manager tried to associate with a VPC has the same priority as a rule group that's already associated.
    public struct DnsRuleGroupPriorityConflictViolation: Swift.Sendable {
        /// The ID of the Firewall Manager DNS Firewall policy that was already applied to the VPC. This policy contains the rule group that's already associated with the VPC.
        public var conflictingPolicyId: Swift.String?
        /// The priority setting of the two conflicting rule groups.
        public var conflictingPriority: Swift.Int
        /// The priorities of rule groups that are already associated with the VPC. To retry your operation, choose priority settings that aren't in this list for the rule groups in your new DNS Firewall policy.
        public var unavailablePriorities: [Swift.Int]?
        /// Information about the VPC ID.
        public var violationTarget: Swift.String?
        /// A description of the violation that specifies the VPC and the rule group that's already associated with it.
        public var violationTargetDescription: Swift.String?

        public init(
            conflictingPolicyId: Swift.String? = nil,
            conflictingPriority: Swift.Int = 0,
            unavailablePriorities: [Swift.Int]? = nil,
            violationTarget: Swift.String? = nil,
            violationTargetDescription: Swift.String? = nil
        )
        {
            self.conflictingPolicyId = conflictingPolicyId
            self.conflictingPriority = conflictingPriority
            self.unavailablePriorities = unavailablePriorities
            self.violationTarget = violationTarget
            self.violationTargetDescription = violationTargetDescription
        }
    }
}

extension FMSClientTypes {

    /// Contains details about the firewall subnet that violates the policy scope.
    public struct FirewallSubnetIsOutOfScopeViolation: Swift.Sendable {
        /// The ID of the firewall subnet that violates the policy scope.
        public var firewallSubnetId: Swift.String?
        /// The Availability Zone of the firewall subnet that violates the policy scope.
        public var subnetAvailabilityZone: Swift.String?
        /// The Availability Zone ID of the firewall subnet that violates the policy scope.
        public var subnetAvailabilityZoneId: Swift.String?
        /// The VPC endpoint ID of the firewall subnet that violates the policy scope.
        public var vpcEndpointId: Swift.String?
        /// The VPC ID of the firewall subnet that violates the policy scope.
        public var vpcId: Swift.String?

        public init(
            firewallSubnetId: Swift.String? = nil,
            subnetAvailabilityZone: Swift.String? = nil,
            subnetAvailabilityZoneId: Swift.String? = nil,
            vpcEndpointId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.firewallSubnetId = firewallSubnetId
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetAvailabilityZoneId = subnetAvailabilityZoneId
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }
    }
}

extension FMSClientTypes {

    /// The violation details for a firewall subnet's VPC endpoint that's deleted or missing.
    public struct FirewallSubnetMissingVPCEndpointViolation: Swift.Sendable {
        /// The ID of the firewall that this VPC endpoint is associated with.
        public var firewallSubnetId: Swift.String?
        /// The name of the Availability Zone of the deleted VPC subnet.
        public var subnetAvailabilityZone: Swift.String?
        /// The ID of the Availability Zone of the deleted VPC subnet.
        public var subnetAvailabilityZoneId: Swift.String?
        /// The resource ID of the VPC associated with the deleted VPC subnet.
        public var vpcId: Swift.String?

        public init(
            firewallSubnetId: Swift.String? = nil,
            subnetAvailabilityZone: Swift.String? = nil,
            subnetAvailabilityZoneId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.firewallSubnetId = firewallSubnetId
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetAvailabilityZoneId = subnetAvailabilityZoneId
            self.vpcId = vpcId
        }
    }
}

extension FMSClientTypes {

    public enum EntryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customentry
        case fmsmanagedfirstentry
        case fmsmanagedlastentry
        case sdkUnknown(Swift.String)

        public static var allCases: [EntryType] {
            return [
                .customentry,
                .fmsmanagedfirstentry,
                .fmsmanagedlastentry
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customentry: return "CUSTOM_ENTRY"
            case .fmsmanagedfirstentry: return "FMS_MANAGED_FIRST_ENTRY"
            case .fmsmanagedlastentry: return "FMS_MANAGED_LAST_ENTRY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    /// Describes a single rule in a network ACL.
    public struct EntryDescription: Swift.Sendable {
        /// Describes a rule in a network ACL. Each network ACL has a set of numbered ingress rules and a separate set of numbered egress rules. When determining whether a packet should be allowed in or out of a subnet associated with the network ACL, Amazon Web Services processes the entries in the network ACL according to the rule numbers, in ascending order. When you manage an individual network ACL, you explicitly specify the rule numbers. When you specify the network ACL rules in a Firewall Manager policy, you provide the rules to run first, in the order that you want them to run, and the rules to run last, in the order that you want them to run. Firewall Manager assigns the rule numbers for you when you save the network ACL policy specification.
        public var entryDetail: FMSClientTypes.NetworkAclEntry?
        /// The rule number for the entry. ACL entries are processed in ascending order by rule number. In a Firewall Manager network ACL policy, Firewall Manager assigns rule numbers.
        public var entryRuleNumber: Swift.Int
        /// Specifies whether the entry is managed by Firewall Manager or by a user, and, for Firewall Manager-managed entries, specifies whether the entry is among those that run first in the network ACL or those that run last.
        public var entryType: FMSClientTypes.EntryType?

        public init(
            entryDetail: FMSClientTypes.NetworkAclEntry? = nil,
            entryRuleNumber: Swift.Int = 0,
            entryType: FMSClientTypes.EntryType? = nil
        )
        {
            self.entryDetail = entryDetail
            self.entryRuleNumber = entryRuleNumber
            self.entryType = entryType
        }
    }
}

extension FMSClientTypes {

    public enum EntryViolationReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case entryconflict
        case incorrectentryorder
        case missingexpectedentry
        case sdkUnknown(Swift.String)

        public static var allCases: [EntryViolationReason] {
            return [
                .entryconflict,
                .incorrectentryorder,
                .missingexpectedentry
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .entryconflict: return "ENTRY_CONFLICT"
            case .incorrectentryorder: return "INCORRECT_ENTRY_ORDER"
            case .missingexpectedentry: return "MISSING_EXPECTED_ENTRY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    /// Detailed information about an entry violation in a network ACL. The violation is against the network ACL specification inside the Firewall Manager network ACL policy. This data object is part of InvalidNetworkAclEntriesViolation.
    public struct EntryViolation: Swift.Sendable {
        /// The evaluation location within the ordered list of entries where the ExpectedEntry is currently located.
        public var actualEvaluationOrder: Swift.String?
        /// The list of entries that are in conflict with ExpectedEntry.
        public var entriesWithConflicts: [FMSClientTypes.EntryDescription]?
        /// The entry that's currently in the ExpectedEvaluationOrder location, in place of the expected entry.
        public var entryAtExpectedEvaluationOrder: FMSClientTypes.EntryDescription?
        /// Descriptions of the violations that Firewall Manager found for these entries.
        public var entryViolationReasons: [FMSClientTypes.EntryViolationReason]?
        /// The Firewall Manager-managed network ACL entry that is involved in the entry violation.
        public var expectedEntry: FMSClientTypes.EntryDescription?
        /// The evaluation location within the ordered list of entries where the ExpectedEntry should be, according to the network ACL policy specifications.
        public var expectedEvaluationOrder: Swift.String?

        public init(
            actualEvaluationOrder: Swift.String? = nil,
            entriesWithConflicts: [FMSClientTypes.EntryDescription]? = nil,
            entryAtExpectedEvaluationOrder: FMSClientTypes.EntryDescription? = nil,
            entryViolationReasons: [FMSClientTypes.EntryViolationReason]? = nil,
            expectedEntry: FMSClientTypes.EntryDescription? = nil,
            expectedEvaluationOrder: Swift.String? = nil
        )
        {
            self.actualEvaluationOrder = actualEvaluationOrder
            self.entriesWithConflicts = entriesWithConflicts
            self.entryAtExpectedEvaluationOrder = entryAtExpectedEvaluationOrder
            self.entryViolationReasons = entryViolationReasons
            self.expectedEntry = expectedEntry
            self.expectedEvaluationOrder = expectedEvaluationOrder
        }
    }
}

extension FMSClientTypes {

    /// Violation detail for the entries in a network ACL resource.
    public struct InvalidNetworkAclEntriesViolation: Swift.Sendable {
        /// The network ACL containing the entry violations.
        public var currentAssociatedNetworkAcl: Swift.String?
        /// Detailed information about the entry violations in the network ACL.
        public var entryViolations: [FMSClientTypes.EntryViolation]?
        /// The subnet that's associated with the network ACL.
        public var subnet: Swift.String?
        /// The Availability Zone where the network ACL is in use.
        public var subnetAvailabilityZone: Swift.String?
        /// The VPC where the violation was found.
        public var vpc: Swift.String?

        public init(
            currentAssociatedNetworkAcl: Swift.String? = nil,
            entryViolations: [FMSClientTypes.EntryViolation]? = nil,
            subnet: Swift.String? = nil,
            subnetAvailabilityZone: Swift.String? = nil,
            vpc: Swift.String? = nil
        )
        {
            self.currentAssociatedNetworkAcl = currentAssociatedNetworkAcl
            self.entryViolations = entryViolations
            self.subnet = subnet
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.vpc = vpc
        }
    }
}

extension FMSClientTypes {

    public enum DestinationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ipv4
        case ipv6
        case prefixlist
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationType] {
            return [
                .ipv4,
                .ipv6,
                .prefixlist
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ipv4: return "IPV4"
            case .ipv6: return "IPV6"
            case .prefixlist: return "PREFIX_LIST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    public enum TargetType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case carriergateway
        case egressonlyinternetgateway
        case gateway
        case instance
        case localgateway
        case natgateway
        case networkinterface
        case transitgateway
        case vpcendpoint
        case vpcpeeringconnection
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetType] {
            return [
                .carriergateway,
                .egressonlyinternetgateway,
                .gateway,
                .instance,
                .localgateway,
                .natgateway,
                .networkinterface,
                .transitgateway,
                .vpcendpoint,
                .vpcpeeringconnection
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .carriergateway: return "CARRIER_GATEWAY"
            case .egressonlyinternetgateway: return "EGRESS_ONLY_INTERNET_GATEWAY"
            case .gateway: return "GATEWAY"
            case .instance: return "INSTANCE"
            case .localgateway: return "LOCAL_GATEWAY"
            case .natgateway: return "NAT_GATEWAY"
            case .networkinterface: return "NETWORK_INTERFACE"
            case .transitgateway: return "TRANSIT_GATEWAY"
            case .vpcendpoint: return "VPC_ENDPOINT"
            case .vpcpeeringconnection: return "VPC_PEERING_CONNECTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    /// Describes a route in a route table.
    public struct Route: Swift.Sendable {
        /// The destination of the route.
        public var destination: Swift.String?
        /// The type of destination for the route.
        public var destinationType: FMSClientTypes.DestinationType?
        /// The route's target.
        public var target: Swift.String?
        /// The type of target for the route.
        public var targetType: FMSClientTypes.TargetType?

        public init(
            destination: Swift.String? = nil,
            destinationType: FMSClientTypes.DestinationType? = nil,
            target: Swift.String? = nil,
            targetType: FMSClientTypes.TargetType? = nil
        )
        {
            self.destination = destination
            self.destinationType = destinationType
            self.target = target
            self.targetType = targetType
        }
    }
}

extension FMSClientTypes {

    /// Violation detail for an internet gateway route with an inactive state in the customer subnet route table or Network Firewall subnet route table.
    public struct NetworkFirewallBlackHoleRouteDetectedViolation: Swift.Sendable {
        /// Information about the route table ID.
        public var routeTableId: Swift.String?
        /// Information about the route or routes that are in violation.
        public var violatingRoutes: [FMSClientTypes.Route]?
        /// The subnet that has an inactive state.
        public var violationTarget: Swift.String?
        /// Information about the VPC ID.
        public var vpcId: Swift.String?

        public init(
            routeTableId: Swift.String? = nil,
            violatingRoutes: [FMSClientTypes.Route]? = nil,
            violationTarget: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.routeTableId = routeTableId
            self.violatingRoutes = violatingRoutes
            self.violationTarget = violationTarget
            self.vpcId = vpcId
        }
    }
}

extension FMSClientTypes {

    /// Information about the expected route in the route table.
    public struct ExpectedRoute: Swift.Sendable {
        /// Information about the allowed targets.
        public var allowedTargets: [Swift.String]?
        /// Information about the contributing subnets.
        public var contributingSubnets: [Swift.String]?
        /// Information about the IPv4 CIDR block.
        public var ipV4Cidr: Swift.String?
        /// Information about the IPv6 CIDR block.
        public var ipV6Cidr: Swift.String?
        /// Information about the ID of the prefix list for the route.
        public var prefixListId: Swift.String?
        /// Information about the route table ID.
        public var routeTableId: Swift.String?

        public init(
            allowedTargets: [Swift.String]? = nil,
            contributingSubnets: [Swift.String]? = nil,
            ipV4Cidr: Swift.String? = nil,
            ipV6Cidr: Swift.String? = nil,
            prefixListId: Swift.String? = nil,
            routeTableId: Swift.String? = nil
        )
        {
            self.allowedTargets = allowedTargets
            self.contributingSubnets = contributingSubnets
            self.ipV4Cidr = ipV4Cidr
            self.ipV6Cidr = ipV6Cidr
            self.prefixListId = prefixListId
            self.routeTableId = routeTableId
        }
    }
}

extension FMSClientTypes {

    /// Violation detail for the subnet for which internet traffic that hasn't been inspected.
    public struct NetworkFirewallInternetTrafficNotInspectedViolation: Swift.Sendable {
        /// The actual firewall subnet routes.
        public var actualFirewallSubnetRoutes: [FMSClientTypes.Route]?
        /// The actual internet gateway routes.
        public var actualInternetGatewayRoutes: [FMSClientTypes.Route]?
        /// Information about the subnet route table for the current firewall.
        public var currentFirewallSubnetRouteTable: Swift.String?
        /// The current route table for the internet gateway.
        public var currentInternetGatewayRouteTable: Swift.String?
        /// The expected endpoint for the current firewall.
        public var expectedFirewallEndpoint: Swift.String?
        /// The firewall subnet routes that are expected.
        public var expectedFirewallSubnetRoutes: [FMSClientTypes.ExpectedRoute]?
        /// The internet gateway routes that are expected.
        public var expectedInternetGatewayRoutes: [FMSClientTypes.ExpectedRoute]?
        /// The firewall subnet ID.
        public var firewallSubnetId: Swift.String?
        /// The internet gateway ID.
        public var internetGatewayId: Swift.String?
        /// Information about whether the route table is used in another Availability Zone.
        public var isRouteTableUsedInDifferentAZ: Swift.Bool
        /// Information about the route table ID.
        public var routeTableId: Swift.String?
        /// The subnet Availability Zone.
        public var subnetAvailabilityZone: Swift.String?
        /// The subnet ID.
        public var subnetId: Swift.String?
        /// The route or routes that are in violation.
        public var violatingRoutes: [FMSClientTypes.Route]?
        /// Information about the VPC ID.
        public var vpcId: Swift.String?

        public init(
            actualFirewallSubnetRoutes: [FMSClientTypes.Route]? = nil,
            actualInternetGatewayRoutes: [FMSClientTypes.Route]? = nil,
            currentFirewallSubnetRouteTable: Swift.String? = nil,
            currentInternetGatewayRouteTable: Swift.String? = nil,
            expectedFirewallEndpoint: Swift.String? = nil,
            expectedFirewallSubnetRoutes: [FMSClientTypes.ExpectedRoute]? = nil,
            expectedInternetGatewayRoutes: [FMSClientTypes.ExpectedRoute]? = nil,
            firewallSubnetId: Swift.String? = nil,
            internetGatewayId: Swift.String? = nil,
            isRouteTableUsedInDifferentAZ: Swift.Bool = false,
            routeTableId: Swift.String? = nil,
            subnetAvailabilityZone: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            violatingRoutes: [FMSClientTypes.Route]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.actualFirewallSubnetRoutes = actualFirewallSubnetRoutes
            self.actualInternetGatewayRoutes = actualInternetGatewayRoutes
            self.currentFirewallSubnetRouteTable = currentFirewallSubnetRouteTable
            self.currentInternetGatewayRouteTable = currentInternetGatewayRouteTable
            self.expectedFirewallEndpoint = expectedFirewallEndpoint
            self.expectedFirewallSubnetRoutes = expectedFirewallSubnetRoutes
            self.expectedInternetGatewayRoutes = expectedInternetGatewayRoutes
            self.firewallSubnetId = firewallSubnetId
            self.internetGatewayId = internetGatewayId
            self.isRouteTableUsedInDifferentAZ = isRouteTableUsedInDifferentAZ
            self.routeTableId = routeTableId
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetId = subnetId
            self.violatingRoutes = violatingRoutes
            self.vpcId = vpcId
        }
    }
}

extension FMSClientTypes {

    /// Violation detail for the improperly configured subnet route. It's possible there is a missing route table route, or a configuration that causes traffic to cross an Availability Zone boundary.
    public struct NetworkFirewallInvalidRouteConfigurationViolation: Swift.Sendable {
        /// The actual firewall endpoint.
        public var actualFirewallEndpoint: Swift.String?
        /// The actual subnet ID for the firewall.
        public var actualFirewallSubnetId: Swift.String?
        /// The actual firewall subnet routes that are expected.
        public var actualFirewallSubnetRoutes: [FMSClientTypes.Route]?
        /// The actual internet gateway routes.
        public var actualInternetGatewayRoutes: [FMSClientTypes.Route]?
        /// The subnets that are affected.
        public var affectedSubnets: [Swift.String]?
        /// The subnet route table for the current firewall.
        public var currentFirewallSubnetRouteTable: Swift.String?
        /// The route table for the current internet gateway.
        public var currentInternetGatewayRouteTable: Swift.String?
        /// The firewall endpoint that's expected.
        public var expectedFirewallEndpoint: Swift.String?
        /// The expected subnet ID for the firewall.
        public var expectedFirewallSubnetId: Swift.String?
        /// The firewall subnet routes that are expected.
        public var expectedFirewallSubnetRoutes: [FMSClientTypes.ExpectedRoute]?
        /// The expected routes for the internet gateway.
        public var expectedInternetGatewayRoutes: [FMSClientTypes.ExpectedRoute]?
        /// The internet gateway ID.
        public var internetGatewayId: Swift.String?
        /// Information about whether the route table is used in another Availability Zone.
        public var isRouteTableUsedInDifferentAZ: Swift.Bool
        /// The route table ID.
        public var routeTableId: Swift.String?
        /// The route that's in violation.
        public var violatingRoute: FMSClientTypes.Route?
        /// Information about the VPC ID.
        public var vpcId: Swift.String?

        public init(
            actualFirewallEndpoint: Swift.String? = nil,
            actualFirewallSubnetId: Swift.String? = nil,
            actualFirewallSubnetRoutes: [FMSClientTypes.Route]? = nil,
            actualInternetGatewayRoutes: [FMSClientTypes.Route]? = nil,
            affectedSubnets: [Swift.String]? = nil,
            currentFirewallSubnetRouteTable: Swift.String? = nil,
            currentInternetGatewayRouteTable: Swift.String? = nil,
            expectedFirewallEndpoint: Swift.String? = nil,
            expectedFirewallSubnetId: Swift.String? = nil,
            expectedFirewallSubnetRoutes: [FMSClientTypes.ExpectedRoute]? = nil,
            expectedInternetGatewayRoutes: [FMSClientTypes.ExpectedRoute]? = nil,
            internetGatewayId: Swift.String? = nil,
            isRouteTableUsedInDifferentAZ: Swift.Bool = false,
            routeTableId: Swift.String? = nil,
            violatingRoute: FMSClientTypes.Route? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.actualFirewallEndpoint = actualFirewallEndpoint
            self.actualFirewallSubnetId = actualFirewallSubnetId
            self.actualFirewallSubnetRoutes = actualFirewallSubnetRoutes
            self.actualInternetGatewayRoutes = actualInternetGatewayRoutes
            self.affectedSubnets = affectedSubnets
            self.currentFirewallSubnetRouteTable = currentFirewallSubnetRouteTable
            self.currentInternetGatewayRouteTable = currentInternetGatewayRouteTable
            self.expectedFirewallEndpoint = expectedFirewallEndpoint
            self.expectedFirewallSubnetId = expectedFirewallSubnetId
            self.expectedFirewallSubnetRoutes = expectedFirewallSubnetRoutes
            self.expectedInternetGatewayRoutes = expectedInternetGatewayRoutes
            self.internetGatewayId = internetGatewayId
            self.isRouteTableUsedInDifferentAZ = isRouteTableUsedInDifferentAZ
            self.routeTableId = routeTableId
            self.violatingRoute = violatingRoute
            self.vpcId = vpcId
        }
    }
}

extension FMSClientTypes {

    /// Violation detail for an expected route missing in Network Firewall.
    public struct NetworkFirewallMissingExpectedRoutesViolation: Swift.Sendable {
        /// The expected routes.
        public var expectedRoutes: [FMSClientTypes.ExpectedRoute]?
        /// The target of the violation.
        public var violationTarget: Swift.String?
        /// Information about the VPC ID.
        public var vpcId: Swift.String?

        public init(
            expectedRoutes: [FMSClientTypes.ExpectedRoute]? = nil,
            violationTarget: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.expectedRoutes = expectedRoutes
            self.violationTarget = violationTarget
            self.vpcId = vpcId
        }
    }
}

extension FMSClientTypes {

    /// Violation detail for Network Firewall for a subnet that's not associated to the expected Firewall Manager managed route table.
    public struct NetworkFirewallMissingExpectedRTViolation: Swift.Sendable {
        /// The Availability Zone of a violating subnet.
        public var availabilityZone: Swift.String?
        /// The resource ID of the current route table that's associated with the subnet, if one is available.
        public var currentRouteTable: Swift.String?
        /// The resource ID of the route table that should be associated with the subnet.
        public var expectedRouteTable: Swift.String?
        /// The ID of the Network Firewall or VPC resource that's in violation.
        public var violationTarget: Swift.String?
        /// The resource ID of the VPC associated with a violating subnet.
        public var vpc: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            currentRouteTable: Swift.String? = nil,
            expectedRouteTable: Swift.String? = nil,
            violationTarget: Swift.String? = nil,
            vpc: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.currentRouteTable = currentRouteTable
            self.expectedRouteTable = expectedRouteTable
            self.violationTarget = violationTarget
            self.vpc = vpc
        }
    }
}

extension FMSClientTypes {

    /// Violation detail for Network Firewall for a subnet that doesn't have a Firewall Manager managed firewall in its VPC.
    public struct NetworkFirewallMissingFirewallViolation: Swift.Sendable {
        /// The Availability Zone of a violating subnet.
        public var availabilityZone: Swift.String?
        /// The reason the resource has this violation, if one is available.
        public var targetViolationReason: Swift.String?
        /// The ID of the Network Firewall or VPC resource that's in violation.
        public var violationTarget: Swift.String?
        /// The resource ID of the VPC associated with a violating subnet.
        public var vpc: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            targetViolationReason: Swift.String? = nil,
            violationTarget: Swift.String? = nil,
            vpc: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.targetViolationReason = targetViolationReason
            self.violationTarget = violationTarget
            self.vpc = vpc
        }
    }
}

extension FMSClientTypes {

    /// Violation detail for Network Firewall for an Availability Zone that's missing the expected Firewall Manager managed subnet.
    public struct NetworkFirewallMissingSubnetViolation: Swift.Sendable {
        /// The Availability Zone of a violating subnet.
        public var availabilityZone: Swift.String?
        /// The reason the resource has this violation, if one is available.
        public var targetViolationReason: Swift.String?
        /// The ID of the Network Firewall or VPC resource that's in violation.
        public var violationTarget: Swift.String?
        /// The resource ID of the VPC associated with a violating subnet.
        public var vpc: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            targetViolationReason: Swift.String? = nil,
            violationTarget: Swift.String? = nil,
            vpc: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.targetViolationReason = targetViolationReason
            self.violationTarget = violationTarget
            self.vpc = vpc
        }
    }
}

extension FMSClientTypes {

    public enum RuleOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case defaultActionOrder
        case strictOrder
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleOrder] {
            return [
                .defaultActionOrder,
                .strictOrder
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .defaultActionOrder: return "DEFAULT_ACTION_ORDER"
            case .strictOrder: return "STRICT_ORDER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    public enum StreamExceptionPolicy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `continue`
        case drop
        case fmsIgnore
        case reject
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamExceptionPolicy] {
            return [
                .continue,
                .drop,
                .fmsIgnore,
                .reject
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .continue: return "CONTINUE"
            case .drop: return "DROP"
            case .fmsIgnore: return "FMS_IGNORE"
            case .reject: return "REJECT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    /// Configuration settings for the handling of the stateful rule groups in a Network Firewall firewall policy.
    public struct StatefulEngineOptions: Swift.Sendable {
        /// Indicates how to manage the order of stateful rule evaluation for the policy. Stateful rules are provided to the rule engine as Suricata compatible strings, and Suricata evaluates them based on certain settings. For more information, see [Evaluation order for stateful rules](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html) in the Network Firewall Developer Guide. Default: DEFAULT_ACTION_ORDER
        public var ruleOrder: FMSClientTypes.RuleOrder?
        /// Indicates how Network Firewall should handle traffic when a network connection breaks midstream.
        ///
        /// * DROP - Fail closed and drop all subsequent traffic going to the firewall.
        ///
        /// * CONTINUE - Continue to apply rules to subsequent traffic without context from traffic before the break. This impacts the behavior of rules that depend on context. For example, with a stateful rule that drops HTTP traffic, Network Firewall won't match subsequent traffic because the it won't have the context from session initialization, which defines the application layer protocol as HTTP. However, a TCP-layer rule using a flow:stateless rule would still match, and so would the aws:drop_strict default action.
        ///
        /// * REJECT - Fail closed and drop all subsequent traffic going to the firewall. With this option, Network Firewall also sends a TCP reject packet back to the client so the client can immediately establish a new session. With the new session, Network Firewall will have context and will apply rules appropriately. For applications that are reliant on long-lived TCP connections that trigger Gateway Load Balancer idle timeouts, this is the recommended setting.
        ///
        /// * FMS_IGNORE - Firewall Manager doesn't monitor or modify the Network Firewall stream exception policy settings.
        ///
        ///
        /// For more information, see [Stream exception policy in your firewall policy](https://docs.aws.amazon.com/network-firewall/latest/developerguide/stream-exception-policy.html) in the Network Firewall Developer Guide. Default: FMS_IGNORE
        public var streamExceptionPolicy: FMSClientTypes.StreamExceptionPolicy?

        public init(
            ruleOrder: FMSClientTypes.RuleOrder? = nil,
            streamExceptionPolicy: FMSClientTypes.StreamExceptionPolicy? = nil
        )
        {
            self.ruleOrder = ruleOrder
            self.streamExceptionPolicy = streamExceptionPolicy
        }
    }
}

extension FMSClientTypes {

    public enum NetworkFirewallOverrideAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dropToAlert
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkFirewallOverrideAction] {
            return [
                .dropToAlert
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dropToAlert: return "DROP_TO_ALERT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    /// The setting that allows the policy owner to change the behavior of the rule group within a policy.
    public struct NetworkFirewallStatefulRuleGroupOverride: Swift.Sendable {
        /// The action that changes the rule group from DROP to ALERT. This only applies to managed rule groups.
        public var action: FMSClientTypes.NetworkFirewallOverrideAction?

        public init(
            action: FMSClientTypes.NetworkFirewallOverrideAction? = nil
        )
        {
            self.action = action
        }
    }
}

extension FMSClientTypes {

    /// Network Firewall stateful rule group, used in a [NetworkFirewallPolicyDescription].
    public struct StatefulRuleGroup: Swift.Sendable {
        /// The action that allows the policy owner to override the behavior of the rule group within a policy.
        public var `override`: FMSClientTypes.NetworkFirewallStatefulRuleGroupOverride?
        /// An integer setting that indicates the order in which to run the stateful rule groups in a single Network Firewall firewall policy. This setting only applies to firewall policies that specify the STRICT_ORDER rule order in the stateful engine options settings. Network Firewall evalutes each stateful rule group against a packet starting with the group that has the lowest priority setting. You must ensure that the priority settings are unique within each policy. For information about You can change the priority settings of your rule groups at any time. To make it easier to insert rule groups later, number them so there's a wide range in between, for example use 100, 200, and so on.
        public var priority: Swift.Int?
        /// The resource ID of the rule group.
        public var resourceId: Swift.String?
        /// The name of the rule group.
        public var ruleGroupName: Swift.String?

        public init(
            `override`: FMSClientTypes.NetworkFirewallStatefulRuleGroupOverride? = nil,
            priority: Swift.Int? = nil,
            resourceId: Swift.String? = nil,
            ruleGroupName: Swift.String? = nil
        )
        {
            self.`override` = `override`
            self.priority = priority
            self.resourceId = resourceId
            self.ruleGroupName = ruleGroupName
        }
    }
}

extension FMSClientTypes {

    /// Network Firewall stateless rule group, used in a [NetworkFirewallPolicyDescription].
    public struct StatelessRuleGroup: Swift.Sendable {
        /// The priority of the rule group. Network Firewall evaluates the stateless rule groups in a firewall policy starting from the lowest priority setting.
        public var priority: Swift.Int?
        /// The resource ID of the rule group.
        public var resourceId: Swift.String?
        /// The name of the rule group.
        public var ruleGroupName: Swift.String?

        public init(
            priority: Swift.Int? = nil,
            resourceId: Swift.String? = nil,
            ruleGroupName: Swift.String? = nil
        )
        {
            self.priority = priority
            self.resourceId = resourceId
            self.ruleGroupName = ruleGroupName
        }
    }
}

extension FMSClientTypes {

    /// The definition of the Network Firewall firewall policy.
    public struct NetworkFirewallPolicyDescription: Swift.Sendable {
        /// The default actions to take on a packet that doesn't match any stateful rules. The stateful default action is optional, and is only valid when using the strict rule order. Valid values of the stateful default action:
        ///
        /// * aws:drop_strict
        ///
        /// * aws:drop_established
        ///
        /// * aws:alert_strict
        ///
        /// * aws:alert_established
        public var statefulDefaultActions: [Swift.String]?
        /// Additional options governing how Network Firewall handles stateful rules. The stateful rule groups that you use in your policy must have stateful rule options settings that are compatible with these settings.
        public var statefulEngineOptions: FMSClientTypes.StatefulEngineOptions?
        /// The stateful rule groups that are used in the Network Firewall firewall policy.
        public var statefulRuleGroups: [FMSClientTypes.StatefulRuleGroup]?
        /// Names of custom actions that are available for use in the stateless default actions settings.
        public var statelessCustomActions: [Swift.String]?
        /// The actions to take on packets that don't match any of the stateless rule groups.
        public var statelessDefaultActions: [Swift.String]?
        /// The actions to take on packet fragments that don't match any of the stateless rule groups.
        public var statelessFragmentDefaultActions: [Swift.String]?
        /// The stateless rule groups that are used in the Network Firewall firewall policy.
        public var statelessRuleGroups: [FMSClientTypes.StatelessRuleGroup]?

        public init(
            statefulDefaultActions: [Swift.String]? = nil,
            statefulEngineOptions: FMSClientTypes.StatefulEngineOptions? = nil,
            statefulRuleGroups: [FMSClientTypes.StatefulRuleGroup]? = nil,
            statelessCustomActions: [Swift.String]? = nil,
            statelessDefaultActions: [Swift.String]? = nil,
            statelessFragmentDefaultActions: [Swift.String]? = nil,
            statelessRuleGroups: [FMSClientTypes.StatelessRuleGroup]? = nil
        )
        {
            self.statefulDefaultActions = statefulDefaultActions
            self.statefulEngineOptions = statefulEngineOptions
            self.statefulRuleGroups = statefulRuleGroups
            self.statelessCustomActions = statelessCustomActions
            self.statelessDefaultActions = statelessDefaultActions
            self.statelessFragmentDefaultActions = statelessFragmentDefaultActions
            self.statelessRuleGroups = statelessRuleGroups
        }
    }
}

extension FMSClientTypes {

    /// Violation detail for Network Firewall for a firewall policy that has a different [NetworkFirewallPolicyDescription] than is required by the Firewall Manager policy.
    public struct NetworkFirewallPolicyModifiedViolation: Swift.Sendable {
        /// The policy that's currently in use in the individual account.
        public var currentPolicyDescription: FMSClientTypes.NetworkFirewallPolicyDescription?
        /// The policy that should be in use in the individual account in order to be compliant.
        public var expectedPolicyDescription: FMSClientTypes.NetworkFirewallPolicyDescription?
        /// The ID of the Network Firewall or VPC resource that's in violation.
        public var violationTarget: Swift.String?

        public init(
            currentPolicyDescription: FMSClientTypes.NetworkFirewallPolicyDescription? = nil,
            expectedPolicyDescription: FMSClientTypes.NetworkFirewallPolicyDescription? = nil,
            violationTarget: Swift.String? = nil
        )
        {
            self.currentPolicyDescription = currentPolicyDescription
            self.expectedPolicyDescription = expectedPolicyDescription
            self.violationTarget = violationTarget
        }
    }
}

extension FMSClientTypes {

    /// Violation detail for an unexpected route that's present in a route table.
    public struct NetworkFirewallUnexpectedFirewallRoutesViolation: Swift.Sendable {
        /// The endpoint of the firewall.
        public var firewallEndpoint: Swift.String?
        /// The subnet ID for the firewall.
        public var firewallSubnetId: Swift.String?
        /// The ID of the route table.
        public var routeTableId: Swift.String?
        /// The routes that are in violation.
        public var violatingRoutes: [FMSClientTypes.Route]?
        /// Information about the VPC ID.
        public var vpcId: Swift.String?

        public init(
            firewallEndpoint: Swift.String? = nil,
            firewallSubnetId: Swift.String? = nil,
            routeTableId: Swift.String? = nil,
            violatingRoutes: [FMSClientTypes.Route]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.firewallEndpoint = firewallEndpoint
            self.firewallSubnetId = firewallSubnetId
            self.routeTableId = routeTableId
            self.violatingRoutes = violatingRoutes
            self.vpcId = vpcId
        }
    }
}

extension FMSClientTypes {

    /// Violation detail for an unexpected gateway route thats present in a route table.
    public struct NetworkFirewallUnexpectedGatewayRoutesViolation: Swift.Sendable {
        /// Information about the gateway ID.
        public var gatewayId: Swift.String?
        /// Information about the route table.
        public var routeTableId: Swift.String?
        /// The routes that are in violation.
        public var violatingRoutes: [FMSClientTypes.Route]?
        /// Information about the VPC ID.
        public var vpcId: Swift.String?

        public init(
            gatewayId: Swift.String? = nil,
            routeTableId: Swift.String? = nil,
            violatingRoutes: [FMSClientTypes.Route]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.gatewayId = gatewayId
            self.routeTableId = routeTableId
            self.violatingRoutes = violatingRoutes
            self.vpcId = vpcId
        }
    }
}

extension FMSClientTypes {

    /// Information about the CreateNetworkAcl action in Amazon EC2. This is a remediation option in RemediationAction.
    public struct CreateNetworkAclAction: Swift.Sendable {
        /// Brief description of this remediation action.
        public var description: Swift.String?
        /// Indicates whether it is possible for Firewall Manager to perform this remediation action. A false value indicates that auto remediation is disabled or Firewall Manager is unable to perform the action due to a conflict of some kind.
        public var fmsCanRemediate: Swift.Bool
        /// The VPC that's associated with the remediation action.
        public var vpc: FMSClientTypes.ActionTarget?

        public init(
            description: Swift.String? = nil,
            fmsCanRemediate: Swift.Bool = false,
            vpc: FMSClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.fmsCanRemediate = fmsCanRemediate
            self.vpc = vpc
        }
    }
}

extension FMSClientTypes {

    /// Information about the CreateNetworkAclEntries action in Amazon EC2. This is a remediation option in RemediationAction.
    public struct CreateNetworkAclEntriesAction: Swift.Sendable {
        /// Brief description of this remediation action.
        public var description: Swift.String?
        /// Indicates whether it is possible for Firewall Manager to perform this remediation action. A false value indicates that auto remediation is disabled or Firewall Manager is unable to perform the action due to a conflict of some kind.
        public var fmsCanRemediate: Swift.Bool
        /// Lists the entries that the remediation action would create.
        public var networkAclEntriesToBeCreated: [FMSClientTypes.EntryDescription]?
        /// The network ACL that's associated with the remediation action.
        public var networkAclId: FMSClientTypes.ActionTarget?

        public init(
            description: Swift.String? = nil,
            fmsCanRemediate: Swift.Bool = false,
            networkAclEntriesToBeCreated: [FMSClientTypes.EntryDescription]? = nil,
            networkAclId: FMSClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.fmsCanRemediate = fmsCanRemediate
            self.networkAclEntriesToBeCreated = networkAclEntriesToBeCreated
            self.networkAclId = networkAclId
        }
    }
}

extension FMSClientTypes {

    /// Information about the DeleteNetworkAclEntries action in Amazon EC2. This is a remediation option in RemediationAction.
    public struct DeleteNetworkAclEntriesAction: Swift.Sendable {
        /// Brief description of this remediation action.
        public var description: Swift.String?
        /// Indicates whether it is possible for Firewall Manager to perform this remediation action. A false value indicates that auto remediation is disabled or Firewall Manager is unable to perform the action due to a conflict of some kind.
        public var fmsCanRemediate: Swift.Bool
        /// Lists the entries that the remediation action would delete.
        public var networkAclEntriesToBeDeleted: [FMSClientTypes.EntryDescription]?
        /// The network ACL that's associated with the remediation action.
        public var networkAclId: FMSClientTypes.ActionTarget?

        public init(
            description: Swift.String? = nil,
            fmsCanRemediate: Swift.Bool = false,
            networkAclEntriesToBeDeleted: [FMSClientTypes.EntryDescription]? = nil,
            networkAclId: FMSClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.fmsCanRemediate = fmsCanRemediate
            self.networkAclEntriesToBeDeleted = networkAclEntriesToBeDeleted
            self.networkAclId = networkAclId
        }
    }
}

extension FMSClientTypes {

    /// The action of associating an EC2 resource, such as a subnet or internet gateway, with a route table.
    public struct EC2AssociateRouteTableAction: Swift.Sendable {
        /// A description of the EC2 route table that is associated with the remediation action.
        public var description: Swift.String?
        /// The ID of the gateway to be used with the EC2 route table that is associated with the remediation action.
        public var gatewayId: FMSClientTypes.ActionTarget?
        /// The ID of the EC2 route table that is associated with the remediation action.
        /// This member is required.
        public var routeTableId: FMSClientTypes.ActionTarget?
        /// The ID of the subnet for the EC2 route table that is associated with the remediation action.
        public var subnetId: FMSClientTypes.ActionTarget?

        public init(
            description: Swift.String? = nil,
            gatewayId: FMSClientTypes.ActionTarget? = nil,
            routeTableId: FMSClientTypes.ActionTarget? = nil,
            subnetId: FMSClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.gatewayId = gatewayId
            self.routeTableId = routeTableId
            self.subnetId = subnetId
        }
    }
}

extension FMSClientTypes {

    /// An action that copies the EC2 route table for use in remediation.
    public struct EC2CopyRouteTableAction: Swift.Sendable {
        /// A description of the copied EC2 route table that is associated with the remediation action.
        public var description: Swift.String?
        /// The ID of the copied EC2 route table that is associated with the remediation action.
        /// This member is required.
        public var routeTableId: FMSClientTypes.ActionTarget?
        /// The VPC ID of the copied EC2 route table that is associated with the remediation action.
        /// This member is required.
        public var vpcId: FMSClientTypes.ActionTarget?

        public init(
            description: Swift.String? = nil,
            routeTableId: FMSClientTypes.ActionTarget? = nil,
            vpcId: FMSClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.routeTableId = routeTableId
            self.vpcId = vpcId
        }
    }
}

extension FMSClientTypes {

    /// Information about the CreateRoute action in Amazon EC2.
    public struct EC2CreateRouteAction: Swift.Sendable {
        /// A description of CreateRoute action in Amazon EC2.
        public var description: Swift.String?
        /// Information about the IPv4 CIDR address block used for the destination match.
        public var destinationCidrBlock: Swift.String?
        /// Information about the IPv6 CIDR block destination.
        public var destinationIpv6CidrBlock: Swift.String?
        /// Information about the ID of a prefix list used for the destination match.
        public var destinationPrefixListId: Swift.String?
        /// Information about the ID of an internet gateway or virtual private gateway attached to your VPC.
        public var gatewayId: FMSClientTypes.ActionTarget?
        /// Information about the ID of the route table for the route.
        /// This member is required.
        public var routeTableId: FMSClientTypes.ActionTarget?
        /// Information about the ID of a VPC endpoint. Supported for Gateway Load Balancer endpoints only.
        public var vpcEndpointId: FMSClientTypes.ActionTarget?

        public init(
            description: Swift.String? = nil,
            destinationCidrBlock: Swift.String? = nil,
            destinationIpv6CidrBlock: Swift.String? = nil,
            destinationPrefixListId: Swift.String? = nil,
            gatewayId: FMSClientTypes.ActionTarget? = nil,
            routeTableId: FMSClientTypes.ActionTarget? = nil,
            vpcEndpointId: FMSClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.destinationCidrBlock = destinationCidrBlock
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.destinationPrefixListId = destinationPrefixListId
            self.gatewayId = gatewayId
            self.routeTableId = routeTableId
            self.vpcEndpointId = vpcEndpointId
        }
    }
}

extension FMSClientTypes {

    /// Information about the CreateRouteTable action in Amazon EC2.
    public struct EC2CreateRouteTableAction: Swift.Sendable {
        /// A description of the CreateRouteTable action.
        public var description: Swift.String?
        /// Information about the ID of a VPC.
        /// This member is required.
        public var vpcId: FMSClientTypes.ActionTarget?

        public init(
            description: Swift.String? = nil,
            vpcId: FMSClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.vpcId = vpcId
        }
    }
}

extension FMSClientTypes {

    /// Information about the DeleteRoute action in Amazon EC2.
    public struct EC2DeleteRouteAction: Swift.Sendable {
        /// A description of the DeleteRoute action.
        public var description: Swift.String?
        /// Information about the IPv4 CIDR range for the route. The value you specify must match the CIDR for the route exactly.
        public var destinationCidrBlock: Swift.String?
        /// Information about the IPv6 CIDR range for the route. The value you specify must match the CIDR for the route exactly.
        public var destinationIpv6CidrBlock: Swift.String?
        /// Information about the ID of the prefix list for the route.
        public var destinationPrefixListId: Swift.String?
        /// Information about the ID of the route table.
        /// This member is required.
        public var routeTableId: FMSClientTypes.ActionTarget?

        public init(
            description: Swift.String? = nil,
            destinationCidrBlock: Swift.String? = nil,
            destinationIpv6CidrBlock: Swift.String? = nil,
            destinationPrefixListId: Swift.String? = nil,
            routeTableId: FMSClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.destinationCidrBlock = destinationCidrBlock
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.destinationPrefixListId = destinationPrefixListId
            self.routeTableId = routeTableId
        }
    }
}

extension FMSClientTypes {

    /// Information about the ReplaceRoute action in Amazon EC2.
    public struct EC2ReplaceRouteAction: Swift.Sendable {
        /// A description of the ReplaceRoute action in Amazon EC2.
        public var description: Swift.String?
        /// Information about the IPv4 CIDR address block used for the destination match. The value that you provide must match the CIDR of an existing route in the table.
        public var destinationCidrBlock: Swift.String?
        /// Information about the IPv6 CIDR address block used for the destination match. The value that you provide must match the CIDR of an existing route in the table.
        public var destinationIpv6CidrBlock: Swift.String?
        /// Information about the ID of the prefix list for the route.
        public var destinationPrefixListId: Swift.String?
        /// Information about the ID of an internet gateway or virtual private gateway.
        public var gatewayId: FMSClientTypes.ActionTarget?
        /// Information about the ID of the route table.
        /// This member is required.
        public var routeTableId: FMSClientTypes.ActionTarget?

        public init(
            description: Swift.String? = nil,
            destinationCidrBlock: Swift.String? = nil,
            destinationIpv6CidrBlock: Swift.String? = nil,
            destinationPrefixListId: Swift.String? = nil,
            gatewayId: FMSClientTypes.ActionTarget? = nil,
            routeTableId: FMSClientTypes.ActionTarget? = nil
        )
        {
            self.description = description
            self.destinationCidrBlock = destinationCidrBlock
            self.destinationIpv6CidrBlock = destinationIpv6CidrBlock
            self.destinationPrefixListId = destinationPrefixListId
            self.gatewayId = gatewayId
            self.routeTableId = routeTableId
        }
    }
}

extension FMSClientTypes {

    /// Information about the ReplaceRouteTableAssociation action in Amazon EC2.
    public struct EC2ReplaceRouteTableAssociationAction: Swift.Sendable {
        /// Information about the association ID.
        /// This member is required.
        public var associationId: FMSClientTypes.ActionTarget?
        /// A description of the ReplaceRouteTableAssociation action in Amazon EC2.
        public var description: Swift.String?
        /// Information about the ID of the new route table to associate with the subnet.
        /// This member is required.
        public var routeTableId: FMSClientTypes.ActionTarget?

        public init(
            associationId: FMSClientTypes.ActionTarget? = nil,
            description: Swift.String? = nil,
            routeTableId: FMSClientTypes.ActionTarget? = nil
        )
        {
            self.associationId = associationId
            self.description = description
            self.routeTableId = routeTableId
        }
    }
}

extension FMSClientTypes {

    /// Contains information about the actions that you can take to remediate scope violations caused by your policy's FirewallCreationConfig. FirewallCreationConfig is an optional configuration that you can use to choose which Availability Zones Firewall Manager creates Network Firewall endpoints in.
    public struct FMSPolicyUpdateFirewallCreationConfigAction: Swift.Sendable {
        /// Describes the remedial action.
        public var description: Swift.String?
        /// A FirewallCreationConfig that you can copy into your current policy's [SecurityServiceData](https://docs.aws.amazon.com/fms/2018-01-01/APIReference/API_SecurityServicePolicyData.html) in order to remedy scope violations.
        public var firewallCreationConfig: Swift.String?

        public init(
            description: Swift.String? = nil,
            firewallCreationConfig: Swift.String? = nil
        )
        {
            self.description = description
            self.firewallCreationConfig = firewallCreationConfig
        }
    }
}

extension FMSClientTypes {

    /// Information about the ReplaceNetworkAclAssociation action in Amazon EC2. This is a remediation option in RemediationAction.
    public struct ReplaceNetworkAclAssociationAction: Swift.Sendable {
        /// Describes a remediation action target.
        public var associationId: FMSClientTypes.ActionTarget?
        /// Brief description of this remediation action.
        public var description: Swift.String?
        /// Indicates whether it is possible for Firewall Manager to perform this remediation action. A false value indicates that auto remediation is disabled or Firewall Manager is unable to perform the action due to a conflict of some kind.
        public var fmsCanRemediate: Swift.Bool
        /// The network ACL that's associated with the remediation action.
        public var networkAclId: FMSClientTypes.ActionTarget?

        public init(
            associationId: FMSClientTypes.ActionTarget? = nil,
            description: Swift.String? = nil,
            fmsCanRemediate: Swift.Bool = false,
            networkAclId: FMSClientTypes.ActionTarget? = nil
        )
        {
            self.associationId = associationId
            self.description = description
            self.fmsCanRemediate = fmsCanRemediate
            self.networkAclId = networkAclId
        }
    }
}

extension FMSClientTypes {

    /// Information about an individual action you can take to remediate a violation.
    public struct RemediationAction: Swift.Sendable {
        /// Information about the CreateNetworkAcl action in Amazon EC2.
        public var createNetworkAclAction: FMSClientTypes.CreateNetworkAclAction?
        /// Information about the CreateNetworkAclEntries action in Amazon EC2.
        public var createNetworkAclEntriesAction: FMSClientTypes.CreateNetworkAclEntriesAction?
        /// Information about the DeleteNetworkAclEntries action in Amazon EC2.
        public var deleteNetworkAclEntriesAction: FMSClientTypes.DeleteNetworkAclEntriesAction?
        /// A description of a remediation action.
        public var description: Swift.String?
        /// Information about the AssociateRouteTable action in the Amazon EC2 API.
        public var ec2AssociateRouteTableAction: FMSClientTypes.EC2AssociateRouteTableAction?
        /// Information about the CopyRouteTable action in the Amazon EC2 API.
        public var ec2CopyRouteTableAction: FMSClientTypes.EC2CopyRouteTableAction?
        /// Information about the CreateRoute action in the Amazon EC2 API.
        public var ec2CreateRouteAction: FMSClientTypes.EC2CreateRouteAction?
        /// Information about the CreateRouteTable action in the Amazon EC2 API.
        public var ec2CreateRouteTableAction: FMSClientTypes.EC2CreateRouteTableAction?
        /// Information about the DeleteRoute action in the Amazon EC2 API.
        public var ec2DeleteRouteAction: FMSClientTypes.EC2DeleteRouteAction?
        /// Information about the ReplaceRoute action in the Amazon EC2 API.
        public var ec2ReplaceRouteAction: FMSClientTypes.EC2ReplaceRouteAction?
        /// Information about the ReplaceRouteTableAssociation action in the Amazon EC2 API.
        public var ec2ReplaceRouteTableAssociationAction: FMSClientTypes.EC2ReplaceRouteTableAssociationAction?
        /// The remedial action to take when updating a firewall configuration.
        public var fmsPolicyUpdateFirewallCreationConfigAction: FMSClientTypes.FMSPolicyUpdateFirewallCreationConfigAction?
        /// Information about the ReplaceNetworkAclAssociation action in Amazon EC2.
        public var replaceNetworkAclAssociationAction: FMSClientTypes.ReplaceNetworkAclAssociationAction?

        public init(
            createNetworkAclAction: FMSClientTypes.CreateNetworkAclAction? = nil,
            createNetworkAclEntriesAction: FMSClientTypes.CreateNetworkAclEntriesAction? = nil,
            deleteNetworkAclEntriesAction: FMSClientTypes.DeleteNetworkAclEntriesAction? = nil,
            description: Swift.String? = nil,
            ec2AssociateRouteTableAction: FMSClientTypes.EC2AssociateRouteTableAction? = nil,
            ec2CopyRouteTableAction: FMSClientTypes.EC2CopyRouteTableAction? = nil,
            ec2CreateRouteAction: FMSClientTypes.EC2CreateRouteAction? = nil,
            ec2CreateRouteTableAction: FMSClientTypes.EC2CreateRouteTableAction? = nil,
            ec2DeleteRouteAction: FMSClientTypes.EC2DeleteRouteAction? = nil,
            ec2ReplaceRouteAction: FMSClientTypes.EC2ReplaceRouteAction? = nil,
            ec2ReplaceRouteTableAssociationAction: FMSClientTypes.EC2ReplaceRouteTableAssociationAction? = nil,
            fmsPolicyUpdateFirewallCreationConfigAction: FMSClientTypes.FMSPolicyUpdateFirewallCreationConfigAction? = nil,
            replaceNetworkAclAssociationAction: FMSClientTypes.ReplaceNetworkAclAssociationAction? = nil
        )
        {
            self.createNetworkAclAction = createNetworkAclAction
            self.createNetworkAclEntriesAction = createNetworkAclEntriesAction
            self.deleteNetworkAclEntriesAction = deleteNetworkAclEntriesAction
            self.description = description
            self.ec2AssociateRouteTableAction = ec2AssociateRouteTableAction
            self.ec2CopyRouteTableAction = ec2CopyRouteTableAction
            self.ec2CreateRouteAction = ec2CreateRouteAction
            self.ec2CreateRouteTableAction = ec2CreateRouteTableAction
            self.ec2DeleteRouteAction = ec2DeleteRouteAction
            self.ec2ReplaceRouteAction = ec2ReplaceRouteAction
            self.ec2ReplaceRouteTableAssociationAction = ec2ReplaceRouteTableAssociationAction
            self.fmsPolicyUpdateFirewallCreationConfigAction = fmsPolicyUpdateFirewallCreationConfigAction
            self.replaceNetworkAclAssociationAction = replaceNetworkAclAssociationAction
        }
    }
}

extension FMSClientTypes {

    /// An ordered list of actions you can take to remediate a violation.
    public struct RemediationActionWithOrder: Swift.Sendable {
        /// The order of the remediation actions in the list.
        public var order: Swift.Int
        /// Information about an action you can take to remediate a violation.
        public var remediationAction: FMSClientTypes.RemediationAction?

        public init(
            order: Swift.Int = 0,
            remediationAction: FMSClientTypes.RemediationAction? = nil
        )
        {
            self.order = order
            self.remediationAction = remediationAction
        }
    }
}

extension FMSClientTypes {

    /// A list of remediation actions.
    public struct PossibleRemediationAction: Swift.Sendable {
        /// A description of the list of remediation actions.
        public var description: Swift.String?
        /// Information about whether an action is taken by default.
        public var isDefaultAction: Swift.Bool
        /// The ordered list of remediation actions.
        /// This member is required.
        public var orderedRemediationActions: [FMSClientTypes.RemediationActionWithOrder]?

        public init(
            description: Swift.String? = nil,
            isDefaultAction: Swift.Bool = false,
            orderedRemediationActions: [FMSClientTypes.RemediationActionWithOrder]? = nil
        )
        {
            self.description = description
            self.isDefaultAction = isDefaultAction
            self.orderedRemediationActions = orderedRemediationActions
        }
    }
}

extension FMSClientTypes {

    /// A list of possible remediation action lists. Each individual possible remediation action is a list of individual remediation actions.
    public struct PossibleRemediationActions: Swift.Sendable {
        /// Information about the actions.
        public var actions: [FMSClientTypes.PossibleRemediationAction]?
        /// A description of the possible remediation actions list.
        public var description: Swift.String?

        public init(
            actions: [FMSClientTypes.PossibleRemediationAction]? = nil,
            description: Swift.String? = nil
        )
        {
            self.actions = actions
            self.description = description
        }
    }
}

extension FMSClientTypes {

    /// Contains details about the route endpoint that violates the policy scope.
    public struct RouteHasOutOfScopeEndpointViolation: Swift.Sendable {
        /// The route table associated with the current firewall subnet.
        public var currentFirewallSubnetRouteTable: Swift.String?
        /// The current route table associated with the Internet Gateway.
        public var currentInternetGatewayRouteTable: Swift.String?
        /// The ID of the firewall subnet.
        public var firewallSubnetId: Swift.String?
        /// The list of firewall subnet routes.
        public var firewallSubnetRoutes: [FMSClientTypes.Route]?
        /// The ID of the Internet Gateway.
        public var internetGatewayId: Swift.String?
        /// The routes in the route table associated with the Internet Gateway.
        public var internetGatewayRoutes: [FMSClientTypes.Route]?
        /// The ID of the route table.
        public var routeTableId: Swift.String?
        /// The subnet's Availability Zone.
        public var subnetAvailabilityZone: Swift.String?
        /// The ID of the subnet's Availability Zone.
        public var subnetAvailabilityZoneId: Swift.String?
        /// The ID of the subnet associated with the route that violates the policy scope.
        public var subnetId: Swift.String?
        /// The list of routes that violate the route table.
        public var violatingRoutes: [FMSClientTypes.Route]?
        /// The VPC ID of the route that violates the policy scope.
        public var vpcId: Swift.String?

        public init(
            currentFirewallSubnetRouteTable: Swift.String? = nil,
            currentInternetGatewayRouteTable: Swift.String? = nil,
            firewallSubnetId: Swift.String? = nil,
            firewallSubnetRoutes: [FMSClientTypes.Route]? = nil,
            internetGatewayId: Swift.String? = nil,
            internetGatewayRoutes: [FMSClientTypes.Route]? = nil,
            routeTableId: Swift.String? = nil,
            subnetAvailabilityZone: Swift.String? = nil,
            subnetAvailabilityZoneId: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            violatingRoutes: [FMSClientTypes.Route]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.currentFirewallSubnetRouteTable = currentFirewallSubnetRouteTable
            self.currentInternetGatewayRouteTable = currentInternetGatewayRouteTable
            self.firewallSubnetId = firewallSubnetId
            self.firewallSubnetRoutes = firewallSubnetRoutes
            self.internetGatewayId = internetGatewayId
            self.internetGatewayRoutes = internetGatewayRoutes
            self.routeTableId = routeTableId
            self.subnetAvailabilityZone = subnetAvailabilityZone
            self.subnetAvailabilityZoneId = subnetAvailabilityZoneId
            self.subnetId = subnetId
            self.violatingRoutes = violatingRoutes
            self.vpcId = vpcId
        }
    }
}

extension FMSClientTypes {

    /// The violation details for a third-party firewall that's not associated with an Firewall Manager managed route table.
    public struct ThirdPartyFirewallMissingExpectedRouteTableViolation: Swift.Sendable {
        /// The Availability Zone of the firewall subnet that's causing the violation.
        public var availabilityZone: Swift.String?
        /// The resource ID of the current route table that's associated with the subnet, if one is available.
        public var currentRouteTable: Swift.String?
        /// The resource ID of the route table that should be associated with the subnet.
        public var expectedRouteTable: Swift.String?
        /// The ID of the third-party firewall or VPC resource that's causing the violation.
        public var violationTarget: Swift.String?
        /// The resource ID of the VPC associated with a fireawll subnet that's causing the violation.
        public var vpc: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            currentRouteTable: Swift.String? = nil,
            expectedRouteTable: Swift.String? = nil,
            violationTarget: Swift.String? = nil,
            vpc: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.currentRouteTable = currentRouteTable
            self.expectedRouteTable = expectedRouteTable
            self.violationTarget = violationTarget
            self.vpc = vpc
        }
    }
}

extension FMSClientTypes {

    /// The violation details about a third-party firewall's subnet that doesn't have a Firewall Manager managed firewall in its VPC.
    public struct ThirdPartyFirewallMissingFirewallViolation: Swift.Sendable {
        /// The Availability Zone of the third-party firewall that's causing the violation.
        public var availabilityZone: Swift.String?
        /// The reason the resource is causing this violation, if a reason is available.
        public var targetViolationReason: Swift.String?
        /// The ID of the third-party firewall that's causing the violation.
        public var violationTarget: Swift.String?
        /// The resource ID of the VPC associated with a third-party firewall.
        public var vpc: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            targetViolationReason: Swift.String? = nil,
            violationTarget: Swift.String? = nil,
            vpc: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.targetViolationReason = targetViolationReason
            self.violationTarget = violationTarget
            self.vpc = vpc
        }
    }
}

extension FMSClientTypes {

    /// The violation details for a third-party firewall for an Availability Zone that's missing the Firewall Manager managed subnet.
    public struct ThirdPartyFirewallMissingSubnetViolation: Swift.Sendable {
        /// The Availability Zone of a subnet that's causing the violation.
        public var availabilityZone: Swift.String?
        /// The reason the resource is causing the violation, if a reason is available.
        public var targetViolationReason: Swift.String?
        /// The ID of the third-party firewall or VPC resource that's causing the violation.
        public var violationTarget: Swift.String?
        /// The resource ID of the VPC associated with a subnet that's causing the violation.
        public var vpc: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            targetViolationReason: Swift.String? = nil,
            violationTarget: Swift.String? = nil,
            vpc: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.targetViolationReason = targetViolationReason
            self.violationTarget = violationTarget
            self.vpc = vpc
        }
    }
}

extension FMSClientTypes {

    /// The violation details for a web ACL whose configuration is incompatible with the Firewall Manager policy.
    public struct WebACLHasIncompatibleConfigurationViolation: Swift.Sendable {
        /// Information about the problems that Firewall Manager encountered with the web ACL configuration.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the web ACL.
        public var webACLArn: Swift.String?

        public init(
            description: Swift.String? = nil,
            webACLArn: Swift.String? = nil
        )
        {
            self.description = description
            self.webACLArn = webACLArn
        }
    }
}

extension FMSClientTypes {

    /// The violation details for a web ACL that's associated with at least one resource that's out of scope of the Firewall Manager policy.
    public struct WebACLHasOutOfScopeResourcesViolation: Swift.Sendable {
        /// An array of Amazon Resource Name (ARN) for the resources that are out of scope of the policy and are associated with the web ACL.
        public var outOfScopeResourceList: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the web ACL.
        public var webACLArn: Swift.String?

        public init(
            outOfScopeResourceList: [Swift.String]? = nil,
            webACLArn: Swift.String? = nil
        )
        {
            self.outOfScopeResourceList = outOfScopeResourceList
            self.webACLArn = webACLArn
        }
    }
}

extension FMSClientTypes {

    /// Violation detail based on resource type.
    public struct ResourceViolation: Swift.Sendable {
        /// Violation detail for an EC2 instance.
        public var awsEc2InstanceViolation: FMSClientTypes.AwsEc2InstanceViolation?
        /// Violation detail for a network interface.
        public var awsEc2NetworkInterfaceViolation: FMSClientTypes.AwsEc2NetworkInterfaceViolation?
        /// Violation detail for security groups.
        public var awsVPCSecurityGroupViolation: FMSClientTypes.AwsVPCSecurityGroupViolation?
        /// Violation detail for a DNS Firewall policy that indicates that a rule group that Firewall Manager tried to associate with a VPC is already associated with the VPC and can't be associated again.
        public var dnsDuplicateRuleGroupViolation: FMSClientTypes.DnsDuplicateRuleGroupViolation?
        /// Violation detail for a DNS Firewall policy that indicates that the VPC reached the limit for associated DNS Firewall rule groups. Firewall Manager tried to associate another rule group with the VPC and failed.
        public var dnsRuleGroupLimitExceededViolation: FMSClientTypes.DnsRuleGroupLimitExceededViolation?
        /// Violation detail for a DNS Firewall policy that indicates that a rule group that Firewall Manager tried to associate with a VPC has the same priority as a rule group that's already associated.
        public var dnsRuleGroupPriorityConflictViolation: FMSClientTypes.DnsRuleGroupPriorityConflictViolation?
        /// Contains details about the firewall subnet that violates the policy scope.
        public var firewallSubnetIsOutOfScopeViolation: FMSClientTypes.FirewallSubnetIsOutOfScopeViolation?
        /// The violation details for a third-party firewall's VPC endpoint subnet that was deleted.
        public var firewallSubnetMissingVPCEndpointViolation: FMSClientTypes.FirewallSubnetMissingVPCEndpointViolation?
        /// Violation detail for the entries in a network ACL resource.
        public var invalidNetworkAclEntriesViolation: FMSClientTypes.InvalidNetworkAclEntriesViolation?
        /// Violation detail for an internet gateway route with an inactive state in the customer subnet route table or Network Firewall subnet route table.
        public var networkFirewallBlackHoleRouteDetectedViolation: FMSClientTypes.NetworkFirewallBlackHoleRouteDetectedViolation?
        /// Violation detail for the subnet for which internet traffic hasn't been inspected.
        public var networkFirewallInternetTrafficNotInspectedViolation: FMSClientTypes.NetworkFirewallInternetTrafficNotInspectedViolation?
        /// The route configuration is invalid.
        public var networkFirewallInvalidRouteConfigurationViolation: FMSClientTypes.NetworkFirewallInvalidRouteConfigurationViolation?
        /// Violation detail for an Network Firewall policy that indicates that a subnet is not associated with the expected Firewall Manager managed route table.
        public var networkFirewallMissingExpectedRTViolation: FMSClientTypes.NetworkFirewallMissingExpectedRTViolation?
        /// Expected routes are missing from Network Firewall.
        public var networkFirewallMissingExpectedRoutesViolation: FMSClientTypes.NetworkFirewallMissingExpectedRoutesViolation?
        /// Violation detail for an Network Firewall policy that indicates that a subnet has no Firewall Manager managed firewall in its VPC.
        public var networkFirewallMissingFirewallViolation: FMSClientTypes.NetworkFirewallMissingFirewallViolation?
        /// Violation detail for an Network Firewall policy that indicates that an Availability Zone is missing the expected Firewall Manager managed subnet.
        public var networkFirewallMissingSubnetViolation: FMSClientTypes.NetworkFirewallMissingSubnetViolation?
        /// Violation detail for an Network Firewall policy that indicates that a firewall policy in an individual account has been modified in a way that makes it noncompliant. For example, the individual account owner might have deleted a rule group, changed the priority of a stateless rule group, or changed a policy default action.
        public var networkFirewallPolicyModifiedViolation: FMSClientTypes.NetworkFirewallPolicyModifiedViolation?
        /// There's an unexpected firewall route.
        public var networkFirewallUnexpectedFirewallRoutesViolation: FMSClientTypes.NetworkFirewallUnexpectedFirewallRoutesViolation?
        /// There's an unexpected gateway route.
        public var networkFirewallUnexpectedGatewayRoutesViolation: FMSClientTypes.NetworkFirewallUnexpectedGatewayRoutesViolation?
        /// A list of possible remediation action lists. Each individual possible remediation action is a list of individual remediation actions.
        public var possibleRemediationActions: FMSClientTypes.PossibleRemediationActions?
        /// Contains details about the route endpoint that violates the policy scope.
        public var routeHasOutOfScopeEndpointViolation: FMSClientTypes.RouteHasOutOfScopeEndpointViolation?
        /// The violation details for a third-party firewall that has the Firewall Manager managed route table that was associated with the third-party firewall has been deleted.
        public var thirdPartyFirewallMissingExpectedRouteTableViolation: FMSClientTypes.ThirdPartyFirewallMissingExpectedRouteTableViolation?
        /// The violation details for a third-party firewall that's been deleted.
        public var thirdPartyFirewallMissingFirewallViolation: FMSClientTypes.ThirdPartyFirewallMissingFirewallViolation?
        /// The violation details for a third-party firewall's subnet that's been deleted.
        public var thirdPartyFirewallMissingSubnetViolation: FMSClientTypes.ThirdPartyFirewallMissingSubnetViolation?
        /// The violation details for a web ACL whose configuration is incompatible with the Firewall Manager policy.
        public var webACLHasIncompatibleConfigurationViolation: FMSClientTypes.WebACLHasIncompatibleConfigurationViolation?
        /// The violation details for a web ACL that's associated with at least one resource that's out of scope of the Firewall Manager policy.
        public var webACLHasOutOfScopeResourcesViolation: FMSClientTypes.WebACLHasOutOfScopeResourcesViolation?

        public init(
            awsEc2InstanceViolation: FMSClientTypes.AwsEc2InstanceViolation? = nil,
            awsEc2NetworkInterfaceViolation: FMSClientTypes.AwsEc2NetworkInterfaceViolation? = nil,
            awsVPCSecurityGroupViolation: FMSClientTypes.AwsVPCSecurityGroupViolation? = nil,
            dnsDuplicateRuleGroupViolation: FMSClientTypes.DnsDuplicateRuleGroupViolation? = nil,
            dnsRuleGroupLimitExceededViolation: FMSClientTypes.DnsRuleGroupLimitExceededViolation? = nil,
            dnsRuleGroupPriorityConflictViolation: FMSClientTypes.DnsRuleGroupPriorityConflictViolation? = nil,
            firewallSubnetIsOutOfScopeViolation: FMSClientTypes.FirewallSubnetIsOutOfScopeViolation? = nil,
            firewallSubnetMissingVPCEndpointViolation: FMSClientTypes.FirewallSubnetMissingVPCEndpointViolation? = nil,
            invalidNetworkAclEntriesViolation: FMSClientTypes.InvalidNetworkAclEntriesViolation? = nil,
            networkFirewallBlackHoleRouteDetectedViolation: FMSClientTypes.NetworkFirewallBlackHoleRouteDetectedViolation? = nil,
            networkFirewallInternetTrafficNotInspectedViolation: FMSClientTypes.NetworkFirewallInternetTrafficNotInspectedViolation? = nil,
            networkFirewallInvalidRouteConfigurationViolation: FMSClientTypes.NetworkFirewallInvalidRouteConfigurationViolation? = nil,
            networkFirewallMissingExpectedRTViolation: FMSClientTypes.NetworkFirewallMissingExpectedRTViolation? = nil,
            networkFirewallMissingExpectedRoutesViolation: FMSClientTypes.NetworkFirewallMissingExpectedRoutesViolation? = nil,
            networkFirewallMissingFirewallViolation: FMSClientTypes.NetworkFirewallMissingFirewallViolation? = nil,
            networkFirewallMissingSubnetViolation: FMSClientTypes.NetworkFirewallMissingSubnetViolation? = nil,
            networkFirewallPolicyModifiedViolation: FMSClientTypes.NetworkFirewallPolicyModifiedViolation? = nil,
            networkFirewallUnexpectedFirewallRoutesViolation: FMSClientTypes.NetworkFirewallUnexpectedFirewallRoutesViolation? = nil,
            networkFirewallUnexpectedGatewayRoutesViolation: FMSClientTypes.NetworkFirewallUnexpectedGatewayRoutesViolation? = nil,
            possibleRemediationActions: FMSClientTypes.PossibleRemediationActions? = nil,
            routeHasOutOfScopeEndpointViolation: FMSClientTypes.RouteHasOutOfScopeEndpointViolation? = nil,
            thirdPartyFirewallMissingExpectedRouteTableViolation: FMSClientTypes.ThirdPartyFirewallMissingExpectedRouteTableViolation? = nil,
            thirdPartyFirewallMissingFirewallViolation: FMSClientTypes.ThirdPartyFirewallMissingFirewallViolation? = nil,
            thirdPartyFirewallMissingSubnetViolation: FMSClientTypes.ThirdPartyFirewallMissingSubnetViolation? = nil,
            webACLHasIncompatibleConfigurationViolation: FMSClientTypes.WebACLHasIncompatibleConfigurationViolation? = nil,
            webACLHasOutOfScopeResourcesViolation: FMSClientTypes.WebACLHasOutOfScopeResourcesViolation? = nil
        )
        {
            self.awsEc2InstanceViolation = awsEc2InstanceViolation
            self.awsEc2NetworkInterfaceViolation = awsEc2NetworkInterfaceViolation
            self.awsVPCSecurityGroupViolation = awsVPCSecurityGroupViolation
            self.dnsDuplicateRuleGroupViolation = dnsDuplicateRuleGroupViolation
            self.dnsRuleGroupLimitExceededViolation = dnsRuleGroupLimitExceededViolation
            self.dnsRuleGroupPriorityConflictViolation = dnsRuleGroupPriorityConflictViolation
            self.firewallSubnetIsOutOfScopeViolation = firewallSubnetIsOutOfScopeViolation
            self.firewallSubnetMissingVPCEndpointViolation = firewallSubnetMissingVPCEndpointViolation
            self.invalidNetworkAclEntriesViolation = invalidNetworkAclEntriesViolation
            self.networkFirewallBlackHoleRouteDetectedViolation = networkFirewallBlackHoleRouteDetectedViolation
            self.networkFirewallInternetTrafficNotInspectedViolation = networkFirewallInternetTrafficNotInspectedViolation
            self.networkFirewallInvalidRouteConfigurationViolation = networkFirewallInvalidRouteConfigurationViolation
            self.networkFirewallMissingExpectedRTViolation = networkFirewallMissingExpectedRTViolation
            self.networkFirewallMissingExpectedRoutesViolation = networkFirewallMissingExpectedRoutesViolation
            self.networkFirewallMissingFirewallViolation = networkFirewallMissingFirewallViolation
            self.networkFirewallMissingSubnetViolation = networkFirewallMissingSubnetViolation
            self.networkFirewallPolicyModifiedViolation = networkFirewallPolicyModifiedViolation
            self.networkFirewallUnexpectedFirewallRoutesViolation = networkFirewallUnexpectedFirewallRoutesViolation
            self.networkFirewallUnexpectedGatewayRoutesViolation = networkFirewallUnexpectedGatewayRoutesViolation
            self.possibleRemediationActions = possibleRemediationActions
            self.routeHasOutOfScopeEndpointViolation = routeHasOutOfScopeEndpointViolation
            self.thirdPartyFirewallMissingExpectedRouteTableViolation = thirdPartyFirewallMissingExpectedRouteTableViolation
            self.thirdPartyFirewallMissingFirewallViolation = thirdPartyFirewallMissingFirewallViolation
            self.thirdPartyFirewallMissingSubnetViolation = thirdPartyFirewallMissingSubnetViolation
            self.webACLHasIncompatibleConfigurationViolation = webACLHasIncompatibleConfigurationViolation
            self.webACLHasOutOfScopeResourcesViolation = webACLHasOutOfScopeResourcesViolation
        }
    }
}

extension FMSClientTypes {

    /// Violations for a resource based on the specified Firewall Manager policy and Amazon Web Services account.
    public struct ViolationDetail: Swift.Sendable {
        /// The Amazon Web Services account that the violation details were requested for.
        /// This member is required.
        public var memberAccount: Swift.String?
        /// The ID of the Firewall Manager policy that the violation details were requested for.
        /// This member is required.
        public var policyId: Swift.String?
        /// Brief description for the requested resource.
        public var resourceDescription: Swift.String?
        /// The resource ID that the violation details were requested for.
        /// This member is required.
        public var resourceId: Swift.String?
        /// The ResourceTag objects associated with the resource.
        public var resourceTags: [FMSClientTypes.Tag]?
        /// The resource type that the violation details were requested for.
        /// This member is required.
        public var resourceType: Swift.String?
        /// List of violations for the requested resource.
        /// This member is required.
        public var resourceViolations: [FMSClientTypes.ResourceViolation]?

        public init(
            memberAccount: Swift.String? = nil,
            policyId: Swift.String? = nil,
            resourceDescription: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceTags: [FMSClientTypes.Tag]? = nil,
            resourceType: Swift.String? = nil,
            resourceViolations: [FMSClientTypes.ResourceViolation]? = nil
        )
        {
            self.memberAccount = memberAccount
            self.policyId = policyId
            self.resourceDescription = resourceDescription
            self.resourceId = resourceId
            self.resourceTags = resourceTags
            self.resourceType = resourceType
            self.resourceViolations = resourceViolations
        }
    }
}

public struct GetViolationDetailsOutput: Swift.Sendable {
    /// Violation detail for a resource.
    public var violationDetail: FMSClientTypes.ViolationDetail?

    public init(
        violationDetail: FMSClientTypes.ViolationDetail? = nil
    )
    {
        self.violationDetail = violationDetail
    }
}

public struct ListAdminAccountsForOrganizationInput: Swift.Sendable {
    /// The maximum number of objects that you want Firewall Manager to return for this request. If more objects are available, in the response, Firewall Manager provides a NextToken value that you can use in a subsequent call to get the next batch of objects.
    public var maxResults: Swift.Int?
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Firewall Manager returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAdminAccountsForOrganizationOutput: Swift.Sendable {
    /// A list of Firewall Manager administrator accounts within the organization that were onboarded as administrators by [AssociateAdminAccount] or [PutAdminAccount].
    public var adminAccounts: [FMSClientTypes.AdminAccountSummary]?
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Firewall Manager returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        adminAccounts: [FMSClientTypes.AdminAccountSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.adminAccounts = adminAccounts
        self.nextToken = nextToken
    }
}

public struct ListAdminsManagingAccountInput: Swift.Sendable {
    /// The maximum number of objects that you want Firewall Manager to return for this request. If more objects are available, in the response, Firewall Manager provides a NextToken value that you can use in a subsequent call to get the next batch of objects.
    public var maxResults: Swift.Int?
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Firewall Manager returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAdminsManagingAccountOutput: Swift.Sendable {
    /// The list of accounts who manage member accounts within their [AdminScope].
    public var adminAccounts: [Swift.String]?
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Firewall Manager returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        adminAccounts: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.adminAccounts = adminAccounts
        self.nextToken = nextToken
    }
}

public struct ListAppsListsInput: Swift.Sendable {
    /// Specifies whether the lists to retrieve are default lists owned by Firewall Manager.
    public var defaultLists: Swift.Bool?
    /// The maximum number of objects that you want Firewall Manager to return for this request. If more objects are available, in the response, Firewall Manager provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify this, Firewall Manager returns all available objects.
    /// This member is required.
    public var maxResults: Swift.Int?
    /// If you specify a value for MaxResults in your list request, and you have more objects than the maximum, Firewall Manager returns this token in the response. For all but the first request, you provide the token returned by the prior request in the request parameters, to retrieve the next batch of objects.
    public var nextToken: Swift.String?

    public init(
        defaultLists: Swift.Bool? = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.defaultLists = defaultLists
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAppsListsOutput: Swift.Sendable {
    /// An array of AppsListDataSummary objects.
    public var appsLists: [FMSClientTypes.AppsListDataSummary]?
    /// If you specify a value for MaxResults in your list request, and you have more objects than the maximum, Firewall Manager returns this token in the response. You can use this token in subsequent requests to retrieve the next batch of objects.
    public var nextToken: Swift.String?

    public init(
        appsLists: [FMSClientTypes.AppsListDataSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appsLists = appsLists
        self.nextToken = nextToken
    }
}

public struct ListComplianceStatusInput: Swift.Sendable {
    /// Specifies the number of PolicyComplianceStatus objects that you want Firewall Manager to return for this request. If you have more PolicyComplianceStatus objects than the number that you specify for MaxResults, the response includes a NextToken value that you can use to get another batch of PolicyComplianceStatus objects.
    public var maxResults: Swift.Int?
    /// If you specify a value for MaxResults and you have more PolicyComplianceStatus objects than the number that you specify for MaxResults, Firewall Manager returns a NextToken value in the response that allows you to list another group of PolicyComplianceStatus objects. For the second and subsequent ListComplianceStatus requests, specify the value of NextToken from the previous response to get information about another batch of PolicyComplianceStatus objects.
    public var nextToken: Swift.String?
    /// The ID of the Firewall Manager policy that you want the details for.
    /// This member is required.
    public var policyId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyId = policyId
    }
}

extension FMSClientTypes {

    public enum PolicyComplianceStatusType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case compliant
        case noncompliant
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyComplianceStatusType] {
            return [
                .compliant,
                .noncompliant
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .compliant: return "COMPLIANT"
            case .noncompliant: return "NON_COMPLIANT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FMSClientTypes {

    /// Describes the compliance status for the account. An account is considered noncompliant if it includes resources that are not protected by the specified policy or that don't comply with the policy.
    public struct EvaluationResult: Swift.Sendable {
        /// Describes an Amazon Web Services account's compliance with the Firewall Manager policy.
        public var complianceStatus: FMSClientTypes.PolicyComplianceStatusType?
        /// Indicates that over 100 resources are noncompliant with the Firewall Manager policy.
        public var evaluationLimitExceeded: Swift.Bool
        /// The number of resources that are noncompliant with the specified policy. For WAF and Shield Advanced policies, a resource is considered noncompliant if it is not associated with the policy. For security group policies, a resource is considered noncompliant if it doesn't comply with the rules of the policy and remediation is disabled or not possible.
        public var violatorCount: Swift.Int

        public init(
            complianceStatus: FMSClientTypes.PolicyComplianceStatusType? = nil,
            evaluationLimitExceeded: Swift.Bool = false,
            violatorCount: Swift.Int = 0
        )
        {
            self.complianceStatus = complianceStatus
            self.evaluationLimitExceeded = evaluationLimitExceeded
            self.violatorCount = violatorCount
        }
    }
}

extension FMSClientTypes {

    /// Indicates whether the account is compliant with the specified policy. An account is considered noncompliant if it includes resources that are not protected by the policy, for WAF and Shield Advanced policies, or that are noncompliant with the policy, for security group policies.
    public struct PolicyComplianceStatus: Swift.Sendable {
        /// An array of EvaluationResult objects.
        public var evaluationResults: [FMSClientTypes.EvaluationResult]?
        /// Details about problems with dependent services, such as WAF or Config, and the error message received that indicates the problem with the service.
        public var issueInfoMap: [Swift.String: Swift.String]?
        /// Timestamp of the last update to the EvaluationResult objects.
        public var lastUpdated: Foundation.Date?
        /// The member account ID.
        public var memberAccount: Swift.String?
        /// The ID of the Firewall Manager policy.
        public var policyId: Swift.String?
        /// The name of the Firewall Manager policy.
        public var policyName: Swift.String?
        /// The Amazon Web Services account that created the Firewall Manager policy.
        public var policyOwner: Swift.String?

        public init(
            evaluationResults: [FMSClientTypes.EvaluationResult]? = nil,
            issueInfoMap: [Swift.String: Swift.String]? = nil,
            lastUpdated: Foundation.Date? = nil,
            memberAccount: Swift.String? = nil,
            policyId: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyOwner: Swift.String? = nil
        )
        {
            self.evaluationResults = evaluationResults
            self.issueInfoMap = issueInfoMap
            self.lastUpdated = lastUpdated
            self.memberAccount = memberAccount
            self.policyId = policyId
            self.policyName = policyName
            self.policyOwner = policyOwner
        }
    }
}

public struct ListComplianceStatusOutput: Swift.Sendable {
    /// If you have more PolicyComplianceStatus objects than the number that you specified for MaxResults in the request, the response includes a NextToken value. To list more PolicyComplianceStatus objects, submit another ListComplianceStatus request, and specify the NextToken value from the response in the NextToken value in the next request.
    public var nextToken: Swift.String?
    /// An array of PolicyComplianceStatus objects.
    public var policyComplianceStatusList: [FMSClientTypes.PolicyComplianceStatus]?

    public init(
        nextToken: Swift.String? = nil,
        policyComplianceStatusList: [FMSClientTypes.PolicyComplianceStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyComplianceStatusList = policyComplianceStatusList
    }
}

public struct ListDiscoveredResourcesInput: Swift.Sendable {
    /// The maximum number of objects that you want Firewall Manager to return for this request. If more objects are available, in the response, Firewall Manager provides a NextToken value that you can use in a subsequent call to get the next batch of objects.
    public var maxResults: Swift.Int?
    /// The Amazon Web Services account IDs to discover resources in. Only one account is supported per request. The account must be a member of your organization.
    /// This member is required.
    public var memberAccountIds: [Swift.String]?
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Firewall Manager returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?
    /// The type of resources to discover.
    /// This member is required.
    public var resourceType: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        memberAccountIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.memberAccountIds = memberAccountIds
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

extension FMSClientTypes {

    /// A resource in the organization that's available to be associated with a Firewall Manager resource set.
    public struct DiscoveredResource: Swift.Sendable {
        /// The Amazon Web Services account ID associated with the discovered resource.
        public var accountId: Swift.String?
        /// The name of the discovered resource.
        public var name: Swift.String?
        /// The type of the discovered resource.
        public var type: Swift.String?
        /// The universal resource identifier (URI) of the discovered resource.
        public var uri: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            uri: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.name = name
            self.type = type
            self.uri = uri
        }
    }
}

public struct ListDiscoveredResourcesOutput: Swift.Sendable {
    /// Details of the resources that were discovered.
    public var items: [FMSClientTypes.DiscoveredResource]?
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Firewall Manager returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        items: [FMSClientTypes.DiscoveredResource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListMemberAccountsInput: Swift.Sendable {
    /// Specifies the number of member account IDs that you want Firewall Manager to return for this request. If you have more IDs than the number that you specify for MaxResults, the response includes a NextToken value that you can use to get another batch of member account IDs.
    public var maxResults: Swift.Int?
    /// If you specify a value for MaxResults and you have more account IDs than the number that you specify for MaxResults, Firewall Manager returns a NextToken value in the response that allows you to list another group of IDs. For the second and subsequent ListMemberAccountsRequest requests, specify the value of NextToken from the previous response to get information about another batch of member account IDs.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListMemberAccountsOutput: Swift.Sendable {
    /// An array of account IDs.
    public var memberAccounts: [Swift.String]?
    /// If you have more member account IDs than the number that you specified for MaxResults in the request, the response includes a NextToken value. To list more IDs, submit another ListMemberAccounts request, and specify the NextToken value from the response in the NextToken value in the next request.
    public var nextToken: Swift.String?

    public init(
        memberAccounts: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.memberAccounts = memberAccounts
        self.nextToken = nextToken
    }
}

public struct ListPoliciesInput: Swift.Sendable {
    /// Specifies the number of PolicySummary objects that you want Firewall Manager to return for this request. If you have more PolicySummary objects than the number that you specify for MaxResults, the response includes a NextToken value that you can use to get another batch of PolicySummary objects.
    public var maxResults: Swift.Int?
    /// If you specify a value for MaxResults and you have more PolicySummary objects than the number that you specify for MaxResults, Firewall Manager returns a NextToken value in the response that allows you to list another group of PolicySummary objects. For the second and subsequent ListPolicies requests, specify the value of NextToken from the previous response to get information about another batch of PolicySummary objects.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension FMSClientTypes {

    /// Details of the Firewall Manager policy.
    public struct PolicySummary: Swift.Sendable {
        /// Indicates whether Firewall Manager should automatically remove protections from resources that leave the policy scope and clean up resources that Firewall Manager is managing for accounts when those accounts leave policy scope. For example, Firewall Manager will disassociate a Firewall Manager managed web ACL from a protected customer resource when the customer resource leaves policy scope. By default, Firewall Manager doesn't remove protections or delete Firewall Manager managed resources. This option is not available for Shield Advanced or WAF Classic policies.
        public var deleteUnusedFMManagedResources: Swift.Bool
        /// The Amazon Resource Name (ARN) of the specified policy.
        public var policyArn: Swift.String?
        /// The ID of the specified policy.
        public var policyId: Swift.String?
        /// The name of the specified policy.
        public var policyName: Swift.String?
        /// Indicates whether the policy is in or out of an admin's policy or Region scope.
        ///
        /// * ACTIVE - The administrator can manage and delete the policy.
        ///
        /// * OUT_OF_ADMIN_SCOPE - The administrator can view the policy, but they can't edit or delete the policy. Existing policy protections stay in place. Any new resources that come into scope of the policy won't be protected.
        public var policyStatus: FMSClientTypes.CustomerPolicyStatus?
        /// Indicates if the policy should be automatically applied to new resources.
        public var remediationEnabled: Swift.Bool
        /// The type of resource protected by or in scope of the policy. This is in the format shown in the [Amazon Web Services Resource Types Reference](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html).
        public var resourceType: Swift.String?
        /// The service that the policy is using to protect the resources. This specifies the type of policy that is created, either an WAF policy, a Shield Advanced policy, or a security group policy.
        public var securityServiceType: FMSClientTypes.SecurityServiceType?

        public init(
            deleteUnusedFMManagedResources: Swift.Bool = false,
            policyArn: Swift.String? = nil,
            policyId: Swift.String? = nil,
            policyName: Swift.String? = nil,
            policyStatus: FMSClientTypes.CustomerPolicyStatus? = nil,
            remediationEnabled: Swift.Bool = false,
            resourceType: Swift.String? = nil,
            securityServiceType: FMSClientTypes.SecurityServiceType? = nil
        )
        {
            self.deleteUnusedFMManagedResources = deleteUnusedFMManagedResources
            self.policyArn = policyArn
            self.policyId = policyId
            self.policyName = policyName
            self.policyStatus = policyStatus
            self.remediationEnabled = remediationEnabled
            self.resourceType = resourceType
            self.securityServiceType = securityServiceType
        }
    }
}

public struct ListPoliciesOutput: Swift.Sendable {
    /// If you have more PolicySummary objects than the number that you specified for MaxResults in the request, the response includes a NextToken value. To list more PolicySummary objects, submit another ListPolicies request, and specify the NextToken value from the response in the NextToken value in the next request.
    public var nextToken: Swift.String?
    /// An array of PolicySummary objects.
    public var policyList: [FMSClientTypes.PolicySummary]?

    public init(
        nextToken: Swift.String? = nil,
        policyList: [FMSClientTypes.PolicySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyList = policyList
    }
}

public struct ListProtocolsListsInput: Swift.Sendable {
    /// Specifies whether the lists to retrieve are default lists owned by Firewall Manager.
    public var defaultLists: Swift.Bool?
    /// The maximum number of objects that you want Firewall Manager to return for this request. If more objects are available, in the response, Firewall Manager provides a NextToken value that you can use in a subsequent call to get the next batch of objects. If you don't specify this, Firewall Manager returns all available objects.
    /// This member is required.
    public var maxResults: Swift.Int?
    /// If you specify a value for MaxResults in your list request, and you have more objects than the maximum, Firewall Manager returns this token in the response. For all but the first request, you provide the token returned by the prior request in the request parameters, to retrieve the next batch of objects.
    public var nextToken: Swift.String?

    public init(
        defaultLists: Swift.Bool? = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.defaultLists = defaultLists
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension FMSClientTypes {

    /// Details of the Firewall Manager protocols list.
    public struct ProtocolsListDataSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the specified protocols list.
        public var listArn: Swift.String?
        /// The ID of the specified protocols list.
        public var listId: Swift.String?
        /// The name of the specified protocols list.
        public var listName: Swift.String?
        /// An array of protocols in the Firewall Manager protocols list.
        public var protocolsList: [Swift.String]?

        public init(
            listArn: Swift.String? = nil,
            listId: Swift.String? = nil,
            listName: Swift.String? = nil,
            protocolsList: [Swift.String]? = nil
        )
        {
            self.listArn = listArn
            self.listId = listId
            self.listName = listName
            self.protocolsList = protocolsList
        }
    }
}

public struct ListProtocolsListsOutput: Swift.Sendable {
    /// If you specify a value for MaxResults in your list request, and you have more objects than the maximum, Firewall Manager returns this token in the response. You can use this token in subsequent requests to retrieve the next batch of objects.
    public var nextToken: Swift.String?
    /// An array of ProtocolsListDataSummary objects.
    public var protocolsLists: [FMSClientTypes.ProtocolsListDataSummary]?

    public init(
        nextToken: Swift.String? = nil,
        protocolsLists: [FMSClientTypes.ProtocolsListDataSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.protocolsLists = protocolsLists
    }
}

public struct ListResourceSetResourcesInput: Swift.Sendable {
    /// A unique identifier for the resource set, used in a request to refer to the resource set.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of objects that you want Firewall Manager to return for this request. If more objects are available, in the response, Firewall Manager provides a NextToken value that you can use in a subsequent call to get the next batch of objects.
    public var maxResults: Swift.Int?
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Firewall Manager returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identifier = identifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension FMSClientTypes {

    /// Details of a resource that is associated to an Firewall Manager resource set.
    public struct Resource: Swift.Sendable {
        /// The Amazon Web Services account ID that the associated resource belongs to.
        public var accountId: Swift.String?
        /// The resource's universal resource indicator (URI).
        /// This member is required.
        public var uri: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            uri: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.uri = uri
        }
    }
}

public struct ListResourceSetResourcesOutput: Swift.Sendable {
    /// An array of the associated resources' uniform resource identifiers (URI).
    /// This member is required.
    public var items: [FMSClientTypes.Resource]?
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Firewall Manager returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        items: [FMSClientTypes.Resource]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListResourceSetsInput: Swift.Sendable {
    /// The maximum number of objects that you want Firewall Manager to return for this request. If more objects are available, in the response, Firewall Manager provides a NextToken value that you can use in a subsequent call to get the next batch of objects.
    public var maxResults: Swift.Int?
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Firewall Manager returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension FMSClientTypes {

    /// Summarizes the resource sets used in a policy.
    public struct ResourceSetSummary: Swift.Sendable {
        /// A description of the resource set.
        public var description: Swift.String?
        /// A unique identifier for the resource set. This ID is returned in the responses to create and list commands. You provide it to operations like update and delete.
        public var id: Swift.String?
        /// The last time that the resource set was changed.
        public var lastUpdateTime: Foundation.Date?
        /// The descriptive name of the resource set. You can't change the name of a resource set after you create it.
        public var name: Swift.String?
        /// Indicates whether the resource set is in or out of an admin's Region scope.
        ///
        /// * ACTIVE - The administrator can manage and delete the resource set.
        ///
        /// * OUT_OF_ADMIN_SCOPE - The administrator can view the resource set, but they can't edit or delete the resource set. Existing protections stay in place. Any new resource that come into scope of the resource set won't be protected.
        public var resourceSetStatus: FMSClientTypes.ResourceSetStatus?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            resourceSetStatus: FMSClientTypes.ResourceSetStatus? = nil
        )
        {
            self.description = description
            self.id = id
            self.lastUpdateTime = lastUpdateTime
            self.name = name
            self.resourceSetStatus = resourceSetStatus
        }
    }
}

public struct ListResourceSetsOutput: Swift.Sendable {
    /// When you request a list of objects with a MaxResults setting, if the number of objects that are still available for retrieval exceeds the maximum you requested, Firewall Manager returns a NextToken value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.
    public var nextToken: Swift.String?
    /// An array of ResourceSetSummary objects.
    public var resourceSets: [FMSClientTypes.ResourceSetSummary]?

    public init(
        nextToken: Swift.String? = nil,
        resourceSets: [FMSClientTypes.ResourceSetSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceSets = resourceSets
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to return tags for. The Firewall Manager resources that support tagging are policies, applications lists, and protocols lists.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags associated with the resource.
    public var tagList: [FMSClientTypes.Tag]?

    public init(
        tagList: [FMSClientTypes.Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

public struct ListThirdPartyFirewallFirewallPoliciesInput: Swift.Sendable {
    /// The maximum number of third-party firewall policies that you want Firewall Manager to return. If the specified third-party firewall vendor is associated with more than MaxResults firewall policies, the response includes a NextToken element. NextToken contains an encrypted token that identifies the first third-party firewall policies that Firewall Manager will return if you submit another request.
    /// This member is required.
    public var maxResults: Swift.Int?
    /// If the previous response included a NextToken element, the specified third-party firewall vendor is associated with more third-party firewall policies. To get more third-party firewall policies, submit another ListThirdPartyFirewallFirewallPoliciesRequest request. For the value of NextToken, specify the value of NextToken from the previous response. If the previous response didn't include a NextToken element, there are no more third-party firewall policies to get.
    public var nextToken: Swift.String?
    /// The name of the third-party firewall vendor.
    /// This member is required.
    public var thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        thirdPartyFirewall: FMSClientTypes.ThirdPartyFirewall? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.thirdPartyFirewall = thirdPartyFirewall
    }
}

extension FMSClientTypes {

    /// Configures the third-party firewall's firewall policy.
    public struct ThirdPartyFirewallFirewallPolicy: Swift.Sendable {
        /// The ID of the specified firewall policy.
        public var firewallPolicyId: Swift.String?
        /// The name of the specified firewall policy.
        public var firewallPolicyName: Swift.String?

        public init(
            firewallPolicyId: Swift.String? = nil,
            firewallPolicyName: Swift.String? = nil
        )
        {
            self.firewallPolicyId = firewallPolicyId
            self.firewallPolicyName = firewallPolicyName
        }
    }
}

public struct ListThirdPartyFirewallFirewallPoliciesOutput: Swift.Sendable {
    /// The value that you will use for NextToken in the next ListThirdPartyFirewallFirewallPolicies request.
    public var nextToken: Swift.String?
    /// A list that contains one ThirdPartyFirewallFirewallPolicies element for each third-party firewall policies that the specified third-party firewall vendor is associated with. Each ThirdPartyFirewallFirewallPolicies element contains the firewall policy name and ID.
    public var thirdPartyFirewallFirewallPolicies: [FMSClientTypes.ThirdPartyFirewallFirewallPolicy]?

    public init(
        nextToken: Swift.String? = nil,
        thirdPartyFirewallFirewallPolicies: [FMSClientTypes.ThirdPartyFirewallFirewallPolicy]? = nil
    )
    {
        self.nextToken = nextToken
        self.thirdPartyFirewallFirewallPolicies = thirdPartyFirewallFirewallPolicies
    }
}

public struct PutAdminAccountInput: Swift.Sendable {
    /// The Amazon Web Services account ID to add as an Firewall Manager administrator account. The account must be a member of the organization that was onboarded to Firewall Manager by [AssociateAdminAccount]. For more information about Organizations, see [Managing the Amazon Web Services Accounts in Your Organization](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_manage_accounts.html).
    /// This member is required.
    public var adminAccount: Swift.String?
    /// Configures the resources that the specified Firewall Manager administrator can manage. As a best practice, set the administrative scope according to the principles of least privilege. Only grant the administrator the specific resources or permissions that they need to perform the duties of their role.
    public var adminScope: FMSClientTypes.AdminScope?

    public init(
        adminAccount: Swift.String? = nil,
        adminScope: FMSClientTypes.AdminScope? = nil
    )
    {
        self.adminAccount = adminAccount
        self.adminScope = adminScope
    }
}

public struct PutAppsListInput: Swift.Sendable {
    /// The details of the Firewall Manager applications list to be created.
    /// This member is required.
    public var appsList: FMSClientTypes.AppsListData?
    /// The tags associated with the resource.
    public var tagList: [FMSClientTypes.Tag]?

    public init(
        appsList: FMSClientTypes.AppsListData? = nil,
        tagList: [FMSClientTypes.Tag]? = nil
    )
    {
        self.appsList = appsList
        self.tagList = tagList
    }
}

public struct PutAppsListOutput: Swift.Sendable {
    /// The details of the Firewall Manager applications list.
    public var appsList: FMSClientTypes.AppsListData?
    /// The Amazon Resource Name (ARN) of the applications list.
    public var appsListArn: Swift.String?

    public init(
        appsList: FMSClientTypes.AppsListData? = nil,
        appsListArn: Swift.String? = nil
    )
    {
        self.appsList = appsList
        self.appsListArn = appsListArn
    }
}

public struct PutNotificationChannelInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the IAM role that allows Amazon SNS to record Firewall Manager activity.
    /// This member is required.
    public var snsRoleName: Swift.String?
    /// The Amazon Resource Name (ARN) of the SNS topic that collects notifications from Firewall Manager.
    /// This member is required.
    public var snsTopicArn: Swift.String?

    public init(
        snsRoleName: Swift.String? = nil,
        snsTopicArn: Swift.String? = nil
    )
    {
        self.snsRoleName = snsRoleName
        self.snsTopicArn = snsTopicArn
    }
}

public struct PutPolicyInput: Swift.Sendable {
    /// The details of the Firewall Manager policy to be created.
    /// This member is required.
    public var policy: FMSClientTypes.Policy?
    /// The tags to add to the Amazon Web Services resource.
    public var tagList: [FMSClientTypes.Tag]?

    public init(
        policy: FMSClientTypes.Policy? = nil,
        tagList: [FMSClientTypes.Tag]? = nil
    )
    {
        self.policy = policy
        self.tagList = tagList
    }
}

public struct PutPolicyOutput: Swift.Sendable {
    /// The details of the Firewall Manager policy.
    public var policy: FMSClientTypes.Policy?
    /// The Amazon Resource Name (ARN) of the policy.
    public var policyArn: Swift.String?

    public init(
        policy: FMSClientTypes.Policy? = nil,
        policyArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.policyArn = policyArn
    }
}

public struct PutProtocolsListInput: Swift.Sendable {
    /// The details of the Firewall Manager protocols list to be created.
    /// This member is required.
    public var protocolsList: FMSClientTypes.ProtocolsListData?
    /// The tags associated with the resource.
    public var tagList: [FMSClientTypes.Tag]?

    public init(
        protocolsList: FMSClientTypes.ProtocolsListData? = nil,
        tagList: [FMSClientTypes.Tag]? = nil
    )
    {
        self.protocolsList = protocolsList
        self.tagList = tagList
    }
}

public struct PutProtocolsListOutput: Swift.Sendable {
    /// The details of the Firewall Manager protocols list.
    public var protocolsList: FMSClientTypes.ProtocolsListData?
    /// The Amazon Resource Name (ARN) of the protocols list.
    public var protocolsListArn: Swift.String?

    public init(
        protocolsList: FMSClientTypes.ProtocolsListData? = nil,
        protocolsListArn: Swift.String? = nil
    )
    {
        self.protocolsList = protocolsList
        self.protocolsListArn = protocolsListArn
    }
}

public struct PutResourceSetInput: Swift.Sendable {
    /// Details about the resource set to be created or updated.>
    /// This member is required.
    public var resourceSet: FMSClientTypes.ResourceSet?
    /// Retrieves the tags associated with the specified resource set. Tags are key:value pairs that you can use to categorize and manage your resources, for purposes like billing. For example, you might set the tag key to "customer" and the value to the customer name or ID. You can specify one or more tags to add to each Amazon Web Services resource, up to 50 tags for a resource.
    public var tagList: [FMSClientTypes.Tag]?

    public init(
        resourceSet: FMSClientTypes.ResourceSet? = nil,
        tagList: [FMSClientTypes.Tag]? = nil
    )
    {
        self.resourceSet = resourceSet
        self.tagList = tagList
    }
}

public struct PutResourceSetOutput: Swift.Sendable {
    /// Details about the resource set.
    /// This member is required.
    public var resourceSet: FMSClientTypes.ResourceSet?
    /// The Amazon Resource Name (ARN) of the resource set.
    /// This member is required.
    public var resourceSetArn: Swift.String?

    public init(
        resourceSet: FMSClientTypes.ResourceSet? = nil,
        resourceSetArn: Swift.String? = nil
    )
    {
        self.resourceSet = resourceSet
        self.resourceSetArn = resourceSetArn
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to return tags for. The Firewall Manager resources that support tagging are policies, applications lists, and protocols lists.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource.
    /// This member is required.
    public var tagList: [FMSClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tagList: [FMSClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagList = tagList
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to return tags for. The Firewall Manager resources that support tagging are policies, applications lists, and protocols lists.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension AssociateAdminAccountInput {

    static func urlPathProvider(_ value: AssociateAdminAccountInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateThirdPartyFirewallInput {

    static func urlPathProvider(_ value: AssociateThirdPartyFirewallInput) -> Swift.String? {
        return "/"
    }
}

extension BatchAssociateResourceInput {

    static func urlPathProvider(_ value: BatchAssociateResourceInput) -> Swift.String? {
        return "/"
    }
}

extension BatchDisassociateResourceInput {

    static func urlPathProvider(_ value: BatchDisassociateResourceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAppsListInput {

    static func urlPathProvider(_ value: DeleteAppsListInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteNotificationChannelInput {

    static func urlPathProvider(_ value: DeleteNotificationChannelInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePolicyInput {

    static func urlPathProvider(_ value: DeletePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteProtocolsListInput {

    static func urlPathProvider(_ value: DeleteProtocolsListInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteResourceSetInput {

    static func urlPathProvider(_ value: DeleteResourceSetInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateAdminAccountInput {

    static func urlPathProvider(_ value: DisassociateAdminAccountInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateThirdPartyFirewallInput {

    static func urlPathProvider(_ value: DisassociateThirdPartyFirewallInput) -> Swift.String? {
        return "/"
    }
}

extension GetAdminAccountInput {

    static func urlPathProvider(_ value: GetAdminAccountInput) -> Swift.String? {
        return "/"
    }
}

extension GetAdminScopeInput {

    static func urlPathProvider(_ value: GetAdminScopeInput) -> Swift.String? {
        return "/"
    }
}

extension GetAppsListInput {

    static func urlPathProvider(_ value: GetAppsListInput) -> Swift.String? {
        return "/"
    }
}

extension GetComplianceDetailInput {

    static func urlPathProvider(_ value: GetComplianceDetailInput) -> Swift.String? {
        return "/"
    }
}

extension GetNotificationChannelInput {

    static func urlPathProvider(_ value: GetNotificationChannelInput) -> Swift.String? {
        return "/"
    }
}

extension GetPolicyInput {

    static func urlPathProvider(_ value: GetPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetProtectionStatusInput {

    static func urlPathProvider(_ value: GetProtectionStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetProtocolsListInput {

    static func urlPathProvider(_ value: GetProtocolsListInput) -> Swift.String? {
        return "/"
    }
}

extension GetResourceSetInput {

    static func urlPathProvider(_ value: GetResourceSetInput) -> Swift.String? {
        return "/"
    }
}

extension GetThirdPartyFirewallAssociationStatusInput {

    static func urlPathProvider(_ value: GetThirdPartyFirewallAssociationStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetViolationDetailsInput {

    static func urlPathProvider(_ value: GetViolationDetailsInput) -> Swift.String? {
        return "/"
    }
}

extension ListAdminAccountsForOrganizationInput {

    static func urlPathProvider(_ value: ListAdminAccountsForOrganizationInput) -> Swift.String? {
        return "/"
    }
}

extension ListAdminsManagingAccountInput {

    static func urlPathProvider(_ value: ListAdminsManagingAccountInput) -> Swift.String? {
        return "/"
    }
}

extension ListAppsListsInput {

    static func urlPathProvider(_ value: ListAppsListsInput) -> Swift.String? {
        return "/"
    }
}

extension ListComplianceStatusInput {

    static func urlPathProvider(_ value: ListComplianceStatusInput) -> Swift.String? {
        return "/"
    }
}

extension ListDiscoveredResourcesInput {

    static func urlPathProvider(_ value: ListDiscoveredResourcesInput) -> Swift.String? {
        return "/"
    }
}

extension ListMemberAccountsInput {

    static func urlPathProvider(_ value: ListMemberAccountsInput) -> Swift.String? {
        return "/"
    }
}

extension ListPoliciesInput {

    static func urlPathProvider(_ value: ListPoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension ListProtocolsListsInput {

    static func urlPathProvider(_ value: ListProtocolsListsInput) -> Swift.String? {
        return "/"
    }
}

extension ListResourceSetResourcesInput {

    static func urlPathProvider(_ value: ListResourceSetResourcesInput) -> Swift.String? {
        return "/"
    }
}

extension ListResourceSetsInput {

    static func urlPathProvider(_ value: ListResourceSetsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListThirdPartyFirewallFirewallPoliciesInput {

    static func urlPathProvider(_ value: ListThirdPartyFirewallFirewallPoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension PutAdminAccountInput {

    static func urlPathProvider(_ value: PutAdminAccountInput) -> Swift.String? {
        return "/"
    }
}

extension PutAppsListInput {

    static func urlPathProvider(_ value: PutAppsListInput) -> Swift.String? {
        return "/"
    }
}

extension PutNotificationChannelInput {

    static func urlPathProvider(_ value: PutNotificationChannelInput) -> Swift.String? {
        return "/"
    }
}

extension PutPolicyInput {

    static func urlPathProvider(_ value: PutPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension PutProtocolsListInput {

    static func urlPathProvider(_ value: PutProtocolsListInput) -> Swift.String? {
        return "/"
    }
}

extension PutResourceSetInput {

    static func urlPathProvider(_ value: PutResourceSetInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateAdminAccountInput {

    static func write(value: AssociateAdminAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdminAccount"].write(value.adminAccount)
    }
}

extension AssociateThirdPartyFirewallInput {

    static func write(value: AssociateThirdPartyFirewallInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ThirdPartyFirewall"].write(value.thirdPartyFirewall)
    }
}

extension BatchAssociateResourceInput {

    static func write(value: BatchAssociateResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceSetIdentifier"].write(value.resourceSetIdentifier)
    }
}

extension BatchDisassociateResourceInput {

    static func write(value: BatchDisassociateResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Items"].writeList(value.items, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceSetIdentifier"].write(value.resourceSetIdentifier)
    }
}

extension DeleteAppsListInput {

    static func write(value: DeleteAppsListInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ListId"].write(value.listId)
    }
}

extension DeleteNotificationChannelInput {

    static func write(value: DeleteNotificationChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeletePolicyInput {

    static func write(value: DeletePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeleteAllPolicyResources"].write(value.deleteAllPolicyResources)
        try writer["PolicyId"].write(value.policyId)
    }
}

extension DeleteProtocolsListInput {

    static func write(value: DeleteProtocolsListInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ListId"].write(value.listId)
    }
}

extension DeleteResourceSetInput {

    static func write(value: DeleteResourceSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Identifier"].write(value.identifier)
    }
}

extension DisassociateAdminAccountInput {

    static func write(value: DisassociateAdminAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DisassociateThirdPartyFirewallInput {

    static func write(value: DisassociateThirdPartyFirewallInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ThirdPartyFirewall"].write(value.thirdPartyFirewall)
    }
}

extension GetAdminAccountInput {

    static func write(value: GetAdminAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetAdminScopeInput {

    static func write(value: GetAdminScopeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdminAccount"].write(value.adminAccount)
    }
}

extension GetAppsListInput {

    static func write(value: GetAppsListInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultList"].write(value.defaultList)
        try writer["ListId"].write(value.listId)
    }
}

extension GetComplianceDetailInput {

    static func write(value: GetComplianceDetailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MemberAccount"].write(value.memberAccount)
        try writer["PolicyId"].write(value.policyId)
    }
}

extension GetNotificationChannelInput {

    static func write(value: GetNotificationChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetPolicyInput {

    static func write(value: GetPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PolicyId"].write(value.policyId)
    }
}

extension GetProtectionStatusInput {

    static func write(value: GetProtectionStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["MaxResults"].write(value.maxResults)
        try writer["MemberAccountId"].write(value.memberAccountId)
        try writer["NextToken"].write(value.nextToken)
        try writer["PolicyId"].write(value.policyId)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension GetProtocolsListInput {

    static func write(value: GetProtocolsListInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultList"].write(value.defaultList)
        try writer["ListId"].write(value.listId)
    }
}

extension GetResourceSetInput {

    static func write(value: GetResourceSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Identifier"].write(value.identifier)
    }
}

extension GetThirdPartyFirewallAssociationStatusInput {

    static func write(value: GetThirdPartyFirewallAssociationStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ThirdPartyFirewall"].write(value.thirdPartyFirewall)
    }
}

extension GetViolationDetailsInput {

    static func write(value: GetViolationDetailsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MemberAccount"].write(value.memberAccount)
        try writer["PolicyId"].write(value.policyId)
        try writer["ResourceId"].write(value.resourceId)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension ListAdminAccountsForOrganizationInput {

    static func write(value: ListAdminAccountsForOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListAdminsManagingAccountInput {

    static func write(value: ListAdminsManagingAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListAppsListsInput {

    static func write(value: ListAppsListsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultLists"].write(value.defaultLists)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListComplianceStatusInput {

    static func write(value: ListComplianceStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PolicyId"].write(value.policyId)
    }
}

extension ListDiscoveredResourcesInput {

    static func write(value: ListDiscoveredResourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["MemberAccountIds"].writeList(value.memberAccountIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension ListMemberAccountsInput {

    static func write(value: ListMemberAccountsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListPoliciesInput {

    static func write(value: ListPoliciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListProtocolsListsInput {

    static func write(value: ListProtocolsListsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultLists"].write(value.defaultLists)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListResourceSetResourcesInput {

    static func write(value: ListResourceSetResourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Identifier"].write(value.identifier)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListResourceSetsInput {

    static func write(value: ListResourceSetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension ListThirdPartyFirewallFirewallPoliciesInput {

    static func write(value: ListThirdPartyFirewallFirewallPoliciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ThirdPartyFirewall"].write(value.thirdPartyFirewall)
    }
}

extension PutAdminAccountInput {

    static func write(value: PutAdminAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdminAccount"].write(value.adminAccount)
        try writer["AdminScope"].write(value.adminScope, with: FMSClientTypes.AdminScope.write(value:to:))
    }
}

extension PutAppsListInput {

    static func write(value: PutAppsListInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppsList"].write(value.appsList, with: FMSClientTypes.AppsListData.write(value:to:))
        try writer["TagList"].writeList(value.tagList, memberWritingClosure: FMSClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutNotificationChannelInput {

    static func write(value: PutNotificationChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SnsRoleName"].write(value.snsRoleName)
        try writer["SnsTopicArn"].write(value.snsTopicArn)
    }
}

extension PutPolicyInput {

    static func write(value: PutPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Policy"].write(value.policy, with: FMSClientTypes.Policy.write(value:to:))
        try writer["TagList"].writeList(value.tagList, memberWritingClosure: FMSClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutProtocolsListInput {

    static func write(value: PutProtocolsListInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProtocolsList"].write(value.protocolsList, with: FMSClientTypes.ProtocolsListData.write(value:to:))
        try writer["TagList"].writeList(value.tagList, memberWritingClosure: FMSClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutResourceSetInput {

    static func write(value: PutResourceSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceSet"].write(value.resourceSet, with: FMSClientTypes.ResourceSet.write(value:to:))
        try writer["TagList"].writeList(value.tagList, memberWritingClosure: FMSClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagList"].writeList(value.tagList, memberWritingClosure: FMSClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AssociateAdminAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateAdminAccountOutput {
        return AssociateAdminAccountOutput()
    }
}

extension AssociateThirdPartyFirewallOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateThirdPartyFirewallOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateThirdPartyFirewallOutput()
        value.thirdPartyFirewallStatus = try reader["ThirdPartyFirewallStatus"].readIfPresent()
        return value
    }
}

extension BatchAssociateResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchAssociateResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchAssociateResourceOutput()
        value.failedItems = try reader["FailedItems"].readListIfPresent(memberReadingClosure: FMSClientTypes.FailedItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.resourceSetIdentifier = try reader["ResourceSetIdentifier"].readIfPresent() ?? ""
        return value
    }
}

extension BatchDisassociateResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDisassociateResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDisassociateResourceOutput()
        value.failedItems = try reader["FailedItems"].readListIfPresent(memberReadingClosure: FMSClientTypes.FailedItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.resourceSetIdentifier = try reader["ResourceSetIdentifier"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteAppsListOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAppsListOutput {
        return DeleteAppsListOutput()
    }
}

extension DeleteNotificationChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteNotificationChannelOutput {
        return DeleteNotificationChannelOutput()
    }
}

extension DeletePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePolicyOutput {
        return DeletePolicyOutput()
    }
}

extension DeleteProtocolsListOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProtocolsListOutput {
        return DeleteProtocolsListOutput()
    }
}

extension DeleteResourceSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourceSetOutput {
        return DeleteResourceSetOutput()
    }
}

extension DisassociateAdminAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateAdminAccountOutput {
        return DisassociateAdminAccountOutput()
    }
}

extension DisassociateThirdPartyFirewallOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateThirdPartyFirewallOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateThirdPartyFirewallOutput()
        value.thirdPartyFirewallStatus = try reader["ThirdPartyFirewallStatus"].readIfPresent()
        return value
    }
}

extension GetAdminAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAdminAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAdminAccountOutput()
        value.adminAccount = try reader["AdminAccount"].readIfPresent()
        value.roleStatus = try reader["RoleStatus"].readIfPresent()
        return value
    }
}

extension GetAdminScopeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAdminScopeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAdminScopeOutput()
        value.adminScope = try reader["AdminScope"].readIfPresent(with: FMSClientTypes.AdminScope.read(from:))
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension GetAppsListOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAppsListOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAppsListOutput()
        value.appsList = try reader["AppsList"].readIfPresent(with: FMSClientTypes.AppsListData.read(from:))
        value.appsListArn = try reader["AppsListArn"].readIfPresent()
        return value
    }
}

extension GetComplianceDetailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetComplianceDetailOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetComplianceDetailOutput()
        value.policyComplianceDetail = try reader["PolicyComplianceDetail"].readIfPresent(with: FMSClientTypes.PolicyComplianceDetail.read(from:))
        return value
    }
}

extension GetNotificationChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNotificationChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNotificationChannelOutput()
        value.snsRoleName = try reader["SnsRoleName"].readIfPresent()
        value.snsTopicArn = try reader["SnsTopicArn"].readIfPresent()
        return value
    }
}

extension GetPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPolicyOutput()
        value.policy = try reader["Policy"].readIfPresent(with: FMSClientTypes.Policy.read(from:))
        value.policyArn = try reader["PolicyArn"].readIfPresent()
        return value
    }
}

extension GetProtectionStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProtectionStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProtectionStatusOutput()
        value.adminAccountId = try reader["AdminAccountId"].readIfPresent()
        value.data = try reader["Data"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.serviceType = try reader["ServiceType"].readIfPresent()
        return value
    }
}

extension GetProtocolsListOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProtocolsListOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProtocolsListOutput()
        value.protocolsList = try reader["ProtocolsList"].readIfPresent(with: FMSClientTypes.ProtocolsListData.read(from:))
        value.protocolsListArn = try reader["ProtocolsListArn"].readIfPresent()
        return value
    }
}

extension GetResourceSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceSetOutput()
        value.resourceSet = try reader["ResourceSet"].readIfPresent(with: FMSClientTypes.ResourceSet.read(from:))
        value.resourceSetArn = try reader["ResourceSetArn"].readIfPresent() ?? ""
        return value
    }
}

extension GetThirdPartyFirewallAssociationStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetThirdPartyFirewallAssociationStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetThirdPartyFirewallAssociationStatusOutput()
        value.marketplaceOnboardingStatus = try reader["MarketplaceOnboardingStatus"].readIfPresent()
        value.thirdPartyFirewallStatus = try reader["ThirdPartyFirewallStatus"].readIfPresent()
        return value
    }
}

extension GetViolationDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetViolationDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetViolationDetailsOutput()
        value.violationDetail = try reader["ViolationDetail"].readIfPresent(with: FMSClientTypes.ViolationDetail.read(from:))
        return value
    }
}

extension ListAdminAccountsForOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAdminAccountsForOrganizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAdminAccountsForOrganizationOutput()
        value.adminAccounts = try reader["AdminAccounts"].readListIfPresent(memberReadingClosure: FMSClientTypes.AdminAccountSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAdminsManagingAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAdminsManagingAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAdminsManagingAccountOutput()
        value.adminAccounts = try reader["AdminAccounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAppsListsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAppsListsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAppsListsOutput()
        value.appsLists = try reader["AppsLists"].readListIfPresent(memberReadingClosure: FMSClientTypes.AppsListDataSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListComplianceStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListComplianceStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListComplianceStatusOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.policyComplianceStatusList = try reader["PolicyComplianceStatusList"].readListIfPresent(memberReadingClosure: FMSClientTypes.PolicyComplianceStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListDiscoveredResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDiscoveredResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDiscoveredResourcesOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: FMSClientTypes.DiscoveredResource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListMemberAccountsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMemberAccountsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMemberAccountsOutput()
        value.memberAccounts = try reader["MemberAccounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPoliciesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.policyList = try reader["PolicyList"].readListIfPresent(memberReadingClosure: FMSClientTypes.PolicySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListProtocolsListsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProtocolsListsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProtocolsListsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.protocolsLists = try reader["ProtocolsLists"].readListIfPresent(memberReadingClosure: FMSClientTypes.ProtocolsListDataSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListResourceSetResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourceSetResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourceSetResourcesOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: FMSClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListResourceSetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourceSetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourceSetsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourceSets = try reader["ResourceSets"].readListIfPresent(memberReadingClosure: FMSClientTypes.ResourceSetSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tagList = try reader["TagList"].readListIfPresent(memberReadingClosure: FMSClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListThirdPartyFirewallFirewallPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListThirdPartyFirewallFirewallPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListThirdPartyFirewallFirewallPoliciesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.thirdPartyFirewallFirewallPolicies = try reader["ThirdPartyFirewallFirewallPolicies"].readListIfPresent(memberReadingClosure: FMSClientTypes.ThirdPartyFirewallFirewallPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutAdminAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutAdminAccountOutput {
        return PutAdminAccountOutput()
    }
}

extension PutAppsListOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutAppsListOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutAppsListOutput()
        value.appsList = try reader["AppsList"].readIfPresent(with: FMSClientTypes.AppsListData.read(from:))
        value.appsListArn = try reader["AppsListArn"].readIfPresent()
        return value
    }
}

extension PutNotificationChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutNotificationChannelOutput {
        return PutNotificationChannelOutput()
    }
}

extension PutPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutPolicyOutput()
        value.policy = try reader["Policy"].readIfPresent(with: FMSClientTypes.Policy.read(from:))
        value.policyArn = try reader["PolicyArn"].readIfPresent()
        return value
    }
}

extension PutProtocolsListOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutProtocolsListOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutProtocolsListOutput()
        value.protocolsList = try reader["ProtocolsList"].readIfPresent(with: FMSClientTypes.ProtocolsListData.read(from:))
        value.protocolsListArn = try reader["ProtocolsListArn"].readIfPresent()
        return value
    }
}

extension PutResourceSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutResourceSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutResourceSetOutput()
        value.resourceSet = try reader["ResourceSet"].readIfPresent(with: FMSClientTypes.ResourceSet.read(from:))
        value.resourceSetArn = try reader["ResourceSetArn"].readIfPresent() ?? ""
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum AssociateAdminAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateThirdPartyFirewallOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchAssociateResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDisassociateResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAppsListOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteNotificationChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProtocolsListOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourceSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateAdminAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateThirdPartyFirewallOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAdminAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAdminScopeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAppsListOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetComplianceDetailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNotificationChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "InvalidTypeException": return try InvalidTypeException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProtectionStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProtocolsListOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetThirdPartyFirewallAssociationStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetViolationDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAdminAccountsForOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAdminsManagingAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAppsListsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListComplianceStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDiscoveredResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMemberAccountsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProtocolsListsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourceSetResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourceSetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListThirdPartyFirewallFirewallPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutAdminAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutAppsListOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutNotificationChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "InvalidTypeException": return try InvalidTypeException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutProtocolsListOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutResourceSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidInputException": return try InvalidInputException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalErrorException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalErrorException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidOperationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidOperationException {
        let reader = baseError.errorBodyReader
        var value = InvalidOperationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidInputException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidInputException {
        let reader = baseError.errorBodyReader
        var value = InvalidInputException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidTypeException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidTypeException {
        let reader = baseError.errorBodyReader
        var value = InvalidTypeException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FMSClientTypes.FailedItem {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.FailedItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.FailedItem()
        value.uri = try reader["URI"].readIfPresent()
        value.reason = try reader["Reason"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.AdminScope {

    static func write(value: FMSClientTypes.AdminScope?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountScope"].write(value.accountScope, with: FMSClientTypes.AccountScope.write(value:to:))
        try writer["OrganizationalUnitScope"].write(value.organizationalUnitScope, with: FMSClientTypes.OrganizationalUnitScope.write(value:to:))
        try writer["PolicyTypeScope"].write(value.policyTypeScope, with: FMSClientTypes.PolicyTypeScope.write(value:to:))
        try writer["RegionScope"].write(value.regionScope, with: FMSClientTypes.RegionScope.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.AdminScope {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.AdminScope()
        value.accountScope = try reader["AccountScope"].readIfPresent(with: FMSClientTypes.AccountScope.read(from:))
        value.organizationalUnitScope = try reader["OrganizationalUnitScope"].readIfPresent(with: FMSClientTypes.OrganizationalUnitScope.read(from:))
        value.regionScope = try reader["RegionScope"].readIfPresent(with: FMSClientTypes.RegionScope.read(from:))
        value.policyTypeScope = try reader["PolicyTypeScope"].readIfPresent(with: FMSClientTypes.PolicyTypeScope.read(from:))
        return value
    }
}

extension FMSClientTypes.PolicyTypeScope {

    static func write(value: FMSClientTypes.PolicyTypeScope?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllPolicyTypesEnabled"].write(value.allPolicyTypesEnabled)
        try writer["PolicyTypes"].writeList(value.policyTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<FMSClientTypes.SecurityServiceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.PolicyTypeScope {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.PolicyTypeScope()
        value.policyTypes = try reader["PolicyTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<FMSClientTypes.SecurityServiceType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.allPolicyTypesEnabled = try reader["AllPolicyTypesEnabled"].readIfPresent() ?? false
        return value
    }
}

extension FMSClientTypes.RegionScope {

    static func write(value: FMSClientTypes.RegionScope?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllRegionsEnabled"].write(value.allRegionsEnabled)
        try writer["Regions"].writeList(value.regions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.RegionScope {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.RegionScope()
        value.regions = try reader["Regions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allRegionsEnabled = try reader["AllRegionsEnabled"].readIfPresent() ?? false
        return value
    }
}

extension FMSClientTypes.OrganizationalUnitScope {

    static func write(value: FMSClientTypes.OrganizationalUnitScope?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllOrganizationalUnitsEnabled"].write(value.allOrganizationalUnitsEnabled)
        try writer["ExcludeSpecifiedOrganizationalUnits"].write(value.excludeSpecifiedOrganizationalUnits)
        try writer["OrganizationalUnits"].writeList(value.organizationalUnits, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.OrganizationalUnitScope {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.OrganizationalUnitScope()
        value.organizationalUnits = try reader["OrganizationalUnits"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allOrganizationalUnitsEnabled = try reader["AllOrganizationalUnitsEnabled"].readIfPresent() ?? false
        value.excludeSpecifiedOrganizationalUnits = try reader["ExcludeSpecifiedOrganizationalUnits"].readIfPresent() ?? false
        return value
    }
}

extension FMSClientTypes.AccountScope {

    static func write(value: FMSClientTypes.AccountScope?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Accounts"].writeList(value.accounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AllAccountsEnabled"].write(value.allAccountsEnabled)
        try writer["ExcludeSpecifiedAccounts"].write(value.excludeSpecifiedAccounts)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.AccountScope {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.AccountScope()
        value.accounts = try reader["Accounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allAccountsEnabled = try reader["AllAccountsEnabled"].readIfPresent() ?? false
        value.excludeSpecifiedAccounts = try reader["ExcludeSpecifiedAccounts"].readIfPresent() ?? false
        return value
    }
}

extension FMSClientTypes.AppsListData {

    static func write(value: FMSClientTypes.AppsListData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppsList"].writeList(value.appsList, memberWritingClosure: FMSClientTypes.App.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CreateTime"].writeTimestamp(value.createTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["LastUpdateTime"].writeTimestamp(value.lastUpdateTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ListId"].write(value.listId)
        try writer["ListName"].write(value.listName)
        try writer["ListUpdateToken"].write(value.listUpdateToken)
        try writer["PreviousAppsList"].writeMap(value.previousAppsList, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: FMSClientTypes.App.write(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.AppsListData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.AppsListData()
        value.listId = try reader["ListId"].readIfPresent()
        value.listName = try reader["ListName"].readIfPresent() ?? ""
        value.listUpdateToken = try reader["ListUpdateToken"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.appsList = try reader["AppsList"].readListIfPresent(memberReadingClosure: FMSClientTypes.App.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.previousAppsList = try reader["PreviousAppsList"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: FMSClientTypes.App.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FMSClientTypes.App {

    static func write(value: FMSClientTypes.App?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppName"].write(value.appName)
        try writer["Port"].write(value.port)
        try writer["Protocol"].write(value.`protocol`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.App {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.App()
        value.appName = try reader["AppName"].readIfPresent() ?? ""
        value.`protocol` = try reader["Protocol"].readIfPresent() ?? ""
        value.port = try reader["Port"].readIfPresent() ?? 0
        return value
    }
}

extension FMSClientTypes.PolicyComplianceDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.PolicyComplianceDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.PolicyComplianceDetail()
        value.policyOwner = try reader["PolicyOwner"].readIfPresent()
        value.policyId = try reader["PolicyId"].readIfPresent()
        value.memberAccount = try reader["MemberAccount"].readIfPresent()
        value.violators = try reader["Violators"].readListIfPresent(memberReadingClosure: FMSClientTypes.ComplianceViolator.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.evaluationLimitExceeded = try reader["EvaluationLimitExceeded"].readIfPresent() ?? false
        value.expiredAt = try reader["ExpiredAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.issueInfoMap = try reader["IssueInfoMap"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FMSClientTypes.ComplianceViolator {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.ComplianceViolator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.ComplianceViolator()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.violationReason = try reader["ViolationReason"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.metadata = try reader["Metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FMSClientTypes.Policy {

    static func write(value: FMSClientTypes.Policy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeleteUnusedFMManagedResources"].write(value.deleteUnusedFMManagedResources)
        try writer["ExcludeMap"].writeMap(value.excludeMap, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ExcludeResourceTags"].write(value.excludeResourceTags)
        try writer["IncludeMap"].writeMap(value.includeMap, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["PolicyDescription"].write(value.policyDescription)
        try writer["PolicyId"].write(value.policyId)
        try writer["PolicyName"].write(value.policyName)
        try writer["PolicyStatus"].write(value.policyStatus)
        try writer["PolicyUpdateToken"].write(value.policyUpdateToken)
        try writer["RemediationEnabled"].write(value.remediationEnabled)
        try writer["ResourceSetIds"].writeList(value.resourceSetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: FMSClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceType"].write(value.resourceType)
        try writer["ResourceTypeList"].writeList(value.resourceTypeList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SecurityServicePolicyData"].write(value.securityServicePolicyData, with: FMSClientTypes.SecurityServicePolicyData.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.Policy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.Policy()
        value.policyId = try reader["PolicyId"].readIfPresent()
        value.policyName = try reader["PolicyName"].readIfPresent() ?? ""
        value.policyUpdateToken = try reader["PolicyUpdateToken"].readIfPresent()
        value.securityServicePolicyData = try reader["SecurityServicePolicyData"].readIfPresent(with: FMSClientTypes.SecurityServicePolicyData.read(from:))
        value.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.resourceTypeList = try reader["ResourceTypeList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceTags = try reader["ResourceTags"].readListIfPresent(memberReadingClosure: FMSClientTypes.ResourceTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.excludeResourceTags = try reader["ExcludeResourceTags"].readIfPresent() ?? false
        value.remediationEnabled = try reader["RemediationEnabled"].readIfPresent() ?? false
        value.deleteUnusedFMManagedResources = try reader["DeleteUnusedFMManagedResources"].readIfPresent() ?? false
        value.includeMap = try reader["IncludeMap"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.excludeMap = try reader["ExcludeMap"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.resourceSetIds = try reader["ResourceSetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.policyDescription = try reader["PolicyDescription"].readIfPresent()
        value.policyStatus = try reader["PolicyStatus"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.ResourceTag {

    static func write(value: FMSClientTypes.ResourceTag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.ResourceTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.ResourceTag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.SecurityServicePolicyData {

    static func write(value: FMSClientTypes.SecurityServicePolicyData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ManagedServiceData"].write(value.managedServiceData)
        try writer["PolicyOption"].write(value.policyOption, with: FMSClientTypes.PolicyOption.write(value:to:))
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.SecurityServicePolicyData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.SecurityServicePolicyData()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.managedServiceData = try reader["ManagedServiceData"].readIfPresent()
        value.policyOption = try reader["PolicyOption"].readIfPresent(with: FMSClientTypes.PolicyOption.read(from:))
        return value
    }
}

extension FMSClientTypes.PolicyOption {

    static func write(value: FMSClientTypes.PolicyOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NetworkAclCommonPolicy"].write(value.networkAclCommonPolicy, with: FMSClientTypes.NetworkAclCommonPolicy.write(value:to:))
        try writer["NetworkFirewallPolicy"].write(value.networkFirewallPolicy, with: FMSClientTypes.NetworkFirewallPolicy.write(value:to:))
        try writer["ThirdPartyFirewallPolicy"].write(value.thirdPartyFirewallPolicy, with: FMSClientTypes.ThirdPartyFirewallPolicy.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.PolicyOption {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.PolicyOption()
        value.networkFirewallPolicy = try reader["NetworkFirewallPolicy"].readIfPresent(with: FMSClientTypes.NetworkFirewallPolicy.read(from:))
        value.thirdPartyFirewallPolicy = try reader["ThirdPartyFirewallPolicy"].readIfPresent(with: FMSClientTypes.ThirdPartyFirewallPolicy.read(from:))
        value.networkAclCommonPolicy = try reader["NetworkAclCommonPolicy"].readIfPresent(with: FMSClientTypes.NetworkAclCommonPolicy.read(from:))
        return value
    }
}

extension FMSClientTypes.NetworkAclCommonPolicy {

    static func write(value: FMSClientTypes.NetworkAclCommonPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NetworkAclEntrySet"].write(value.networkAclEntrySet, with: FMSClientTypes.NetworkAclEntrySet.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.NetworkAclCommonPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.NetworkAclCommonPolicy()
        value.networkAclEntrySet = try reader["NetworkAclEntrySet"].readIfPresent(with: FMSClientTypes.NetworkAclEntrySet.read(from:))
        return value
    }
}

extension FMSClientTypes.NetworkAclEntrySet {

    static func write(value: FMSClientTypes.NetworkAclEntrySet?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FirstEntries"].writeList(value.firstEntries, memberWritingClosure: FMSClientTypes.NetworkAclEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ForceRemediateForFirstEntries"].write(value.forceRemediateForFirstEntries)
        try writer["ForceRemediateForLastEntries"].write(value.forceRemediateForLastEntries)
        try writer["LastEntries"].writeList(value.lastEntries, memberWritingClosure: FMSClientTypes.NetworkAclEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.NetworkAclEntrySet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.NetworkAclEntrySet()
        value.firstEntries = try reader["FirstEntries"].readListIfPresent(memberReadingClosure: FMSClientTypes.NetworkAclEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.forceRemediateForFirstEntries = try reader["ForceRemediateForFirstEntries"].readIfPresent() ?? false
        value.lastEntries = try reader["LastEntries"].readListIfPresent(memberReadingClosure: FMSClientTypes.NetworkAclEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.forceRemediateForLastEntries = try reader["ForceRemediateForLastEntries"].readIfPresent() ?? false
        return value
    }
}

extension FMSClientTypes.NetworkAclEntry {

    static func write(value: FMSClientTypes.NetworkAclEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CidrBlock"].write(value.cidrBlock)
        try writer["Egress"].write(value.egress)
        try writer["IcmpTypeCode"].write(value.icmpTypeCode, with: FMSClientTypes.NetworkAclIcmpTypeCode.write(value:to:))
        try writer["Ipv6CidrBlock"].write(value.ipv6CidrBlock)
        try writer["PortRange"].write(value.portRange, with: FMSClientTypes.NetworkAclPortRange.write(value:to:))
        try writer["Protocol"].write(value.`protocol`)
        try writer["RuleAction"].write(value.ruleAction)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.NetworkAclEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.NetworkAclEntry()
        value.icmpTypeCode = try reader["IcmpTypeCode"].readIfPresent(with: FMSClientTypes.NetworkAclIcmpTypeCode.read(from:))
        value.`protocol` = try reader["Protocol"].readIfPresent() ?? ""
        value.portRange = try reader["PortRange"].readIfPresent(with: FMSClientTypes.NetworkAclPortRange.read(from:))
        value.cidrBlock = try reader["CidrBlock"].readIfPresent()
        value.ipv6CidrBlock = try reader["Ipv6CidrBlock"].readIfPresent()
        value.ruleAction = try reader["RuleAction"].readIfPresent() ?? .sdkUnknown("")
        value.egress = try reader["Egress"].readIfPresent() ?? false
        return value
    }
}

extension FMSClientTypes.NetworkAclPortRange {

    static func write(value: FMSClientTypes.NetworkAclPortRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["From"].write(value.from)
        try writer["To"].write(value.to)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.NetworkAclPortRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.NetworkAclPortRange()
        value.from = try reader["From"].readIfPresent()
        value.to = try reader["To"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.NetworkAclIcmpTypeCode {

    static func write(value: FMSClientTypes.NetworkAclIcmpTypeCode?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Code"].write(value.code)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.NetworkAclIcmpTypeCode {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.NetworkAclIcmpTypeCode()
        value.code = try reader["Code"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.ThirdPartyFirewallPolicy {

    static func write(value: FMSClientTypes.ThirdPartyFirewallPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FirewallDeploymentModel"].write(value.firewallDeploymentModel)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.ThirdPartyFirewallPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.ThirdPartyFirewallPolicy()
        value.firewallDeploymentModel = try reader["FirewallDeploymentModel"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.NetworkFirewallPolicy {

    static func write(value: FMSClientTypes.NetworkFirewallPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FirewallDeploymentModel"].write(value.firewallDeploymentModel)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.NetworkFirewallPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.NetworkFirewallPolicy()
        value.firewallDeploymentModel = try reader["FirewallDeploymentModel"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.ProtocolsListData {

    static func write(value: FMSClientTypes.ProtocolsListData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreateTime"].writeTimestamp(value.createTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["LastUpdateTime"].writeTimestamp(value.lastUpdateTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ListId"].write(value.listId)
        try writer["ListName"].write(value.listName)
        try writer["ListUpdateToken"].write(value.listUpdateToken)
        try writer["PreviousProtocolsList"].writeMap(value.previousProtocolsList, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ProtocolsList"].writeList(value.protocolsList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.ProtocolsListData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.ProtocolsListData()
        value.listId = try reader["ListId"].readIfPresent()
        value.listName = try reader["ListName"].readIfPresent() ?? ""
        value.listUpdateToken = try reader["ListUpdateToken"].readIfPresent()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.protocolsList = try reader["ProtocolsList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.previousProtocolsList = try reader["PreviousProtocolsList"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FMSClientTypes.ResourceSet {

    static func write(value: FMSClientTypes.ResourceSet?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Id"].write(value.id)
        try writer["LastUpdateTime"].writeTimestamp(value.lastUpdateTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Name"].write(value.name)
        try writer["ResourceSetStatus"].write(value.resourceSetStatus)
        try writer["ResourceTypeList"].writeList(value.resourceTypeList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UpdateToken"].write(value.updateToken)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.ResourceSet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.ResourceSet()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        value.updateToken = try reader["UpdateToken"].readIfPresent()
        value.resourceTypeList = try reader["ResourceTypeList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resourceSetStatus = try reader["ResourceSetStatus"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.ViolationDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.ViolationDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.ViolationDetail()
        value.policyId = try reader["PolicyId"].readIfPresent() ?? ""
        value.memberAccount = try reader["MemberAccount"].readIfPresent() ?? ""
        value.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.resourceViolations = try reader["ResourceViolations"].readListIfPresent(memberReadingClosure: FMSClientTypes.ResourceViolation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.resourceTags = try reader["ResourceTags"].readListIfPresent(memberReadingClosure: FMSClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceDescription = try reader["ResourceDescription"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.Tag {

    static func write(value: FMSClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension FMSClientTypes.ResourceViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.ResourceViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.ResourceViolation()
        value.awsVPCSecurityGroupViolation = try reader["AwsVPCSecurityGroupViolation"].readIfPresent(with: FMSClientTypes.AwsVPCSecurityGroupViolation.read(from:))
        value.awsEc2NetworkInterfaceViolation = try reader["AwsEc2NetworkInterfaceViolation"].readIfPresent(with: FMSClientTypes.AwsEc2NetworkInterfaceViolation.read(from:))
        value.awsEc2InstanceViolation = try reader["AwsEc2InstanceViolation"].readIfPresent(with: FMSClientTypes.AwsEc2InstanceViolation.read(from:))
        value.networkFirewallMissingFirewallViolation = try reader["NetworkFirewallMissingFirewallViolation"].readIfPresent(with: FMSClientTypes.NetworkFirewallMissingFirewallViolation.read(from:))
        value.networkFirewallMissingSubnetViolation = try reader["NetworkFirewallMissingSubnetViolation"].readIfPresent(with: FMSClientTypes.NetworkFirewallMissingSubnetViolation.read(from:))
        value.networkFirewallMissingExpectedRTViolation = try reader["NetworkFirewallMissingExpectedRTViolation"].readIfPresent(with: FMSClientTypes.NetworkFirewallMissingExpectedRTViolation.read(from:))
        value.networkFirewallPolicyModifiedViolation = try reader["NetworkFirewallPolicyModifiedViolation"].readIfPresent(with: FMSClientTypes.NetworkFirewallPolicyModifiedViolation.read(from:))
        value.networkFirewallInternetTrafficNotInspectedViolation = try reader["NetworkFirewallInternetTrafficNotInspectedViolation"].readIfPresent(with: FMSClientTypes.NetworkFirewallInternetTrafficNotInspectedViolation.read(from:))
        value.networkFirewallInvalidRouteConfigurationViolation = try reader["NetworkFirewallInvalidRouteConfigurationViolation"].readIfPresent(with: FMSClientTypes.NetworkFirewallInvalidRouteConfigurationViolation.read(from:))
        value.networkFirewallBlackHoleRouteDetectedViolation = try reader["NetworkFirewallBlackHoleRouteDetectedViolation"].readIfPresent(with: FMSClientTypes.NetworkFirewallBlackHoleRouteDetectedViolation.read(from:))
        value.networkFirewallUnexpectedFirewallRoutesViolation = try reader["NetworkFirewallUnexpectedFirewallRoutesViolation"].readIfPresent(with: FMSClientTypes.NetworkFirewallUnexpectedFirewallRoutesViolation.read(from:))
        value.networkFirewallUnexpectedGatewayRoutesViolation = try reader["NetworkFirewallUnexpectedGatewayRoutesViolation"].readIfPresent(with: FMSClientTypes.NetworkFirewallUnexpectedGatewayRoutesViolation.read(from:))
        value.networkFirewallMissingExpectedRoutesViolation = try reader["NetworkFirewallMissingExpectedRoutesViolation"].readIfPresent(with: FMSClientTypes.NetworkFirewallMissingExpectedRoutesViolation.read(from:))
        value.dnsRuleGroupPriorityConflictViolation = try reader["DnsRuleGroupPriorityConflictViolation"].readIfPresent(with: FMSClientTypes.DnsRuleGroupPriorityConflictViolation.read(from:))
        value.dnsDuplicateRuleGroupViolation = try reader["DnsDuplicateRuleGroupViolation"].readIfPresent(with: FMSClientTypes.DnsDuplicateRuleGroupViolation.read(from:))
        value.dnsRuleGroupLimitExceededViolation = try reader["DnsRuleGroupLimitExceededViolation"].readIfPresent(with: FMSClientTypes.DnsRuleGroupLimitExceededViolation.read(from:))
        value.firewallSubnetIsOutOfScopeViolation = try reader["FirewallSubnetIsOutOfScopeViolation"].readIfPresent(with: FMSClientTypes.FirewallSubnetIsOutOfScopeViolation.read(from:))
        value.routeHasOutOfScopeEndpointViolation = try reader["RouteHasOutOfScopeEndpointViolation"].readIfPresent(with: FMSClientTypes.RouteHasOutOfScopeEndpointViolation.read(from:))
        value.thirdPartyFirewallMissingFirewallViolation = try reader["ThirdPartyFirewallMissingFirewallViolation"].readIfPresent(with: FMSClientTypes.ThirdPartyFirewallMissingFirewallViolation.read(from:))
        value.thirdPartyFirewallMissingSubnetViolation = try reader["ThirdPartyFirewallMissingSubnetViolation"].readIfPresent(with: FMSClientTypes.ThirdPartyFirewallMissingSubnetViolation.read(from:))
        value.thirdPartyFirewallMissingExpectedRouteTableViolation = try reader["ThirdPartyFirewallMissingExpectedRouteTableViolation"].readIfPresent(with: FMSClientTypes.ThirdPartyFirewallMissingExpectedRouteTableViolation.read(from:))
        value.firewallSubnetMissingVPCEndpointViolation = try reader["FirewallSubnetMissingVPCEndpointViolation"].readIfPresent(with: FMSClientTypes.FirewallSubnetMissingVPCEndpointViolation.read(from:))
        value.invalidNetworkAclEntriesViolation = try reader["InvalidNetworkAclEntriesViolation"].readIfPresent(with: FMSClientTypes.InvalidNetworkAclEntriesViolation.read(from:))
        value.possibleRemediationActions = try reader["PossibleRemediationActions"].readIfPresent(with: FMSClientTypes.PossibleRemediationActions.read(from:))
        value.webACLHasIncompatibleConfigurationViolation = try reader["WebACLHasIncompatibleConfigurationViolation"].readIfPresent(with: FMSClientTypes.WebACLHasIncompatibleConfigurationViolation.read(from:))
        value.webACLHasOutOfScopeResourcesViolation = try reader["WebACLHasOutOfScopeResourcesViolation"].readIfPresent(with: FMSClientTypes.WebACLHasOutOfScopeResourcesViolation.read(from:))
        return value
    }
}

extension FMSClientTypes.WebACLHasOutOfScopeResourcesViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.WebACLHasOutOfScopeResourcesViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.WebACLHasOutOfScopeResourcesViolation()
        value.webACLArn = try reader["WebACLArn"].readIfPresent()
        value.outOfScopeResourceList = try reader["OutOfScopeResourceList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FMSClientTypes.WebACLHasIncompatibleConfigurationViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.WebACLHasIncompatibleConfigurationViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.WebACLHasIncompatibleConfigurationViolation()
        value.webACLArn = try reader["WebACLArn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.PossibleRemediationActions {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.PossibleRemediationActions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.PossibleRemediationActions()
        value.description = try reader["Description"].readIfPresent()
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: FMSClientTypes.PossibleRemediationAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FMSClientTypes.PossibleRemediationAction {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.PossibleRemediationAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.PossibleRemediationAction()
        value.description = try reader["Description"].readIfPresent()
        value.orderedRemediationActions = try reader["OrderedRemediationActions"].readListIfPresent(memberReadingClosure: FMSClientTypes.RemediationActionWithOrder.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.isDefaultAction = try reader["IsDefaultAction"].readIfPresent() ?? false
        return value
    }
}

extension FMSClientTypes.RemediationActionWithOrder {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.RemediationActionWithOrder {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.RemediationActionWithOrder()
        value.remediationAction = try reader["RemediationAction"].readIfPresent(with: FMSClientTypes.RemediationAction.read(from:))
        value.order = try reader["Order"].readIfPresent() ?? 0
        return value
    }
}

extension FMSClientTypes.RemediationAction {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.RemediationAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.RemediationAction()
        value.description = try reader["Description"].readIfPresent()
        value.ec2CreateRouteAction = try reader["EC2CreateRouteAction"].readIfPresent(with: FMSClientTypes.EC2CreateRouteAction.read(from:))
        value.ec2ReplaceRouteAction = try reader["EC2ReplaceRouteAction"].readIfPresent(with: FMSClientTypes.EC2ReplaceRouteAction.read(from:))
        value.ec2DeleteRouteAction = try reader["EC2DeleteRouteAction"].readIfPresent(with: FMSClientTypes.EC2DeleteRouteAction.read(from:))
        value.ec2CopyRouteTableAction = try reader["EC2CopyRouteTableAction"].readIfPresent(with: FMSClientTypes.EC2CopyRouteTableAction.read(from:))
        value.ec2ReplaceRouteTableAssociationAction = try reader["EC2ReplaceRouteTableAssociationAction"].readIfPresent(with: FMSClientTypes.EC2ReplaceRouteTableAssociationAction.read(from:))
        value.ec2AssociateRouteTableAction = try reader["EC2AssociateRouteTableAction"].readIfPresent(with: FMSClientTypes.EC2AssociateRouteTableAction.read(from:))
        value.ec2CreateRouteTableAction = try reader["EC2CreateRouteTableAction"].readIfPresent(with: FMSClientTypes.EC2CreateRouteTableAction.read(from:))
        value.fmsPolicyUpdateFirewallCreationConfigAction = try reader["FMSPolicyUpdateFirewallCreationConfigAction"].readIfPresent(with: FMSClientTypes.FMSPolicyUpdateFirewallCreationConfigAction.read(from:))
        value.createNetworkAclAction = try reader["CreateNetworkAclAction"].readIfPresent(with: FMSClientTypes.CreateNetworkAclAction.read(from:))
        value.replaceNetworkAclAssociationAction = try reader["ReplaceNetworkAclAssociationAction"].readIfPresent(with: FMSClientTypes.ReplaceNetworkAclAssociationAction.read(from:))
        value.createNetworkAclEntriesAction = try reader["CreateNetworkAclEntriesAction"].readIfPresent(with: FMSClientTypes.CreateNetworkAclEntriesAction.read(from:))
        value.deleteNetworkAclEntriesAction = try reader["DeleteNetworkAclEntriesAction"].readIfPresent(with: FMSClientTypes.DeleteNetworkAclEntriesAction.read(from:))
        return value
    }
}

extension FMSClientTypes.DeleteNetworkAclEntriesAction {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.DeleteNetworkAclEntriesAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.DeleteNetworkAclEntriesAction()
        value.description = try reader["Description"].readIfPresent()
        value.networkAclId = try reader["NetworkAclId"].readIfPresent(with: FMSClientTypes.ActionTarget.read(from:))
        value.networkAclEntriesToBeDeleted = try reader["NetworkAclEntriesToBeDeleted"].readListIfPresent(memberReadingClosure: FMSClientTypes.EntryDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.fmsCanRemediate = try reader["FMSCanRemediate"].readIfPresent() ?? false
        return value
    }
}

extension FMSClientTypes.EntryDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.EntryDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.EntryDescription()
        value.entryDetail = try reader["EntryDetail"].readIfPresent(with: FMSClientTypes.NetworkAclEntry.read(from:))
        value.entryRuleNumber = try reader["EntryRuleNumber"].readIfPresent() ?? 0
        value.entryType = try reader["EntryType"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.ActionTarget {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.ActionTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.ActionTarget()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.CreateNetworkAclEntriesAction {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.CreateNetworkAclEntriesAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.CreateNetworkAclEntriesAction()
        value.description = try reader["Description"].readIfPresent()
        value.networkAclId = try reader["NetworkAclId"].readIfPresent(with: FMSClientTypes.ActionTarget.read(from:))
        value.networkAclEntriesToBeCreated = try reader["NetworkAclEntriesToBeCreated"].readListIfPresent(memberReadingClosure: FMSClientTypes.EntryDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.fmsCanRemediate = try reader["FMSCanRemediate"].readIfPresent() ?? false
        return value
    }
}

extension FMSClientTypes.ReplaceNetworkAclAssociationAction {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.ReplaceNetworkAclAssociationAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.ReplaceNetworkAclAssociationAction()
        value.description = try reader["Description"].readIfPresent()
        value.associationId = try reader["AssociationId"].readIfPresent(with: FMSClientTypes.ActionTarget.read(from:))
        value.networkAclId = try reader["NetworkAclId"].readIfPresent(with: FMSClientTypes.ActionTarget.read(from:))
        value.fmsCanRemediate = try reader["FMSCanRemediate"].readIfPresent() ?? false
        return value
    }
}

extension FMSClientTypes.CreateNetworkAclAction {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.CreateNetworkAclAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.CreateNetworkAclAction()
        value.description = try reader["Description"].readIfPresent()
        value.vpc = try reader["Vpc"].readIfPresent(with: FMSClientTypes.ActionTarget.read(from:))
        value.fmsCanRemediate = try reader["FMSCanRemediate"].readIfPresent() ?? false
        return value
    }
}

extension FMSClientTypes.FMSPolicyUpdateFirewallCreationConfigAction {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.FMSPolicyUpdateFirewallCreationConfigAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.FMSPolicyUpdateFirewallCreationConfigAction()
        value.description = try reader["Description"].readIfPresent()
        value.firewallCreationConfig = try reader["FirewallCreationConfig"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.EC2CreateRouteTableAction {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.EC2CreateRouteTableAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.EC2CreateRouteTableAction()
        value.description = try reader["Description"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent(with: FMSClientTypes.ActionTarget.read(from:))
        return value
    }
}

extension FMSClientTypes.EC2AssociateRouteTableAction {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.EC2AssociateRouteTableAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.EC2AssociateRouteTableAction()
        value.description = try reader["Description"].readIfPresent()
        value.routeTableId = try reader["RouteTableId"].readIfPresent(with: FMSClientTypes.ActionTarget.read(from:))
        value.subnetId = try reader["SubnetId"].readIfPresent(with: FMSClientTypes.ActionTarget.read(from:))
        value.gatewayId = try reader["GatewayId"].readIfPresent(with: FMSClientTypes.ActionTarget.read(from:))
        return value
    }
}

extension FMSClientTypes.EC2ReplaceRouteTableAssociationAction {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.EC2ReplaceRouteTableAssociationAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.EC2ReplaceRouteTableAssociationAction()
        value.description = try reader["Description"].readIfPresent()
        value.associationId = try reader["AssociationId"].readIfPresent(with: FMSClientTypes.ActionTarget.read(from:))
        value.routeTableId = try reader["RouteTableId"].readIfPresent(with: FMSClientTypes.ActionTarget.read(from:))
        return value
    }
}

extension FMSClientTypes.EC2CopyRouteTableAction {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.EC2CopyRouteTableAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.EC2CopyRouteTableAction()
        value.description = try reader["Description"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent(with: FMSClientTypes.ActionTarget.read(from:))
        value.routeTableId = try reader["RouteTableId"].readIfPresent(with: FMSClientTypes.ActionTarget.read(from:))
        return value
    }
}

extension FMSClientTypes.EC2DeleteRouteAction {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.EC2DeleteRouteAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.EC2DeleteRouteAction()
        value.description = try reader["Description"].readIfPresent()
        value.destinationCidrBlock = try reader["DestinationCidrBlock"].readIfPresent()
        value.destinationPrefixListId = try reader["DestinationPrefixListId"].readIfPresent()
        value.destinationIpv6CidrBlock = try reader["DestinationIpv6CidrBlock"].readIfPresent()
        value.routeTableId = try reader["RouteTableId"].readIfPresent(with: FMSClientTypes.ActionTarget.read(from:))
        return value
    }
}

extension FMSClientTypes.EC2ReplaceRouteAction {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.EC2ReplaceRouteAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.EC2ReplaceRouteAction()
        value.description = try reader["Description"].readIfPresent()
        value.destinationCidrBlock = try reader["DestinationCidrBlock"].readIfPresent()
        value.destinationPrefixListId = try reader["DestinationPrefixListId"].readIfPresent()
        value.destinationIpv6CidrBlock = try reader["DestinationIpv6CidrBlock"].readIfPresent()
        value.gatewayId = try reader["GatewayId"].readIfPresent(with: FMSClientTypes.ActionTarget.read(from:))
        value.routeTableId = try reader["RouteTableId"].readIfPresent(with: FMSClientTypes.ActionTarget.read(from:))
        return value
    }
}

extension FMSClientTypes.EC2CreateRouteAction {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.EC2CreateRouteAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.EC2CreateRouteAction()
        value.description = try reader["Description"].readIfPresent()
        value.destinationCidrBlock = try reader["DestinationCidrBlock"].readIfPresent()
        value.destinationPrefixListId = try reader["DestinationPrefixListId"].readIfPresent()
        value.destinationIpv6CidrBlock = try reader["DestinationIpv6CidrBlock"].readIfPresent()
        value.vpcEndpointId = try reader["VpcEndpointId"].readIfPresent(with: FMSClientTypes.ActionTarget.read(from:))
        value.gatewayId = try reader["GatewayId"].readIfPresent(with: FMSClientTypes.ActionTarget.read(from:))
        value.routeTableId = try reader["RouteTableId"].readIfPresent(with: FMSClientTypes.ActionTarget.read(from:))
        return value
    }
}

extension FMSClientTypes.InvalidNetworkAclEntriesViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.InvalidNetworkAclEntriesViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.InvalidNetworkAclEntriesViolation()
        value.vpc = try reader["Vpc"].readIfPresent()
        value.subnet = try reader["Subnet"].readIfPresent()
        value.subnetAvailabilityZone = try reader["SubnetAvailabilityZone"].readIfPresent()
        value.currentAssociatedNetworkAcl = try reader["CurrentAssociatedNetworkAcl"].readIfPresent()
        value.entryViolations = try reader["EntryViolations"].readListIfPresent(memberReadingClosure: FMSClientTypes.EntryViolation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FMSClientTypes.EntryViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.EntryViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.EntryViolation()
        value.expectedEntry = try reader["ExpectedEntry"].readIfPresent(with: FMSClientTypes.EntryDescription.read(from:))
        value.expectedEvaluationOrder = try reader["ExpectedEvaluationOrder"].readIfPresent()
        value.actualEvaluationOrder = try reader["ActualEvaluationOrder"].readIfPresent()
        value.entryAtExpectedEvaluationOrder = try reader["EntryAtExpectedEvaluationOrder"].readIfPresent(with: FMSClientTypes.EntryDescription.read(from:))
        value.entriesWithConflicts = try reader["EntriesWithConflicts"].readListIfPresent(memberReadingClosure: FMSClientTypes.EntryDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.entryViolationReasons = try reader["EntryViolationReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<FMSClientTypes.EntryViolationReason>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FMSClientTypes.FirewallSubnetMissingVPCEndpointViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.FirewallSubnetMissingVPCEndpointViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.FirewallSubnetMissingVPCEndpointViolation()
        value.firewallSubnetId = try reader["FirewallSubnetId"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.subnetAvailabilityZone = try reader["SubnetAvailabilityZone"].readIfPresent()
        value.subnetAvailabilityZoneId = try reader["SubnetAvailabilityZoneId"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.ThirdPartyFirewallMissingExpectedRouteTableViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.ThirdPartyFirewallMissingExpectedRouteTableViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.ThirdPartyFirewallMissingExpectedRouteTableViolation()
        value.violationTarget = try reader["ViolationTarget"].readIfPresent()
        value.vpc = try reader["VPC"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.currentRouteTable = try reader["CurrentRouteTable"].readIfPresent()
        value.expectedRouteTable = try reader["ExpectedRouteTable"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.ThirdPartyFirewallMissingSubnetViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.ThirdPartyFirewallMissingSubnetViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.ThirdPartyFirewallMissingSubnetViolation()
        value.violationTarget = try reader["ViolationTarget"].readIfPresent()
        value.vpc = try reader["VPC"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.targetViolationReason = try reader["TargetViolationReason"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.ThirdPartyFirewallMissingFirewallViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.ThirdPartyFirewallMissingFirewallViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.ThirdPartyFirewallMissingFirewallViolation()
        value.violationTarget = try reader["ViolationTarget"].readIfPresent()
        value.vpc = try reader["VPC"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.targetViolationReason = try reader["TargetViolationReason"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.RouteHasOutOfScopeEndpointViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.RouteHasOutOfScopeEndpointViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.RouteHasOutOfScopeEndpointViolation()
        value.subnetId = try reader["SubnetId"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.routeTableId = try reader["RouteTableId"].readIfPresent()
        value.violatingRoutes = try reader["ViolatingRoutes"].readListIfPresent(memberReadingClosure: FMSClientTypes.Route.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnetAvailabilityZone = try reader["SubnetAvailabilityZone"].readIfPresent()
        value.subnetAvailabilityZoneId = try reader["SubnetAvailabilityZoneId"].readIfPresent()
        value.currentFirewallSubnetRouteTable = try reader["CurrentFirewallSubnetRouteTable"].readIfPresent()
        value.firewallSubnetId = try reader["FirewallSubnetId"].readIfPresent()
        value.firewallSubnetRoutes = try reader["FirewallSubnetRoutes"].readListIfPresent(memberReadingClosure: FMSClientTypes.Route.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.internetGatewayId = try reader["InternetGatewayId"].readIfPresent()
        value.currentInternetGatewayRouteTable = try reader["CurrentInternetGatewayRouteTable"].readIfPresent()
        value.internetGatewayRoutes = try reader["InternetGatewayRoutes"].readListIfPresent(memberReadingClosure: FMSClientTypes.Route.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FMSClientTypes.Route {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.Route {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.Route()
        value.destinationType = try reader["DestinationType"].readIfPresent()
        value.targetType = try reader["TargetType"].readIfPresent()
        value.destination = try reader["Destination"].readIfPresent()
        value.target = try reader["Target"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.FirewallSubnetIsOutOfScopeViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.FirewallSubnetIsOutOfScopeViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.FirewallSubnetIsOutOfScopeViolation()
        value.firewallSubnetId = try reader["FirewallSubnetId"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.subnetAvailabilityZone = try reader["SubnetAvailabilityZone"].readIfPresent()
        value.subnetAvailabilityZoneId = try reader["SubnetAvailabilityZoneId"].readIfPresent()
        value.vpcEndpointId = try reader["VpcEndpointId"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.DnsRuleGroupLimitExceededViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.DnsRuleGroupLimitExceededViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.DnsRuleGroupLimitExceededViolation()
        value.violationTarget = try reader["ViolationTarget"].readIfPresent()
        value.violationTargetDescription = try reader["ViolationTargetDescription"].readIfPresent()
        value.numberOfRuleGroupsAlreadyAssociated = try reader["NumberOfRuleGroupsAlreadyAssociated"].readIfPresent() ?? 0
        return value
    }
}

extension FMSClientTypes.DnsDuplicateRuleGroupViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.DnsDuplicateRuleGroupViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.DnsDuplicateRuleGroupViolation()
        value.violationTarget = try reader["ViolationTarget"].readIfPresent()
        value.violationTargetDescription = try reader["ViolationTargetDescription"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.DnsRuleGroupPriorityConflictViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.DnsRuleGroupPriorityConflictViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.DnsRuleGroupPriorityConflictViolation()
        value.violationTarget = try reader["ViolationTarget"].readIfPresent()
        value.violationTargetDescription = try reader["ViolationTargetDescription"].readIfPresent()
        value.conflictingPriority = try reader["ConflictingPriority"].readIfPresent() ?? 0
        value.conflictingPolicyId = try reader["ConflictingPolicyId"].readIfPresent()
        value.unavailablePriorities = try reader["UnavailablePriorities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FMSClientTypes.NetworkFirewallMissingExpectedRoutesViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.NetworkFirewallMissingExpectedRoutesViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.NetworkFirewallMissingExpectedRoutesViolation()
        value.violationTarget = try reader["ViolationTarget"].readIfPresent()
        value.expectedRoutes = try reader["ExpectedRoutes"].readListIfPresent(memberReadingClosure: FMSClientTypes.ExpectedRoute.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["VpcId"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.ExpectedRoute {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.ExpectedRoute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.ExpectedRoute()
        value.ipV4Cidr = try reader["IpV4Cidr"].readIfPresent()
        value.prefixListId = try reader["PrefixListId"].readIfPresent()
        value.ipV6Cidr = try reader["IpV6Cidr"].readIfPresent()
        value.contributingSubnets = try reader["ContributingSubnets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowedTargets = try reader["AllowedTargets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.routeTableId = try reader["RouteTableId"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.NetworkFirewallUnexpectedGatewayRoutesViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.NetworkFirewallUnexpectedGatewayRoutesViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.NetworkFirewallUnexpectedGatewayRoutesViolation()
        value.gatewayId = try reader["GatewayId"].readIfPresent()
        value.violatingRoutes = try reader["ViolatingRoutes"].readListIfPresent(memberReadingClosure: FMSClientTypes.Route.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.routeTableId = try reader["RouteTableId"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.NetworkFirewallUnexpectedFirewallRoutesViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.NetworkFirewallUnexpectedFirewallRoutesViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.NetworkFirewallUnexpectedFirewallRoutesViolation()
        value.firewallSubnetId = try reader["FirewallSubnetId"].readIfPresent()
        value.violatingRoutes = try reader["ViolatingRoutes"].readListIfPresent(memberReadingClosure: FMSClientTypes.Route.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.routeTableId = try reader["RouteTableId"].readIfPresent()
        value.firewallEndpoint = try reader["FirewallEndpoint"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.NetworkFirewallBlackHoleRouteDetectedViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.NetworkFirewallBlackHoleRouteDetectedViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.NetworkFirewallBlackHoleRouteDetectedViolation()
        value.violationTarget = try reader["ViolationTarget"].readIfPresent()
        value.routeTableId = try reader["RouteTableId"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.violatingRoutes = try reader["ViolatingRoutes"].readListIfPresent(memberReadingClosure: FMSClientTypes.Route.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FMSClientTypes.NetworkFirewallInvalidRouteConfigurationViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.NetworkFirewallInvalidRouteConfigurationViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.NetworkFirewallInvalidRouteConfigurationViolation()
        value.affectedSubnets = try reader["AffectedSubnets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.routeTableId = try reader["RouteTableId"].readIfPresent()
        value.isRouteTableUsedInDifferentAZ = try reader["IsRouteTableUsedInDifferentAZ"].readIfPresent() ?? false
        value.violatingRoute = try reader["ViolatingRoute"].readIfPresent(with: FMSClientTypes.Route.read(from:))
        value.currentFirewallSubnetRouteTable = try reader["CurrentFirewallSubnetRouteTable"].readIfPresent()
        value.expectedFirewallEndpoint = try reader["ExpectedFirewallEndpoint"].readIfPresent()
        value.actualFirewallEndpoint = try reader["ActualFirewallEndpoint"].readIfPresent()
        value.expectedFirewallSubnetId = try reader["ExpectedFirewallSubnetId"].readIfPresent()
        value.actualFirewallSubnetId = try reader["ActualFirewallSubnetId"].readIfPresent()
        value.expectedFirewallSubnetRoutes = try reader["ExpectedFirewallSubnetRoutes"].readListIfPresent(memberReadingClosure: FMSClientTypes.ExpectedRoute.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.actualFirewallSubnetRoutes = try reader["ActualFirewallSubnetRoutes"].readListIfPresent(memberReadingClosure: FMSClientTypes.Route.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.internetGatewayId = try reader["InternetGatewayId"].readIfPresent()
        value.currentInternetGatewayRouteTable = try reader["CurrentInternetGatewayRouteTable"].readIfPresent()
        value.expectedInternetGatewayRoutes = try reader["ExpectedInternetGatewayRoutes"].readListIfPresent(memberReadingClosure: FMSClientTypes.ExpectedRoute.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.actualInternetGatewayRoutes = try reader["ActualInternetGatewayRoutes"].readListIfPresent(memberReadingClosure: FMSClientTypes.Route.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["VpcId"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.NetworkFirewallInternetTrafficNotInspectedViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.NetworkFirewallInternetTrafficNotInspectedViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.NetworkFirewallInternetTrafficNotInspectedViolation()
        value.subnetId = try reader["SubnetId"].readIfPresent()
        value.subnetAvailabilityZone = try reader["SubnetAvailabilityZone"].readIfPresent()
        value.routeTableId = try reader["RouteTableId"].readIfPresent()
        value.violatingRoutes = try reader["ViolatingRoutes"].readListIfPresent(memberReadingClosure: FMSClientTypes.Route.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.isRouteTableUsedInDifferentAZ = try reader["IsRouteTableUsedInDifferentAZ"].readIfPresent() ?? false
        value.currentFirewallSubnetRouteTable = try reader["CurrentFirewallSubnetRouteTable"].readIfPresent()
        value.expectedFirewallEndpoint = try reader["ExpectedFirewallEndpoint"].readIfPresent()
        value.firewallSubnetId = try reader["FirewallSubnetId"].readIfPresent()
        value.expectedFirewallSubnetRoutes = try reader["ExpectedFirewallSubnetRoutes"].readListIfPresent(memberReadingClosure: FMSClientTypes.ExpectedRoute.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.actualFirewallSubnetRoutes = try reader["ActualFirewallSubnetRoutes"].readListIfPresent(memberReadingClosure: FMSClientTypes.Route.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.internetGatewayId = try reader["InternetGatewayId"].readIfPresent()
        value.currentInternetGatewayRouteTable = try reader["CurrentInternetGatewayRouteTable"].readIfPresent()
        value.expectedInternetGatewayRoutes = try reader["ExpectedInternetGatewayRoutes"].readListIfPresent(memberReadingClosure: FMSClientTypes.ExpectedRoute.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.actualInternetGatewayRoutes = try reader["ActualInternetGatewayRoutes"].readListIfPresent(memberReadingClosure: FMSClientTypes.Route.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["VpcId"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.NetworkFirewallPolicyModifiedViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.NetworkFirewallPolicyModifiedViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.NetworkFirewallPolicyModifiedViolation()
        value.violationTarget = try reader["ViolationTarget"].readIfPresent()
        value.currentPolicyDescription = try reader["CurrentPolicyDescription"].readIfPresent(with: FMSClientTypes.NetworkFirewallPolicyDescription.read(from:))
        value.expectedPolicyDescription = try reader["ExpectedPolicyDescription"].readIfPresent(with: FMSClientTypes.NetworkFirewallPolicyDescription.read(from:))
        return value
    }
}

extension FMSClientTypes.NetworkFirewallPolicyDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.NetworkFirewallPolicyDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.NetworkFirewallPolicyDescription()
        value.statelessRuleGroups = try reader["StatelessRuleGroups"].readListIfPresent(memberReadingClosure: FMSClientTypes.StatelessRuleGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.statelessDefaultActions = try reader["StatelessDefaultActions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.statelessFragmentDefaultActions = try reader["StatelessFragmentDefaultActions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.statelessCustomActions = try reader["StatelessCustomActions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.statefulRuleGroups = try reader["StatefulRuleGroups"].readListIfPresent(memberReadingClosure: FMSClientTypes.StatefulRuleGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.statefulDefaultActions = try reader["StatefulDefaultActions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.statefulEngineOptions = try reader["StatefulEngineOptions"].readIfPresent(with: FMSClientTypes.StatefulEngineOptions.read(from:))
        return value
    }
}

extension FMSClientTypes.StatefulEngineOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.StatefulEngineOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.StatefulEngineOptions()
        value.ruleOrder = try reader["RuleOrder"].readIfPresent()
        value.streamExceptionPolicy = try reader["StreamExceptionPolicy"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.StatefulRuleGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.StatefulRuleGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.StatefulRuleGroup()
        value.ruleGroupName = try reader["RuleGroupName"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.priority = try reader["Priority"].readIfPresent()
        value.`override` = try reader["Override"].readIfPresent(with: FMSClientTypes.NetworkFirewallStatefulRuleGroupOverride.read(from:))
        return value
    }
}

extension FMSClientTypes.NetworkFirewallStatefulRuleGroupOverride {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.NetworkFirewallStatefulRuleGroupOverride {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.NetworkFirewallStatefulRuleGroupOverride()
        value.action = try reader["Action"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.StatelessRuleGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.StatelessRuleGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.StatelessRuleGroup()
        value.ruleGroupName = try reader["RuleGroupName"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.priority = try reader["Priority"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.NetworkFirewallMissingExpectedRTViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.NetworkFirewallMissingExpectedRTViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.NetworkFirewallMissingExpectedRTViolation()
        value.violationTarget = try reader["ViolationTarget"].readIfPresent()
        value.vpc = try reader["VPC"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.currentRouteTable = try reader["CurrentRouteTable"].readIfPresent()
        value.expectedRouteTable = try reader["ExpectedRouteTable"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.NetworkFirewallMissingSubnetViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.NetworkFirewallMissingSubnetViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.NetworkFirewallMissingSubnetViolation()
        value.violationTarget = try reader["ViolationTarget"].readIfPresent()
        value.vpc = try reader["VPC"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.targetViolationReason = try reader["TargetViolationReason"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.NetworkFirewallMissingFirewallViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.NetworkFirewallMissingFirewallViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.NetworkFirewallMissingFirewallViolation()
        value.violationTarget = try reader["ViolationTarget"].readIfPresent()
        value.vpc = try reader["VPC"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.targetViolationReason = try reader["TargetViolationReason"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.AwsEc2InstanceViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.AwsEc2InstanceViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.AwsEc2InstanceViolation()
        value.violationTarget = try reader["ViolationTarget"].readIfPresent()
        value.awsEc2NetworkInterfaceViolations = try reader["AwsEc2NetworkInterfaceViolations"].readListIfPresent(memberReadingClosure: FMSClientTypes.AwsEc2NetworkInterfaceViolation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FMSClientTypes.AwsEc2NetworkInterfaceViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.AwsEc2NetworkInterfaceViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.AwsEc2NetworkInterfaceViolation()
        value.violationTarget = try reader["ViolationTarget"].readIfPresent()
        value.violatingSecurityGroups = try reader["ViolatingSecurityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FMSClientTypes.AwsVPCSecurityGroupViolation {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.AwsVPCSecurityGroupViolation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.AwsVPCSecurityGroupViolation()
        value.violationTarget = try reader["ViolationTarget"].readIfPresent()
        value.violationTargetDescription = try reader["ViolationTargetDescription"].readIfPresent()
        value.partialMatches = try reader["PartialMatches"].readListIfPresent(memberReadingClosure: FMSClientTypes.PartialMatch.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.possibleSecurityGroupRemediationActions = try reader["PossibleSecurityGroupRemediationActions"].readListIfPresent(memberReadingClosure: FMSClientTypes.SecurityGroupRemediationAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FMSClientTypes.SecurityGroupRemediationAction {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.SecurityGroupRemediationAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.SecurityGroupRemediationAction()
        value.remediationActionType = try reader["RemediationActionType"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.remediationResult = try reader["RemediationResult"].readIfPresent(with: FMSClientTypes.SecurityGroupRuleDescription.read(from:))
        value.isDefaultAction = try reader["IsDefaultAction"].readIfPresent() ?? false
        return value
    }
}

extension FMSClientTypes.SecurityGroupRuleDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.SecurityGroupRuleDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.SecurityGroupRuleDescription()
        value.ipv4Range = try reader["IPV4Range"].readIfPresent()
        value.ipv6Range = try reader["IPV6Range"].readIfPresent()
        value.prefixListId = try reader["PrefixListId"].readIfPresent()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.fromPort = try reader["FromPort"].readIfPresent()
        value.toPort = try reader["ToPort"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.PartialMatch {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.PartialMatch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.PartialMatch()
        value.reference = try reader["Reference"].readIfPresent()
        value.targetViolationReasons = try reader["TargetViolationReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FMSClientTypes.AdminAccountSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.AdminAccountSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.AdminAccountSummary()
        value.adminAccount = try reader["AdminAccount"].readIfPresent()
        value.defaultAdmin = try reader["DefaultAdmin"].readIfPresent() ?? false
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.AppsListDataSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.AppsListDataSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.AppsListDataSummary()
        value.listArn = try reader["ListArn"].readIfPresent()
        value.listId = try reader["ListId"].readIfPresent()
        value.listName = try reader["ListName"].readIfPresent()
        value.appsList = try reader["AppsList"].readListIfPresent(memberReadingClosure: FMSClientTypes.App.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FMSClientTypes.PolicyComplianceStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.PolicyComplianceStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.PolicyComplianceStatus()
        value.policyOwner = try reader["PolicyOwner"].readIfPresent()
        value.policyId = try reader["PolicyId"].readIfPresent()
        value.policyName = try reader["PolicyName"].readIfPresent()
        value.memberAccount = try reader["MemberAccount"].readIfPresent()
        value.evaluationResults = try reader["EvaluationResults"].readListIfPresent(memberReadingClosure: FMSClientTypes.EvaluationResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastUpdated = try reader["LastUpdated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.issueInfoMap = try reader["IssueInfoMap"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FMSClientTypes.EvaluationResult {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.EvaluationResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.EvaluationResult()
        value.complianceStatus = try reader["ComplianceStatus"].readIfPresent()
        value.violatorCount = try reader["ViolatorCount"].readIfPresent() ?? 0
        value.evaluationLimitExceeded = try reader["EvaluationLimitExceeded"].readIfPresent() ?? false
        return value
    }
}

extension FMSClientTypes.DiscoveredResource {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.DiscoveredResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.DiscoveredResource()
        value.uri = try reader["URI"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.PolicySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.PolicySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.PolicySummary()
        value.policyArn = try reader["PolicyArn"].readIfPresent()
        value.policyId = try reader["PolicyId"].readIfPresent()
        value.policyName = try reader["PolicyName"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.securityServiceType = try reader["SecurityServiceType"].readIfPresent()
        value.remediationEnabled = try reader["RemediationEnabled"].readIfPresent() ?? false
        value.deleteUnusedFMManagedResources = try reader["DeleteUnusedFMManagedResources"].readIfPresent() ?? false
        value.policyStatus = try reader["PolicyStatus"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.ProtocolsListDataSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.ProtocolsListDataSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.ProtocolsListDataSummary()
        value.listArn = try reader["ListArn"].readIfPresent()
        value.listId = try reader["ListId"].readIfPresent()
        value.listName = try reader["ListName"].readIfPresent()
        value.protocolsList = try reader["ProtocolsList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FMSClientTypes.Resource {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.Resource()
        value.uri = try reader["URI"].readIfPresent() ?? ""
        value.accountId = try reader["AccountId"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.ResourceSetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.ResourceSetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.ResourceSetSummary()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.lastUpdateTime = try reader["LastUpdateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resourceSetStatus = try reader["ResourceSetStatus"].readIfPresent()
        return value
    }
}

extension FMSClientTypes.ThirdPartyFirewallFirewallPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> FMSClientTypes.ThirdPartyFirewallFirewallPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FMSClientTypes.ThirdPartyFirewallFirewallPolicy()
        value.firewallPolicyId = try reader["FirewallPolicyId"].readIfPresent()
        value.firewallPolicyName = try reader["FirewallPolicyName"].readIfPresent()
        return value
    }
}

public enum FMSClientTypes {}
