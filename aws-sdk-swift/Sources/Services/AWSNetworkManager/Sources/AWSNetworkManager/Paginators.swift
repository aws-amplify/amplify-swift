//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension NetworkManagerClient {
    /// Paginate over `[DescribeGlobalNetworksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeGlobalNetworksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeGlobalNetworksOutput`
    public func describeGlobalNetworksPaginated(input: DescribeGlobalNetworksInput) -> ClientRuntime.PaginatorSequence<DescribeGlobalNetworksInput, DescribeGlobalNetworksOutput> {
        return ClientRuntime.PaginatorSequence<DescribeGlobalNetworksInput, DescribeGlobalNetworksOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeGlobalNetworks(input:))
    }
}

extension DescribeGlobalNetworksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeGlobalNetworksInput {
        return DescribeGlobalNetworksInput(
            globalNetworkIds: self.globalNetworkIds,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeGlobalNetworksInput, OperationStackOutput == DescribeGlobalNetworksOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeGlobalNetworksPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.GlobalNetwork]`
    /// - Returns: `[NetworkManagerClientTypes.GlobalNetwork]`
    public func globalNetworks() async throws -> [NetworkManagerClientTypes.GlobalNetwork] {
        return try await self.asyncCompactMap { item in item.globalNetworks }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[GetConnectionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetConnectionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetConnectionsOutput`
    public func getConnectionsPaginated(input: GetConnectionsInput) -> ClientRuntime.PaginatorSequence<GetConnectionsInput, GetConnectionsOutput> {
        return ClientRuntime.PaginatorSequence<GetConnectionsInput, GetConnectionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getConnections(input:))
    }
}

extension GetConnectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetConnectionsInput {
        return GetConnectionsInput(
            connectionIds: self.connectionIds,
            deviceId: self.deviceId,
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == GetConnectionsInput, OperationStackOutput == GetConnectionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getConnectionsPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.Connection]`
    /// - Returns: `[NetworkManagerClientTypes.Connection]`
    public func connections() async throws -> [NetworkManagerClientTypes.Connection] {
        return try await self.asyncCompactMap { item in item.connections }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[GetConnectPeerAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetConnectPeerAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetConnectPeerAssociationsOutput`
    public func getConnectPeerAssociationsPaginated(input: GetConnectPeerAssociationsInput) -> ClientRuntime.PaginatorSequence<GetConnectPeerAssociationsInput, GetConnectPeerAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<GetConnectPeerAssociationsInput, GetConnectPeerAssociationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getConnectPeerAssociations(input:))
    }
}

extension GetConnectPeerAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetConnectPeerAssociationsInput {
        return GetConnectPeerAssociationsInput(
            connectPeerIds: self.connectPeerIds,
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == GetConnectPeerAssociationsInput, OperationStackOutput == GetConnectPeerAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getConnectPeerAssociationsPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.ConnectPeerAssociation]`
    /// - Returns: `[NetworkManagerClientTypes.ConnectPeerAssociation]`
    public func connectPeerAssociations() async throws -> [NetworkManagerClientTypes.ConnectPeerAssociation] {
        return try await self.asyncCompactMap { item in item.connectPeerAssociations }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[GetCoreNetworkChangeEventsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetCoreNetworkChangeEventsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetCoreNetworkChangeEventsOutput`
    public func getCoreNetworkChangeEventsPaginated(input: GetCoreNetworkChangeEventsInput) -> ClientRuntime.PaginatorSequence<GetCoreNetworkChangeEventsInput, GetCoreNetworkChangeEventsOutput> {
        return ClientRuntime.PaginatorSequence<GetCoreNetworkChangeEventsInput, GetCoreNetworkChangeEventsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getCoreNetworkChangeEvents(input:))
    }
}

extension GetCoreNetworkChangeEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetCoreNetworkChangeEventsInput {
        return GetCoreNetworkChangeEventsInput(
            coreNetworkId: self.coreNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            policyVersionId: self.policyVersionId
        )}
}

extension PaginatorSequence where OperationStackInput == GetCoreNetworkChangeEventsInput, OperationStackOutput == GetCoreNetworkChangeEventsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getCoreNetworkChangeEventsPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.CoreNetworkChangeEvent]`
    /// - Returns: `[NetworkManagerClientTypes.CoreNetworkChangeEvent]`
    public func coreNetworkChangeEvents() async throws -> [NetworkManagerClientTypes.CoreNetworkChangeEvent] {
        return try await self.asyncCompactMap { item in item.coreNetworkChangeEvents }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[GetCoreNetworkChangeSetOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetCoreNetworkChangeSetInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetCoreNetworkChangeSetOutput`
    public func getCoreNetworkChangeSetPaginated(input: GetCoreNetworkChangeSetInput) -> ClientRuntime.PaginatorSequence<GetCoreNetworkChangeSetInput, GetCoreNetworkChangeSetOutput> {
        return ClientRuntime.PaginatorSequence<GetCoreNetworkChangeSetInput, GetCoreNetworkChangeSetOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getCoreNetworkChangeSet(input:))
    }
}

extension GetCoreNetworkChangeSetInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetCoreNetworkChangeSetInput {
        return GetCoreNetworkChangeSetInput(
            coreNetworkId: self.coreNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            policyVersionId: self.policyVersionId
        )}
}

extension PaginatorSequence where OperationStackInput == GetCoreNetworkChangeSetInput, OperationStackOutput == GetCoreNetworkChangeSetOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getCoreNetworkChangeSetPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.CoreNetworkChange]`
    /// - Returns: `[NetworkManagerClientTypes.CoreNetworkChange]`
    public func coreNetworkChanges() async throws -> [NetworkManagerClientTypes.CoreNetworkChange] {
        return try await self.asyncCompactMap { item in item.coreNetworkChanges }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[GetCustomerGatewayAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetCustomerGatewayAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetCustomerGatewayAssociationsOutput`
    public func getCustomerGatewayAssociationsPaginated(input: GetCustomerGatewayAssociationsInput) -> ClientRuntime.PaginatorSequence<GetCustomerGatewayAssociationsInput, GetCustomerGatewayAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<GetCustomerGatewayAssociationsInput, GetCustomerGatewayAssociationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getCustomerGatewayAssociations(input:))
    }
}

extension GetCustomerGatewayAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetCustomerGatewayAssociationsInput {
        return GetCustomerGatewayAssociationsInput(
            customerGatewayArns: self.customerGatewayArns,
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == GetCustomerGatewayAssociationsInput, OperationStackOutput == GetCustomerGatewayAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getCustomerGatewayAssociationsPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.CustomerGatewayAssociation]`
    /// - Returns: `[NetworkManagerClientTypes.CustomerGatewayAssociation]`
    public func customerGatewayAssociations() async throws -> [NetworkManagerClientTypes.CustomerGatewayAssociation] {
        return try await self.asyncCompactMap { item in item.customerGatewayAssociations }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[GetDevicesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetDevicesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetDevicesOutput`
    public func getDevicesPaginated(input: GetDevicesInput) -> ClientRuntime.PaginatorSequence<GetDevicesInput, GetDevicesOutput> {
        return ClientRuntime.PaginatorSequence<GetDevicesInput, GetDevicesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getDevices(input:))
    }
}

extension GetDevicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetDevicesInput {
        return GetDevicesInput(
            deviceIds: self.deviceIds,
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            siteId: self.siteId
        )}
}

extension PaginatorSequence where OperationStackInput == GetDevicesInput, OperationStackOutput == GetDevicesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getDevicesPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.Device]`
    /// - Returns: `[NetworkManagerClientTypes.Device]`
    public func devices() async throws -> [NetworkManagerClientTypes.Device] {
        return try await self.asyncCompactMap { item in item.devices }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[GetLinkAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetLinkAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetLinkAssociationsOutput`
    public func getLinkAssociationsPaginated(input: GetLinkAssociationsInput) -> ClientRuntime.PaginatorSequence<GetLinkAssociationsInput, GetLinkAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<GetLinkAssociationsInput, GetLinkAssociationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getLinkAssociations(input:))
    }
}

extension GetLinkAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetLinkAssociationsInput {
        return GetLinkAssociationsInput(
            deviceId: self.deviceId,
            globalNetworkId: self.globalNetworkId,
            linkId: self.linkId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == GetLinkAssociationsInput, OperationStackOutput == GetLinkAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getLinkAssociationsPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.LinkAssociation]`
    /// - Returns: `[NetworkManagerClientTypes.LinkAssociation]`
    public func linkAssociations() async throws -> [NetworkManagerClientTypes.LinkAssociation] {
        return try await self.asyncCompactMap { item in item.linkAssociations }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[GetLinksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetLinksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetLinksOutput`
    public func getLinksPaginated(input: GetLinksInput) -> ClientRuntime.PaginatorSequence<GetLinksInput, GetLinksOutput> {
        return ClientRuntime.PaginatorSequence<GetLinksInput, GetLinksOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getLinks(input:))
    }
}

extension GetLinksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetLinksInput {
        return GetLinksInput(
            globalNetworkId: self.globalNetworkId,
            linkIds: self.linkIds,
            maxResults: self.maxResults,
            nextToken: token,
            provider: self.provider,
            siteId: self.siteId,
            type: self.type
        )}
}

extension PaginatorSequence where OperationStackInput == GetLinksInput, OperationStackOutput == GetLinksOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getLinksPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.Link]`
    /// - Returns: `[NetworkManagerClientTypes.Link]`
    public func links() async throws -> [NetworkManagerClientTypes.Link] {
        return try await self.asyncCompactMap { item in item.links }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[GetNetworkResourceCountsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetNetworkResourceCountsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetNetworkResourceCountsOutput`
    public func getNetworkResourceCountsPaginated(input: GetNetworkResourceCountsInput) -> ClientRuntime.PaginatorSequence<GetNetworkResourceCountsInput, GetNetworkResourceCountsOutput> {
        return ClientRuntime.PaginatorSequence<GetNetworkResourceCountsInput, GetNetworkResourceCountsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getNetworkResourceCounts(input:))
    }
}

extension GetNetworkResourceCountsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetNetworkResourceCountsInput {
        return GetNetworkResourceCountsInput(
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            resourceType: self.resourceType
        )}
}

extension PaginatorSequence where OperationStackInput == GetNetworkResourceCountsInput, OperationStackOutput == GetNetworkResourceCountsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getNetworkResourceCountsPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.NetworkResourceCount]`
    /// - Returns: `[NetworkManagerClientTypes.NetworkResourceCount]`
    public func networkResourceCounts() async throws -> [NetworkManagerClientTypes.NetworkResourceCount] {
        return try await self.asyncCompactMap { item in item.networkResourceCounts }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[GetNetworkResourceRelationshipsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetNetworkResourceRelationshipsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetNetworkResourceRelationshipsOutput`
    public func getNetworkResourceRelationshipsPaginated(input: GetNetworkResourceRelationshipsInput) -> ClientRuntime.PaginatorSequence<GetNetworkResourceRelationshipsInput, GetNetworkResourceRelationshipsOutput> {
        return ClientRuntime.PaginatorSequence<GetNetworkResourceRelationshipsInput, GetNetworkResourceRelationshipsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getNetworkResourceRelationships(input:))
    }
}

extension GetNetworkResourceRelationshipsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetNetworkResourceRelationshipsInput {
        return GetNetworkResourceRelationshipsInput(
            accountId: self.accountId,
            awsRegion: self.awsRegion,
            coreNetworkId: self.coreNetworkId,
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            registeredGatewayArn: self.registeredGatewayArn,
            resourceArn: self.resourceArn,
            resourceType: self.resourceType
        )}
}

extension PaginatorSequence where OperationStackInput == GetNetworkResourceRelationshipsInput, OperationStackOutput == GetNetworkResourceRelationshipsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getNetworkResourceRelationshipsPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.Relationship]`
    /// - Returns: `[NetworkManagerClientTypes.Relationship]`
    public func relationships() async throws -> [NetworkManagerClientTypes.Relationship] {
        return try await self.asyncCompactMap { item in item.relationships }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[GetNetworkResourcesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetNetworkResourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetNetworkResourcesOutput`
    public func getNetworkResourcesPaginated(input: GetNetworkResourcesInput) -> ClientRuntime.PaginatorSequence<GetNetworkResourcesInput, GetNetworkResourcesOutput> {
        return ClientRuntime.PaginatorSequence<GetNetworkResourcesInput, GetNetworkResourcesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getNetworkResources(input:))
    }
}

extension GetNetworkResourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetNetworkResourcesInput {
        return GetNetworkResourcesInput(
            accountId: self.accountId,
            awsRegion: self.awsRegion,
            coreNetworkId: self.coreNetworkId,
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            registeredGatewayArn: self.registeredGatewayArn,
            resourceArn: self.resourceArn,
            resourceType: self.resourceType
        )}
}

extension PaginatorSequence where OperationStackInput == GetNetworkResourcesInput, OperationStackOutput == GetNetworkResourcesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getNetworkResourcesPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.NetworkResource]`
    /// - Returns: `[NetworkManagerClientTypes.NetworkResource]`
    public func networkResources() async throws -> [NetworkManagerClientTypes.NetworkResource] {
        return try await self.asyncCompactMap { item in item.networkResources }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[GetNetworkTelemetryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetNetworkTelemetryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetNetworkTelemetryOutput`
    public func getNetworkTelemetryPaginated(input: GetNetworkTelemetryInput) -> ClientRuntime.PaginatorSequence<GetNetworkTelemetryInput, GetNetworkTelemetryOutput> {
        return ClientRuntime.PaginatorSequence<GetNetworkTelemetryInput, GetNetworkTelemetryOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getNetworkTelemetry(input:))
    }
}

extension GetNetworkTelemetryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetNetworkTelemetryInput {
        return GetNetworkTelemetryInput(
            accountId: self.accountId,
            awsRegion: self.awsRegion,
            coreNetworkId: self.coreNetworkId,
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            registeredGatewayArn: self.registeredGatewayArn,
            resourceArn: self.resourceArn,
            resourceType: self.resourceType
        )}
}

extension PaginatorSequence where OperationStackInput == GetNetworkTelemetryInput, OperationStackOutput == GetNetworkTelemetryOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getNetworkTelemetryPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.NetworkTelemetry]`
    /// - Returns: `[NetworkManagerClientTypes.NetworkTelemetry]`
    public func networkTelemetry() async throws -> [NetworkManagerClientTypes.NetworkTelemetry] {
        return try await self.asyncCompactMap { item in item.networkTelemetry }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[GetSitesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetSitesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetSitesOutput`
    public func getSitesPaginated(input: GetSitesInput) -> ClientRuntime.PaginatorSequence<GetSitesInput, GetSitesOutput> {
        return ClientRuntime.PaginatorSequence<GetSitesInput, GetSitesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getSites(input:))
    }
}

extension GetSitesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetSitesInput {
        return GetSitesInput(
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            siteIds: self.siteIds
        )}
}

extension PaginatorSequence where OperationStackInput == GetSitesInput, OperationStackOutput == GetSitesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getSitesPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.Site]`
    /// - Returns: `[NetworkManagerClientTypes.Site]`
    public func sites() async throws -> [NetworkManagerClientTypes.Site] {
        return try await self.asyncCompactMap { item in item.sites }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[GetTransitGatewayConnectPeerAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetTransitGatewayConnectPeerAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetTransitGatewayConnectPeerAssociationsOutput`
    public func getTransitGatewayConnectPeerAssociationsPaginated(input: GetTransitGatewayConnectPeerAssociationsInput) -> ClientRuntime.PaginatorSequence<GetTransitGatewayConnectPeerAssociationsInput, GetTransitGatewayConnectPeerAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<GetTransitGatewayConnectPeerAssociationsInput, GetTransitGatewayConnectPeerAssociationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getTransitGatewayConnectPeerAssociations(input:))
    }
}

extension GetTransitGatewayConnectPeerAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTransitGatewayConnectPeerAssociationsInput {
        return GetTransitGatewayConnectPeerAssociationsInput(
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayConnectPeerArns: self.transitGatewayConnectPeerArns
        )}
}

extension PaginatorSequence where OperationStackInput == GetTransitGatewayConnectPeerAssociationsInput, OperationStackOutput == GetTransitGatewayConnectPeerAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getTransitGatewayConnectPeerAssociationsPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]`
    /// - Returns: `[NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation]`
    public func transitGatewayConnectPeerAssociations() async throws -> [NetworkManagerClientTypes.TransitGatewayConnectPeerAssociation] {
        return try await self.asyncCompactMap { item in item.transitGatewayConnectPeerAssociations }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[GetTransitGatewayRegistrationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetTransitGatewayRegistrationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetTransitGatewayRegistrationsOutput`
    public func getTransitGatewayRegistrationsPaginated(input: GetTransitGatewayRegistrationsInput) -> ClientRuntime.PaginatorSequence<GetTransitGatewayRegistrationsInput, GetTransitGatewayRegistrationsOutput> {
        return ClientRuntime.PaginatorSequence<GetTransitGatewayRegistrationsInput, GetTransitGatewayRegistrationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getTransitGatewayRegistrations(input:))
    }
}

extension GetTransitGatewayRegistrationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTransitGatewayRegistrationsInput {
        return GetTransitGatewayRegistrationsInput(
            globalNetworkId: self.globalNetworkId,
            maxResults: self.maxResults,
            nextToken: token,
            transitGatewayArns: self.transitGatewayArns
        )}
}

extension PaginatorSequence where OperationStackInput == GetTransitGatewayRegistrationsInput, OperationStackOutput == GetTransitGatewayRegistrationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getTransitGatewayRegistrationsPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.TransitGatewayRegistration]`
    /// - Returns: `[NetworkManagerClientTypes.TransitGatewayRegistration]`
    public func transitGatewayRegistrations() async throws -> [NetworkManagerClientTypes.TransitGatewayRegistration] {
        return try await self.asyncCompactMap { item in item.transitGatewayRegistrations }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[ListAttachmentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAttachmentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAttachmentsOutput`
    public func listAttachmentsPaginated(input: ListAttachmentsInput) -> ClientRuntime.PaginatorSequence<ListAttachmentsInput, ListAttachmentsOutput> {
        return ClientRuntime.PaginatorSequence<ListAttachmentsInput, ListAttachmentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAttachments(input:))
    }
}

extension ListAttachmentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAttachmentsInput {
        return ListAttachmentsInput(
            attachmentType: self.attachmentType,
            coreNetworkId: self.coreNetworkId,
            edgeLocation: self.edgeLocation,
            maxResults: self.maxResults,
            nextToken: token,
            state: self.state
        )}
}

extension PaginatorSequence where OperationStackInput == ListAttachmentsInput, OperationStackOutput == ListAttachmentsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAttachmentsPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.Attachment]`
    /// - Returns: `[NetworkManagerClientTypes.Attachment]`
    public func attachments() async throws -> [NetworkManagerClientTypes.Attachment] {
        return try await self.asyncCompactMap { item in item.attachments }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[ListConnectPeersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListConnectPeersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListConnectPeersOutput`
    public func listConnectPeersPaginated(input: ListConnectPeersInput) -> ClientRuntime.PaginatorSequence<ListConnectPeersInput, ListConnectPeersOutput> {
        return ClientRuntime.PaginatorSequence<ListConnectPeersInput, ListConnectPeersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listConnectPeers(input:))
    }
}

extension ListConnectPeersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListConnectPeersInput {
        return ListConnectPeersInput(
            connectAttachmentId: self.connectAttachmentId,
            coreNetworkId: self.coreNetworkId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListConnectPeersInput, OperationStackOutput == ListConnectPeersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listConnectPeersPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.ConnectPeerSummary]`
    /// - Returns: `[NetworkManagerClientTypes.ConnectPeerSummary]`
    public func connectPeers() async throws -> [NetworkManagerClientTypes.ConnectPeerSummary] {
        return try await self.asyncCompactMap { item in item.connectPeers }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[ListCoreNetworkPolicyVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCoreNetworkPolicyVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCoreNetworkPolicyVersionsOutput`
    public func listCoreNetworkPolicyVersionsPaginated(input: ListCoreNetworkPolicyVersionsInput) -> ClientRuntime.PaginatorSequence<ListCoreNetworkPolicyVersionsInput, ListCoreNetworkPolicyVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListCoreNetworkPolicyVersionsInput, ListCoreNetworkPolicyVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCoreNetworkPolicyVersions(input:))
    }
}

extension ListCoreNetworkPolicyVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCoreNetworkPolicyVersionsInput {
        return ListCoreNetworkPolicyVersionsInput(
            coreNetworkId: self.coreNetworkId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListCoreNetworkPolicyVersionsInput, OperationStackOutput == ListCoreNetworkPolicyVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCoreNetworkPolicyVersionsPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.CoreNetworkPolicyVersion]`
    /// - Returns: `[NetworkManagerClientTypes.CoreNetworkPolicyVersion]`
    public func coreNetworkPolicyVersions() async throws -> [NetworkManagerClientTypes.CoreNetworkPolicyVersion] {
        return try await self.asyncCompactMap { item in item.coreNetworkPolicyVersions }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[ListCoreNetworksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCoreNetworksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCoreNetworksOutput`
    public func listCoreNetworksPaginated(input: ListCoreNetworksInput) -> ClientRuntime.PaginatorSequence<ListCoreNetworksInput, ListCoreNetworksOutput> {
        return ClientRuntime.PaginatorSequence<ListCoreNetworksInput, ListCoreNetworksOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCoreNetworks(input:))
    }
}

extension ListCoreNetworksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCoreNetworksInput {
        return ListCoreNetworksInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListCoreNetworksInput, OperationStackOutput == ListCoreNetworksOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCoreNetworksPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.CoreNetworkSummary]`
    /// - Returns: `[NetworkManagerClientTypes.CoreNetworkSummary]`
    public func coreNetworks() async throws -> [NetworkManagerClientTypes.CoreNetworkSummary] {
        return try await self.asyncCompactMap { item in item.coreNetworks }
    }
}
extension NetworkManagerClient {
    /// Paginate over `[ListPeeringsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPeeringsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPeeringsOutput`
    public func listPeeringsPaginated(input: ListPeeringsInput) -> ClientRuntime.PaginatorSequence<ListPeeringsInput, ListPeeringsOutput> {
        return ClientRuntime.PaginatorSequence<ListPeeringsInput, ListPeeringsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPeerings(input:))
    }
}

extension ListPeeringsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPeeringsInput {
        return ListPeeringsInput(
            coreNetworkId: self.coreNetworkId,
            edgeLocation: self.edgeLocation,
            maxResults: self.maxResults,
            nextToken: token,
            peeringType: self.peeringType,
            state: self.state
        )}
}

extension PaginatorSequence where OperationStackInput == ListPeeringsInput, OperationStackOutput == ListPeeringsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPeeringsPaginated`
    /// to access the nested member `[NetworkManagerClientTypes.Peering]`
    /// - Returns: `[NetworkManagerClientTypes.Peering]`
    public func peerings() async throws -> [NetworkManagerClientTypes.Peering] {
        return try await self.asyncCompactMap { item in item.peerings }
    }
}
