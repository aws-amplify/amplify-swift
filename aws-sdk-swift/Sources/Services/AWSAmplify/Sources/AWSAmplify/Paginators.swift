//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension AmplifyClient {
    /// Paginate over `[ListAppsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAppsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAppsOutput`
    public func listAppsPaginated(input: ListAppsInput) -> ClientRuntime.PaginatorSequence<ListAppsInput, ListAppsOutput> {
        return ClientRuntime.PaginatorSequence<ListAppsInput, ListAppsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listApps(input:))
    }
}

extension ListAppsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAppsInput {
        return ListAppsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAppsInput, OperationStackOutput == ListAppsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAppsPaginated`
    /// to access the nested member `[AmplifyClientTypes.App]`
    /// - Returns: `[AmplifyClientTypes.App]`
    public func apps() async throws -> [AmplifyClientTypes.App] {
        return try await self.asyncCompactMap { item in item.apps }
    }
}
extension AmplifyClient {
    /// Paginate over `[ListBranchesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBranchesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBranchesOutput`
    public func listBranchesPaginated(input: ListBranchesInput) -> ClientRuntime.PaginatorSequence<ListBranchesInput, ListBranchesOutput> {
        return ClientRuntime.PaginatorSequence<ListBranchesInput, ListBranchesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBranches(input:))
    }
}

extension ListBranchesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBranchesInput {
        return ListBranchesInput(
            appId: self.appId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListBranchesInput, OperationStackOutput == ListBranchesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listBranchesPaginated`
    /// to access the nested member `[AmplifyClientTypes.Branch]`
    /// - Returns: `[AmplifyClientTypes.Branch]`
    public func branches() async throws -> [AmplifyClientTypes.Branch] {
        return try await self.asyncCompactMap { item in item.branches }
    }
}
extension AmplifyClient {
    /// Paginate over `[ListDomainAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDomainAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDomainAssociationsOutput`
    public func listDomainAssociationsPaginated(input: ListDomainAssociationsInput) -> ClientRuntime.PaginatorSequence<ListDomainAssociationsInput, ListDomainAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<ListDomainAssociationsInput, ListDomainAssociationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDomainAssociations(input:))
    }
}

extension ListDomainAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDomainAssociationsInput {
        return ListDomainAssociationsInput(
            appId: self.appId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDomainAssociationsInput, OperationStackOutput == ListDomainAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDomainAssociationsPaginated`
    /// to access the nested member `[AmplifyClientTypes.DomainAssociation]`
    /// - Returns: `[AmplifyClientTypes.DomainAssociation]`
    public func domainAssociations() async throws -> [AmplifyClientTypes.DomainAssociation] {
        return try await self.asyncCompactMap { item in item.domainAssociations }
    }
}
extension AmplifyClient {
    /// Paginate over `[ListJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListJobsOutput`
    public func listJobsPaginated(input: ListJobsInput) -> ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listJobs(input:))
    }
}

extension ListJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListJobsInput {
        return ListJobsInput(
            appId: self.appId,
            branchName: self.branchName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListJobsInput, OperationStackOutput == ListJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listJobsPaginated`
    /// to access the nested member `[AmplifyClientTypes.JobSummary]`
    /// - Returns: `[AmplifyClientTypes.JobSummary]`
    public func jobSummaries() async throws -> [AmplifyClientTypes.JobSummary] {
        return try await self.asyncCompactMap { item in item.jobSummaries }
    }
}
