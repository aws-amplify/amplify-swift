//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension SecurityHubClient {
    /// Paginate over `[DescribeActionTargetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeActionTargetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeActionTargetsOutput`
    public func describeActionTargetsPaginated(input: DescribeActionTargetsInput) -> ClientRuntime.PaginatorSequence<DescribeActionTargetsInput, DescribeActionTargetsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeActionTargetsInput, DescribeActionTargetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeActionTargets(input:))
    }
}

extension DescribeActionTargetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeActionTargetsInput {
        return DescribeActionTargetsInput(
            actionTargetArns: self.actionTargetArns,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeActionTargetsInput, OperationStackOutput == DescribeActionTargetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeActionTargetsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.ActionTarget]`
    /// - Returns: `[SecurityHubClientTypes.ActionTarget]`
    public func actionTargets() async throws -> [SecurityHubClientTypes.ActionTarget] {
        return try await self.asyncCompactMap { item in item.actionTargets }
    }
}
extension SecurityHubClient {
    /// Paginate over `[DescribeProductsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeProductsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeProductsOutput`
    public func describeProductsPaginated(input: DescribeProductsInput) -> ClientRuntime.PaginatorSequence<DescribeProductsInput, DescribeProductsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeProductsInput, DescribeProductsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeProducts(input:))
    }
}

extension DescribeProductsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeProductsInput {
        return DescribeProductsInput(
            maxResults: self.maxResults,
            nextToken: token,
            productArn: self.productArn
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeProductsInput, OperationStackOutput == DescribeProductsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeProductsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.Product]`
    /// - Returns: `[SecurityHubClientTypes.Product]`
    public func products() async throws -> [SecurityHubClientTypes.Product] {
        return try await self.asyncCompactMap { item in item.products }
    }
}
extension SecurityHubClient {
    /// Paginate over `[DescribeStandardsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeStandardsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeStandardsOutput`
    public func describeStandardsPaginated(input: DescribeStandardsInput) -> ClientRuntime.PaginatorSequence<DescribeStandardsInput, DescribeStandardsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeStandardsInput, DescribeStandardsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeStandards(input:))
    }
}

extension DescribeStandardsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeStandardsInput {
        return DescribeStandardsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeStandardsInput, OperationStackOutput == DescribeStandardsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeStandardsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.Standard]`
    /// - Returns: `[SecurityHubClientTypes.Standard]`
    public func standards() async throws -> [SecurityHubClientTypes.Standard] {
        return try await self.asyncCompactMap { item in item.standards }
    }
}
extension SecurityHubClient {
    /// Paginate over `[DescribeStandardsControlsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeStandardsControlsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeStandardsControlsOutput`
    public func describeStandardsControlsPaginated(input: DescribeStandardsControlsInput) -> ClientRuntime.PaginatorSequence<DescribeStandardsControlsInput, DescribeStandardsControlsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeStandardsControlsInput, DescribeStandardsControlsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeStandardsControls(input:))
    }
}

extension DescribeStandardsControlsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeStandardsControlsInput {
        return DescribeStandardsControlsInput(
            maxResults: self.maxResults,
            nextToken: token,
            standardsSubscriptionArn: self.standardsSubscriptionArn
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeStandardsControlsInput, OperationStackOutput == DescribeStandardsControlsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeStandardsControlsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.StandardsControl]`
    /// - Returns: `[SecurityHubClientTypes.StandardsControl]`
    public func controls() async throws -> [SecurityHubClientTypes.StandardsControl] {
        return try await self.asyncCompactMap { item in item.controls }
    }
}
extension SecurityHubClient {
    /// Paginate over `[GetEnabledStandardsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetEnabledStandardsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetEnabledStandardsOutput`
    public func getEnabledStandardsPaginated(input: GetEnabledStandardsInput) -> ClientRuntime.PaginatorSequence<GetEnabledStandardsInput, GetEnabledStandardsOutput> {
        return ClientRuntime.PaginatorSequence<GetEnabledStandardsInput, GetEnabledStandardsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getEnabledStandards(input:))
    }
}

extension GetEnabledStandardsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetEnabledStandardsInput {
        return GetEnabledStandardsInput(
            maxResults: self.maxResults,
            nextToken: token,
            standardsSubscriptionArns: self.standardsSubscriptionArns
        )}
}

extension PaginatorSequence where OperationStackInput == GetEnabledStandardsInput, OperationStackOutput == GetEnabledStandardsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getEnabledStandardsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.StandardsSubscription]`
    /// - Returns: `[SecurityHubClientTypes.StandardsSubscription]`
    public func standardsSubscriptions() async throws -> [SecurityHubClientTypes.StandardsSubscription] {
        return try await self.asyncCompactMap { item in item.standardsSubscriptions }
    }
}
extension SecurityHubClient {
    /// Paginate over `[GetFindingHistoryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetFindingHistoryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetFindingHistoryOutput`
    public func getFindingHistoryPaginated(input: GetFindingHistoryInput) -> ClientRuntime.PaginatorSequence<GetFindingHistoryInput, GetFindingHistoryOutput> {
        return ClientRuntime.PaginatorSequence<GetFindingHistoryInput, GetFindingHistoryOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getFindingHistory(input:))
    }
}

extension GetFindingHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetFindingHistoryInput {
        return GetFindingHistoryInput(
            endTime: self.endTime,
            findingIdentifier: self.findingIdentifier,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime
        )}
}

extension PaginatorSequence where OperationStackInput == GetFindingHistoryInput, OperationStackOutput == GetFindingHistoryOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getFindingHistoryPaginated`
    /// to access the nested member `[SecurityHubClientTypes.FindingHistoryRecord]`
    /// - Returns: `[SecurityHubClientTypes.FindingHistoryRecord]`
    public func records() async throws -> [SecurityHubClientTypes.FindingHistoryRecord] {
        return try await self.asyncCompactMap { item in item.records }
    }
}
extension SecurityHubClient {
    /// Paginate over `[GetFindingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetFindingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetFindingsOutput`
    public func getFindingsPaginated(input: GetFindingsInput) -> ClientRuntime.PaginatorSequence<GetFindingsInput, GetFindingsOutput> {
        return ClientRuntime.PaginatorSequence<GetFindingsInput, GetFindingsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getFindings(input:))
    }
}

extension GetFindingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetFindingsInput {
        return GetFindingsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortCriteria: self.sortCriteria
        )}
}

extension PaginatorSequence where OperationStackInput == GetFindingsInput, OperationStackOutput == GetFindingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getFindingsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.AwsSecurityFinding]`
    /// - Returns: `[SecurityHubClientTypes.AwsSecurityFinding]`
    public func findings() async throws -> [SecurityHubClientTypes.AwsSecurityFinding] {
        return try await self.asyncCompactMap { item in item.findings }
    }
}
extension SecurityHubClient {
    /// Paginate over `[GetInsightsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetInsightsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetInsightsOutput`
    public func getInsightsPaginated(input: GetInsightsInput) -> ClientRuntime.PaginatorSequence<GetInsightsInput, GetInsightsOutput> {
        return ClientRuntime.PaginatorSequence<GetInsightsInput, GetInsightsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getInsights(input:))
    }
}

extension GetInsightsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetInsightsInput {
        return GetInsightsInput(
            insightArns: self.insightArns,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == GetInsightsInput, OperationStackOutput == GetInsightsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getInsightsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.Insight]`
    /// - Returns: `[SecurityHubClientTypes.Insight]`
    public func insights() async throws -> [SecurityHubClientTypes.Insight] {
        return try await self.asyncCompactMap { item in item.insights }
    }
}
extension SecurityHubClient {
    /// Paginate over `[ListConfigurationPoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListConfigurationPoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListConfigurationPoliciesOutput`
    public func listConfigurationPoliciesPaginated(input: ListConfigurationPoliciesInput) -> ClientRuntime.PaginatorSequence<ListConfigurationPoliciesInput, ListConfigurationPoliciesOutput> {
        return ClientRuntime.PaginatorSequence<ListConfigurationPoliciesInput, ListConfigurationPoliciesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listConfigurationPolicies(input:))
    }
}

extension ListConfigurationPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListConfigurationPoliciesInput {
        return ListConfigurationPoliciesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListConfigurationPoliciesInput, OperationStackOutput == ListConfigurationPoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listConfigurationPoliciesPaginated`
    /// to access the nested member `[SecurityHubClientTypes.ConfigurationPolicySummary]`
    /// - Returns: `[SecurityHubClientTypes.ConfigurationPolicySummary]`
    public func configurationPolicySummaries() async throws -> [SecurityHubClientTypes.ConfigurationPolicySummary] {
        return try await self.asyncCompactMap { item in item.configurationPolicySummaries }
    }
}
extension SecurityHubClient {
    /// Paginate over `[ListConfigurationPolicyAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListConfigurationPolicyAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListConfigurationPolicyAssociationsOutput`
    public func listConfigurationPolicyAssociationsPaginated(input: ListConfigurationPolicyAssociationsInput) -> ClientRuntime.PaginatorSequence<ListConfigurationPolicyAssociationsInput, ListConfigurationPolicyAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<ListConfigurationPolicyAssociationsInput, ListConfigurationPolicyAssociationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listConfigurationPolicyAssociations(input:))
    }
}

extension ListConfigurationPolicyAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListConfigurationPolicyAssociationsInput {
        return ListConfigurationPolicyAssociationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListConfigurationPolicyAssociationsInput, OperationStackOutput == ListConfigurationPolicyAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listConfigurationPolicyAssociationsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.ConfigurationPolicyAssociationSummary]`
    /// - Returns: `[SecurityHubClientTypes.ConfigurationPolicyAssociationSummary]`
    public func configurationPolicyAssociationSummaries() async throws -> [SecurityHubClientTypes.ConfigurationPolicyAssociationSummary] {
        return try await self.asyncCompactMap { item in item.configurationPolicyAssociationSummaries }
    }
}
extension SecurityHubClient {
    /// Paginate over `[ListEnabledProductsForImportOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListEnabledProductsForImportInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListEnabledProductsForImportOutput`
    public func listEnabledProductsForImportPaginated(input: ListEnabledProductsForImportInput) -> ClientRuntime.PaginatorSequence<ListEnabledProductsForImportInput, ListEnabledProductsForImportOutput> {
        return ClientRuntime.PaginatorSequence<ListEnabledProductsForImportInput, ListEnabledProductsForImportOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listEnabledProductsForImport(input:))
    }
}

extension ListEnabledProductsForImportInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEnabledProductsForImportInput {
        return ListEnabledProductsForImportInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListEnabledProductsForImportInput, OperationStackOutput == ListEnabledProductsForImportOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listEnabledProductsForImportPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func productSubscriptions() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.productSubscriptions }
    }
}
extension SecurityHubClient {
    /// Paginate over `[ListFindingAggregatorsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFindingAggregatorsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFindingAggregatorsOutput`
    public func listFindingAggregatorsPaginated(input: ListFindingAggregatorsInput) -> ClientRuntime.PaginatorSequence<ListFindingAggregatorsInput, ListFindingAggregatorsOutput> {
        return ClientRuntime.PaginatorSequence<ListFindingAggregatorsInput, ListFindingAggregatorsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFindingAggregators(input:))
    }
}

extension ListFindingAggregatorsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFindingAggregatorsInput {
        return ListFindingAggregatorsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListFindingAggregatorsInput, OperationStackOutput == ListFindingAggregatorsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFindingAggregatorsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.FindingAggregator]`
    /// - Returns: `[SecurityHubClientTypes.FindingAggregator]`
    public func findingAggregators() async throws -> [SecurityHubClientTypes.FindingAggregator] {
        return try await self.asyncCompactMap { item in item.findingAggregators }
    }
}
extension SecurityHubClient {
    /// Paginate over `[ListInvitationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInvitationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInvitationsOutput`
    public func listInvitationsPaginated(input: ListInvitationsInput) -> ClientRuntime.PaginatorSequence<ListInvitationsInput, ListInvitationsOutput> {
        return ClientRuntime.PaginatorSequence<ListInvitationsInput, ListInvitationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listInvitations(input:))
    }
}

extension ListInvitationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInvitationsInput {
        return ListInvitationsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListInvitationsInput, OperationStackOutput == ListInvitationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInvitationsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.Invitation]`
    /// - Returns: `[SecurityHubClientTypes.Invitation]`
    public func invitations() async throws -> [SecurityHubClientTypes.Invitation] {
        return try await self.asyncCompactMap { item in item.invitations }
    }
}
extension SecurityHubClient {
    /// Paginate over `[ListMembersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMembersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMembersOutput`
    public func listMembersPaginated(input: ListMembersInput) -> ClientRuntime.PaginatorSequence<ListMembersInput, ListMembersOutput> {
        return ClientRuntime.PaginatorSequence<ListMembersInput, ListMembersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMembers(input:))
    }
}

extension ListMembersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMembersInput {
        return ListMembersInput(
            maxResults: self.maxResults,
            nextToken: token,
            onlyAssociated: self.onlyAssociated
        )}
}

extension PaginatorSequence where OperationStackInput == ListMembersInput, OperationStackOutput == ListMembersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMembersPaginated`
    /// to access the nested member `[SecurityHubClientTypes.Member]`
    /// - Returns: `[SecurityHubClientTypes.Member]`
    public func members() async throws -> [SecurityHubClientTypes.Member] {
        return try await self.asyncCompactMap { item in item.members }
    }
}
extension SecurityHubClient {
    /// Paginate over `[ListOrganizationAdminAccountsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOrganizationAdminAccountsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOrganizationAdminAccountsOutput`
    public func listOrganizationAdminAccountsPaginated(input: ListOrganizationAdminAccountsInput) -> ClientRuntime.PaginatorSequence<ListOrganizationAdminAccountsInput, ListOrganizationAdminAccountsOutput> {
        return ClientRuntime.PaginatorSequence<ListOrganizationAdminAccountsInput, ListOrganizationAdminAccountsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listOrganizationAdminAccounts(input:))
    }
}

extension ListOrganizationAdminAccountsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOrganizationAdminAccountsInput {
        return ListOrganizationAdminAccountsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListOrganizationAdminAccountsInput, OperationStackOutput == ListOrganizationAdminAccountsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOrganizationAdminAccountsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.AdminAccount]`
    /// - Returns: `[SecurityHubClientTypes.AdminAccount]`
    public func adminAccounts() async throws -> [SecurityHubClientTypes.AdminAccount] {
        return try await self.asyncCompactMap { item in item.adminAccounts }
    }
}
extension SecurityHubClient {
    /// Paginate over `[ListSecurityControlDefinitionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSecurityControlDefinitionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSecurityControlDefinitionsOutput`
    public func listSecurityControlDefinitionsPaginated(input: ListSecurityControlDefinitionsInput) -> ClientRuntime.PaginatorSequence<ListSecurityControlDefinitionsInput, ListSecurityControlDefinitionsOutput> {
        return ClientRuntime.PaginatorSequence<ListSecurityControlDefinitionsInput, ListSecurityControlDefinitionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSecurityControlDefinitions(input:))
    }
}

extension ListSecurityControlDefinitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSecurityControlDefinitionsInput {
        return ListSecurityControlDefinitionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            standardsArn: self.standardsArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListSecurityControlDefinitionsInput, OperationStackOutput == ListSecurityControlDefinitionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSecurityControlDefinitionsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.SecurityControlDefinition]`
    /// - Returns: `[SecurityHubClientTypes.SecurityControlDefinition]`
    public func securityControlDefinitions() async throws -> [SecurityHubClientTypes.SecurityControlDefinition] {
        return try await self.asyncCompactMap { item in item.securityControlDefinitions }
    }
}
extension SecurityHubClient {
    /// Paginate over `[ListStandardsControlAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListStandardsControlAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListStandardsControlAssociationsOutput`
    public func listStandardsControlAssociationsPaginated(input: ListStandardsControlAssociationsInput) -> ClientRuntime.PaginatorSequence<ListStandardsControlAssociationsInput, ListStandardsControlAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<ListStandardsControlAssociationsInput, ListStandardsControlAssociationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listStandardsControlAssociations(input:))
    }
}

extension ListStandardsControlAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListStandardsControlAssociationsInput {
        return ListStandardsControlAssociationsInput(
            maxResults: self.maxResults,
            nextToken: token,
            securityControlId: self.securityControlId
        )}
}

extension PaginatorSequence where OperationStackInput == ListStandardsControlAssociationsInput, OperationStackOutput == ListStandardsControlAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listStandardsControlAssociationsPaginated`
    /// to access the nested member `[SecurityHubClientTypes.StandardsControlAssociationSummary]`
    /// - Returns: `[SecurityHubClientTypes.StandardsControlAssociationSummary]`
    public func standardsControlAssociationSummaries() async throws -> [SecurityHubClientTypes.StandardsControlAssociationSummary] {
        return try await self.asyncCompactMap { item in item.standardsControlAssociationSummaries }
    }
}
