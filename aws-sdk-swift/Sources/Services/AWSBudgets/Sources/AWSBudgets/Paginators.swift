//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension BudgetsClient {
    /// Paginate over `[DescribeBudgetActionHistoriesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeBudgetActionHistoriesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeBudgetActionHistoriesOutput`
    public func describeBudgetActionHistoriesPaginated(input: DescribeBudgetActionHistoriesInput) -> ClientRuntime.PaginatorSequence<DescribeBudgetActionHistoriesInput, DescribeBudgetActionHistoriesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeBudgetActionHistoriesInput, DescribeBudgetActionHistoriesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeBudgetActionHistories(input:))
    }
}

extension DescribeBudgetActionHistoriesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeBudgetActionHistoriesInput {
        return DescribeBudgetActionHistoriesInput(
            accountId: self.accountId,
            actionId: self.actionId,
            budgetName: self.budgetName,
            maxResults: self.maxResults,
            nextToken: token,
            timePeriod: self.timePeriod
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeBudgetActionHistoriesInput, OperationStackOutput == DescribeBudgetActionHistoriesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeBudgetActionHistoriesPaginated`
    /// to access the nested member `[BudgetsClientTypes.ActionHistory]`
    /// - Returns: `[BudgetsClientTypes.ActionHistory]`
    public func actionHistories() async throws -> [BudgetsClientTypes.ActionHistory] {
        return try await self.asyncCompactMap { item in item.actionHistories }
    }
}
extension BudgetsClient {
    /// Paginate over `[DescribeBudgetActionsForAccountOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeBudgetActionsForAccountInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeBudgetActionsForAccountOutput`
    public func describeBudgetActionsForAccountPaginated(input: DescribeBudgetActionsForAccountInput) -> ClientRuntime.PaginatorSequence<DescribeBudgetActionsForAccountInput, DescribeBudgetActionsForAccountOutput> {
        return ClientRuntime.PaginatorSequence<DescribeBudgetActionsForAccountInput, DescribeBudgetActionsForAccountOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeBudgetActionsForAccount(input:))
    }
}

extension DescribeBudgetActionsForAccountInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeBudgetActionsForAccountInput {
        return DescribeBudgetActionsForAccountInput(
            accountId: self.accountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeBudgetActionsForAccountInput, OperationStackOutput == DescribeBudgetActionsForAccountOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeBudgetActionsForAccountPaginated`
    /// to access the nested member `[BudgetsClientTypes.Action]`
    /// - Returns: `[BudgetsClientTypes.Action]`
    public func actions() async throws -> [BudgetsClientTypes.Action] {
        return try await self.asyncCompactMap { item in item.actions }
    }
}
extension BudgetsClient {
    /// Paginate over `[DescribeBudgetActionsForBudgetOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeBudgetActionsForBudgetInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeBudgetActionsForBudgetOutput`
    public func describeBudgetActionsForBudgetPaginated(input: DescribeBudgetActionsForBudgetInput) -> ClientRuntime.PaginatorSequence<DescribeBudgetActionsForBudgetInput, DescribeBudgetActionsForBudgetOutput> {
        return ClientRuntime.PaginatorSequence<DescribeBudgetActionsForBudgetInput, DescribeBudgetActionsForBudgetOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeBudgetActionsForBudget(input:))
    }
}

extension DescribeBudgetActionsForBudgetInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeBudgetActionsForBudgetInput {
        return DescribeBudgetActionsForBudgetInput(
            accountId: self.accountId,
            budgetName: self.budgetName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeBudgetActionsForBudgetInput, OperationStackOutput == DescribeBudgetActionsForBudgetOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeBudgetActionsForBudgetPaginated`
    /// to access the nested member `[BudgetsClientTypes.Action]`
    /// - Returns: `[BudgetsClientTypes.Action]`
    public func actions() async throws -> [BudgetsClientTypes.Action] {
        return try await self.asyncCompactMap { item in item.actions }
    }
}
extension BudgetsClient {
    /// Paginate over `[DescribeBudgetNotificationsForAccountOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeBudgetNotificationsForAccountInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeBudgetNotificationsForAccountOutput`
    public func describeBudgetNotificationsForAccountPaginated(input: DescribeBudgetNotificationsForAccountInput) -> ClientRuntime.PaginatorSequence<DescribeBudgetNotificationsForAccountInput, DescribeBudgetNotificationsForAccountOutput> {
        return ClientRuntime.PaginatorSequence<DescribeBudgetNotificationsForAccountInput, DescribeBudgetNotificationsForAccountOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeBudgetNotificationsForAccount(input:))
    }
}

extension DescribeBudgetNotificationsForAccountInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeBudgetNotificationsForAccountInput {
        return DescribeBudgetNotificationsForAccountInput(
            accountId: self.accountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeBudgetNotificationsForAccountInput, OperationStackOutput == DescribeBudgetNotificationsForAccountOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeBudgetNotificationsForAccountPaginated`
    /// to access the nested member `[BudgetsClientTypes.BudgetNotificationsForAccount]`
    /// - Returns: `[BudgetsClientTypes.BudgetNotificationsForAccount]`
    public func budgetNotificationsForAccount() async throws -> [BudgetsClientTypes.BudgetNotificationsForAccount] {
        return try await self.asyncCompactMap { item in item.budgetNotificationsForAccount }
    }
}
extension BudgetsClient {
    /// Paginate over `[DescribeBudgetPerformanceHistoryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeBudgetPerformanceHistoryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeBudgetPerformanceHistoryOutput`
    public func describeBudgetPerformanceHistoryPaginated(input: DescribeBudgetPerformanceHistoryInput) -> ClientRuntime.PaginatorSequence<DescribeBudgetPerformanceHistoryInput, DescribeBudgetPerformanceHistoryOutput> {
        return ClientRuntime.PaginatorSequence<DescribeBudgetPerformanceHistoryInput, DescribeBudgetPerformanceHistoryOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeBudgetPerformanceHistory(input:))
    }
}

extension DescribeBudgetPerformanceHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeBudgetPerformanceHistoryInput {
        return DescribeBudgetPerformanceHistoryInput(
            accountId: self.accountId,
            budgetName: self.budgetName,
            maxResults: self.maxResults,
            nextToken: token,
            timePeriod: self.timePeriod
        )}
}
extension BudgetsClient {
    /// Paginate over `[DescribeBudgetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeBudgetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeBudgetsOutput`
    public func describeBudgetsPaginated(input: DescribeBudgetsInput) -> ClientRuntime.PaginatorSequence<DescribeBudgetsInput, DescribeBudgetsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeBudgetsInput, DescribeBudgetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeBudgets(input:))
    }
}

extension DescribeBudgetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeBudgetsInput {
        return DescribeBudgetsInput(
            accountId: self.accountId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeBudgetsInput, OperationStackOutput == DescribeBudgetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeBudgetsPaginated`
    /// to access the nested member `[BudgetsClientTypes.Budget]`
    /// - Returns: `[BudgetsClientTypes.Budget]`
    public func budgets() async throws -> [BudgetsClientTypes.Budget] {
        return try await self.asyncCompactMap { item in item.budgets }
    }
}
extension BudgetsClient {
    /// Paginate over `[DescribeNotificationsForBudgetOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeNotificationsForBudgetInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeNotificationsForBudgetOutput`
    public func describeNotificationsForBudgetPaginated(input: DescribeNotificationsForBudgetInput) -> ClientRuntime.PaginatorSequence<DescribeNotificationsForBudgetInput, DescribeNotificationsForBudgetOutput> {
        return ClientRuntime.PaginatorSequence<DescribeNotificationsForBudgetInput, DescribeNotificationsForBudgetOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeNotificationsForBudget(input:))
    }
}

extension DescribeNotificationsForBudgetInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeNotificationsForBudgetInput {
        return DescribeNotificationsForBudgetInput(
            accountId: self.accountId,
            budgetName: self.budgetName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeNotificationsForBudgetInput, OperationStackOutput == DescribeNotificationsForBudgetOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeNotificationsForBudgetPaginated`
    /// to access the nested member `[BudgetsClientTypes.Notification]`
    /// - Returns: `[BudgetsClientTypes.Notification]`
    public func notifications() async throws -> [BudgetsClientTypes.Notification] {
        return try await self.asyncCompactMap { item in item.notifications }
    }
}
extension BudgetsClient {
    /// Paginate over `[DescribeSubscribersForNotificationOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeSubscribersForNotificationInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeSubscribersForNotificationOutput`
    public func describeSubscribersForNotificationPaginated(input: DescribeSubscribersForNotificationInput) -> ClientRuntime.PaginatorSequence<DescribeSubscribersForNotificationInput, DescribeSubscribersForNotificationOutput> {
        return ClientRuntime.PaginatorSequence<DescribeSubscribersForNotificationInput, DescribeSubscribersForNotificationOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeSubscribersForNotification(input:))
    }
}

extension DescribeSubscribersForNotificationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSubscribersForNotificationInput {
        return DescribeSubscribersForNotificationInput(
            accountId: self.accountId,
            budgetName: self.budgetName,
            maxResults: self.maxResults,
            nextToken: token,
            notification: self.notification
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeSubscribersForNotificationInput, OperationStackOutput == DescribeSubscribersForNotificationOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeSubscribersForNotificationPaginated`
    /// to access the nested member `[BudgetsClientTypes.Subscriber]`
    /// - Returns: `[BudgetsClientTypes.Subscriber]`
    public func subscribers() async throws -> [BudgetsClientTypes.Subscriber] {
        return try await self.asyncCompactMap { item in item.subscribers }
    }
}
