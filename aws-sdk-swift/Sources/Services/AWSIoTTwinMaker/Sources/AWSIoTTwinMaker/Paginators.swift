//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension IoTTwinMakerClient {
    /// Paginate over `[ExecuteQueryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ExecuteQueryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ExecuteQueryOutput`
    public func executeQueryPaginated(input: ExecuteQueryInput) -> ClientRuntime.PaginatorSequence<ExecuteQueryInput, ExecuteQueryOutput> {
        return ClientRuntime.PaginatorSequence<ExecuteQueryInput, ExecuteQueryOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.executeQuery(input:))
    }
}

extension ExecuteQueryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ExecuteQueryInput {
        return ExecuteQueryInput(
            maxResults: self.maxResults,
            nextToken: token,
            queryStatement: self.queryStatement,
            workspaceId: self.workspaceId
        )}
}
extension IoTTwinMakerClient {
    /// Paginate over `[GetPropertyValueOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetPropertyValueInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetPropertyValueOutput`
    public func getPropertyValuePaginated(input: GetPropertyValueInput) -> ClientRuntime.PaginatorSequence<GetPropertyValueInput, GetPropertyValueOutput> {
        return ClientRuntime.PaginatorSequence<GetPropertyValueInput, GetPropertyValueOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getPropertyValue(input:))
    }
}

extension GetPropertyValueInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetPropertyValueInput {
        return GetPropertyValueInput(
            componentName: self.componentName,
            componentPath: self.componentPath,
            componentTypeId: self.componentTypeId,
            entityId: self.entityId,
            maxResults: self.maxResults,
            nextToken: token,
            propertyGroupName: self.propertyGroupName,
            selectedProperties: self.selectedProperties,
            tabularConditions: self.tabularConditions,
            workspaceId: self.workspaceId
        )}
}
extension IoTTwinMakerClient {
    /// Paginate over `[GetPropertyValueHistoryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetPropertyValueHistoryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetPropertyValueHistoryOutput`
    public func getPropertyValueHistoryPaginated(input: GetPropertyValueHistoryInput) -> ClientRuntime.PaginatorSequence<GetPropertyValueHistoryInput, GetPropertyValueHistoryOutput> {
        return ClientRuntime.PaginatorSequence<GetPropertyValueHistoryInput, GetPropertyValueHistoryOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getPropertyValueHistory(input:))
    }
}

extension GetPropertyValueHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetPropertyValueHistoryInput {
        return GetPropertyValueHistoryInput(
            componentName: self.componentName,
            componentPath: self.componentPath,
            componentTypeId: self.componentTypeId,
            endDateTime: self.endDateTime,
            endTime: self.endTime,
            entityId: self.entityId,
            interpolation: self.interpolation,
            maxResults: self.maxResults,
            nextToken: token,
            orderByTime: self.orderByTime,
            propertyFilters: self.propertyFilters,
            selectedProperties: self.selectedProperties,
            startDateTime: self.startDateTime,
            startTime: self.startTime,
            workspaceId: self.workspaceId
        )}
}
extension IoTTwinMakerClient {
    /// Paginate over `[ListComponentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListComponentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListComponentsOutput`
    public func listComponentsPaginated(input: ListComponentsInput) -> ClientRuntime.PaginatorSequence<ListComponentsInput, ListComponentsOutput> {
        return ClientRuntime.PaginatorSequence<ListComponentsInput, ListComponentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listComponents(input:))
    }
}

extension ListComponentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListComponentsInput {
        return ListComponentsInput(
            componentPath: self.componentPath,
            entityId: self.entityId,
            maxResults: self.maxResults,
            nextToken: token,
            workspaceId: self.workspaceId
        )}
}
extension IoTTwinMakerClient {
    /// Paginate over `[ListComponentTypesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListComponentTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListComponentTypesOutput`
    public func listComponentTypesPaginated(input: ListComponentTypesInput) -> ClientRuntime.PaginatorSequence<ListComponentTypesInput, ListComponentTypesOutput> {
        return ClientRuntime.PaginatorSequence<ListComponentTypesInput, ListComponentTypesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listComponentTypes(input:))
    }
}

extension ListComponentTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListComponentTypesInput {
        return ListComponentTypesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            workspaceId: self.workspaceId
        )}
}
extension IoTTwinMakerClient {
    /// Paginate over `[ListEntitiesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListEntitiesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListEntitiesOutput`
    public func listEntitiesPaginated(input: ListEntitiesInput) -> ClientRuntime.PaginatorSequence<ListEntitiesInput, ListEntitiesOutput> {
        return ClientRuntime.PaginatorSequence<ListEntitiesInput, ListEntitiesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listEntities(input:))
    }
}

extension ListEntitiesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEntitiesInput {
        return ListEntitiesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            workspaceId: self.workspaceId
        )}
}
extension IoTTwinMakerClient {
    /// Paginate over `[ListMetadataTransferJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMetadataTransferJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMetadataTransferJobsOutput`
    public func listMetadataTransferJobsPaginated(input: ListMetadataTransferJobsInput) -> ClientRuntime.PaginatorSequence<ListMetadataTransferJobsInput, ListMetadataTransferJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListMetadataTransferJobsInput, ListMetadataTransferJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMetadataTransferJobs(input:))
    }
}

extension ListMetadataTransferJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMetadataTransferJobsInput {
        return ListMetadataTransferJobsInput(
            destinationType: self.destinationType,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sourceType: self.sourceType
        )}
}
extension IoTTwinMakerClient {
    /// Paginate over `[ListPropertiesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPropertiesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPropertiesOutput`
    public func listPropertiesPaginated(input: ListPropertiesInput) -> ClientRuntime.PaginatorSequence<ListPropertiesInput, ListPropertiesOutput> {
        return ClientRuntime.PaginatorSequence<ListPropertiesInput, ListPropertiesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listProperties(input:))
    }
}

extension ListPropertiesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPropertiesInput {
        return ListPropertiesInput(
            componentName: self.componentName,
            componentPath: self.componentPath,
            entityId: self.entityId,
            maxResults: self.maxResults,
            nextToken: token,
            workspaceId: self.workspaceId
        )}
}
extension IoTTwinMakerClient {
    /// Paginate over `[ListScenesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListScenesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListScenesOutput`
    public func listScenesPaginated(input: ListScenesInput) -> ClientRuntime.PaginatorSequence<ListScenesInput, ListScenesOutput> {
        return ClientRuntime.PaginatorSequence<ListScenesInput, ListScenesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listScenes(input:))
    }
}

extension ListScenesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListScenesInput {
        return ListScenesInput(
            maxResults: self.maxResults,
            nextToken: token,
            workspaceId: self.workspaceId
        )}
}
extension IoTTwinMakerClient {
    /// Paginate over `[ListSyncJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSyncJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSyncJobsOutput`
    public func listSyncJobsPaginated(input: ListSyncJobsInput) -> ClientRuntime.PaginatorSequence<ListSyncJobsInput, ListSyncJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListSyncJobsInput, ListSyncJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSyncJobs(input:))
    }
}

extension ListSyncJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSyncJobsInput {
        return ListSyncJobsInput(
            maxResults: self.maxResults,
            nextToken: token,
            workspaceId: self.workspaceId
        )}
}
extension IoTTwinMakerClient {
    /// Paginate over `[ListSyncResourcesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSyncResourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSyncResourcesOutput`
    public func listSyncResourcesPaginated(input: ListSyncResourcesInput) -> ClientRuntime.PaginatorSequence<ListSyncResourcesInput, ListSyncResourcesOutput> {
        return ClientRuntime.PaginatorSequence<ListSyncResourcesInput, ListSyncResourcesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSyncResources(input:))
    }
}

extension ListSyncResourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSyncResourcesInput {
        return ListSyncResourcesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            syncSource: self.syncSource,
            workspaceId: self.workspaceId
        )}
}
extension IoTTwinMakerClient {
    /// Paginate over `[ListWorkspacesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorkspacesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorkspacesOutput`
    public func listWorkspacesPaginated(input: ListWorkspacesInput) -> ClientRuntime.PaginatorSequence<ListWorkspacesInput, ListWorkspacesOutput> {
        return ClientRuntime.PaginatorSequence<ListWorkspacesInput, ListWorkspacesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listWorkspaces(input:))
    }
}

extension ListWorkspacesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkspacesInput {
        return ListWorkspacesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
