//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct AssociateChannelFlowOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteChannelBanOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteChannelFlowOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteChannelMembershipOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteChannelMessageOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteChannelModeratorOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteChannelOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteMessagingStreamingConfigurationsOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateChannelFlowOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension ChimeSDKMessagingClientTypes {

    public enum AllowNotifications: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case filtered
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AllowNotifications] {
            return [
                .all,
                .filtered,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .filtered: return "FILTERED"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    public enum ChannelMembershipType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case hidden
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMembershipType] {
            return [
                .default,
                .hidden
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .hidden: return "HIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    /// Summary of the membership details of an AppInstanceUser.
    public struct AppInstanceUserMembershipSummary: Swift.Sendable {
        /// The time at which an AppInstanceUser last marked a channel as read.
        public var readMarkerTimestamp: Foundation.Date?
        /// The ID of the SubChannel that the AppInstanceUser is a member of.
        public var subChannelId: Swift.String?
        /// The type of ChannelMembership.
        public var type: ChimeSDKMessagingClientTypes.ChannelMembershipType?

        public init(
            readMarkerTimestamp: Foundation.Date? = nil,
            subChannelId: Swift.String? = nil,
            type: ChimeSDKMessagingClientTypes.ChannelMembershipType? = nil
        )
        {
            self.readMarkerTimestamp = readMarkerTimestamp
            self.subChannelId = subChannelId
            self.type = type
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    public enum ErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessdenied
        case badrequest
        case conflict
        case forbidden
        case notfound
        case phonenumberassociationsexist
        case preconditionfailed
        case resourcelimitexceeded
        case servicefailure
        case serviceunavailable
        case throttled
        case throttling
        case unauthorized
        case unprocessable
        case voiceconnectorgroupassociationsexist
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessdenied,
                .badrequest,
                .conflict,
                .forbidden,
                .notfound,
                .phonenumberassociationsexist,
                .preconditionfailed,
                .resourcelimitexceeded,
                .servicefailure,
                .serviceunavailable,
                .throttled,
                .throttling,
                .unauthorized,
                .unprocessable,
                .voiceconnectorgroupassociationsexist
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "AccessDenied"
            case .badrequest: return "BadRequest"
            case .conflict: return "Conflict"
            case .forbidden: return "Forbidden"
            case .notfound: return "NotFound"
            case .phonenumberassociationsexist: return "PhoneNumberAssociationsExist"
            case .preconditionfailed: return "PreconditionFailed"
            case .resourcelimitexceeded: return "ResourceLimitExceeded"
            case .servicefailure: return "ServiceFailure"
            case .serviceunavailable: return "ServiceUnavailable"
            case .throttled: return "Throttled"
            case .throttling: return "Throttling"
            case .unauthorized: return "Unauthorized"
            case .unprocessable: return "Unprocessable"
            case .voiceconnectorgroupassociationsexist: return "VoiceConnectorGroupAssociationsExist"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input parameters don't match the service's restrictions.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMessagingClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMessagingClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The client is permanently forbidden from making the request.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMessagingClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// One or more of the resources in the request does not exist in the system.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMessagingClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The service encountered an unexpected error.
public struct ServiceFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMessagingClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMessagingClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The client exceeded its request rate limit.
public struct ThrottledClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMessagingClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottledClientException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The client is not currently authorized to make the request.
public struct UnauthorizedClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMessagingClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedClientException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct AssociateChannelFlowInput: Swift.Sendable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the channel flow.
    /// This member is required.
    public var channelFlowArn: Swift.String?
    /// The AppInstanceUserArn of the user making the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelFlowArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelFlowArn = channelFlowArn
        self.chimeBearer = chimeBearer
    }
}

extension ChimeSDKMessagingClientTypes {

    /// The details of a user or bot.
    public struct Identity: Swift.Sendable {
        /// The ARN in an Identity.
        public var arn: Swift.String?
        /// The name in an Identity.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }
}

extension ChimeSDKMessagingClientTypes.Identity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Identity(arn: \(Swift.String(describing: arn)), name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {

    /// The membership information, including member ARNs, the channel ARN, and membership types.
    public struct BatchChannelMemberships: Swift.Sendable {
        /// The ARN of the channel to which you're adding members.
        public var channelArn: Swift.String?
        /// The identifier of the member who invited another member.
        public var invitedBy: ChimeSDKMessagingClientTypes.Identity?
        /// The users successfully added to the request.
        public var members: [ChimeSDKMessagingClientTypes.Identity]?
        /// The ID of the SubChannel.
        public var subChannelId: Swift.String?
        /// The membership types set for the channel members.
        public var type: ChimeSDKMessagingClientTypes.ChannelMembershipType?

        public init(
            channelArn: Swift.String? = nil,
            invitedBy: ChimeSDKMessagingClientTypes.Identity? = nil,
            members: [ChimeSDKMessagingClientTypes.Identity]? = nil,
            subChannelId: Swift.String? = nil,
            type: ChimeSDKMessagingClientTypes.ChannelMembershipType? = nil
        )
        {
            self.channelArn = channelArn
            self.invitedBy = invitedBy
            self.members = members
            self.subChannelId = subChannelId
            self.type = type
        }
    }
}

/// The request exceeds the resource limit.
public struct ResourceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMessagingClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct BatchCreateChannelMembershipInput: Swift.Sendable {
    /// The ARN of the channel to which you're adding users or bots.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ARNs of the members you want to add to the channel. Only AppInstanceUsers and AppInstanceBots can be added as a channel member.
    /// This member is required.
    public var memberArns: [Swift.String]?
    /// The ID of the SubChannel in the request. Only required when creating membership in a SubChannel for a moderator in an elastic channel.
    public var subChannelId: Swift.String?
    /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned. This is only supported by moderators.
    public var type: ChimeSDKMessagingClientTypes.ChannelMembershipType?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArns: [Swift.String]? = nil,
        subChannelId: Swift.String? = nil,
        type: ChimeSDKMessagingClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArns = memberArns
        self.subChannelId = subChannelId
        self.type = type
    }
}

extension ChimeSDKMessagingClientTypes {

    /// A list of failed member ARNs, error codes, and error messages.
    public struct BatchCreateChannelMembershipError: Swift.Sendable {
        /// The error code.
        public var errorCode: ChimeSDKMessagingClientTypes.ErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The AppInstanceUserArn of the member that the service couldn't add.
        public var memberArn: Swift.String?

        public init(
            errorCode: ChimeSDKMessagingClientTypes.ErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            memberArn: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.memberArn = memberArn
        }
    }
}

public struct BatchCreateChannelMembershipOutput: Swift.Sendable {
    /// The list of channel memberships in the response.
    public var batchChannelMemberships: ChimeSDKMessagingClientTypes.BatchChannelMemberships?
    /// If the action fails for one or more of the memberships in the request, a list of the memberships is returned, along with error codes and error messages.
    public var errors: [ChimeSDKMessagingClientTypes.BatchCreateChannelMembershipError]?

    public init(
        batchChannelMemberships: ChimeSDKMessagingClientTypes.BatchChannelMemberships? = nil,
        errors: [ChimeSDKMessagingClientTypes.BatchCreateChannelMembershipError]? = nil
    )
    {
        self.batchChannelMemberships = batchChannelMemberships
        self.errors = errors
    }
}

extension ChimeSDKMessagingClientTypes {

    /// The attributes required to configure and create an elastic channel. An elastic channel can support a maximum of 1-million members.
    public struct ElasticChannelConfiguration: Swift.Sendable {
        /// The maximum number of SubChannels that you want to allow in the elastic channel.
        /// This member is required.
        public var maximumSubChannels: Swift.Int?
        /// The minimum allowed percentage of TargetMembershipsPerSubChannel users. Ceil of the calculated value is used in balancing members among SubChannels of the elastic channel.
        /// This member is required.
        public var minimumMembershipPercentage: Swift.Int?
        /// The maximum number of members allowed in a SubChannel.
        /// This member is required.
        public var targetMembershipsPerSubChannel: Swift.Int?

        public init(
            maximumSubChannels: Swift.Int? = nil,
            minimumMembershipPercentage: Swift.Int? = nil,
            targetMembershipsPerSubChannel: Swift.Int? = nil
        )
        {
            self.maximumSubChannels = maximumSubChannels
            self.minimumMembershipPercentage = minimumMembershipPercentage
            self.targetMembershipsPerSubChannel = targetMembershipsPerSubChannel
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    public enum ExpirationCriterion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createdTimestamp
        case lastMessageTimestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [ExpirationCriterion] {
            return [
                .createdTimestamp,
                .lastMessageTimestamp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createdTimestamp: return "CREATED_TIMESTAMP"
            case .lastMessageTimestamp: return "LAST_MESSAGE_TIMESTAMP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    /// Settings that control the interval after which a channel is deleted.
    public struct ExpirationSettings: Swift.Sendable {
        /// The conditions that must be met for a channel to expire.
        /// This member is required.
        public var expirationCriterion: ChimeSDKMessagingClientTypes.ExpirationCriterion?
        /// The period in days after which the system automatically deletes a channel.
        /// This member is required.
        public var expirationDays: Swift.Int?

        public init(
            expirationCriterion: ChimeSDKMessagingClientTypes.ExpirationCriterion? = nil,
            expirationDays: Swift.Int? = nil
        )
        {
            self.expirationCriterion = expirationCriterion
            self.expirationDays = expirationDays
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    public enum ChannelMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case restricted
        case unrestricted
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMode] {
            return [
                .restricted,
                .unrestricted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .restricted: return "RESTRICTED"
            case .unrestricted: return "UNRESTRICTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    public enum ChannelPrivacy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelPrivacy] {
            return [
                .private,
                .public
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    /// The details of a channel.
    public struct Channel: Swift.Sendable {
        /// The ARN of a channel.
        public var channelArn: Swift.String?
        /// The ARN of the channel flow.
        public var channelFlowArn: Swift.String?
        /// The AppInstanceUser who created the channel.
        public var createdBy: ChimeSDKMessagingClientTypes.Identity?
        /// The time at which the AppInstanceUser created the channel.
        public var createdTimestamp: Foundation.Date?
        /// The attributes required to configure and create an elastic channel. An elastic channel can support a maximum of 1-million members.
        public var elasticChannelConfiguration: ChimeSDKMessagingClientTypes.ElasticChannelConfiguration?
        /// Settings that control when a channel expires.
        public var expirationSettings: ChimeSDKMessagingClientTypes.ExpirationSettings?
        /// The time at which a member sent the last message in the channel.
        public var lastMessageTimestamp: Foundation.Date?
        /// The time at which a channel was last updated.
        public var lastUpdatedTimestamp: Foundation.Date?
        /// The channel's metadata.
        public var metadata: Swift.String?
        /// The mode of the channel.
        public var mode: ChimeSDKMessagingClientTypes.ChannelMode?
        /// The name of a channel.
        public var name: Swift.String?
        /// The channel's privacy setting.
        public var privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy?

        public init(
            channelArn: Swift.String? = nil,
            channelFlowArn: Swift.String? = nil,
            createdBy: ChimeSDKMessagingClientTypes.Identity? = nil,
            createdTimestamp: Foundation.Date? = nil,
            elasticChannelConfiguration: ChimeSDKMessagingClientTypes.ElasticChannelConfiguration? = nil,
            expirationSettings: ChimeSDKMessagingClientTypes.ExpirationSettings? = nil,
            lastMessageTimestamp: Foundation.Date? = nil,
            lastUpdatedTimestamp: Foundation.Date? = nil,
            metadata: Swift.String? = nil,
            mode: ChimeSDKMessagingClientTypes.ChannelMode? = nil,
            name: Swift.String? = nil,
            privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy? = nil
        )
        {
            self.channelArn = channelArn
            self.channelFlowArn = channelFlowArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.elasticChannelConfiguration = elasticChannelConfiguration
            self.expirationSettings = expirationSettings
            self.lastMessageTimestamp = lastMessageTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }
    }
}

extension ChimeSDKMessagingClientTypes.Channel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Channel(channelArn: \(Swift.String(describing: channelArn)), channelFlowArn: \(Swift.String(describing: channelFlowArn)), createdBy: \(Swift.String(describing: createdBy)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), elasticChannelConfiguration: \(Swift.String(describing: elasticChannelConfiguration)), expirationSettings: \(Swift.String(describing: expirationSettings)), lastMessageTimestamp: \(Swift.String(describing: lastMessageTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), mode: \(Swift.String(describing: mode)), privacy: \(Swift.String(describing: privacy)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {

    /// Summary of details of a channel associated with channel flow.
    public struct ChannelAssociatedWithFlowSummary: Swift.Sendable {
        /// The ARN of the channel.
        public var channelArn: Swift.String?
        /// The channel's metadata.
        public var metadata: Swift.String?
        /// The mode of the channel.
        public var mode: ChimeSDKMessagingClientTypes.ChannelMode?
        /// The name of the channel flow.
        public var name: Swift.String?
        /// The channel's privacy setting.
        public var privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy?

        public init(
            channelArn: Swift.String? = nil,
            metadata: Swift.String? = nil,
            mode: ChimeSDKMessagingClientTypes.ChannelMode? = nil,
            name: Swift.String? = nil,
            privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy? = nil
        )
        {
            self.channelArn = channelArn
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }
    }
}

extension ChimeSDKMessagingClientTypes.ChannelAssociatedWithFlowSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelAssociatedWithFlowSummary(channelArn: \(Swift.String(describing: channelArn)), mode: \(Swift.String(describing: mode)), privacy: \(Swift.String(describing: privacy)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {

    /// The details of a channel ban.
    public struct ChannelBan: Swift.Sendable {
        /// The ARN of the channel from which a member is being banned.
        public var channelArn: Swift.String?
        /// The AppInstanceUser who created the ban.
        public var createdBy: ChimeSDKMessagingClientTypes.Identity?
        /// The time at which the ban was created.
        public var createdTimestamp: Foundation.Date?
        /// The member being banned from the channel.
        public var member: ChimeSDKMessagingClientTypes.Identity?

        public init(
            channelArn: Swift.String? = nil,
            createdBy: ChimeSDKMessagingClientTypes.Identity? = nil,
            createdTimestamp: Foundation.Date? = nil,
            member: ChimeSDKMessagingClientTypes.Identity? = nil
        )
        {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.member = member
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    /// Summary of the details of a ChannelBan.
    public struct ChannelBanSummary: Swift.Sendable {
        /// The member being banned from a channel.
        public var member: ChimeSDKMessagingClientTypes.Identity?

        public init(
            member: ChimeSDKMessagingClientTypes.Identity? = nil
        )
        {
            self.member = member
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    public enum InvocationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case async
        case sdkUnknown(Swift.String)

        public static var allCases: [InvocationType] {
            return [
                .async
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .async: return "ASYNC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    /// Stores metadata about a Lambda processor.
    public struct LambdaConfiguration: Swift.Sendable {
        /// Controls how the Lambda function is invoked.
        /// This member is required.
        public var invocationType: ChimeSDKMessagingClientTypes.InvocationType?
        /// The ARN of the Lambda message processing function.
        /// This member is required.
        public var resourceArn: Swift.String?

        public init(
            invocationType: ChimeSDKMessagingClientTypes.InvocationType? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.invocationType = invocationType
            self.resourceArn = resourceArn
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    /// A processor's metadata.
    public struct ProcessorConfiguration: Swift.Sendable {
        /// Indicates that the processor is of type Lambda.
        /// This member is required.
        public var lambda: ChimeSDKMessagingClientTypes.LambdaConfiguration?

        public init(
            lambda: ChimeSDKMessagingClientTypes.LambdaConfiguration? = nil
        )
        {
            self.lambda = lambda
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    public enum FallbackAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case abort
        case `continue`
        case sdkUnknown(Swift.String)

        public static var allCases: [FallbackAction] {
            return [
                .abort,
                .continue
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .abort: return "ABORT"
            case .continue: return "CONTINUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    /// The information about a processor in a channel flow.
    public struct Processor: Swift.Sendable {
        /// The information about the type of processor and its identifier.
        /// This member is required.
        public var configuration: ChimeSDKMessagingClientTypes.ProcessorConfiguration?
        /// The sequence in which processors run. If you have multiple processors in a channel flow, message processing goes through each processor in the sequence. The value determines the sequence. At this point, we support only 1 processor within a flow.
        /// This member is required.
        public var executionOrder: Swift.Int?
        /// Determines whether to continue with message processing or stop it in cases where communication with a processor fails. If a processor has a fallback action of ABORT and communication with it fails, the processor sets the message status to FAILED and does not send the message to any recipients. Note that if the last processor in the channel flow sequence has a fallback action of CONTINUE and communication with the processor fails, then the message is considered processed and sent to recipients of the channel.
        /// This member is required.
        public var fallbackAction: ChimeSDKMessagingClientTypes.FallbackAction?
        /// The name of the channel flow.
        /// This member is required.
        public var name: Swift.String?

        public init(
            configuration: ChimeSDKMessagingClientTypes.ProcessorConfiguration? = nil,
            executionOrder: Swift.Int? = nil,
            fallbackAction: ChimeSDKMessagingClientTypes.FallbackAction? = nil,
            name: Swift.String? = nil
        )
        {
            self.configuration = configuration
            self.executionOrder = executionOrder
            self.fallbackAction = fallbackAction
            self.name = name
        }
    }
}

extension ChimeSDKMessagingClientTypes.Processor: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Processor(configuration: \(Swift.String(describing: configuration)), executionOrder: \(Swift.String(describing: executionOrder)), fallbackAction: \(Swift.String(describing: fallbackAction)), name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {

    /// The details of a channel flow.
    public struct ChannelFlow: Swift.Sendable {
        /// The ARN of the channel flow.
        public var channelFlowArn: Swift.String?
        /// The time at which the channel flow was created.
        public var createdTimestamp: Foundation.Date?
        /// The time at which a channel flow was updated.
        public var lastUpdatedTimestamp: Foundation.Date?
        /// The name of the channel flow.
        public var name: Swift.String?
        /// Information about the processor Lambda functions.
        public var processors: [ChimeSDKMessagingClientTypes.Processor]?

        public init(
            channelFlowArn: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            lastUpdatedTimestamp: Foundation.Date? = nil,
            name: Swift.String? = nil,
            processors: [ChimeSDKMessagingClientTypes.Processor]? = nil
        )
        {
            self.channelFlowArn = channelFlowArn
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.name = name
            self.processors = processors
        }
    }
}

extension ChimeSDKMessagingClientTypes.ChannelFlow: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelFlow(channelFlowArn: \(Swift.String(describing: channelFlowArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), processors: \(Swift.String(describing: processors)), name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {

    /// A list of message attribute values.
    public struct MessageAttributeValue: Swift.Sendable {
        /// The strings in a message attribute value.
        public var stringValues: [Swift.String]?

        public init(
            stringValues: [Swift.String]? = nil
        )
        {
            self.stringValues = stringValues
        }
    }
}

extension ChimeSDKMessagingClientTypes.MessageAttributeValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MessageAttributeValue(stringValues: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {

    public enum PushNotificationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case voip
        case sdkUnknown(Swift.String)

        public static var allCases: [PushNotificationType] {
            return [
                .default,
                .voip
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .voip: return "VOIP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    /// The push notification configuration of the message.
    public struct PushNotificationConfiguration: Swift.Sendable {
        /// The body of the push notification.
        public var body: Swift.String?
        /// The title of the push notification.
        public var title: Swift.String?
        /// Enum value that indicates the type of the push notification for a message. DEFAULT: Normal mobile push notification. VOIP: VOIP mobile push notification.
        public var type: ChimeSDKMessagingClientTypes.PushNotificationType?

        public init(
            body: Swift.String? = nil,
            title: Swift.String? = nil,
            type: ChimeSDKMessagingClientTypes.PushNotificationType? = nil
        )
        {
            self.body = body
            self.title = title
            self.type = type
        }
    }
}

extension ChimeSDKMessagingClientTypes.PushNotificationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PushNotificationConfiguration(type: \(Swift.String(describing: type)), body: \"CONTENT_REDACTED\", title: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {

    /// Stores information about a callback.
    public struct ChannelMessageCallback: Swift.Sendable {
        /// The message content. For Amazon Lex V2 bot responses, this field holds a list of messages originating from the bot. For more information, refer to [Processing responses from an AppInstanceBot](https://docs.aws.amazon.com/chime-sdk/latest/dg/appinstance-bots#process-response.html) in the Amazon Chime SDK Messaging Developer Guide.
        public var content: Swift.String?
        /// The content type of the call-back message. For Amazon Lex V2 bot responses, the content type is application/amz-chime-lex-msgs for success responses and application/amz-chime-lex-error for failure responses. For more information, refer to [Processing responses from an AppInstanceBot](https://docs.aws.amazon.com/chime-sdk/latest/dg/appinstance-bots#process-response.html) in the Amazon Chime SDK Messaging Developer Guide.
        public var contentType: Swift.String?
        /// The attributes for the channel message. For Amazon Lex V2 bot responses, the attributes are mapped to specific fields from the bot. For more information, refer to [Processing responses from an AppInstanceBot](https://docs.aws.amazon.com/chime-sdk/latest/dg/appinstance-bots#process-response.html) in the Amazon Chime SDK Messaging Developer Guide.
        public var messageAttributes: [Swift.String: ChimeSDKMessagingClientTypes.MessageAttributeValue]?
        /// The message ID.
        /// This member is required.
        public var messageId: Swift.String?
        /// The message metadata.
        public var metadata: Swift.String?
        /// The push notification configuration of the message.
        public var pushNotification: ChimeSDKMessagingClientTypes.PushNotificationConfiguration?
        /// The ID of the SubChannel.
        public var subChannelId: Swift.String?

        public init(
            content: Swift.String? = nil,
            contentType: Swift.String? = nil,
            messageAttributes: [Swift.String: ChimeSDKMessagingClientTypes.MessageAttributeValue]? = nil,
            messageId: Swift.String? = nil,
            metadata: Swift.String? = nil,
            pushNotification: ChimeSDKMessagingClientTypes.PushNotificationConfiguration? = nil,
            subChannelId: Swift.String? = nil
        )
        {
            self.content = content
            self.contentType = contentType
            self.messageAttributes = messageAttributes
            self.messageId = messageId
            self.metadata = metadata
            self.pushNotification = pushNotification
            self.subChannelId = subChannelId
        }
    }
}

extension ChimeSDKMessagingClientTypes.ChannelMessageCallback: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMessageCallback(messageId: \(Swift.String(describing: messageId)), pushNotification: \(Swift.String(describing: pushNotification)), subChannelId: \(Swift.String(describing: subChannelId)), content: \"CONTENT_REDACTED\", contentType: \"CONTENT_REDACTED\", messageAttributes: [keys: \"CONTENT_REDACTED\", values: \(Swift.String(describing: messageAttributes?.values))], metadata: \"CONTENT_REDACTED\")"}
}

public struct ChannelFlowCallbackInput: Swift.Sendable {
    /// The identifier passed to the processor by the service when invoked. Use the identifier to call back the service.
    /// This member is required.
    public var callbackId: Swift.String?
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// Stores information about the processed message.
    /// This member is required.
    public var channelMessage: ChimeSDKMessagingClientTypes.ChannelMessageCallback?
    /// When a processor determines that a message needs to be DENIED, pass this parameter with a value of true.
    public var deleteResource: Swift.Bool?

    public init(
        callbackId: Swift.String? = nil,
        channelArn: Swift.String? = nil,
        channelMessage: ChimeSDKMessagingClientTypes.ChannelMessageCallback? = nil,
        deleteResource: Swift.Bool? = false
    )
    {
        self.callbackId = callbackId
        self.channelArn = channelArn
        self.channelMessage = channelMessage
        self.deleteResource = deleteResource
    }
}

public struct ChannelFlowCallbackOutput: Swift.Sendable {
    /// The call back ID passed in the request.
    public var callbackId: Swift.String?
    /// The ARN of the channel.
    public var channelArn: Swift.String?

    public init(
        callbackId: Swift.String? = nil,
        channelArn: Swift.String? = nil
    )
    {
        self.callbackId = callbackId
        self.channelArn = channelArn
    }
}

extension ChimeSDKMessagingClientTypes {

    /// Summary of details of a channel flow.
    public struct ChannelFlowSummary: Swift.Sendable {
        /// The ARN of the channel flow.
        public var channelFlowArn: Swift.String?
        /// The name of the channel flow.
        public var name: Swift.String?
        /// Information about the processor Lambda functions.
        public var processors: [ChimeSDKMessagingClientTypes.Processor]?

        public init(
            channelFlowArn: Swift.String? = nil,
            name: Swift.String? = nil,
            processors: [ChimeSDKMessagingClientTypes.Processor]? = nil
        )
        {
            self.channelFlowArn = channelFlowArn
            self.name = name
            self.processors = processors
        }
    }
}

extension ChimeSDKMessagingClientTypes.ChannelFlowSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelFlowSummary(channelFlowArn: \(Swift.String(describing: channelFlowArn)), processors: \(Swift.String(describing: processors)), name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {

    /// The details of a channel member.
    public struct ChannelMembership: Swift.Sendable {
        /// The ARN of the member's channel.
        public var channelArn: Swift.String?
        /// The time at which the channel membership was created.
        public var createdTimestamp: Foundation.Date?
        /// The identifier of the member who invited another member.
        public var invitedBy: ChimeSDKMessagingClientTypes.Identity?
        /// The time at which a channel membership was last updated.
        public var lastUpdatedTimestamp: Foundation.Date?
        /// The data of the channel member.
        public var member: ChimeSDKMessagingClientTypes.Identity?
        /// The ID of the SubChannel that a user belongs to.
        public var subChannelId: Swift.String?
        /// The membership type set for the channel member.
        public var type: ChimeSDKMessagingClientTypes.ChannelMembershipType?

        public init(
            channelArn: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            invitedBy: ChimeSDKMessagingClientTypes.Identity? = nil,
            lastUpdatedTimestamp: Foundation.Date? = nil,
            member: ChimeSDKMessagingClientTypes.Identity? = nil,
            subChannelId: Swift.String? = nil,
            type: ChimeSDKMessagingClientTypes.ChannelMembershipType? = nil
        )
        {
            self.channelArn = channelArn
            self.createdTimestamp = createdTimestamp
            self.invitedBy = invitedBy
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.member = member
            self.subChannelId = subChannelId
            self.type = type
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    /// Summary of the details of a Channel.
    public struct ChannelSummary: Swift.Sendable {
        /// The ARN of the channel.
        public var channelArn: Swift.String?
        /// The time at which the last persistent message visible to the caller in a channel was sent.
        public var lastMessageTimestamp: Foundation.Date?
        /// The metadata of the channel.
        public var metadata: Swift.String?
        /// The mode of the channel.
        public var mode: ChimeSDKMessagingClientTypes.ChannelMode?
        /// The name of the channel.
        public var name: Swift.String?
        /// The privacy setting of the channel.
        public var privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy?

        public init(
            channelArn: Swift.String? = nil,
            lastMessageTimestamp: Foundation.Date? = nil,
            metadata: Swift.String? = nil,
            mode: ChimeSDKMessagingClientTypes.ChannelMode? = nil,
            name: Swift.String? = nil,
            privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy? = nil
        )
        {
            self.channelArn = channelArn
            self.lastMessageTimestamp = lastMessageTimestamp
            self.metadata = metadata
            self.mode = mode
            self.name = name
            self.privacy = privacy
        }
    }
}

extension ChimeSDKMessagingClientTypes.ChannelSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelSummary(channelArn: \(Swift.String(describing: channelArn)), lastMessageTimestamp: \(Swift.String(describing: lastMessageTimestamp)), mode: \(Swift.String(describing: mode)), privacy: \(Swift.String(describing: privacy)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {

    /// Summary of the channel membership details of an AppInstanceUser.
    public struct ChannelMembershipForAppInstanceUserSummary: Swift.Sendable {
        /// Returns the channel membership data for an AppInstance.
        public var appInstanceUserMembershipSummary: ChimeSDKMessagingClientTypes.AppInstanceUserMembershipSummary?
        /// Returns the channel data for an AppInstance.
        public var channelSummary: ChimeSDKMessagingClientTypes.ChannelSummary?

        public init(
            appInstanceUserMembershipSummary: ChimeSDKMessagingClientTypes.AppInstanceUserMembershipSummary? = nil,
            channelSummary: ChimeSDKMessagingClientTypes.ChannelSummary? = nil
        )
        {
            self.appInstanceUserMembershipSummary = appInstanceUserMembershipSummary
            self.channelSummary = channelSummary
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    /// The channel membership preferences for push notification.
    public struct PushNotificationPreferences: Swift.Sendable {
        /// Enum value that indicates which push notifications to send to the requested member of a channel. ALL sends all push notifications, NONE sends no push notifications, FILTERED sends only filtered push notifications.
        /// This member is required.
        public var allowNotifications: ChimeSDKMessagingClientTypes.AllowNotifications?
        /// The simple JSON object used to send a subset of a push notification to the requested member.
        public var filterRule: Swift.String?

        public init(
            allowNotifications: ChimeSDKMessagingClientTypes.AllowNotifications? = nil,
            filterRule: Swift.String? = nil
        )
        {
            self.allowNotifications = allowNotifications
            self.filterRule = filterRule
        }
    }
}

extension ChimeSDKMessagingClientTypes.PushNotificationPreferences: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PushNotificationPreferences(allowNotifications: \(Swift.String(describing: allowNotifications)), filterRule: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {

    /// The channel membership preferences for an AppInstanceUser.
    public struct ChannelMembershipPreferences: Swift.Sendable {
        /// The push notification configuration of a message.
        public var pushNotifications: ChimeSDKMessagingClientTypes.PushNotificationPreferences?

        public init(
            pushNotifications: ChimeSDKMessagingClientTypes.PushNotificationPreferences? = nil
        )
        {
            self.pushNotifications = pushNotifications
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    /// Summary of the details of a ChannelMembership.
    public struct ChannelMembershipSummary: Swift.Sendable {
        /// A member's summary data.
        public var member: ChimeSDKMessagingClientTypes.Identity?

        public init(
            member: ChimeSDKMessagingClientTypes.Identity? = nil
        )
        {
            self.member = member
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    public enum ChannelMessagePersistenceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case nonPersistent
        case persistent
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMessagePersistenceType] {
            return [
                .nonPersistent,
                .persistent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .nonPersistent: return "NON_PERSISTENT"
            case .persistent: return "PERSISTENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    public enum ChannelMessageStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case denied
        case failed
        case pending
        case sent
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMessageStatus] {
            return [
                .denied,
                .failed,
                .pending,
                .sent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .denied: return "DENIED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .sent: return "SENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    /// Stores information about a message status.
    public struct ChannelMessageStatusStructure: Swift.Sendable {
        /// Contains more details about the message status.
        public var detail: Swift.String?
        /// The message status value.
        public var value: ChimeSDKMessagingClientTypes.ChannelMessageStatus?

        public init(
            detail: Swift.String? = nil,
            value: ChimeSDKMessagingClientTypes.ChannelMessageStatus? = nil
        )
        {
            self.detail = detail
            self.value = value
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    /// The target of a message, a sender, a user, or a bot. Only the target and the sender can view targeted messages. Only users who can see targeted messages can take actions on them. However, administrators can delete targeted messages that they cant see.
    public struct Target: Swift.Sendable {
        /// The ARN of the target channel member.
        public var memberArn: Swift.String?

        public init(
            memberArn: Swift.String? = nil
        )
        {
            self.memberArn = memberArn
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    public enum ChannelMessageType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case control
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelMessageType] {
            return [
                .control,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .control: return "CONTROL"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    /// The details of a message in a channel.
    public struct ChannelMessage: Swift.Sendable {
        /// The ARN of the channel.
        public var channelArn: Swift.String?
        /// The content of the channel message. For Amazon Lex V2 bot responses, this field holds a list of messages originating from the bot. For more information, refer to [Processing responses from an AppInstanceBot](https://docs.aws.amazon.com/chime-sdk/latest/dg/appinstance-bots#process-response.html) in the Amazon Chime SDK Messaging Developer Guide.
        public var content: Swift.String?
        /// The content type of the channel message. For Amazon Lex V2 bot responses, the content type is application/amz-chime-lex-msgs for success responses and application/amz-chime-lex-error for failure responses. For more information, refer to [Processing responses from an AppInstanceBot](https://docs.aws.amazon.com/chime-sdk/latest/dg/appinstance-bots#process-response.html) in the Amazon Chime SDK Messaging Developer Guide.
        public var contentType: Swift.String?
        /// The time at which the message was created.
        public var createdTimestamp: Foundation.Date?
        /// The time at which a message was edited.
        public var lastEditedTimestamp: Foundation.Date?
        /// The time at which a message was updated.
        public var lastUpdatedTimestamp: Foundation.Date?
        /// The attributes for the channel message. For Amazon Lex V2 bot responses, the attributes are mapped to specific fields from the bot. For more information, refer to [Processing responses from an AppInstanceBot](https://docs.aws.amazon.com/chime-sdk/latest/dg/appinstance-bots#process-response.html) in the Amazon Chime SDK Messaging Developer Guide.
        public var messageAttributes: [Swift.String: ChimeSDKMessagingClientTypes.MessageAttributeValue]?
        /// The ID of a message.
        public var messageId: Swift.String?
        /// The message metadata.
        public var metadata: Swift.String?
        /// The persistence setting for a channel message.
        public var persistence: ChimeSDKMessagingClientTypes.ChannelMessagePersistenceType?
        /// Hides the content of a message.
        public var redacted: Swift.Bool
        /// The message sender.
        public var sender: ChimeSDKMessagingClientTypes.Identity?
        /// The status of the channel message.
        public var status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure?
        /// The ID of the SubChannel.
        public var subChannelId: Swift.String?
        /// The target of a message, a sender, a user, or a bot. Only the target and the sender can view targeted messages. Only users who can see targeted messages can take actions on them. However, administrators can delete targeted messages that they cant see.
        public var target: [ChimeSDKMessagingClientTypes.Target]?
        /// The message type.
        public var type: ChimeSDKMessagingClientTypes.ChannelMessageType?

        public init(
            channelArn: Swift.String? = nil,
            content: Swift.String? = nil,
            contentType: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            lastEditedTimestamp: Foundation.Date? = nil,
            lastUpdatedTimestamp: Foundation.Date? = nil,
            messageAttributes: [Swift.String: ChimeSDKMessagingClientTypes.MessageAttributeValue]? = nil,
            messageId: Swift.String? = nil,
            metadata: Swift.String? = nil,
            persistence: ChimeSDKMessagingClientTypes.ChannelMessagePersistenceType? = nil,
            redacted: Swift.Bool = false,
            sender: ChimeSDKMessagingClientTypes.Identity? = nil,
            status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure? = nil,
            subChannelId: Swift.String? = nil,
            target: [ChimeSDKMessagingClientTypes.Target]? = nil,
            type: ChimeSDKMessagingClientTypes.ChannelMessageType? = nil
        )
        {
            self.channelArn = channelArn
            self.content = content
            self.contentType = contentType
            self.createdTimestamp = createdTimestamp
            self.lastEditedTimestamp = lastEditedTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.messageAttributes = messageAttributes
            self.messageId = messageId
            self.metadata = metadata
            self.persistence = persistence
            self.redacted = redacted
            self.sender = sender
            self.status = status
            self.subChannelId = subChannelId
            self.target = target
            self.type = type
        }
    }
}

extension ChimeSDKMessagingClientTypes.ChannelMessage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMessage(channelArn: \(Swift.String(describing: channelArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastEditedTimestamp: \(Swift.String(describing: lastEditedTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), messageId: \(Swift.String(describing: messageId)), persistence: \(Swift.String(describing: persistence)), redacted: \(Swift.String(describing: redacted)), sender: \(Swift.String(describing: sender)), status: \(Swift.String(describing: status)), subChannelId: \(Swift.String(describing: subChannelId)), target: \(Swift.String(describing: target)), type: \(Swift.String(describing: type)), content: \"CONTENT_REDACTED\", contentType: \"CONTENT_REDACTED\", messageAttributes: [keys: \"CONTENT_REDACTED\", values: \(Swift.String(describing: messageAttributes?.values))], metadata: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {

    /// Summary of the messages in a Channel.
    public struct ChannelMessageSummary: Swift.Sendable {
        /// The content of the channel message. For Amazon Lex V2 bot responses, this field holds a list of messages originating from the bot. For more information, refer to [Processing responses from an AppInstanceBot](https://docs.aws.amazon.com/chime-sdk/latest/dg/appinstance-bots#process-response.html) in the Amazon Chime SDK Messaging Developer Guide.
        public var content: Swift.String?
        /// The content type of the channel message listed in the summary. For Amazon Lex V2 bot responses, the content type is application/amz-chime-lex-msgs for success responses and application/amz-chime-lex-error for failure responses. For more information, refer to [Processing responses from an AppInstanceBot](https://docs.aws.amazon.com/chime-sdk/latest/dg/appinstance-bots#process-response.html) in the Amazon Chime SDK Messaging Developer Guide.
        public var contentType: Swift.String?
        /// The time at which the message summary was created.
        public var createdTimestamp: Foundation.Date?
        /// The time at which a message was last edited.
        public var lastEditedTimestamp: Foundation.Date?
        /// The time at which a message was last updated.
        public var lastUpdatedTimestamp: Foundation.Date?
        /// The attributes for the channel message. For Amazon Lex V2 bot responses, the attributes are mapped to specific fields from the bot. For more information, refer to [Processing responses from an AppInstanceBot](https://docs.aws.amazon.com/chime-sdk/latest/dg/appinstance-bots#process-response.html) in the Amazon Chime SDK Messaging Developer Guide.
        public var messageAttributes: [Swift.String: ChimeSDKMessagingClientTypes.MessageAttributeValue]?
        /// The ID of the message.
        public var messageId: Swift.String?
        /// The metadata of the message.
        public var metadata: Swift.String?
        /// Indicates whether a message was redacted.
        public var redacted: Swift.Bool
        /// The message sender.
        public var sender: ChimeSDKMessagingClientTypes.Identity?
        /// The message status. The status value is SENT for messages sent to a channel without a channel flow. For channels associated with channel flow, the value determines the processing stage.
        public var status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure?
        /// The target of a message, a sender, a user, or a bot. Only the target and the sender can view targeted messages. Only users who can see targeted messages can take actions on them. However, administrators can delete targeted messages that they cant see.
        public var target: [ChimeSDKMessagingClientTypes.Target]?
        /// The type of message.
        public var type: ChimeSDKMessagingClientTypes.ChannelMessageType?

        public init(
            content: Swift.String? = nil,
            contentType: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            lastEditedTimestamp: Foundation.Date? = nil,
            lastUpdatedTimestamp: Foundation.Date? = nil,
            messageAttributes: [Swift.String: ChimeSDKMessagingClientTypes.MessageAttributeValue]? = nil,
            messageId: Swift.String? = nil,
            metadata: Swift.String? = nil,
            redacted: Swift.Bool = false,
            sender: ChimeSDKMessagingClientTypes.Identity? = nil,
            status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure? = nil,
            target: [ChimeSDKMessagingClientTypes.Target]? = nil,
            type: ChimeSDKMessagingClientTypes.ChannelMessageType? = nil
        )
        {
            self.content = content
            self.contentType = contentType
            self.createdTimestamp = createdTimestamp
            self.lastEditedTimestamp = lastEditedTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.messageAttributes = messageAttributes
            self.messageId = messageId
            self.metadata = metadata
            self.redacted = redacted
            self.sender = sender
            self.status = status
            self.target = target
            self.type = type
        }
    }
}

extension ChimeSDKMessagingClientTypes.ChannelMessageSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChannelMessageSummary(createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastEditedTimestamp: \(Swift.String(describing: lastEditedTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), messageId: \(Swift.String(describing: messageId)), redacted: \(Swift.String(describing: redacted)), sender: \(Swift.String(describing: sender)), status: \(Swift.String(describing: status)), target: \(Swift.String(describing: target)), type: \(Swift.String(describing: type)), content: \"CONTENT_REDACTED\", contentType: \"CONTENT_REDACTED\", messageAttributes: [keys: \"CONTENT_REDACTED\", values: \(Swift.String(describing: messageAttributes?.values))], metadata: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {

    /// Summary of the details of a moderated channel.
    public struct ChannelModeratedByAppInstanceUserSummary: Swift.Sendable {
        /// Summary of the details of a Channel.
        public var channelSummary: ChimeSDKMessagingClientTypes.ChannelSummary?

        public init(
            channelSummary: ChimeSDKMessagingClientTypes.ChannelSummary? = nil
        )
        {
            self.channelSummary = channelSummary
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    /// The details of a channel moderator.
    public struct ChannelModerator: Swift.Sendable {
        /// The ARN of the moderator's channel.
        public var channelArn: Swift.String?
        /// The AppInstanceUser who created the moderator.
        public var createdBy: ChimeSDKMessagingClientTypes.Identity?
        /// The time at which the moderator was created.
        public var createdTimestamp: Foundation.Date?
        /// The moderator's data.
        public var moderator: ChimeSDKMessagingClientTypes.Identity?

        public init(
            channelArn: Swift.String? = nil,
            createdBy: ChimeSDKMessagingClientTypes.Identity? = nil,
            createdTimestamp: Foundation.Date? = nil,
            moderator: ChimeSDKMessagingClientTypes.Identity? = nil
        )
        {
            self.channelArn = channelArn
            self.createdBy = createdBy
            self.createdTimestamp = createdTimestamp
            self.moderator = moderator
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    /// Summary of the details of a ChannelModerator.
    public struct ChannelModeratorSummary: Swift.Sendable {
        /// The data for a moderator.
        public var moderator: ChimeSDKMessagingClientTypes.Identity?

        public init(
            moderator: ChimeSDKMessagingClientTypes.Identity? = nil
        )
        {
            self.moderator = moderator
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    /// A tag object containing a key-value pair.
    public struct Tag: Swift.Sendable {
        /// The key in a tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value in a tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension ChimeSDKMessagingClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

public struct CreateChannelInput: Swift.Sendable {
    /// The ARN of the channel request.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The ID of the channel in the request.
    public var channelId: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The client token for the request. An Idempotency token.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The attributes required to configure and create an elastic channel. An elastic channel can support a maximum of 1-million users, excluding moderators.
    public var elasticChannelConfiguration: ChimeSDKMessagingClientTypes.ElasticChannelConfiguration?
    /// Settings that control the interval after which the channel is automatically deleted.
    public var expirationSettings: ChimeSDKMessagingClientTypes.ExpirationSettings?
    /// The ARNs of the channel members in the request.
    public var memberArns: [Swift.String]?
    /// The metadata of the creation request. Limited to 1KB and UTF-8.
    public var metadata: Swift.String?
    /// The channel mode: UNRESTRICTED or RESTRICTED. Administrators, moderators, and channel members can add themselves and other members to unrestricted channels. Only administrators and moderators can add members to restricted channels.
    public var mode: ChimeSDKMessagingClientTypes.ChannelMode?
    /// The ARNs of the channel moderators in the request.
    public var moderatorArns: [Swift.String]?
    /// The name of the channel.
    /// This member is required.
    public var name: Swift.String?
    /// The channel's privacy level: PUBLIC or PRIVATE. Private channels aren't discoverable by users outside the channel. Public channels are discoverable by anyone in the AppInstance.
    public var privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy?
    /// The tags for the creation request.
    public var tags: [ChimeSDKMessagingClientTypes.Tag]?

    public init(
        appInstanceArn: Swift.String? = nil,
        channelId: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        elasticChannelConfiguration: ChimeSDKMessagingClientTypes.ElasticChannelConfiguration? = nil,
        expirationSettings: ChimeSDKMessagingClientTypes.ExpirationSettings? = nil,
        memberArns: [Swift.String]? = nil,
        metadata: Swift.String? = nil,
        mode: ChimeSDKMessagingClientTypes.ChannelMode? = nil,
        moderatorArns: [Swift.String]? = nil,
        name: Swift.String? = nil,
        privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy? = nil,
        tags: [ChimeSDKMessagingClientTypes.Tag]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.channelId = channelId
        self.chimeBearer = chimeBearer
        self.clientRequestToken = clientRequestToken
        self.elasticChannelConfiguration = elasticChannelConfiguration
        self.expirationSettings = expirationSettings
        self.memberArns = memberArns
        self.metadata = metadata
        self.mode = mode
        self.moderatorArns = moderatorArns
        self.name = name
        self.privacy = privacy
        self.tags = tags
    }
}

extension CreateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), elasticChannelConfiguration: \(Swift.String(describing: elasticChannelConfiguration)), expirationSettings: \(Swift.String(describing: expirationSettings)), memberArns: \(Swift.String(describing: memberArns)), mode: \(Swift.String(describing: mode)), moderatorArns: \(Swift.String(describing: moderatorArns)), privacy: \(Swift.String(describing: privacy)), tags: \(Swift.String(describing: tags)), channelId: \"CONTENT_REDACTED\", clientRequestToken: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateChannelOutput: Swift.Sendable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

public struct CreateChannelBanInput: Swift.Sendable {
    /// The ARN of the ban request.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member being banned.
    /// This member is required.
    public var memberArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

public struct CreateChannelBanOutput: Swift.Sendable {
    /// The ARN of the response to the ban request.
    public var channelArn: Swift.String?
    /// The ChannelArn and BannedIdentity of the member in the ban response.
    public var member: ChimeSDKMessagingClientTypes.Identity?

    public init(
        channelArn: Swift.String? = nil,
        member: ChimeSDKMessagingClientTypes.Identity? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
    }
}

public struct CreateChannelFlowInput: Swift.Sendable {
    /// The ARN of the channel flow request.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The client token for the request. An Idempotency token.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The name of the channel flow.
    /// This member is required.
    public var name: Swift.String?
    /// Information about the processor Lambda functions.
    /// This member is required.
    public var processors: [ChimeSDKMessagingClientTypes.Processor]?
    /// The tags for the creation request.
    public var tags: [ChimeSDKMessagingClientTypes.Tag]?

    public init(
        appInstanceArn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil,
        processors: [ChimeSDKMessagingClientTypes.Processor]? = nil,
        tags: [ChimeSDKMessagingClientTypes.Tag]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.processors = processors
        self.tags = tags
    }
}

extension CreateChannelFlowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateChannelFlowInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), processors: \(Swift.String(describing: processors)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateChannelFlowOutput: Swift.Sendable {
    /// The ARN of the channel flow.
    public var channelFlowArn: Swift.String?

    public init(
        channelFlowArn: Swift.String? = nil
    )
    {
        self.channelFlowArn = channelFlowArn
    }
}

public struct CreateChannelMembershipInput: Swift.Sendable {
    /// The ARN of the channel to which you're adding users.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member you want to add to the channel.
    /// This member is required.
    public var memberArn: Swift.String?
    /// The ID of the SubChannel in the request. Only required when creating membership in a SubChannel for a moderator in an elastic channel.
    public var subChannelId: Swift.String?
    /// The membership type of a user, DEFAULT or HIDDEN. Default members are always returned as part of ListChannelMemberships. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN. Otherwise hidden members are not returned. This is only supported by moderators.
    /// This member is required.
    public var type: ChimeSDKMessagingClientTypes.ChannelMembershipType?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil,
        subChannelId: Swift.String? = nil,
        type: ChimeSDKMessagingClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
        self.subChannelId = subChannelId
        self.type = type
    }
}

public struct CreateChannelMembershipOutput: Swift.Sendable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ARN and metadata of the member being added.
    public var member: ChimeSDKMessagingClientTypes.Identity?
    /// The ID of the SubChannel in the response.
    public var subChannelId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        member: ChimeSDKMessagingClientTypes.Identity? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
        self.subChannelId = subChannelId
    }
}

public struct CreateChannelModeratorInput: Swift.Sendable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the moderator.
    /// This member is required.
    public var channelModeratorArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

public struct CreateChannelModeratorOutput: Swift.Sendable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ARNs of the channel and the moderator.
    public var channelModerator: ChimeSDKMessagingClientTypes.Identity?

    public init(
        channelArn: Swift.String? = nil,
        channelModerator: ChimeSDKMessagingClientTypes.Identity? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModerator = channelModerator
    }
}

public struct DeleteChannelInput: Swift.Sendable {
    /// The ARN of the channel being deleted.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

public struct DeleteChannelBanInput: Swift.Sendable {
    /// The ARN of the channel from which the AppInstanceUser was banned.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ARN of the AppInstanceUser that you want to reinstate.
    /// This member is required.
    public var memberArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

public struct DeleteChannelFlowInput: Swift.Sendable {
    /// The ARN of the channel flow.
    /// This member is required.
    public var channelFlowArn: Swift.String?

    public init(
        channelFlowArn: Swift.String? = nil
    )
    {
        self.channelFlowArn = channelFlowArn
    }
}

public struct DeleteChannelMembershipInput: Swift.Sendable {
    /// The ARN of the channel from which you want to remove the user.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member that you're removing from the channel.
    /// This member is required.
    public var memberArn: Swift.String?
    /// The ID of the SubChannel in the request. Only for use by moderators.
    public var subChannelId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
        self.subChannelId = subChannelId
    }
}

public struct DeleteChannelMessageInput: Swift.Sendable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ID of the message being deleted.
    /// This member is required.
    public var messageId: Swift.String?
    /// The ID of the SubChannel in the request. Only required when deleting messages in a SubChannel that the user belongs to.
    public var subChannelId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
        self.subChannelId = subChannelId
    }
}

public struct DeleteChannelModeratorInput: Swift.Sendable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the moderator being deleted.
    /// This member is required.
    public var channelModeratorArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

public struct DeleteMessagingStreamingConfigurationsInput: Swift.Sendable {
    /// The ARN of the streaming configurations being deleted.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

public struct DescribeChannelInput: Swift.Sendable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

public struct DescribeChannelOutput: Swift.Sendable {
    /// The channel details.
    public var channel: ChimeSDKMessagingClientTypes.Channel?

    public init(
        channel: ChimeSDKMessagingClientTypes.Channel? = nil
    )
    {
        self.channel = channel
    }
}

public struct DescribeChannelBanInput: Swift.Sendable {
    /// The ARN of the channel from which the user is banned.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member being banned.
    /// This member is required.
    public var memberArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

public struct DescribeChannelBanOutput: Swift.Sendable {
    /// The details of the ban.
    public var channelBan: ChimeSDKMessagingClientTypes.ChannelBan?

    public init(
        channelBan: ChimeSDKMessagingClientTypes.ChannelBan? = nil
    )
    {
        self.channelBan = channelBan
    }
}

public struct DescribeChannelFlowInput: Swift.Sendable {
    /// The ARN of the channel flow.
    /// This member is required.
    public var channelFlowArn: Swift.String?

    public init(
        channelFlowArn: Swift.String? = nil
    )
    {
        self.channelFlowArn = channelFlowArn
    }
}

public struct DescribeChannelFlowOutput: Swift.Sendable {
    /// The channel flow details.
    public var channelFlow: ChimeSDKMessagingClientTypes.ChannelFlow?

    public init(
        channelFlow: ChimeSDKMessagingClientTypes.ChannelFlow? = nil
    )
    {
        self.channelFlow = channelFlow
    }
}

public struct DescribeChannelMembershipInput: Swift.Sendable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member.
    /// This member is required.
    public var memberArn: Swift.String?
    /// The ID of the SubChannel in the request. The response contains an ElasticChannelConfiguration object. Only required to get a users SubChannel membership details.
    public var subChannelId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
        self.subChannelId = subChannelId
    }
}

public struct DescribeChannelMembershipOutput: Swift.Sendable {
    /// The details of the membership.
    public var channelMembership: ChimeSDKMessagingClientTypes.ChannelMembership?

    public init(
        channelMembership: ChimeSDKMessagingClientTypes.ChannelMembership? = nil
    )
    {
        self.channelMembership = channelMembership
    }
}

public struct DescribeChannelMembershipForAppInstanceUserInput: Swift.Sendable {
    /// The ARN of the user or bot in a channel.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The ARN of the channel to which the user belongs.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

public struct DescribeChannelMembershipForAppInstanceUserOutput: Swift.Sendable {
    /// The channel to which a user belongs.
    public var channelMembership: ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary?

    public init(
        channelMembership: ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary? = nil
    )
    {
        self.channelMembership = channelMembership
    }
}

public struct DescribeChannelModeratedByAppInstanceUserInput: Swift.Sendable {
    /// The ARN of the user or bot in the moderated channel.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The ARN of the moderated channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

public struct DescribeChannelModeratedByAppInstanceUserOutput: Swift.Sendable {
    /// The moderated channel.
    public var channel: ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary?

    public init(
        channel: ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary? = nil
    )
    {
        self.channel = channel
    }
}

public struct DescribeChannelModeratorInput: Swift.Sendable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the channel moderator.
    /// This member is required.
    public var channelModeratorArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelModeratorArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModeratorArn = channelModeratorArn
        self.chimeBearer = chimeBearer
    }
}

public struct DescribeChannelModeratorOutput: Swift.Sendable {
    /// The details of the channel moderator.
    public var channelModerator: ChimeSDKMessagingClientTypes.ChannelModerator?

    public init(
        channelModerator: ChimeSDKMessagingClientTypes.ChannelModerator? = nil
    )
    {
        self.channelModerator = channelModerator
    }
}

public struct DisassociateChannelFlowInput: Swift.Sendable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the channel flow.
    /// This member is required.
    public var channelFlowArn: Swift.String?
    /// The AppInstanceUserArn of the user making the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelFlowArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelFlowArn = channelFlowArn
        self.chimeBearer = chimeBearer
    }
}

public struct GetChannelMembershipPreferencesInput: Swift.Sendable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The AppInstanceUserArn of the member retrieving the preferences.
    /// This member is required.
    public var memberArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
    }
}

public struct GetChannelMembershipPreferencesOutput: Swift.Sendable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The details of a user.
    public var member: ChimeSDKMessagingClientTypes.Identity?
    /// The channel membership preferences for an AppInstanceUser .
    public var preferences: ChimeSDKMessagingClientTypes.ChannelMembershipPreferences?

    public init(
        channelArn: Swift.String? = nil,
        member: ChimeSDKMessagingClientTypes.Identity? = nil,
        preferences: ChimeSDKMessagingClientTypes.ChannelMembershipPreferences? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
        self.preferences = preferences
    }
}

public struct GetChannelMessageInput: Swift.Sendable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ID of the message.
    /// This member is required.
    public var messageId: Swift.String?
    /// The ID of the SubChannel in the request. Only required when getting messages in a SubChannel that the user belongs to.
    public var subChannelId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
        self.subChannelId = subChannelId
    }
}

public struct GetChannelMessageOutput: Swift.Sendable {
    /// The details of and content in the message.
    public var channelMessage: ChimeSDKMessagingClientTypes.ChannelMessage?

    public init(
        channelMessage: ChimeSDKMessagingClientTypes.ChannelMessage? = nil
    )
    {
        self.channelMessage = channelMessage
    }
}

public struct GetChannelMessageStatusInput: Swift.Sendable {
    /// The ARN of the channel
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user making the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ID of the message.
    /// This member is required.
    public var messageId: Swift.String?
    /// The ID of the SubChannel in the request. Only required when getting message status in a SubChannel that the user belongs to.
    public var subChannelId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
        self.subChannelId = subChannelId
    }
}

public struct GetChannelMessageStatusOutput: Swift.Sendable {
    /// The message status and details.
    public var status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure?

    public init(
        status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure? = nil
    )
    {
        self.status = status
    }
}

public struct GetMessagingSessionEndpointInput: Swift.Sendable {

    public init() { }
}

extension ChimeSDKMessagingClientTypes {

    /// The websocket endpoint used to connect to Amazon Chime SDK messaging.
    public struct MessagingSessionEndpoint: Swift.Sendable {
        /// The endpoint to which you establish a websocket connection.
        public var url: Swift.String?

        public init(
            url: Swift.String? = nil
        )
        {
            self.url = url
        }
    }
}

public struct GetMessagingSessionEndpointOutput: Swift.Sendable {
    /// The endpoint returned in the response.
    public var endpoint: ChimeSDKMessagingClientTypes.MessagingSessionEndpoint?

    public init(
        endpoint: ChimeSDKMessagingClientTypes.MessagingSessionEndpoint? = nil
    )
    {
        self.endpoint = endpoint
    }
}

public struct GetMessagingStreamingConfigurationsInput: Swift.Sendable {
    /// The ARN of the streaming configurations.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

extension ChimeSDKMessagingClientTypes {

    public enum MessagingDataType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case channel
        case channelmessage
        case sdkUnknown(Swift.String)

        public static var allCases: [MessagingDataType] {
            return [
                .channel,
                .channelmessage
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .channel: return "Channel"
            case .channelmessage: return "ChannelMessage"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    /// The configuration for connecting a messaging stream to Amazon Kinesis.
    public struct StreamingConfiguration: Swift.Sendable {
        /// The data type of the configuration.
        /// This member is required.
        public var dataType: ChimeSDKMessagingClientTypes.MessagingDataType?
        /// The ARN of the resource in the configuration.
        /// This member is required.
        public var resourceArn: Swift.String?

        public init(
            dataType: ChimeSDKMessagingClientTypes.MessagingDataType? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.dataType = dataType
            self.resourceArn = resourceArn
        }
    }
}

public struct GetMessagingStreamingConfigurationsOutput: Swift.Sendable {
    /// The streaming settings.
    public var streamingConfigurations: [ChimeSDKMessagingClientTypes.StreamingConfiguration]?

    public init(
        streamingConfigurations: [ChimeSDKMessagingClientTypes.StreamingConfiguration]? = nil
    )
    {
        self.streamingConfigurations = streamingConfigurations
    }
}

public struct ListChannelBansInput: Swift.Sendable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of bans that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested bans are returned.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListChannelBansInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelBansInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelBansOutput: Swift.Sendable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The information for each requested ban.
    public var channelBans: [ChimeSDKMessagingClientTypes.ChannelBanSummary]?
    /// The token passed by previous API calls until all requested bans are returned.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelBans: [ChimeSDKMessagingClientTypes.ChannelBanSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelBans = channelBans
        self.nextToken = nextToken
    }
}

extension ListChannelBansOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelBansOutput(channelArn: \(Swift.String(describing: channelArn)), channelBans: \(Swift.String(describing: channelBans)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelFlowsInput: Swift.Sendable {
    /// The ARN of the app instance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The maximum number of channel flows that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channel flows are returned.
    public var nextToken: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListChannelFlowsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelFlowsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelFlowsOutput: Swift.Sendable {
    /// The information about each channel flow.
    public var channelFlows: [ChimeSDKMessagingClientTypes.ChannelFlowSummary]?
    /// The token passed by previous API calls until all requested channels are returned.
    public var nextToken: Swift.String?

    public init(
        channelFlows: [ChimeSDKMessagingClientTypes.ChannelFlowSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelFlows = channelFlows
        self.nextToken = nextToken
    }
}

extension ListChannelFlowsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelFlowsOutput(channelFlows: \(Swift.String(describing: channelFlows)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelMembershipsInput: Swift.Sendable {
    /// The maximum number of channel memberships that you want returned.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of channel memberships that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channel memberships are returned.
    public var nextToken: Swift.String?
    /// The ID of the SubChannel in the request. Only required when listing a user's memberships in a particular sub-channel of an elastic channel.
    public var subChannelId: Swift.String?
    /// The membership type of a user, DEFAULT or HIDDEN. Default members are returned as part of ListChannelMemberships if no type is specified. Hidden members are only returned if the type filter in ListChannelMemberships equals HIDDEN.
    public var type: ChimeSDKMessagingClientTypes.ChannelMembershipType?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        subChannelId: Swift.String? = nil,
        type: ChimeSDKMessagingClientTypes.ChannelMembershipType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subChannelId = subChannelId
        self.type = type
    }
}

extension ListChannelMembershipsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), subChannelId: \(Swift.String(describing: subChannelId)), type: \(Swift.String(describing: type)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelMembershipsOutput: Swift.Sendable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The information for the requested channel memberships.
    public var channelMemberships: [ChimeSDKMessagingClientTypes.ChannelMembershipSummary]?
    /// The token passed by previous API calls until all requested channel memberships are returned.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelMemberships: [ChimeSDKMessagingClientTypes.ChannelMembershipSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelMemberships = channelMemberships
        self.nextToken = nextToken
    }
}

extension ListChannelMembershipsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsOutput(channelArn: \(Swift.String(describing: channelArn)), channelMemberships: \(Swift.String(describing: channelMemberships)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelMembershipsForAppInstanceUserInput: Swift.Sendable {
    /// The ARN of the user or bot.
    public var appInstanceUserArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of users that you want returned.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of channel memberships is reached.
    public var nextToken: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListChannelMembershipsForAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsForAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelMembershipsForAppInstanceUserOutput: Swift.Sendable {
    /// The information for the requested channel memberships.
    public var channelMemberships: [ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary]?
    /// The token passed by previous API calls until all requested users are returned.
    public var nextToken: Swift.String?

    public init(
        channelMemberships: [ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelMemberships = channelMemberships
        self.nextToken = nextToken
    }
}

extension ListChannelMembershipsForAppInstanceUserOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMembershipsForAppInstanceUserOutput(channelMemberships: \(Swift.String(describing: channelMemberships)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {

    public enum SortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListChannelMessagesInput: Swift.Sendable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of messages that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested messages are returned.
    public var nextToken: Swift.String?
    /// The final or ending time stamp for your requested messages.
    public var notAfter: Foundation.Date?
    /// The initial or starting time stamp for your requested messages.
    public var notBefore: Foundation.Date?
    /// The order in which you want messages sorted. Default is Descending, based on time created.
    public var sortOrder: ChimeSDKMessagingClientTypes.SortOrder?
    /// The ID of the SubChannel in the request. Only required when listing the messages in a SubChannel that the user belongs to.
    public var subChannelId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        notAfter: Foundation.Date? = nil,
        notBefore: Foundation.Date? = nil,
        sortOrder: ChimeSDKMessagingClientTypes.SortOrder? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.notAfter = notAfter
        self.notBefore = notBefore
        self.sortOrder = sortOrder
        self.subChannelId = subChannelId
    }
}

extension ListChannelMessagesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMessagesInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), notAfter: \(Swift.String(describing: notAfter)), notBefore: \(Swift.String(describing: notBefore)), sortOrder: \(Swift.String(describing: sortOrder)), subChannelId: \(Swift.String(describing: subChannelId)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelMessagesOutput: Swift.Sendable {
    /// The ARN of the channel containing the requested messages.
    public var channelArn: Swift.String?
    /// The information about, and content of, each requested message.
    public var channelMessages: [ChimeSDKMessagingClientTypes.ChannelMessageSummary]?
    /// The token passed by previous API calls until all requested messages are returned.
    public var nextToken: Swift.String?
    /// The ID of the SubChannel in the response.
    public var subChannelId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelMessages: [ChimeSDKMessagingClientTypes.ChannelMessageSummary]? = nil,
        nextToken: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelMessages = channelMessages
        self.nextToken = nextToken
        self.subChannelId = subChannelId
    }
}

extension ListChannelMessagesOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelMessagesOutput(channelArn: \(Swift.String(describing: channelArn)), channelMessages: \(Swift.String(describing: channelMessages)), subChannelId: \(Swift.String(describing: subChannelId)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelModeratorsInput: Swift.Sendable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of moderators that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested moderators are returned.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListChannelModeratorsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelModeratorsInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelModeratorsOutput: Swift.Sendable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The information about and names of each moderator.
    public var channelModerators: [ChimeSDKMessagingClientTypes.ChannelModeratorSummary]?
    /// The token passed by previous API calls until all requested moderators are returned.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        channelModerators: [ChimeSDKMessagingClientTypes.ChannelModeratorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.channelModerators = channelModerators
        self.nextToken = nextToken
    }
}

extension ListChannelModeratorsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelModeratorsOutput(channelArn: \(Swift.String(describing: channelArn)), channelModerators: \(Swift.String(describing: channelModerators)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelsInput: Swift.Sendable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of channels that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channels are returned.
    public var nextToken: Swift.String?
    /// The privacy setting. PUBLIC retrieves all the public channels. PRIVATE retrieves private channels. Only an AppInstanceAdmin can retrieve private channels.
    public var privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy?

    public init(
        appInstanceArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        privacy: ChimeSDKMessagingClientTypes.ChannelPrivacy? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.privacy = privacy
    }
}

extension ListChannelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), privacy: \(Swift.String(describing: privacy)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelsOutput: Swift.Sendable {
    /// The information about each channel.
    public var channels: [ChimeSDKMessagingClientTypes.ChannelSummary]?
    /// The token returned from previous API requests until the number of channels is reached.
    public var nextToken: Swift.String?

    public init(
        channels: [ChimeSDKMessagingClientTypes.ChannelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

extension ListChannelsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsOutput(channels: \(Swift.String(describing: channels)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelsAssociatedWithChannelFlowInput: Swift.Sendable {
    /// The ARN of the channel flow.
    /// This member is required.
    public var channelFlowArn: Swift.String?
    /// The maximum number of channels that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested channels are returned.
    public var nextToken: Swift.String?

    public init(
        channelFlowArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelFlowArn = channelFlowArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListChannelsAssociatedWithChannelFlowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsAssociatedWithChannelFlowInput(channelFlowArn: \(Swift.String(describing: channelFlowArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelsAssociatedWithChannelFlowOutput: Swift.Sendable {
    /// The information about each channel.
    public var channels: [ChimeSDKMessagingClientTypes.ChannelAssociatedWithFlowSummary]?
    /// The token passed by previous API calls until all requested channels are returned.
    public var nextToken: Swift.String?

    public init(
        channels: [ChimeSDKMessagingClientTypes.ChannelAssociatedWithFlowSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

extension ListChannelsAssociatedWithChannelFlowOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsAssociatedWithChannelFlowOutput(channels: \(Swift.String(describing: channels)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelsModeratedByAppInstanceUserInput: Swift.Sendable {
    /// The ARN of the user or bot in the moderated channel.
    public var appInstanceUserArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of channels in the request.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of channels moderated by the user is reached.
    public var nextToken: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListChannelsModeratedByAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsModeratedByAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListChannelsModeratedByAppInstanceUserOutput: Swift.Sendable {
    /// The moderated channels in the request.
    public var channels: [ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary]?
    /// The token returned from previous API requests until the number of channels moderated by the user is reached.
    public var nextToken: Swift.String?

    public init(
        channels: [ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

extension ListChannelsModeratedByAppInstanceUserOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListChannelsModeratedByAppInstanceUserOutput(channels: \(Swift.String(describing: channels)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListSubChannelsInput: Swift.Sendable {
    /// The ARN of elastic channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The AppInstanceUserArn of the user making the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The maximum number of sub-channels that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested sub-channels are returned.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListSubChannelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSubChannelsInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMessagingClientTypes {

    /// Summary of the sub-channels associated with the elastic channel.
    public struct SubChannelSummary: Swift.Sendable {
        /// The number of members in a SubChannel.
        public var membershipCount: Swift.Int?
        /// The unique ID of a SubChannel.
        public var subChannelId: Swift.String?

        public init(
            membershipCount: Swift.Int? = nil,
            subChannelId: Swift.String? = nil
        )
        {
            self.membershipCount = membershipCount
            self.subChannelId = subChannelId
        }
    }
}

public struct ListSubChannelsOutput: Swift.Sendable {
    /// The ARN of elastic channel.
    public var channelArn: Swift.String?
    /// The token passed by previous API calls until all requested sub-channels are returned.
    public var nextToken: Swift.String?
    /// The information about each sub-channel.
    public var subChannels: [ChimeSDKMessagingClientTypes.SubChannelSummary]?

    public init(
        channelArn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        subChannels: [ChimeSDKMessagingClientTypes.SubChannelSummary]? = nil
    )
    {
        self.channelArn = channelArn
        self.nextToken = nextToken
        self.subChannels = subChannels
    }
}

extension ListSubChannelsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListSubChannelsOutput(channelArn: \(Swift.String(describing: channelArn)), subChannels: \(Swift.String(describing: subChannels)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tag key-value pairs.
    public var tags: [ChimeSDKMessagingClientTypes.Tag]?

    public init(
        tags: [ChimeSDKMessagingClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct PutChannelExpirationSettingsInput: Swift.Sendable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    public var chimeBearer: Swift.String?
    /// Settings that control the interval after which a channel is deleted.
    public var expirationSettings: ChimeSDKMessagingClientTypes.ExpirationSettings?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        expirationSettings: ChimeSDKMessagingClientTypes.ExpirationSettings? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.expirationSettings = expirationSettings
    }
}

public struct PutChannelExpirationSettingsOutput: Swift.Sendable {
    /// The channel ARN.
    public var channelArn: Swift.String?
    /// Settings that control the interval after which a channel is deleted.
    public var expirationSettings: ChimeSDKMessagingClientTypes.ExpirationSettings?

    public init(
        channelArn: Swift.String? = nil,
        expirationSettings: ChimeSDKMessagingClientTypes.ExpirationSettings? = nil
    )
    {
        self.channelArn = channelArn
        self.expirationSettings = expirationSettings
    }
}

public struct PutChannelMembershipPreferencesInput: Swift.Sendable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ARN of the member setting the preferences.
    /// This member is required.
    public var memberArn: Swift.String?
    /// The channel membership preferences of an AppInstanceUser .
    /// This member is required.
    public var preferences: ChimeSDKMessagingClientTypes.ChannelMembershipPreferences?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        memberArn: Swift.String? = nil,
        preferences: ChimeSDKMessagingClientTypes.ChannelMembershipPreferences? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.memberArn = memberArn
        self.preferences = preferences
    }
}

public struct PutChannelMembershipPreferencesOutput: Swift.Sendable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The details of a user.
    public var member: ChimeSDKMessagingClientTypes.Identity?
    /// The ARN and metadata of the member being added.
    public var preferences: ChimeSDKMessagingClientTypes.ChannelMembershipPreferences?

    public init(
        channelArn: Swift.String? = nil,
        member: ChimeSDKMessagingClientTypes.Identity? = nil,
        preferences: ChimeSDKMessagingClientTypes.ChannelMembershipPreferences? = nil
    )
    {
        self.channelArn = channelArn
        self.member = member
        self.preferences = preferences
    }
}

public struct PutMessagingStreamingConfigurationsInput: Swift.Sendable {
    /// The ARN of the streaming configuration.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The streaming configurations.
    /// This member is required.
    public var streamingConfigurations: [ChimeSDKMessagingClientTypes.StreamingConfiguration]?

    public init(
        appInstanceArn: Swift.String? = nil,
        streamingConfigurations: [ChimeSDKMessagingClientTypes.StreamingConfiguration]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.streamingConfigurations = streamingConfigurations
    }
}

public struct PutMessagingStreamingConfigurationsOutput: Swift.Sendable {
    /// The requested streaming configurations.
    public var streamingConfigurations: [ChimeSDKMessagingClientTypes.StreamingConfiguration]?

    public init(
        streamingConfigurations: [ChimeSDKMessagingClientTypes.StreamingConfiguration]? = nil
    )
    {
        self.streamingConfigurations = streamingConfigurations
    }
}

public struct RedactChannelMessageInput: Swift.Sendable {
    /// The ARN of the channel containing the messages that you want to redact.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The ID of the message being redacted.
    /// This member is required.
    public var messageId: Swift.String?
    /// The ID of the SubChannel in the request.
    public var subChannelId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        messageId: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.messageId = messageId
        self.subChannelId = subChannelId
    }
}

public struct RedactChannelMessageOutput: Swift.Sendable {
    /// The ARN of the channel containing the messages that you want to redact.
    public var channelArn: Swift.String?
    /// The ID of the message being redacted.
    public var messageId: Swift.String?
    /// The ID of the SubChannel in the response. Only required when redacting messages in a SubChannel that the user belongs to.
    public var subChannelId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
        self.subChannelId = subChannelId
    }
}

extension ChimeSDKMessagingClientTypes {

    public enum SearchFieldKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case members
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchFieldKey] {
            return [
                .members
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .members: return "MEMBERS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    public enum SearchFieldOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equals
        case includes
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchFieldOperator] {
            return [
                .equals,
                .includes
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equals: return "EQUALS"
            case .includes: return "INCLUDES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMessagingClientTypes {

    /// A Field of the channel that you want to search.
    public struct SearchField: Swift.Sendable {
        /// An enum value that indicates the key to search the channel on. MEMBERS allows you to search channels based on memberships. You can use it with the EQUALS operator to get channels whose memberships are equal to the specified values, and with the INCLUDES operator to get channels whose memberships include the specified values.
        /// This member is required.
        public var key: ChimeSDKMessagingClientTypes.SearchFieldKey?
        /// The operator used to compare field values, currently EQUALS or INCLUDES. Use the EQUALS operator to find channels whose memberships equal the specified values. Use the INCLUDES operator to find channels whose memberships include the specified values.
        /// This member is required.
        public var `operator`: ChimeSDKMessagingClientTypes.SearchFieldOperator?
        /// The values that you want to search for, a list of strings. The values must be AppInstanceUserArns specified as a list of strings. This operation isn't supported for AppInstanceUsers with large number of memberships.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: ChimeSDKMessagingClientTypes.SearchFieldKey? = nil,
            `operator`: ChimeSDKMessagingClientTypes.SearchFieldOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.`operator` = `operator`
            self.values = values
        }
    }
}

public struct SearchChannelsInput: Swift.Sendable {
    /// The AppInstanceUserArn of the user making the API call.
    public var chimeBearer: Swift.String?
    /// A list of the Field objects in the channel being searched.
    /// This member is required.
    public var fields: [ChimeSDKMessagingClientTypes.SearchField]?
    /// The maximum number of channels that you want returned.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of channels is reached.
    public var nextToken: Swift.String?

    public init(
        chimeBearer: Swift.String? = nil,
        fields: [ChimeSDKMessagingClientTypes.SearchField]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.chimeBearer = chimeBearer
        self.fields = fields
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SearchChannelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchChannelsInput(chimeBearer: \(Swift.String(describing: chimeBearer)), fields: \(Swift.String(describing: fields)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct SearchChannelsOutput: Swift.Sendable {
    /// A list of the channels in the request.
    public var channels: [ChimeSDKMessagingClientTypes.ChannelSummary]?
    /// The token returned from previous API responses until the number of channels is reached.
    public var nextToken: Swift.String?

    public init(
        channels: [ChimeSDKMessagingClientTypes.ChannelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

extension SearchChannelsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchChannelsOutput(channels: \(Swift.String(describing: channels)), nextToken: \"CONTENT_REDACTED\")"}
}

public struct SendChannelMessageInput: Swift.Sendable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The Idempotency token for each client request.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The content of the channel message.
    /// This member is required.
    public var content: Swift.String?
    /// The content type of the channel message.
    public var contentType: Swift.String?
    /// The attributes for the message, used for message filtering along with a FilterRule defined in the PushNotificationPreferences.
    public var messageAttributes: [Swift.String: ChimeSDKMessagingClientTypes.MessageAttributeValue]?
    /// The optional metadata for each message.
    public var metadata: Swift.String?
    /// Boolean that controls whether the message is persisted on the back end. Required.
    /// This member is required.
    public var persistence: ChimeSDKMessagingClientTypes.ChannelMessagePersistenceType?
    /// The push notification configuration of the message.
    public var pushNotification: ChimeSDKMessagingClientTypes.PushNotificationConfiguration?
    /// The ID of the SubChannel in the request.
    public var subChannelId: Swift.String?
    /// The target of a message. Must be a member of the channel, such as another user, a bot, or the sender. Only the target and the sender can view targeted messages. Only users who can see targeted messages can take actions on them. However, administrators can delete targeted messages that they cant see.
    public var target: [ChimeSDKMessagingClientTypes.Target]?
    /// The type of message, STANDARD or CONTROL. STANDARD messages can be up to 4KB in size and contain metadata. Metadata is arbitrary, and you can use it in a variety of ways, such as containing a link to an attachment. CONTROL messages are limited to 30 bytes and do not contain metadata.
    /// This member is required.
    public var type: ChimeSDKMessagingClientTypes.ChannelMessageType?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        content: Swift.String? = nil,
        contentType: Swift.String? = nil,
        messageAttributes: [Swift.String: ChimeSDKMessagingClientTypes.MessageAttributeValue]? = nil,
        metadata: Swift.String? = nil,
        persistence: ChimeSDKMessagingClientTypes.ChannelMessagePersistenceType? = nil,
        pushNotification: ChimeSDKMessagingClientTypes.PushNotificationConfiguration? = nil,
        subChannelId: Swift.String? = nil,
        target: [ChimeSDKMessagingClientTypes.Target]? = nil,
        type: ChimeSDKMessagingClientTypes.ChannelMessageType? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.contentType = contentType
        self.messageAttributes = messageAttributes
        self.metadata = metadata
        self.persistence = persistence
        self.pushNotification = pushNotification
        self.subChannelId = subChannelId
        self.target = target
        self.type = type
    }
}

extension SendChannelMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendChannelMessageInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), persistence: \(Swift.String(describing: persistence)), pushNotification: \(Swift.String(describing: pushNotification)), subChannelId: \(Swift.String(describing: subChannelId)), target: \(Swift.String(describing: target)), type: \(Swift.String(describing: type)), clientRequestToken: \"CONTENT_REDACTED\", content: \"CONTENT_REDACTED\", contentType: \"CONTENT_REDACTED\", messageAttributes: [keys: \"CONTENT_REDACTED\", values: \(Swift.String(describing: messageAttributes?.values))], metadata: \"CONTENT_REDACTED\")"}
}

public struct SendChannelMessageOutput: Swift.Sendable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ID string assigned to each message.
    public var messageId: Swift.String?
    /// The status of the channel message.
    public var status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure?
    /// The ID of the SubChannel in the response.
    public var subChannelId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil,
        status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
        self.status = status
        self.subChannelId = subChannelId
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    public var tags: [ChimeSDKMessagingClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [ChimeSDKMessagingClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tagKeys: \"CONTENT_REDACTED\")"}
}

public struct UpdateChannelInput: Swift.Sendable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The metadata for the update request.
    public var metadata: Swift.String?
    /// The mode of the update request.
    public var mode: ChimeSDKMessagingClientTypes.ChannelMode?
    /// The name of the channel.
    public var name: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        metadata: Swift.String? = nil,
        mode: ChimeSDKMessagingClientTypes.ChannelMode? = nil,
        name: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.metadata = metadata
        self.mode = mode
        self.name = name
    }
}

extension UpdateChannelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), mode: \(Swift.String(describing: mode)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateChannelOutput: Swift.Sendable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

public struct UpdateChannelFlowInput: Swift.Sendable {
    /// The ARN of the channel flow.
    /// This member is required.
    public var channelFlowArn: Swift.String?
    /// The name of the channel flow.
    /// This member is required.
    public var name: Swift.String?
    /// Information about the processor Lambda functions
    /// This member is required.
    public var processors: [ChimeSDKMessagingClientTypes.Processor]?

    public init(
        channelFlowArn: Swift.String? = nil,
        name: Swift.String? = nil,
        processors: [ChimeSDKMessagingClientTypes.Processor]? = nil
    )
    {
        self.channelFlowArn = channelFlowArn
        self.name = name
        self.processors = processors
    }
}

extension UpdateChannelFlowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelFlowInput(channelFlowArn: \(Swift.String(describing: channelFlowArn)), processors: \(Swift.String(describing: processors)), name: \"CONTENT_REDACTED\")"}
}

public struct UpdateChannelFlowOutput: Swift.Sendable {
    /// The ARN of the channel flow.
    public var channelFlowArn: Swift.String?

    public init(
        channelFlowArn: Swift.String? = nil
    )
    {
        self.channelFlowArn = channelFlowArn
    }
}

public struct UpdateChannelMessageInput: Swift.Sendable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?
    /// The content of the channel message.
    /// This member is required.
    public var content: Swift.String?
    /// The content type of the channel message.
    public var contentType: Swift.String?
    /// The ID string of the message being updated.
    /// This member is required.
    public var messageId: Swift.String?
    /// The metadata of the message being updated.
    public var metadata: Swift.String?
    /// The ID of the SubChannel in the request. Only required when updating messages in a SubChannel that the user belongs to.
    public var subChannelId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil,
        content: Swift.String? = nil,
        contentType: Swift.String? = nil,
        messageId: Swift.String? = nil,
        metadata: Swift.String? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
        self.content = content
        self.contentType = contentType
        self.messageId = messageId
        self.metadata = metadata
        self.subChannelId = subChannelId
    }
}

extension UpdateChannelMessageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateChannelMessageInput(channelArn: \(Swift.String(describing: channelArn)), chimeBearer: \(Swift.String(describing: chimeBearer)), messageId: \(Swift.String(describing: messageId)), subChannelId: \(Swift.String(describing: subChannelId)), content: \"CONTENT_REDACTED\", contentType: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\")"}
}

public struct UpdateChannelMessageOutput: Swift.Sendable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?
    /// The ID string of the message being updated.
    public var messageId: Swift.String?
    /// The status of the message update.
    public var status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure?
    /// The ID of the SubChannel in the response.
    public var subChannelId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        messageId: Swift.String? = nil,
        status: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure? = nil,
        subChannelId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.messageId = messageId
        self.status = status
        self.subChannelId = subChannelId
    }
}

public struct UpdateChannelReadMarkerInput: Swift.Sendable {
    /// The ARN of the channel.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ARN of the AppInstanceUser or AppInstanceBot that makes the API call.
    /// This member is required.
    public var chimeBearer: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        chimeBearer: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.chimeBearer = chimeBearer
    }
}

public struct UpdateChannelReadMarkerOutput: Swift.Sendable {
    /// The ARN of the channel.
    public var channelArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

extension AssociateChannelFlowInput {

    static func urlPathProvider(_ value: AssociateChannelFlowInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/channel-flow"
    }
}

extension AssociateChannelFlowInput {

    static func headerProvider(_ value: AssociateChannelFlowInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension BatchCreateChannelMembershipInput {

    static func urlPathProvider(_ value: BatchCreateChannelMembershipInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships"
    }
}

extension BatchCreateChannelMembershipInput {

    static func headerProvider(_ value: BatchCreateChannelMembershipInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension BatchCreateChannelMembershipInput {

    static func queryItemProvider(_ value: BatchCreateChannelMembershipInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "batch-create"))
        return items
    }
}

extension ChannelFlowCallbackInput {

    static func urlPathProvider(_ value: ChannelFlowCallbackInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

extension ChannelFlowCallbackInput {

    static func queryItemProvider(_ value: ChannelFlowCallbackInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "channel-flow-callback"))
        return items
    }
}

extension CreateChannelInput {

    static func urlPathProvider(_ value: CreateChannelInput) -> Swift.String? {
        return "/channels"
    }
}

extension CreateChannelInput {

    static func headerProvider(_ value: CreateChannelInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension CreateChannelBanInput {

    static func urlPathProvider(_ value: CreateChannelBanInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans"
    }
}

extension CreateChannelBanInput {

    static func headerProvider(_ value: CreateChannelBanInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension CreateChannelFlowInput {

    static func urlPathProvider(_ value: CreateChannelFlowInput) -> Swift.String? {
        return "/channel-flows"
    }
}

extension CreateChannelMembershipInput {

    static func urlPathProvider(_ value: CreateChannelMembershipInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships"
    }
}

extension CreateChannelMembershipInput {

    static func headerProvider(_ value: CreateChannelMembershipInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension CreateChannelModeratorInput {

    static func urlPathProvider(_ value: CreateChannelModeratorInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators"
    }
}

extension CreateChannelModeratorInput {

    static func headerProvider(_ value: CreateChannelModeratorInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelInput {

    static func urlPathProvider(_ value: DeleteChannelInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

extension DeleteChannelInput {

    static func headerProvider(_ value: DeleteChannelInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelBanInput {

    static func urlPathProvider(_ value: DeleteChannelBanInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let memberArn = value.memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans/\(memberArn.urlPercentEncoding())"
    }
}

extension DeleteChannelBanInput {

    static func headerProvider(_ value: DeleteChannelBanInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelFlowInput {

    static func urlPathProvider(_ value: DeleteChannelFlowInput) -> Swift.String? {
        guard let channelFlowArn = value.channelFlowArn else {
            return nil
        }
        return "/channel-flows/\(channelFlowArn.urlPercentEncoding())"
    }
}

extension DeleteChannelMembershipInput {

    static func urlPathProvider(_ value: DeleteChannelMembershipInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let memberArn = value.memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())"
    }
}

extension DeleteChannelMembershipInput {

    static func headerProvider(_ value: DeleteChannelMembershipInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelMembershipInput {

    static func queryItemProvider(_ value: DeleteChannelMembershipInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let subChannelId = value.subChannelId {
            let subChannelIdQueryItem = Smithy.URIQueryItem(name: "sub-channel-id".urlPercentEncoding(), value: Swift.String(subChannelId).urlPercentEncoding())
            items.append(subChannelIdQueryItem)
        }
        return items
    }
}

extension DeleteChannelMessageInput {

    static func urlPathProvider(_ value: DeleteChannelMessageInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let messageId = value.messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

extension DeleteChannelMessageInput {

    static func headerProvider(_ value: DeleteChannelMessageInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteChannelMessageInput {

    static func queryItemProvider(_ value: DeleteChannelMessageInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let subChannelId = value.subChannelId {
            let subChannelIdQueryItem = Smithy.URIQueryItem(name: "sub-channel-id".urlPercentEncoding(), value: Swift.String(subChannelId).urlPercentEncoding())
            items.append(subChannelIdQueryItem)
        }
        return items
    }
}

extension DeleteChannelModeratorInput {

    static func urlPathProvider(_ value: DeleteChannelModeratorInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let channelModeratorArn = value.channelModeratorArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators/\(channelModeratorArn.urlPercentEncoding())"
    }
}

extension DeleteChannelModeratorInput {

    static func headerProvider(_ value: DeleteChannelModeratorInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DeleteMessagingStreamingConfigurationsInput {

    static func urlPathProvider(_ value: DeleteMessagingStreamingConfigurationsInput) -> Swift.String? {
        guard let appInstanceArn = value.appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/streaming-configurations"
    }
}

extension DescribeChannelInput {

    static func urlPathProvider(_ value: DescribeChannelInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

extension DescribeChannelInput {

    static func headerProvider(_ value: DescribeChannelInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelBanInput {

    static func urlPathProvider(_ value: DescribeChannelBanInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let memberArn = value.memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans/\(memberArn.urlPercentEncoding())"
    }
}

extension DescribeChannelBanInput {

    static func headerProvider(_ value: DescribeChannelBanInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelFlowInput {

    static func urlPathProvider(_ value: DescribeChannelFlowInput) -> Swift.String? {
        guard let channelFlowArn = value.channelFlowArn else {
            return nil
        }
        return "/channel-flows/\(channelFlowArn.urlPercentEncoding())"
    }
}

extension DescribeChannelMembershipInput {

    static func urlPathProvider(_ value: DescribeChannelMembershipInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let memberArn = value.memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())"
    }
}

extension DescribeChannelMembershipInput {

    static func headerProvider(_ value: DescribeChannelMembershipInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelMembershipInput {

    static func queryItemProvider(_ value: DescribeChannelMembershipInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let subChannelId = value.subChannelId {
            let subChannelIdQueryItem = Smithy.URIQueryItem(name: "sub-channel-id".urlPercentEncoding(), value: Swift.String(subChannelId).urlPercentEncoding())
            items.append(subChannelIdQueryItem)
        }
        return items
    }
}

extension DescribeChannelMembershipForAppInstanceUserInput {

    static func urlPathProvider(_ value: DescribeChannelMembershipForAppInstanceUserInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

extension DescribeChannelMembershipForAppInstanceUserInput {

    static func headerProvider(_ value: DescribeChannelMembershipForAppInstanceUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelMembershipForAppInstanceUserInput {

    static func queryItemProvider(_ value: DescribeChannelMembershipForAppInstanceUserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "scope", value: "app-instance-user-membership"))
        guard let appInstanceUserArn = value.appInstanceUserArn else {
            let message = "Creating a URL Query Item failed. appInstanceUserArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let appInstanceUserArnQueryItem = Smithy.URIQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
        items.append(appInstanceUserArnQueryItem)
        return items
    }
}

extension DescribeChannelModeratedByAppInstanceUserInput {

    static func urlPathProvider(_ value: DescribeChannelModeratedByAppInstanceUserInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

extension DescribeChannelModeratedByAppInstanceUserInput {

    static func headerProvider(_ value: DescribeChannelModeratedByAppInstanceUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DescribeChannelModeratedByAppInstanceUserInput {

    static func queryItemProvider(_ value: DescribeChannelModeratedByAppInstanceUserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "scope", value: "app-instance-user-moderated-channel"))
        guard let appInstanceUserArn = value.appInstanceUserArn else {
            let message = "Creating a URL Query Item failed. appInstanceUserArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let appInstanceUserArnQueryItem = Smithy.URIQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
        items.append(appInstanceUserArnQueryItem)
        return items
    }
}

extension DescribeChannelModeratorInput {

    static func urlPathProvider(_ value: DescribeChannelModeratorInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let channelModeratorArn = value.channelModeratorArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators/\(channelModeratorArn.urlPercentEncoding())"
    }
}

extension DescribeChannelModeratorInput {

    static func headerProvider(_ value: DescribeChannelModeratorInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension DisassociateChannelFlowInput {

    static func urlPathProvider(_ value: DisassociateChannelFlowInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let channelFlowArn = value.channelFlowArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/channel-flow/\(channelFlowArn.urlPercentEncoding())"
    }
}

extension DisassociateChannelFlowInput {

    static func headerProvider(_ value: DisassociateChannelFlowInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension GetChannelMembershipPreferencesInput {

    static func urlPathProvider(_ value: GetChannelMembershipPreferencesInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let memberArn = value.memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())/preferences"
    }
}

extension GetChannelMembershipPreferencesInput {

    static func headerProvider(_ value: GetChannelMembershipPreferencesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension GetChannelMessageInput {

    static func urlPathProvider(_ value: GetChannelMessageInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let messageId = value.messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

extension GetChannelMessageInput {

    static func headerProvider(_ value: GetChannelMessageInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension GetChannelMessageInput {

    static func queryItemProvider(_ value: GetChannelMessageInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let subChannelId = value.subChannelId {
            let subChannelIdQueryItem = Smithy.URIQueryItem(name: "sub-channel-id".urlPercentEncoding(), value: Swift.String(subChannelId).urlPercentEncoding())
            items.append(subChannelIdQueryItem)
        }
        return items
    }
}

extension GetChannelMessageStatusInput {

    static func urlPathProvider(_ value: GetChannelMessageStatusInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let messageId = value.messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

extension GetChannelMessageStatusInput {

    static func headerProvider(_ value: GetChannelMessageStatusInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension GetChannelMessageStatusInput {

    static func queryItemProvider(_ value: GetChannelMessageStatusInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "scope", value: "message-status"))
        if let subChannelId = value.subChannelId {
            let subChannelIdQueryItem = Smithy.URIQueryItem(name: "sub-channel-id".urlPercentEncoding(), value: Swift.String(subChannelId).urlPercentEncoding())
            items.append(subChannelIdQueryItem)
        }
        return items
    }
}

extension GetMessagingSessionEndpointInput {

    static func urlPathProvider(_ value: GetMessagingSessionEndpointInput) -> Swift.String? {
        return "/endpoints/messaging-session"
    }
}

extension GetMessagingStreamingConfigurationsInput {

    static func urlPathProvider(_ value: GetMessagingStreamingConfigurationsInput) -> Swift.String? {
        guard let appInstanceArn = value.appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/streaming-configurations"
    }
}

extension ListChannelBansInput {

    static func urlPathProvider(_ value: ListChannelBansInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/bans"
    }
}

extension ListChannelBansInput {

    static func headerProvider(_ value: ListChannelBansInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelBansInput {

    static func queryItemProvider(_ value: ListChannelBansInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListChannelFlowsInput {

    static func urlPathProvider(_ value: ListChannelFlowsInput) -> Swift.String? {
        return "/channel-flows"
    }
}

extension ListChannelFlowsInput {

    static func queryItemProvider(_ value: ListChannelFlowsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let appInstanceArn = value.appInstanceArn else {
            let message = "Creating a URL Query Item failed. appInstanceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let appInstanceArnQueryItem = Smithy.URIQueryItem(name: "app-instance-arn".urlPercentEncoding(), value: Swift.String(appInstanceArn).urlPercentEncoding())
        items.append(appInstanceArnQueryItem)
        return items
    }
}

extension ListChannelMembershipsInput {

    static func urlPathProvider(_ value: ListChannelMembershipsInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships"
    }
}

extension ListChannelMembershipsInput {

    static func headerProvider(_ value: ListChannelMembershipsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelMembershipsInput {

    static func queryItemProvider(_ value: ListChannelMembershipsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let subChannelId = value.subChannelId {
            let subChannelIdQueryItem = Smithy.URIQueryItem(name: "sub-channel-id".urlPercentEncoding(), value: Swift.String(subChannelId).urlPercentEncoding())
            items.append(subChannelIdQueryItem)
        }
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListChannelMembershipsForAppInstanceUserInput {

    static func urlPathProvider(_ value: ListChannelMembershipsForAppInstanceUserInput) -> Swift.String? {
        return "/channels"
    }
}

extension ListChannelMembershipsForAppInstanceUserInput {

    static func headerProvider(_ value: ListChannelMembershipsForAppInstanceUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelMembershipsForAppInstanceUserInput {

    static func queryItemProvider(_ value: ListChannelMembershipsForAppInstanceUserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "scope", value: "app-instance-user-memberships"))
        if let appInstanceUserArn = value.appInstanceUserArn {
            let appInstanceUserArnQueryItem = Smithy.URIQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            items.append(appInstanceUserArnQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListChannelMessagesInput {

    static func urlPathProvider(_ value: ListChannelMessagesInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages"
    }
}

extension ListChannelMessagesInput {

    static func headerProvider(_ value: ListChannelMessagesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelMessagesInput {

    static func queryItemProvider(_ value: ListChannelMessagesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let subChannelId = value.subChannelId {
            let subChannelIdQueryItem = Smithy.URIQueryItem(name: "sub-channel-id".urlPercentEncoding(), value: Swift.String(subChannelId).urlPercentEncoding())
            items.append(subChannelIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let sortOrder = value.sortOrder {
            let sortOrderQueryItem = Smithy.URIQueryItem(name: "sort-order".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let notBefore = value.notBefore {
            let notBeforeQueryItem = Smithy.URIQueryItem(name: "not-before".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: notBefore)).urlPercentEncoding())
            items.append(notBeforeQueryItem)
        }
        if let notAfter = value.notAfter {
            let notAfterQueryItem = Smithy.URIQueryItem(name: "not-after".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: notAfter)).urlPercentEncoding())
            items.append(notAfterQueryItem)
        }
        return items
    }
}

extension ListChannelModeratorsInput {

    static func urlPathProvider(_ value: ListChannelModeratorsInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/moderators"
    }
}

extension ListChannelModeratorsInput {

    static func headerProvider(_ value: ListChannelModeratorsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelModeratorsInput {

    static func queryItemProvider(_ value: ListChannelModeratorsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListChannelsInput {

    static func urlPathProvider(_ value: ListChannelsInput) -> Swift.String? {
        return "/channels"
    }
}

extension ListChannelsInput {

    static func headerProvider(_ value: ListChannelsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelsInput {

    static func queryItemProvider(_ value: ListChannelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let privacy = value.privacy {
            let privacyQueryItem = Smithy.URIQueryItem(name: "privacy".urlPercentEncoding(), value: Swift.String(privacy.rawValue).urlPercentEncoding())
            items.append(privacyQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let appInstanceArn = value.appInstanceArn else {
            let message = "Creating a URL Query Item failed. appInstanceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let appInstanceArnQueryItem = Smithy.URIQueryItem(name: "app-instance-arn".urlPercentEncoding(), value: Swift.String(appInstanceArn).urlPercentEncoding())
        items.append(appInstanceArnQueryItem)
        return items
    }
}

extension ListChannelsAssociatedWithChannelFlowInput {

    static func urlPathProvider(_ value: ListChannelsAssociatedWithChannelFlowInput) -> Swift.String? {
        return "/channels"
    }
}

extension ListChannelsAssociatedWithChannelFlowInput {

    static func queryItemProvider(_ value: ListChannelsAssociatedWithChannelFlowInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "scope", value: "channel-flow-associations"))
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        guard let channelFlowArn = value.channelFlowArn else {
            let message = "Creating a URL Query Item failed. channelFlowArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let channelFlowArnQueryItem = Smithy.URIQueryItem(name: "channel-flow-arn".urlPercentEncoding(), value: Swift.String(channelFlowArn).urlPercentEncoding())
        items.append(channelFlowArnQueryItem)
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListChannelsModeratedByAppInstanceUserInput {

    static func urlPathProvider(_ value: ListChannelsModeratedByAppInstanceUserInput) -> Swift.String? {
        return "/channels"
    }
}

extension ListChannelsModeratedByAppInstanceUserInput {

    static func headerProvider(_ value: ListChannelsModeratedByAppInstanceUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListChannelsModeratedByAppInstanceUserInput {

    static func queryItemProvider(_ value: ListChannelsModeratedByAppInstanceUserInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "scope", value: "app-instance-user-moderated-channels"))
        if let appInstanceUserArn = value.appInstanceUserArn {
            let appInstanceUserArnQueryItem = Smithy.URIQueryItem(name: "app-instance-user-arn".urlPercentEncoding(), value: Swift.String(appInstanceUserArn).urlPercentEncoding())
            items.append(appInstanceUserArnQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSubChannelsInput {

    static func urlPathProvider(_ value: ListSubChannelsInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/subchannels"
    }
}

extension ListSubChannelsInput {

    static func headerProvider(_ value: ListSubChannelsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension ListSubChannelsInput {

    static func queryItemProvider(_ value: ListSubChannelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension ListTagsForResourceInput {

    static func queryItemProvider(_ value: ListTagsForResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceARN = value.resourceARN else {
            let message = "Creating a URL Query Item failed. resourceARN is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceARNQueryItem = Smithy.URIQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
        items.append(resourceARNQueryItem)
        return items
    }
}

extension PutChannelExpirationSettingsInput {

    static func urlPathProvider(_ value: PutChannelExpirationSettingsInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/expiration-settings"
    }
}

extension PutChannelExpirationSettingsInput {

    static func headerProvider(_ value: PutChannelExpirationSettingsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension PutChannelMembershipPreferencesInput {

    static func urlPathProvider(_ value: PutChannelMembershipPreferencesInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let memberArn = value.memberArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/memberships/\(memberArn.urlPercentEncoding())/preferences"
    }
}

extension PutChannelMembershipPreferencesInput {

    static func headerProvider(_ value: PutChannelMembershipPreferencesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension PutMessagingStreamingConfigurationsInput {

    static func urlPathProvider(_ value: PutMessagingStreamingConfigurationsInput) -> Swift.String? {
        guard let appInstanceArn = value.appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/streaming-configurations"
    }
}

extension RedactChannelMessageInput {

    static func urlPathProvider(_ value: RedactChannelMessageInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let messageId = value.messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

extension RedactChannelMessageInput {

    static func headerProvider(_ value: RedactChannelMessageInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension RedactChannelMessageInput {

    static func queryItemProvider(_ value: RedactChannelMessageInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "redact"))
        return items
    }
}

extension SearchChannelsInput {

    static func urlPathProvider(_ value: SearchChannelsInput) -> Swift.String? {
        return "/channels"
    }
}

extension SearchChannelsInput {

    static func headerProvider(_ value: SearchChannelsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension SearchChannelsInput {

    static func queryItemProvider(_ value: SearchChannelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "search"))
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension SendChannelMessageInput {

    static func urlPathProvider(_ value: SendChannelMessageInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages"
    }
}

extension SendChannelMessageInput {

    static func headerProvider(_ value: SendChannelMessageInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension TagResourceInput {

    static func queryItemProvider(_ value: TagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "tag-resource"))
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "untag-resource"))
        return items
    }
}

extension UpdateChannelInput {

    static func urlPathProvider(_ value: UpdateChannelInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())"
    }
}

extension UpdateChannelInput {

    static func headerProvider(_ value: UpdateChannelInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension UpdateChannelFlowInput {

    static func urlPathProvider(_ value: UpdateChannelFlowInput) -> Swift.String? {
        guard let channelFlowArn = value.channelFlowArn else {
            return nil
        }
        return "/channel-flows/\(channelFlowArn.urlPercentEncoding())"
    }
}

extension UpdateChannelMessageInput {

    static func urlPathProvider(_ value: UpdateChannelMessageInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        guard let messageId = value.messageId else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/messages/\(messageId.urlPercentEncoding())"
    }
}

extension UpdateChannelMessageInput {

    static func headerProvider(_ value: UpdateChannelMessageInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension UpdateChannelReadMarkerInput {

    static func urlPathProvider(_ value: UpdateChannelReadMarkerInput) -> Swift.String? {
        guard let channelArn = value.channelArn else {
            return nil
        }
        return "/channels/\(channelArn.urlPercentEncoding())/readMarker"
    }
}

extension UpdateChannelReadMarkerInput {

    static func headerProvider(_ value: UpdateChannelReadMarkerInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let chimeBearer = value.chimeBearer {
            items.add(SmithyHTTPAPI.Header(name: "x-amz-chime-bearer", value: Swift.String(chimeBearer)))
        }
        return items
    }
}

extension AssociateChannelFlowInput {

    static func write(value: AssociateChannelFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelFlowArn"].write(value.channelFlowArn)
    }
}

extension BatchCreateChannelMembershipInput {

    static func write(value: BatchCreateChannelMembershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MemberArns"].writeList(value.memberArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubChannelId"].write(value.subChannelId)
        try writer["Type"].write(value.type)
    }
}

extension ChannelFlowCallbackInput {

    static func write(value: ChannelFlowCallbackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CallbackId"].write(value.callbackId)
        try writer["ChannelMessage"].write(value.channelMessage, with: ChimeSDKMessagingClientTypes.ChannelMessageCallback.write(value:to:))
        try writer["DeleteResource"].write(value.deleteResource)
    }
}

extension CreateChannelInput {

    static func write(value: CreateChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppInstanceArn"].write(value.appInstanceArn)
        try writer["ChannelId"].write(value.channelId)
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["ElasticChannelConfiguration"].write(value.elasticChannelConfiguration, with: ChimeSDKMessagingClientTypes.ElasticChannelConfiguration.write(value:to:))
        try writer["ExpirationSettings"].write(value.expirationSettings, with: ChimeSDKMessagingClientTypes.ExpirationSettings.write(value:to:))
        try writer["MemberArns"].writeList(value.memberArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Metadata"].write(value.metadata)
        try writer["Mode"].write(value.mode)
        try writer["ModeratorArns"].writeList(value.moderatorArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Privacy"].write(value.privacy)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeSDKMessagingClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateChannelBanInput {

    static func write(value: CreateChannelBanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MemberArn"].write(value.memberArn)
    }
}

extension CreateChannelFlowInput {

    static func write(value: CreateChannelFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AppInstanceArn"].write(value.appInstanceArn)
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Name"].write(value.name)
        try writer["Processors"].writeList(value.processors, memberWritingClosure: ChimeSDKMessagingClientTypes.Processor.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeSDKMessagingClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateChannelMembershipInput {

    static func write(value: CreateChannelMembershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MemberArn"].write(value.memberArn)
        try writer["SubChannelId"].write(value.subChannelId)
        try writer["Type"].write(value.type)
    }
}

extension CreateChannelModeratorInput {

    static func write(value: CreateChannelModeratorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelModeratorArn"].write(value.channelModeratorArn)
    }
}

extension PutChannelExpirationSettingsInput {

    static func write(value: PutChannelExpirationSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExpirationSettings"].write(value.expirationSettings, with: ChimeSDKMessagingClientTypes.ExpirationSettings.write(value:to:))
    }
}

extension PutChannelMembershipPreferencesInput {

    static func write(value: PutChannelMembershipPreferencesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Preferences"].write(value.preferences, with: ChimeSDKMessagingClientTypes.ChannelMembershipPreferences.write(value:to:))
    }
}

extension PutMessagingStreamingConfigurationsInput {

    static func write(value: PutMessagingStreamingConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StreamingConfigurations"].writeList(value.streamingConfigurations, memberWritingClosure: ChimeSDKMessagingClientTypes.StreamingConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension RedactChannelMessageInput {

    static func write(value: RedactChannelMessageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SubChannelId"].write(value.subChannelId)
    }
}

extension SearchChannelsInput {

    static func write(value: SearchChannelsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Fields"].writeList(value.fields, memberWritingClosure: ChimeSDKMessagingClientTypes.SearchField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SendChannelMessageInput {

    static func write(value: SendChannelMessageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Content"].write(value.content)
        try writer["ContentType"].write(value.contentType)
        try writer["MessageAttributes"].writeMap(value.messageAttributes, valueWritingClosure: ChimeSDKMessagingClientTypes.MessageAttributeValue.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Metadata"].write(value.metadata)
        try writer["Persistence"].write(value.persistence)
        try writer["PushNotification"].write(value.pushNotification, with: ChimeSDKMessagingClientTypes.PushNotificationConfiguration.write(value:to:))
        try writer["SubChannelId"].write(value.subChannelId)
        try writer["Target"].writeList(value.target, memberWritingClosure: ChimeSDKMessagingClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeSDKMessagingClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateChannelInput {

    static func write(value: UpdateChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Metadata"].write(value.metadata)
        try writer["Mode"].write(value.mode)
        try writer["Name"].write(value.name)
    }
}

extension UpdateChannelFlowInput {

    static func write(value: UpdateChannelFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Processors"].writeList(value.processors, memberWritingClosure: ChimeSDKMessagingClientTypes.Processor.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateChannelMessageInput {

    static func write(value: UpdateChannelMessageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Content"].write(value.content)
        try writer["ContentType"].write(value.contentType)
        try writer["Metadata"].write(value.metadata)
        try writer["SubChannelId"].write(value.subChannelId)
    }
}

extension AssociateChannelFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateChannelFlowOutput {
        return AssociateChannelFlowOutput()
    }
}

extension BatchCreateChannelMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchCreateChannelMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchCreateChannelMembershipOutput()
        value.batchChannelMemberships = try reader["BatchChannelMemberships"].readIfPresent(with: ChimeSDKMessagingClientTypes.BatchChannelMemberships.read(from:))
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.BatchCreateChannelMembershipError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ChannelFlowCallbackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ChannelFlowCallbackOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ChannelFlowCallbackOutput()
        value.callbackId = try reader["CallbackId"].readIfPresent()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        return value
    }
}

extension CreateChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateChannelOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        return value
    }
}

extension CreateChannelBanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateChannelBanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateChannelBanOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.member = try reader["Member"].readIfPresent(with: ChimeSDKMessagingClientTypes.Identity.read(from:))
        return value
    }
}

extension CreateChannelFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateChannelFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateChannelFlowOutput()
        value.channelFlowArn = try reader["ChannelFlowArn"].readIfPresent()
        return value
    }
}

extension CreateChannelMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateChannelMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateChannelMembershipOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.member = try reader["Member"].readIfPresent(with: ChimeSDKMessagingClientTypes.Identity.read(from:))
        value.subChannelId = try reader["SubChannelId"].readIfPresent()
        return value
    }
}

extension CreateChannelModeratorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateChannelModeratorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateChannelModeratorOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.channelModerator = try reader["ChannelModerator"].readIfPresent(with: ChimeSDKMessagingClientTypes.Identity.read(from:))
        return value
    }
}

extension DeleteChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteChannelOutput {
        return DeleteChannelOutput()
    }
}

extension DeleteChannelBanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteChannelBanOutput {
        return DeleteChannelBanOutput()
    }
}

extension DeleteChannelFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteChannelFlowOutput {
        return DeleteChannelFlowOutput()
    }
}

extension DeleteChannelMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteChannelMembershipOutput {
        return DeleteChannelMembershipOutput()
    }
}

extension DeleteChannelMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteChannelMessageOutput {
        return DeleteChannelMessageOutput()
    }
}

extension DeleteChannelModeratorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteChannelModeratorOutput {
        return DeleteChannelModeratorOutput()
    }
}

extension DeleteMessagingStreamingConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMessagingStreamingConfigurationsOutput {
        return DeleteMessagingStreamingConfigurationsOutput()
    }
}

extension DescribeChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeChannelOutput()
        value.channel = try reader["Channel"].readIfPresent(with: ChimeSDKMessagingClientTypes.Channel.read(from:))
        return value
    }
}

extension DescribeChannelBanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeChannelBanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeChannelBanOutput()
        value.channelBan = try reader["ChannelBan"].readIfPresent(with: ChimeSDKMessagingClientTypes.ChannelBan.read(from:))
        return value
    }
}

extension DescribeChannelFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeChannelFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeChannelFlowOutput()
        value.channelFlow = try reader["ChannelFlow"].readIfPresent(with: ChimeSDKMessagingClientTypes.ChannelFlow.read(from:))
        return value
    }
}

extension DescribeChannelMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeChannelMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeChannelMembershipOutput()
        value.channelMembership = try reader["ChannelMembership"].readIfPresent(with: ChimeSDKMessagingClientTypes.ChannelMembership.read(from:))
        return value
    }
}

extension DescribeChannelMembershipForAppInstanceUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeChannelMembershipForAppInstanceUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeChannelMembershipForAppInstanceUserOutput()
        value.channelMembership = try reader["ChannelMembership"].readIfPresent(with: ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary.read(from:))
        return value
    }
}

extension DescribeChannelModeratedByAppInstanceUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeChannelModeratedByAppInstanceUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeChannelModeratedByAppInstanceUserOutput()
        value.channel = try reader["Channel"].readIfPresent(with: ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary.read(from:))
        return value
    }
}

extension DescribeChannelModeratorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeChannelModeratorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeChannelModeratorOutput()
        value.channelModerator = try reader["ChannelModerator"].readIfPresent(with: ChimeSDKMessagingClientTypes.ChannelModerator.read(from:))
        return value
    }
}

extension DisassociateChannelFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateChannelFlowOutput {
        return DisassociateChannelFlowOutput()
    }
}

extension GetChannelMembershipPreferencesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetChannelMembershipPreferencesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetChannelMembershipPreferencesOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.member = try reader["Member"].readIfPresent(with: ChimeSDKMessagingClientTypes.Identity.read(from:))
        value.preferences = try reader["Preferences"].readIfPresent(with: ChimeSDKMessagingClientTypes.ChannelMembershipPreferences.read(from:))
        return value
    }
}

extension GetChannelMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetChannelMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetChannelMessageOutput()
        value.channelMessage = try reader["ChannelMessage"].readIfPresent(with: ChimeSDKMessagingClientTypes.ChannelMessage.read(from:))
        return value
    }
}

extension GetChannelMessageStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetChannelMessageStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetChannelMessageStatusOutput()
        value.status = try reader["Status"].readIfPresent(with: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure.read(from:))
        return value
    }
}

extension GetMessagingSessionEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMessagingSessionEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMessagingSessionEndpointOutput()
        value.endpoint = try reader["Endpoint"].readIfPresent(with: ChimeSDKMessagingClientTypes.MessagingSessionEndpoint.read(from:))
        return value
    }
}

extension GetMessagingStreamingConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMessagingStreamingConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMessagingStreamingConfigurationsOutput()
        value.streamingConfigurations = try reader["StreamingConfigurations"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.StreamingConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListChannelBansOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelBansOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelBansOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.channelBans = try reader["ChannelBans"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.ChannelBanSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListChannelFlowsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelFlowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelFlowsOutput()
        value.channelFlows = try reader["ChannelFlows"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.ChannelFlowSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListChannelMembershipsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelMembershipsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelMembershipsOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.channelMemberships = try reader["ChannelMemberships"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.ChannelMembershipSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListChannelMembershipsForAppInstanceUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelMembershipsForAppInstanceUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelMembershipsForAppInstanceUserOutput()
        value.channelMemberships = try reader["ChannelMemberships"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListChannelMessagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelMessagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelMessagesOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.channelMessages = try reader["ChannelMessages"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.ChannelMessageSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.subChannelId = try reader["SubChannelId"].readIfPresent()
        return value
    }
}

extension ListChannelModeratorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelModeratorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelModeratorsOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.channelModerators = try reader["ChannelModerators"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.ChannelModeratorSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListChannelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelsOutput()
        value.channels = try reader["Channels"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.ChannelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListChannelsAssociatedWithChannelFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelsAssociatedWithChannelFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelsAssociatedWithChannelFlowOutput()
        value.channels = try reader["Channels"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.ChannelAssociatedWithFlowSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListChannelsModeratedByAppInstanceUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListChannelsModeratedByAppInstanceUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChannelsModeratedByAppInstanceUserOutput()
        value.channels = try reader["Channels"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListSubChannelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSubChannelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSubChannelsOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.subChannels = try reader["SubChannels"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.SubChannelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutChannelExpirationSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutChannelExpirationSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutChannelExpirationSettingsOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.expirationSettings = try reader["ExpirationSettings"].readIfPresent(with: ChimeSDKMessagingClientTypes.ExpirationSettings.read(from:))
        return value
    }
}

extension PutChannelMembershipPreferencesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutChannelMembershipPreferencesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutChannelMembershipPreferencesOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.member = try reader["Member"].readIfPresent(with: ChimeSDKMessagingClientTypes.Identity.read(from:))
        value.preferences = try reader["Preferences"].readIfPresent(with: ChimeSDKMessagingClientTypes.ChannelMembershipPreferences.read(from:))
        return value
    }
}

extension PutMessagingStreamingConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutMessagingStreamingConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutMessagingStreamingConfigurationsOutput()
        value.streamingConfigurations = try reader["StreamingConfigurations"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.StreamingConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RedactChannelMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RedactChannelMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RedactChannelMessageOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.messageId = try reader["MessageId"].readIfPresent()
        value.subChannelId = try reader["SubChannelId"].readIfPresent()
        return value
    }
}

extension SearchChannelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchChannelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchChannelsOutput()
        value.channels = try reader["Channels"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.ChannelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension SendChannelMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendChannelMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendChannelMessageOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.messageId = try reader["MessageId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent(with: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure.read(from:))
        value.subChannelId = try reader["SubChannelId"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateChannelOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        return value
    }
}

extension UpdateChannelFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateChannelFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateChannelFlowOutput()
        value.channelFlowArn = try reader["ChannelFlowArn"].readIfPresent()
        return value
    }
}

extension UpdateChannelMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateChannelMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateChannelMessageOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.messageId = try reader["MessageId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent(with: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure.read(from:))
        value.subChannelId = try reader["SubChannelId"].readIfPresent()
        return value
    }
}

extension UpdateChannelReadMarkerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateChannelReadMarkerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateChannelReadMarkerOutput()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        return value
    }
}

enum AssociateChannelFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchCreateChannelMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ChannelFlowCallbackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateChannelBanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateChannelFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateChannelMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateChannelModeratorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteChannelBanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteChannelFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteChannelMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteChannelMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteChannelModeratorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMessagingStreamingConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeChannelBanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeChannelFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeChannelMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeChannelMembershipForAppInstanceUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeChannelModeratedByAppInstanceUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeChannelModeratorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateChannelFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetChannelMembershipPreferencesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetChannelMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetChannelMessageStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMessagingSessionEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMessagingStreamingConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelBansOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelFlowsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelMembershipsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelMembershipsForAppInstanceUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelMessagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelModeratorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelsAssociatedWithChannelFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListChannelsModeratedByAppInstanceUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSubChannelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutChannelExpirationSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutChannelMembershipPreferencesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutMessagingStreamingConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RedactChannelMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchChannelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendChannelMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateChannelFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateChannelMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateChannelReadMarkerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UnauthorizedClientException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedClientException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedClientException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottledClientException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottledClientException {
        let reader = baseError.errorBodyReader
        var value = ThrottledClientException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceFailureException {
        let reader = baseError.errorBodyReader
        var value = ServiceFailureException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ResourceLimitExceededException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ChimeSDKMessagingClientTypes.BatchChannelMemberships {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.BatchChannelMemberships {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.BatchChannelMemberships()
        value.invitedBy = try reader["InvitedBy"].readIfPresent(with: ChimeSDKMessagingClientTypes.Identity.read(from:))
        value.type = try reader["Type"].readIfPresent()
        value.members = try reader["Members"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.Identity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.subChannelId = try reader["SubChannelId"].readIfPresent()
        return value
    }
}

extension ChimeSDKMessagingClientTypes.Identity {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.Identity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.Identity()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension ChimeSDKMessagingClientTypes.BatchCreateChannelMembershipError {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.BatchCreateChannelMembershipError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.BatchCreateChannelMembershipError()
        value.memberArn = try reader["MemberArn"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension ChimeSDKMessagingClientTypes.Channel {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.Channel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.Channel()
        value.name = try reader["Name"].readIfPresent()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.mode = try reader["Mode"].readIfPresent()
        value.privacy = try reader["Privacy"].readIfPresent()
        value.metadata = try reader["Metadata"].readIfPresent()
        value.createdBy = try reader["CreatedBy"].readIfPresent(with: ChimeSDKMessagingClientTypes.Identity.read(from:))
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastMessageTimestamp = try reader["LastMessageTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.channelFlowArn = try reader["ChannelFlowArn"].readIfPresent()
        value.elasticChannelConfiguration = try reader["ElasticChannelConfiguration"].readIfPresent(with: ChimeSDKMessagingClientTypes.ElasticChannelConfiguration.read(from:))
        value.expirationSettings = try reader["ExpirationSettings"].readIfPresent(with: ChimeSDKMessagingClientTypes.ExpirationSettings.read(from:))
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ExpirationSettings {

    static func write(value: ChimeSDKMessagingClientTypes.ExpirationSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExpirationCriterion"].write(value.expirationCriterion)
        try writer["ExpirationDays"].write(value.expirationDays)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.ExpirationSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.ExpirationSettings()
        value.expirationDays = try reader["ExpirationDays"].readIfPresent() ?? 0
        value.expirationCriterion = try reader["ExpirationCriterion"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ElasticChannelConfiguration {

    static func write(value: ChimeSDKMessagingClientTypes.ElasticChannelConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaximumSubChannels"].write(value.maximumSubChannels)
        try writer["MinimumMembershipPercentage"].write(value.minimumMembershipPercentage)
        try writer["TargetMembershipsPerSubChannel"].write(value.targetMembershipsPerSubChannel)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.ElasticChannelConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.ElasticChannelConfiguration()
        value.maximumSubChannels = try reader["MaximumSubChannels"].readIfPresent() ?? 0
        value.targetMembershipsPerSubChannel = try reader["TargetMembershipsPerSubChannel"].readIfPresent() ?? 0
        value.minimumMembershipPercentage = try reader["MinimumMembershipPercentage"].readIfPresent() ?? 0
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ChannelBan {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.ChannelBan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.ChannelBan()
        value.member = try reader["Member"].readIfPresent(with: ChimeSDKMessagingClientTypes.Identity.read(from:))
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["CreatedBy"].readIfPresent(with: ChimeSDKMessagingClientTypes.Identity.read(from:))
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ChannelFlow {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.ChannelFlow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.ChannelFlow()
        value.channelFlowArn = try reader["ChannelFlowArn"].readIfPresent()
        value.processors = try reader["Processors"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.Processor.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ChimeSDKMessagingClientTypes.Processor {

    static func write(value: ChimeSDKMessagingClientTypes.Processor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Configuration"].write(value.configuration, with: ChimeSDKMessagingClientTypes.ProcessorConfiguration.write(value:to:))
        try writer["ExecutionOrder"].write(value.executionOrder)
        try writer["FallbackAction"].write(value.fallbackAction)
        try writer["Name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.Processor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.Processor()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.configuration = try reader["Configuration"].readIfPresent(with: ChimeSDKMessagingClientTypes.ProcessorConfiguration.read(from:))
        value.executionOrder = try reader["ExecutionOrder"].readIfPresent() ?? 0
        value.fallbackAction = try reader["FallbackAction"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ProcessorConfiguration {

    static func write(value: ChimeSDKMessagingClientTypes.ProcessorConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Lambda"].write(value.lambda, with: ChimeSDKMessagingClientTypes.LambdaConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.ProcessorConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.ProcessorConfiguration()
        value.lambda = try reader["Lambda"].readIfPresent(with: ChimeSDKMessagingClientTypes.LambdaConfiguration.read(from:))
        return value
    }
}

extension ChimeSDKMessagingClientTypes.LambdaConfiguration {

    static func write(value: ChimeSDKMessagingClientTypes.LambdaConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InvocationType"].write(value.invocationType)
        try writer["ResourceArn"].write(value.resourceArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.LambdaConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.LambdaConfiguration()
        value.resourceArn = try reader["ResourceArn"].readIfPresent() ?? ""
        value.invocationType = try reader["InvocationType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ChannelMembership {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.ChannelMembership {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.ChannelMembership()
        value.invitedBy = try reader["InvitedBy"].readIfPresent(with: ChimeSDKMessagingClientTypes.Identity.read(from:))
        value.type = try reader["Type"].readIfPresent()
        value.member = try reader["Member"].readIfPresent(with: ChimeSDKMessagingClientTypes.Identity.read(from:))
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.subChannelId = try reader["SubChannelId"].readIfPresent()
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.ChannelMembershipForAppInstanceUserSummary()
        value.channelSummary = try reader["ChannelSummary"].readIfPresent(with: ChimeSDKMessagingClientTypes.ChannelSummary.read(from:))
        value.appInstanceUserMembershipSummary = try reader["AppInstanceUserMembershipSummary"].readIfPresent(with: ChimeSDKMessagingClientTypes.AppInstanceUserMembershipSummary.read(from:))
        return value
    }
}

extension ChimeSDKMessagingClientTypes.AppInstanceUserMembershipSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.AppInstanceUserMembershipSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.AppInstanceUserMembershipSummary()
        value.type = try reader["Type"].readIfPresent()
        value.readMarkerTimestamp = try reader["ReadMarkerTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.subChannelId = try reader["SubChannelId"].readIfPresent()
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ChannelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.ChannelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.ChannelSummary()
        value.name = try reader["Name"].readIfPresent()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.mode = try reader["Mode"].readIfPresent()
        value.privacy = try reader["Privacy"].readIfPresent()
        value.metadata = try reader["Metadata"].readIfPresent()
        value.lastMessageTimestamp = try reader["LastMessageTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.ChannelModeratedByAppInstanceUserSummary()
        value.channelSummary = try reader["ChannelSummary"].readIfPresent(with: ChimeSDKMessagingClientTypes.ChannelSummary.read(from:))
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ChannelModerator {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.ChannelModerator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.ChannelModerator()
        value.moderator = try reader["Moderator"].readIfPresent(with: ChimeSDKMessagingClientTypes.Identity.read(from:))
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdBy = try reader["CreatedBy"].readIfPresent(with: ChimeSDKMessagingClientTypes.Identity.read(from:))
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ChannelMembershipPreferences {

    static func write(value: ChimeSDKMessagingClientTypes.ChannelMembershipPreferences?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PushNotifications"].write(value.pushNotifications, with: ChimeSDKMessagingClientTypes.PushNotificationPreferences.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.ChannelMembershipPreferences {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.ChannelMembershipPreferences()
        value.pushNotifications = try reader["PushNotifications"].readIfPresent(with: ChimeSDKMessagingClientTypes.PushNotificationPreferences.read(from:))
        return value
    }
}

extension ChimeSDKMessagingClientTypes.PushNotificationPreferences {

    static func write(value: ChimeSDKMessagingClientTypes.PushNotificationPreferences?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllowNotifications"].write(value.allowNotifications)
        try writer["FilterRule"].write(value.filterRule)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.PushNotificationPreferences {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.PushNotificationPreferences()
        value.allowNotifications = try reader["AllowNotifications"].readIfPresent() ?? .sdkUnknown("")
        value.filterRule = try reader["FilterRule"].readIfPresent()
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ChannelMessage {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.ChannelMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.ChannelMessage()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.messageId = try reader["MessageId"].readIfPresent()
        value.content = try reader["Content"].readIfPresent()
        value.metadata = try reader["Metadata"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastEditedTimestamp = try reader["LastEditedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sender = try reader["Sender"].readIfPresent(with: ChimeSDKMessagingClientTypes.Identity.read(from:))
        value.redacted = try reader["Redacted"].readIfPresent() ?? false
        value.persistence = try reader["Persistence"].readIfPresent()
        value.status = try reader["Status"].readIfPresent(with: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure.read(from:))
        value.messageAttributes = try reader["MessageAttributes"].readMapIfPresent(valueReadingClosure: ChimeSDKMessagingClientTypes.MessageAttributeValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.subChannelId = try reader["SubChannelId"].readIfPresent()
        value.contentType = try reader["ContentType"].readIfPresent()
        value.target = try reader["Target"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ChimeSDKMessagingClientTypes.Target {

    static func write(value: ChimeSDKMessagingClientTypes.Target?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MemberArn"].write(value.memberArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.Target {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.Target()
        value.memberArn = try reader["MemberArn"].readIfPresent()
        return value
    }
}

extension ChimeSDKMessagingClientTypes.MessageAttributeValue {

    static func write(value: ChimeSDKMessagingClientTypes.MessageAttributeValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StringValues"].writeList(value.stringValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.MessageAttributeValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.MessageAttributeValue()
        value.stringValues = try reader["StringValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure()
        value.value = try reader["Value"].readIfPresent()
        value.detail = try reader["Detail"].readIfPresent()
        return value
    }
}

extension ChimeSDKMessagingClientTypes.MessagingSessionEndpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.MessagingSessionEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.MessagingSessionEndpoint()
        value.url = try reader["Url"].readIfPresent()
        return value
    }
}

extension ChimeSDKMessagingClientTypes.StreamingConfiguration {

    static func write(value: ChimeSDKMessagingClientTypes.StreamingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataType"].write(value.dataType)
        try writer["ResourceArn"].write(value.resourceArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.StreamingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.StreamingConfiguration()
        value.dataType = try reader["DataType"].readIfPresent() ?? .sdkUnknown("")
        value.resourceArn = try reader["ResourceArn"].readIfPresent() ?? ""
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ChannelBanSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.ChannelBanSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.ChannelBanSummary()
        value.member = try reader["Member"].readIfPresent(with: ChimeSDKMessagingClientTypes.Identity.read(from:))
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ChannelFlowSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.ChannelFlowSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.ChannelFlowSummary()
        value.channelFlowArn = try reader["ChannelFlowArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.processors = try reader["Processors"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.Processor.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ChannelMembershipSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.ChannelMembershipSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.ChannelMembershipSummary()
        value.member = try reader["Member"].readIfPresent(with: ChimeSDKMessagingClientTypes.Identity.read(from:))
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ChannelMessageSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.ChannelMessageSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.ChannelMessageSummary()
        value.messageId = try reader["MessageId"].readIfPresent()
        value.content = try reader["Content"].readIfPresent()
        value.metadata = try reader["Metadata"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastEditedTimestamp = try reader["LastEditedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sender = try reader["Sender"].readIfPresent(with: ChimeSDKMessagingClientTypes.Identity.read(from:))
        value.redacted = try reader["Redacted"].readIfPresent() ?? false
        value.status = try reader["Status"].readIfPresent(with: ChimeSDKMessagingClientTypes.ChannelMessageStatusStructure.read(from:))
        value.messageAttributes = try reader["MessageAttributes"].readMapIfPresent(valueReadingClosure: ChimeSDKMessagingClientTypes.MessageAttributeValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.contentType = try reader["ContentType"].readIfPresent()
        value.target = try reader["Target"].readListIfPresent(memberReadingClosure: ChimeSDKMessagingClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ChannelModeratorSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.ChannelModeratorSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.ChannelModeratorSummary()
        value.moderator = try reader["Moderator"].readIfPresent(with: ChimeSDKMessagingClientTypes.Identity.read(from:))
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ChannelAssociatedWithFlowSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.ChannelAssociatedWithFlowSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.ChannelAssociatedWithFlowSummary()
        value.name = try reader["Name"].readIfPresent()
        value.channelArn = try reader["ChannelArn"].readIfPresent()
        value.mode = try reader["Mode"].readIfPresent()
        value.privacy = try reader["Privacy"].readIfPresent()
        value.metadata = try reader["Metadata"].readIfPresent()
        return value
    }
}

extension ChimeSDKMessagingClientTypes.SubChannelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.SubChannelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.SubChannelSummary()
        value.subChannelId = try reader["SubChannelId"].readIfPresent()
        value.membershipCount = try reader["MembershipCount"].readIfPresent()
        return value
    }
}

extension ChimeSDKMessagingClientTypes.Tag {

    static func write(value: ChimeSDKMessagingClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMessagingClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMessagingClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension ChimeSDKMessagingClientTypes.ChannelMessageCallback {

    static func write(value: ChimeSDKMessagingClientTypes.ChannelMessageCallback?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Content"].write(value.content)
        try writer["ContentType"].write(value.contentType)
        try writer["MessageAttributes"].writeMap(value.messageAttributes, valueWritingClosure: ChimeSDKMessagingClientTypes.MessageAttributeValue.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["MessageId"].write(value.messageId)
        try writer["Metadata"].write(value.metadata)
        try writer["PushNotification"].write(value.pushNotification, with: ChimeSDKMessagingClientTypes.PushNotificationConfiguration.write(value:to:))
        try writer["SubChannelId"].write(value.subChannelId)
    }
}

extension ChimeSDKMessagingClientTypes.PushNotificationConfiguration {

    static func write(value: ChimeSDKMessagingClientTypes.PushNotificationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Body"].write(value.body)
        try writer["Title"].write(value.title)
        try writer["Type"].write(value.type)
    }
}

extension ChimeSDKMessagingClientTypes.SearchField {

    static func write(value: ChimeSDKMessagingClientTypes.SearchField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Operator"].write(value.`operator`)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum ChimeSDKMessagingClientTypes {}
