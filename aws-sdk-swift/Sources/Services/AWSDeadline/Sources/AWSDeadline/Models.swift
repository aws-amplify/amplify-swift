//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import SmithyJSON
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

extension DeadlineClientTypes {

    /// The range for the GPU fleet acceleration.
    public struct AcceleratorCountRange: Swift.Sendable {
        /// The maximum GPU for the accelerator.
        public var max: Swift.Int?
        /// The minimum GPU for the accelerator.
        /// This member is required.
        public var min: Swift.Int?

        public init(
            max: Swift.Int? = nil,
            min: Swift.Int? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }
}

extension DeadlineClientTypes {

    /// The range for memory, in MiB, to use for the accelerator.
    public struct AcceleratorTotalMemoryMiBRange: Swift.Sendable {
        /// The maximum amount of memory to use for the accelerator, measured in MiB.
        public var max: Swift.Int?
        /// The minimum amount of memory to use for the accelerator, measured in MiB.
        /// This member is required.
        public var min: Swift.Int?

        public init(
            max: Swift.Int? = nil,
            min: Swift.Int? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }
}

extension DeadlineClientTypes {

    public enum AcceleratorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// GPU accelerator type.
        case gpu
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceleratorType] {
            return [
                .gpu
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gpu: return "gpu"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// You don't have permission to perform the action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Information about the resources in use when the exception was thrown.
        public internal(set) var context: [Swift.String: Swift.String]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        context: [Swift.String: Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.context = context
        self.properties.message = message
    }
}

extension DeadlineClientTypes {

    /// The assigned starting environment for a worker during session.
    public struct AssignedEnvironmentEnterSessionActionDefinition: Swift.Sendable {
        /// The environment ID of the assigned environment at the start of a session.
        /// This member is required.
        public var environmentId: Swift.String?

        public init(
            environmentId: Swift.String? = nil
        )
        {
            self.environmentId = environmentId
        }
    }
}

extension DeadlineClientTypes {

    /// The assigned environment when a worker exits a session.
    public struct AssignedEnvironmentExitSessionActionDefinition: Swift.Sendable {
        /// The environment ID of the assigned environment when exiting a session.
        /// This member is required.
        public var environmentId: Swift.String?

        public init(
            environmentId: Swift.String? = nil
        )
        {
            self.environmentId = environmentId
        }
    }
}

extension DeadlineClientTypes {

    /// Log configuration details.
    public struct LogConfiguration: Swift.Sendable {
        /// The log configuration error details.
        public var error: Swift.String?
        /// The log drivers for worker related logs.
        /// This member is required.
        public var logDriver: Swift.String?
        /// The options for a log driver.
        public var options: [Swift.String: Swift.String]?
        /// The parameters for the log configuration.
        public var parameters: [Swift.String: Swift.String]?

        public init(
            error: Swift.String? = nil,
            logDriver: Swift.String? = nil,
            options: [Swift.String: Swift.String]? = nil,
            parameters: [Swift.String: Swift.String]? = nil
        )
        {
            self.error = error
            self.logDriver = logDriver
            self.options = options
            self.parameters = parameters
        }
    }
}

extension DeadlineClientTypes {

    /// The details for an assigned session action as it relates to a job attachment.
    public struct AssignedSyncInputJobAttachmentsSessionActionDefinition: Swift.Sendable {
        /// The step ID.
        public var stepId: Swift.String?

        public init(
            stepId: Swift.String? = nil
        )
        {
            self.stepId = stepId
        }
    }
}

extension DeadlineClientTypes {

    /// The data types for the task parameters.
    public enum TaskParameterValue: Swift.Sendable {
        /// A signed integer represented as a string.
        case int(Swift.String)
        /// A double precision IEEE-754 floating point number represented as a string.
        case float(Swift.String)
        /// A UTF-8 string.
        case string(Swift.String)
        /// A file system path represented as a string.
        case path(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension DeadlineClientTypes {

    /// The specific task, step, and parameters to include.
    public struct AssignedTaskRunSessionActionDefinition: Swift.Sendable {
        /// The parameters to include.
        /// This member is required.
        public var parameters: [Swift.String: DeadlineClientTypes.TaskParameterValue]?
        /// The step ID.
        /// This member is required.
        public var stepId: Swift.String?
        /// The task ID.
        /// This member is required.
        public var taskId: Swift.String?

        public init(
            parameters: [Swift.String: DeadlineClientTypes.TaskParameterValue]? = nil,
            stepId: Swift.String? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.parameters = parameters
            self.stepId = stepId
            self.taskId = taskId
        }
    }
}

extension DeadlineClientTypes.AssignedTaskRunSessionActionDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssignedTaskRunSessionActionDefinition(stepId: \(Swift.String(describing: stepId)), taskId: \(Swift.String(describing: taskId)), parameters: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {

    /// The definition of the assigned session action.
    public enum AssignedSessionActionDefinition: Swift.Sendable {
        /// The environment a session starts on.
        case enventer(DeadlineClientTypes.AssignedEnvironmentEnterSessionActionDefinition)
        /// The environment a session exits from.
        case envexit(DeadlineClientTypes.AssignedEnvironmentExitSessionActionDefinition)
        /// The task run.
        case taskrun(DeadlineClientTypes.AssignedTaskRunSessionActionDefinition)
        /// The job attachment to sync with an assigned session action.
        case syncinputjobattachments(DeadlineClientTypes.AssignedSyncInputJobAttachmentsSessionActionDefinition)
        case sdkUnknown(Swift.String)
    }
}

extension DeadlineClientTypes {

    /// The action for a session defined by the session action ID.
    public struct AssignedSessionAction: Swift.Sendable {
        /// The definition of the assigned session action.
        /// This member is required.
        public var definition: DeadlineClientTypes.AssignedSessionActionDefinition?
        /// The session action ID for the assigned session.
        /// This member is required.
        public var sessionActionId: Swift.String?

        public init(
            definition: DeadlineClientTypes.AssignedSessionActionDefinition? = nil,
            sessionActionId: Swift.String? = nil
        )
        {
            self.definition = definition
            self.sessionActionId = sessionActionId
        }
    }
}

extension DeadlineClientTypes {

    /// The assigned session for the worker.
    public struct AssignedSession: Swift.Sendable {
        /// The job ID for the assigned session.
        /// This member is required.
        public var jobId: Swift.String?
        /// The log configuration for the worker's assigned session.
        /// This member is required.
        public var logConfiguration: DeadlineClientTypes.LogConfiguration?
        /// The queue ID of the assigned session.
        /// This member is required.
        public var queueId: Swift.String?
        /// The session actions to apply to the assigned session.
        /// This member is required.
        public var sessionActions: [DeadlineClientTypes.AssignedSessionAction]?

        public init(
            jobId: Swift.String? = nil,
            logConfiguration: DeadlineClientTypes.LogConfiguration? = nil,
            queueId: Swift.String? = nil,
            sessionActions: [DeadlineClientTypes.AssignedSessionAction]? = nil
        )
        {
            self.jobId = jobId
            self.logConfiguration = logConfiguration
            self.queueId = queueId
            self.sessionActions = sessionActions
        }
    }
}

/// Deadline Cloud can't process your request right now. Try again later.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds a client should wait before retrying the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The requested resource can't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Information about the resources in use when the exception was thrown.
        public internal(set) var context: [Swift.String: Swift.String]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that couldn't be found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that couldn't be found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        context: [Swift.String: Swift.String]? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.context = context
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension DeadlineClientTypes {

    public enum ServiceQuotaExceededExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case kmsKeyLimitExceeded
        case serviceQuotaExceededException
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceQuotaExceededExceptionReason] {
            return [
                .kmsKeyLimitExceeded,
                .serviceQuotaExceededException
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .kmsKeyLimitExceeded: return "KMS_KEY_LIMIT_EXCEEDED"
            case .serviceQuotaExceededException: return "SERVICE_QUOTA_EXCEEDED_EXCEPTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// You exceeded your service quota. Service quotas, also referred to as limits, are the maximum number of service resources or operations for your Amazon Web Services account.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Information about the resources in use when the exception was thrown.
        public internal(set) var context: [Swift.String: Swift.String]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifies the quota that has been exceeded.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// A string that describes the reason the quota was exceeded.
        /// This member is required.
        public internal(set) var reason: DeadlineClientTypes.ServiceQuotaExceededExceptionReason? = nil
        /// The identifier of the affected resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the affected resource
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// Identifies the service that exceeded the quota.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        context: [Swift.String: Swift.String]? = nil,
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        reason: DeadlineClientTypes.ServiceQuotaExceededExceptionReason? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.context = context
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.reason = reason
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// Your request exceeded a request rate quota.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Information about the resources in use when the exception was thrown.
        public internal(set) var context: [Swift.String: Swift.String]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifies the quota that is being throttled.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds a client should wait before retrying the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// Identifies the service that is being throttled.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        context: [Swift.String: Swift.String]? = nil,
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.context = context
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension DeadlineClientTypes {

    /// The details of a validation exception.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The error message for the validation exception.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the validation exception.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension DeadlineClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request isn't valid. This can occur if your request contains malformed JSON or unsupported characters.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Information about the resources in use when the exception was thrown.
        public internal(set) var context: [Swift.String: Swift.String]? = nil
        /// A list of fields that failed validation.
        public internal(set) var fieldList: [DeadlineClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason that the request failed validation.
        /// This member is required.
        public internal(set) var reason: DeadlineClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        context: [Swift.String: Swift.String]? = nil,
        fieldList: [DeadlineClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: DeadlineClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.context = context
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension DeadlineClientTypes {

    public enum MembershipLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contributor
        case manager
        case owner
        case viewer
        case sdkUnknown(Swift.String)

        public static var allCases: [MembershipLevel] {
            return [
                .contributor,
                .manager,
                .owner,
                .viewer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contributor: return "CONTRIBUTOR"
            case .manager: return "MANAGER"
            case .owner: return "OWNER"
            case .viewer: return "VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    public enum DeadlinePrincipalType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case group
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [DeadlinePrincipalType] {
            return [
                .group,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AssociateMemberToFarmInput: Swift.Sendable {
    /// The ID of the farm to associate with the member.
    /// This member is required.
    public var farmId: Swift.String?
    /// The identity store ID of the member to associate with the farm.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The principal's membership level for the associated farm.
    /// This member is required.
    public var membershipLevel: DeadlineClientTypes.MembershipLevel?
    /// The member's principal ID to associate with the farm.
    /// This member is required.
    public var principalId: Swift.String?
    /// The principal type of the member to associate with the farm.
    /// This member is required.
    public var principalType: DeadlineClientTypes.DeadlinePrincipalType?

    public init(
        farmId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        membershipLevel: DeadlineClientTypes.MembershipLevel? = nil,
        principalId: Swift.String? = nil,
        principalType: DeadlineClientTypes.DeadlinePrincipalType? = nil
    )
    {
        self.farmId = farmId
        self.identityStoreId = identityStoreId
        self.membershipLevel = membershipLevel
        self.principalId = principalId
        self.principalType = principalType
    }
}

public struct AssociateMemberToFarmOutput: Swift.Sendable {

    public init() { }
}

public struct AssociateMemberToFleetInput: Swift.Sendable {
    /// The farm ID of the fleet to associate with the member.
    /// This member is required.
    public var farmId: Swift.String?
    /// The ID of the fleet to associate with a member.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The member's identity store ID to associate with the fleet.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The principal's membership level for the associated fleet.
    /// This member is required.
    public var membershipLevel: DeadlineClientTypes.MembershipLevel?
    /// The member's principal ID to associate with a fleet.
    /// This member is required.
    public var principalId: Swift.String?
    /// The member's principal type to associate with the fleet.
    /// This member is required.
    public var principalType: DeadlineClientTypes.DeadlinePrincipalType?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        membershipLevel: DeadlineClientTypes.MembershipLevel? = nil,
        principalId: Swift.String? = nil,
        principalType: DeadlineClientTypes.DeadlinePrincipalType? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.identityStoreId = identityStoreId
        self.membershipLevel = membershipLevel
        self.principalId = principalId
        self.principalType = principalType
    }
}

public struct AssociateMemberToFleetOutput: Swift.Sendable {

    public init() { }
}

public struct AssociateMemberToJobInput: Swift.Sendable {
    /// The farm ID of the job to associate with the member.
    /// This member is required.
    public var farmId: Swift.String?
    /// The member's identity store ID to associate with the job.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The job ID to associate with the member.
    /// This member is required.
    public var jobId: Swift.String?
    /// The principal's membership level for the associated job.
    /// This member is required.
    public var membershipLevel: DeadlineClientTypes.MembershipLevel?
    /// The member's principal ID to associate with the job.
    /// This member is required.
    public var principalId: Swift.String?
    /// The member's principal type to associate with the job.
    /// This member is required.
    public var principalType: DeadlineClientTypes.DeadlinePrincipalType?
    /// The queue ID to associate to the member.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        membershipLevel: DeadlineClientTypes.MembershipLevel? = nil,
        principalId: Swift.String? = nil,
        principalType: DeadlineClientTypes.DeadlinePrincipalType? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.identityStoreId = identityStoreId
        self.jobId = jobId
        self.membershipLevel = membershipLevel
        self.principalId = principalId
        self.principalType = principalType
        self.queueId = queueId
    }
}

public struct AssociateMemberToJobOutput: Swift.Sendable {

    public init() { }
}

public struct AssociateMemberToQueueInput: Swift.Sendable {
    /// The farm ID of the queue to associate with the member.
    /// This member is required.
    public var farmId: Swift.String?
    /// The member's identity store ID to associate with the queue.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The principal's membership level for the associated queue.
    /// This member is required.
    public var membershipLevel: DeadlineClientTypes.MembershipLevel?
    /// The member's principal ID to associate with the queue.
    /// This member is required.
    public var principalId: Swift.String?
    /// The member's principal type to associate with the queue.
    /// This member is required.
    public var principalType: DeadlineClientTypes.DeadlinePrincipalType?
    /// The ID of the queue to associate to the member.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        membershipLevel: DeadlineClientTypes.MembershipLevel? = nil,
        principalId: Swift.String? = nil,
        principalType: DeadlineClientTypes.DeadlinePrincipalType? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.identityStoreId = identityStoreId
        self.membershipLevel = membershipLevel
        self.principalId = principalId
        self.principalType = principalType
        self.queueId = queueId
    }
}

public struct AssociateMemberToQueueOutput: Swift.Sendable {

    public init() { }
}

public struct AssumeFleetRoleForReadInput: Swift.Sendable {
    /// The farm ID for the fleet's farm.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID.
    /// This member is required.
    public var fleetId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
    }
}

extension DeadlineClientTypes {

    /// The Identity and Access Management credentials.
    public struct AwsCredentials: Swift.Sendable {
        /// The IAM access key ID.
        /// This member is required.
        public var accessKeyId: Swift.String?
        /// The expiration date and time of the IAM credentials.
        /// This member is required.
        public var expiration: Foundation.Date?
        /// The IAM secret access key.
        /// This member is required.
        public var secretAccessKey: Swift.String?
        /// The IAM session token
        /// This member is required.
        public var sessionToken: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            expiration: Foundation.Date? = nil,
            secretAccessKey: Swift.String? = nil,
            sessionToken: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.expiration = expiration
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }
    }
}

extension DeadlineClientTypes.AwsCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct AssumeFleetRoleForReadOutput: Swift.Sendable {
    /// The credentials for the fleet role.
    /// This member is required.
    public var credentials: DeadlineClientTypes.AwsCredentials?

    public init(
        credentials: DeadlineClientTypes.AwsCredentials? = nil
    )
    {
        self.credentials = credentials
    }
}

extension AssumeFleetRoleForReadOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension DeadlineClientTypes {

    public enum ConflictExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case concurrentModification
        case conflictException
        case resourceAlreadyExists
        case resourceInUse
        case statusConflict
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .concurrentModification,
                .conflictException,
                .resourceAlreadyExists,
                .resourceInUse,
                .statusConflict
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .concurrentModification: return "CONCURRENT_MODIFICATION"
            case .conflictException: return "CONFLICT_EXCEPTION"
            case .resourceAlreadyExists: return "RESOURCE_ALREADY_EXISTS"
            case .resourceInUse: return "RESOURCE_IN_USE"
            case .statusConflict: return "STATUS_CONFLICT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Your request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Information about the resources in use when the exception was thrown.
        public internal(set) var context: [Swift.String: Swift.String]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// A description of the error.
        /// This member is required.
        public internal(set) var reason: DeadlineClientTypes.ConflictExceptionReason? = nil
        /// The identifier of the resource in use.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource in use.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        context: [Swift.String: Swift.String]? = nil,
        message: Swift.String? = nil,
        reason: DeadlineClientTypes.ConflictExceptionReason? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.context = context
        self.properties.message = message
        self.properties.reason = reason
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

public struct AssumeFleetRoleForWorkerInput: Swift.Sendable {
    /// The farm ID for the fleet's farm.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID that contains the worker.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The ID of the worker assuming the fleet role.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.workerId = workerId
    }
}

public struct AssumeFleetRoleForWorkerOutput: Swift.Sendable {
    /// The credentials for the worker.
    /// This member is required.
    public var credentials: DeadlineClientTypes.AwsCredentials?

    public init(
        credentials: DeadlineClientTypes.AwsCredentials? = nil
    )
    {
        self.credentials = credentials
    }
}

extension AssumeFleetRoleForWorkerOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct AssumeQueueRoleForReadInput: Swift.Sendable {
    /// The farm ID of the farm containing the queue.
    /// This member is required.
    public var farmId: Swift.String?
    /// The queue ID.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.queueId = queueId
    }
}

public struct AssumeQueueRoleForReadOutput: Swift.Sendable {
    /// The credentials for the queue role.
    /// This member is required.
    public var credentials: DeadlineClientTypes.AwsCredentials?

    public init(
        credentials: DeadlineClientTypes.AwsCredentials? = nil
    )
    {
        self.credentials = credentials
    }
}

extension AssumeQueueRoleForReadOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct AssumeQueueRoleForUserInput: Swift.Sendable {
    /// The farm ID of the queue that the user assumes the role for.
    /// This member is required.
    public var farmId: Swift.String?
    /// The queue ID of the queue that the user assumes the role for.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.queueId = queueId
    }
}

public struct AssumeQueueRoleForUserOutput: Swift.Sendable {
    /// The credentials for the queue role that a user has access to.
    /// This member is required.
    public var credentials: DeadlineClientTypes.AwsCredentials?

    public init(
        credentials: DeadlineClientTypes.AwsCredentials? = nil
    )
    {
        self.credentials = credentials
    }
}

extension AssumeQueueRoleForUserOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct AssumeQueueRoleForWorkerInput: Swift.Sendable {
    /// The farm ID of the worker assuming the queue role.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID of the worker assuming the queue role.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The queue ID of the worker assuming the queue role.
    /// This member is required.
    public var queueId: Swift.String?
    /// The worker ID of the worker assuming the queue role.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.queueId = queueId
        self.workerId = workerId
    }
}

public struct AssumeQueueRoleForWorkerOutput: Swift.Sendable {
    /// The Amazon Web Services credentials for the role that the worker is assuming.
    public var credentials: DeadlineClientTypes.AwsCredentials?

    public init(
        credentials: DeadlineClientTypes.AwsCredentials? = nil
    )
    {
        self.credentials = credentials
    }
}

extension AssumeQueueRoleForWorkerOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension DeadlineClientTypes {

    public enum JobAttachmentsFileSystem: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case copied
        case virtual
        case sdkUnknown(Swift.String)

        public static var allCases: [JobAttachmentsFileSystem] {
            return [
                .copied,
                .virtual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .copied: return "COPIED"
            case .virtual: return "VIRTUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    public enum PathFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case posix
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [PathFormat] {
            return [
                .posix,
                .windows
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .posix: return "posix"
            case .windows: return "windows"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    /// The details of the manifest that links a job's source information.
    public struct ManifestProperties: Swift.Sendable {
        /// The file system location name.
        public var fileSystemLocationName: Swift.String?
        /// The has value of the file.
        public var inputManifestHash: Swift.String?
        /// The file path.
        public var inputManifestPath: Swift.String?
        /// The file path relative to the directory.
        public var outputRelativeDirectories: [Swift.String]?
        /// The file's root path.
        /// This member is required.
        public var rootPath: Swift.String?
        /// The format of the root path.
        /// This member is required.
        public var rootPathFormat: DeadlineClientTypes.PathFormat?

        public init(
            fileSystemLocationName: Swift.String? = nil,
            inputManifestHash: Swift.String? = nil,
            inputManifestPath: Swift.String? = nil,
            outputRelativeDirectories: [Swift.String]? = nil,
            rootPath: Swift.String? = nil,
            rootPathFormat: DeadlineClientTypes.PathFormat? = nil
        )
        {
            self.fileSystemLocationName = fileSystemLocationName
            self.inputManifestHash = inputManifestHash
            self.inputManifestPath = inputManifestPath
            self.outputRelativeDirectories = outputRelativeDirectories
            self.rootPath = rootPath
            self.rootPathFormat = rootPathFormat
        }
    }
}

extension DeadlineClientTypes.ManifestProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension DeadlineClientTypes {

    /// The attachments for jobs.
    public struct Attachments: Swift.Sendable {
        /// The file system.
        public var fileSystem: DeadlineClientTypes.JobAttachmentsFileSystem?
        /// A list of manifests which describe job attachment configurations.
        /// This member is required.
        public var manifests: [DeadlineClientTypes.ManifestProperties]?

        public init(
            fileSystem: DeadlineClientTypes.JobAttachmentsFileSystem? = .copied,
            manifests: [DeadlineClientTypes.ManifestProperties]? = nil
        )
        {
            self.fileSystem = fileSystem
            self.manifests = manifests
        }
    }
}

extension DeadlineClientTypes.Attachments: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Attachments(fileSystem: \(Swift.String(describing: fileSystem)), manifests: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {

    public enum AutoScalingMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case eventBasedAutoScaling
        case noScaling
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoScalingMode] {
            return [
                .eventBasedAutoScaling,
                .noScaling
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .eventBasedAutoScaling: return "EVENT_BASED_AUTO_SCALING"
            case .noScaling: return "NO_SCALING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    public enum AutoScalingStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case growing
        case shrinking
        case steady
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoScalingStatus] {
            return [
                .growing,
                .shrinking,
                .steady
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .growing: return "GROWING"
            case .shrinking: return "SHRINKING"
            case .steady: return "STEADY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    /// The IDs of the job and environment.
    public struct EnvironmentDetailsIdentifiers: Swift.Sendable {
        /// The environment ID.
        /// This member is required.
        public var environmentId: Swift.String?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?

        public init(
            environmentId: Swift.String? = nil,
            jobId: Swift.String? = nil
        )
        {
            self.environmentId = environmentId
            self.jobId = jobId
        }
    }
}

extension DeadlineClientTypes {

    /// Identifier details for job attachments.
    public struct JobAttachmentDetailsIdentifiers: Swift.Sendable {
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?

        public init(
            jobId: Swift.String? = nil
        )
        {
            self.jobId = jobId
        }
    }
}

extension DeadlineClientTypes {

    /// The identifiers for a job.
    public struct JobDetailsIdentifiers: Swift.Sendable {
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?

        public init(
            jobId: Swift.String? = nil
        )
        {
            self.jobId = jobId
        }
    }
}

extension DeadlineClientTypes {

    /// The details of identifiers for a step.
    public struct StepDetailsIdentifiers: Swift.Sendable {
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The step ID.
        /// This member is required.
        public var stepId: Swift.String?

        public init(
            jobId: Swift.String? = nil,
            stepId: Swift.String? = nil
        )
        {
            self.jobId = jobId
            self.stepId = stepId
        }
    }
}

extension DeadlineClientTypes {

    /// The details of a job entity identifier.
    public enum JobEntityIdentifiersUnion: Swift.Sendable {
        /// The job details.
        case jobdetails(DeadlineClientTypes.JobDetailsIdentifiers)
        /// The job attachment details.
        case jobattachmentdetails(DeadlineClientTypes.JobAttachmentDetailsIdentifiers)
        /// The step details.
        case stepdetails(DeadlineClientTypes.StepDetailsIdentifiers)
        /// The environment details.
        case environmentdetails(DeadlineClientTypes.EnvironmentDetailsIdentifiers)
        case sdkUnknown(Swift.String)
    }
}

public struct BatchGetJobEntityInput: Swift.Sendable {
    /// The farm ID of the worker that's fetching job details. The worker must have an assignment on a job to fetch job details.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID of the worker that's fetching job details. The worker must have an assignment on a job to fetch job details.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The job identifiers to include within the job entity batch details.
    /// This member is required.
    public var identifiers: [DeadlineClientTypes.JobEntityIdentifiersUnion]?
    /// The worker ID of the worker containing the job details to get.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        identifiers: [DeadlineClientTypes.JobEntityIdentifiersUnion]? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.identifiers = identifiers
        self.workerId = workerId
    }
}

extension DeadlineClientTypes {

    /// The details of a specified environment.
    public struct EnvironmentDetailsEntity: Swift.Sendable {
        /// The environment ID.
        /// This member is required.
        public var environmentId: Swift.String?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The schema version in the environment.
        /// This member is required.
        public var schemaVersion: Swift.String?
        /// The template used for the environment.
        /// This member is required.
        public var template: Smithy.Document?

        public init(
            environmentId: Swift.String? = nil,
            jobId: Swift.String? = nil,
            schemaVersion: Swift.String? = nil,
            template: Smithy.Document? = nil
        )
        {
            self.environmentId = environmentId
            self.jobId = jobId
            self.schemaVersion = schemaVersion
            self.template = template
        }
    }
}

extension DeadlineClientTypes.EnvironmentDetailsEntity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentDetailsEntity(environmentId: \(Swift.String(describing: environmentId)), jobId: \(Swift.String(describing: jobId)), schemaVersion: \(Swift.String(describing: schemaVersion)), template: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {

    /// The job attachments.
    public struct JobAttachmentDetailsEntity: Swift.Sendable {
        /// The job attachments.
        /// This member is required.
        public var attachments: DeadlineClientTypes.Attachments?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?

        public init(
            attachments: DeadlineClientTypes.Attachments? = nil,
            jobId: Swift.String? = nil
        )
        {
            self.attachments = attachments
            self.jobId = jobId
        }
    }
}

extension DeadlineClientTypes {

    /// The job attachment settings. These are the Amazon S3 bucket name and the Amazon S3 prefix.
    public struct JobAttachmentSettings: Swift.Sendable {
        /// The root prefix.
        /// This member is required.
        public var rootPrefix: Swift.String?
        /// The Amazon S3 bucket name.
        /// This member is required.
        public var s3BucketName: Swift.String?

        public init(
            rootPrefix: Swift.String? = nil,
            s3BucketName: Swift.String? = nil
        )
        {
            self.rootPrefix = rootPrefix
            self.s3BucketName = s3BucketName
        }
    }
}

extension DeadlineClientTypes {

    /// The POSIX user.
    public struct PosixUser: Swift.Sendable {
        /// The name of the POSIX user's group.
        /// This member is required.
        public var group: Swift.String?
        /// The name of the POSIX user.
        /// This member is required.
        public var user: Swift.String?

        public init(
            group: Swift.String? = nil,
            user: Swift.String? = nil
        )
        {
            self.group = group
            self.user = user
        }
    }
}

extension DeadlineClientTypes {

    public enum RunAs: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case queueConfiguredUser
        case workerAgentUser
        case sdkUnknown(Swift.String)

        public static var allCases: [RunAs] {
            return [
                .queueConfiguredUser,
                .workerAgentUser
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .queueConfiguredUser: return "QUEUE_CONFIGURED_USER"
            case .workerAgentUser: return "WORKER_AGENT_USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    /// The Windows user details.
    public struct WindowsUser: Swift.Sendable {
        /// The password ARN for the Windows user.
        /// This member is required.
        public var passwordArn: Swift.String?
        /// The user.
        /// This member is required.
        public var user: Swift.String?

        public init(
            passwordArn: Swift.String? = nil,
            user: Swift.String? = nil
        )
        {
            self.passwordArn = passwordArn
            self.user = user
        }
    }
}

extension DeadlineClientTypes {

    /// Identifies the user for a job.
    public struct JobRunAsUser: Swift.Sendable {
        /// The user and group that the jobs in the queue run as.
        public var posix: DeadlineClientTypes.PosixUser?
        /// Specifies whether the job should run using the queue's system user or if the job should run using the worker agent system user.
        /// This member is required.
        public var runAs: DeadlineClientTypes.RunAs?
        /// Identifies a Microsoft Windows user.
        public var windows: DeadlineClientTypes.WindowsUser?

        public init(
            posix: DeadlineClientTypes.PosixUser? = nil,
            runAs: DeadlineClientTypes.RunAs? = nil,
            windows: DeadlineClientTypes.WindowsUser? = nil
        )
        {
            self.posix = posix
            self.runAs = runAs
            self.windows = windows
        }
    }
}

extension DeadlineClientTypes {

    /// The details of job parameters.
    public enum JobParameter: Swift.Sendable {
        /// A signed integer represented as a string.
        case int(Swift.String)
        /// A double precision IEEE-754 floating point number represented as a string.
        case float(Swift.String)
        /// A UTF-8 string.
        case string(Swift.String)
        /// A file system path represented as a string.
        case path(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension DeadlineClientTypes {

    /// The details of a source and destination path.
    public struct PathMappingRule: Swift.Sendable {
        /// The destination path.
        /// This member is required.
        public var destinationPath: Swift.String?
        /// The source path.
        /// This member is required.
        public var sourcePath: Swift.String?
        /// The source path format.
        /// This member is required.
        public var sourcePathFormat: DeadlineClientTypes.PathFormat?

        public init(
            destinationPath: Swift.String? = nil,
            sourcePath: Swift.String? = nil,
            sourcePathFormat: DeadlineClientTypes.PathFormat? = nil
        )
        {
            self.destinationPath = destinationPath
            self.sourcePath = sourcePath
            self.sourcePathFormat = sourcePathFormat
        }
    }
}

extension DeadlineClientTypes.PathMappingRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension DeadlineClientTypes {

    /// The job details for a specific job.
    public struct JobDetailsEntity: Swift.Sendable {
        /// The job attachment settings.
        public var jobAttachmentSettings: DeadlineClientTypes.JobAttachmentSettings?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The user name and group that the job uses when run.
        public var jobRunAsUser: DeadlineClientTypes.JobRunAsUser?
        /// The log group name.
        /// This member is required.
        public var logGroupName: Swift.String?
        /// The parameters.
        public var parameters: [Swift.String: DeadlineClientTypes.JobParameter]?
        /// The path mapping rules.
        public var pathMappingRules: [DeadlineClientTypes.PathMappingRule]?
        /// The queue role ARN.
        public var queueRoleArn: Swift.String?
        /// The schema version.
        /// This member is required.
        public var schemaVersion: Swift.String?

        public init(
            jobAttachmentSettings: DeadlineClientTypes.JobAttachmentSettings? = nil,
            jobId: Swift.String? = nil,
            jobRunAsUser: DeadlineClientTypes.JobRunAsUser? = nil,
            logGroupName: Swift.String? = nil,
            parameters: [Swift.String: DeadlineClientTypes.JobParameter]? = nil,
            pathMappingRules: [DeadlineClientTypes.PathMappingRule]? = nil,
            queueRoleArn: Swift.String? = nil,
            schemaVersion: Swift.String? = nil
        )
        {
            self.jobAttachmentSettings = jobAttachmentSettings
            self.jobId = jobId
            self.jobRunAsUser = jobRunAsUser
            self.logGroupName = logGroupName
            self.parameters = parameters
            self.pathMappingRules = pathMappingRules
            self.queueRoleArn = queueRoleArn
            self.schemaVersion = schemaVersion
        }
    }
}

extension DeadlineClientTypes.JobDetailsEntity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobDetailsEntity(jobAttachmentSettings: \(Swift.String(describing: jobAttachmentSettings)), jobId: \(Swift.String(describing: jobId)), jobRunAsUser: \(Swift.String(describing: jobRunAsUser)), logGroupName: \(Swift.String(describing: logGroupName)), queueRoleArn: \(Swift.String(describing: queueRoleArn)), schemaVersion: \(Swift.String(describing: schemaVersion)), parameters: \"CONTENT_REDACTED\", pathMappingRules: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {

    /// The details of a step entity.
    public struct StepDetailsEntity: Swift.Sendable {
        /// The dependencies for a step.
        /// This member is required.
        public var dependencies: [Swift.String]?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The schema version for a step template.
        /// This member is required.
        public var schemaVersion: Swift.String?
        /// The step ID.
        /// This member is required.
        public var stepId: Swift.String?
        /// The template for a step.
        /// This member is required.
        public var template: Smithy.Document?

        public init(
            dependencies: [Swift.String]? = nil,
            jobId: Swift.String? = nil,
            schemaVersion: Swift.String? = nil,
            stepId: Swift.String? = nil,
            template: Smithy.Document? = nil
        )
        {
            self.dependencies = dependencies
            self.jobId = jobId
            self.schemaVersion = schemaVersion
            self.stepId = stepId
            self.template = template
        }
    }
}

extension DeadlineClientTypes.StepDetailsEntity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StepDetailsEntity(dependencies: \(Swift.String(describing: dependencies)), jobId: \(Swift.String(describing: jobId)), schemaVersion: \(Swift.String(describing: schemaVersion)), stepId: \(Swift.String(describing: stepId)), template: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {

    /// The details of a job entity.
    public enum JobEntity: Swift.Sendable {
        /// The job details.
        case jobdetails(DeadlineClientTypes.JobDetailsEntity)
        /// The job attachment details.
        case jobattachmentdetails(DeadlineClientTypes.JobAttachmentDetailsEntity)
        /// The step details.
        case stepdetails(DeadlineClientTypes.StepDetailsEntity)
        /// The environment details for the job entity.
        case environmentdetails(DeadlineClientTypes.EnvironmentDetailsEntity)
        case sdkUnknown(Swift.String)
    }
}

extension DeadlineClientTypes {

    public enum JobEntityErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessdeniedexception
        case conflictexception
        case internalserverexception
        case maxpayloadsizeexceeded
        case resourcenotfoundexception
        case validationexception
        case sdkUnknown(Swift.String)

        public static var allCases: [JobEntityErrorCode] {
            return [
                .accessdeniedexception,
                .conflictexception,
                .internalserverexception,
                .maxpayloadsizeexceeded,
                .resourcenotfoundexception,
                .validationexception
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .conflictexception: return "ConflictException"
            case .internalserverexception: return "InternalServerException"
            case .maxpayloadsizeexceeded: return "MaxPayloadSizeExceeded"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case .validationexception: return "ValidationException"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    /// The error details for the environment.
    public struct EnvironmentDetailsError: Swift.Sendable {
        /// The error code.
        /// This member is required.
        public var code: DeadlineClientTypes.JobEntityErrorCode?
        /// The environment ID.
        /// This member is required.
        public var environmentId: Swift.String?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The error message detailing the error's cause.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: DeadlineClientTypes.JobEntityErrorCode? = nil,
            environmentId: Swift.String? = nil,
            jobId: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.environmentId = environmentId
            self.jobId = jobId
            self.message = message
        }
    }
}

extension DeadlineClientTypes {

    /// The error details for job attachments.
    public struct JobAttachmentDetailsError: Swift.Sendable {
        /// The error code.
        /// This member is required.
        public var code: DeadlineClientTypes.JobEntityErrorCode?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The error message detailing the error's cause.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: DeadlineClientTypes.JobEntityErrorCode? = nil,
            jobId: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.jobId = jobId
            self.message = message
        }
    }
}

extension DeadlineClientTypes {

    /// The details of a job error.
    public struct JobDetailsError: Swift.Sendable {
        /// The error code.
        /// This member is required.
        public var code: DeadlineClientTypes.JobEntityErrorCode?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The error message detailing the error's cause.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: DeadlineClientTypes.JobEntityErrorCode? = nil,
            jobId: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.jobId = jobId
            self.message = message
        }
    }
}

extension DeadlineClientTypes {

    /// The details of the step error.
    public struct StepDetailsError: Swift.Sendable {
        /// The error code.
        /// This member is required.
        public var code: DeadlineClientTypes.JobEntityErrorCode?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The error message detailing the error's cause.
        /// This member is required.
        public var message: Swift.String?
        /// The step ID.
        /// This member is required.
        public var stepId: Swift.String?

        public init(
            code: DeadlineClientTypes.JobEntityErrorCode? = nil,
            jobId: Swift.String? = nil,
            message: Swift.String? = nil,
            stepId: Swift.String? = nil
        )
        {
            self.code = code
            self.jobId = jobId
            self.message = message
            self.stepId = stepId
        }
    }
}

extension DeadlineClientTypes {

    /// The error for the job entity.
    public enum GetJobEntityError: Swift.Sendable {
        /// The job details for the failed job entity.
        case jobdetails(DeadlineClientTypes.JobDetailsError)
        /// The job attachment details for the failed job entity.
        case jobattachmentdetails(DeadlineClientTypes.JobAttachmentDetailsError)
        /// The step details for the failed job entity.
        case stepdetails(DeadlineClientTypes.StepDetailsError)
        /// The environment details for the failed job entity.
        case environmentdetails(DeadlineClientTypes.EnvironmentDetailsError)
        case sdkUnknown(Swift.String)
    }
}

public struct BatchGetJobEntityOutput: Swift.Sendable {
    /// A list of the job entities, or details, in the batch.
    /// This member is required.
    public var entities: [DeadlineClientTypes.JobEntity]?
    /// A list of errors from the job error logs for the batch.
    /// This member is required.
    public var errors: [DeadlineClientTypes.GetJobEntityError]?

    public init(
        entities: [DeadlineClientTypes.JobEntity]? = nil,
        errors: [DeadlineClientTypes.GetJobEntityError]? = nil
    )
    {
        self.entities = entities
        self.errors = errors
    }
}

extension DeadlineClientTypes {

    public enum BudgetActionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case stopSchedulingAndCancelTasks
        case stopSchedulingAndCompleteTasks
        case sdkUnknown(Swift.String)

        public static var allCases: [BudgetActionType] {
            return [
                .stopSchedulingAndCancelTasks,
                .stopSchedulingAndCompleteTasks
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .stopSchedulingAndCancelTasks: return "STOP_SCHEDULING_AND_CANCEL_TASKS"
            case .stopSchedulingAndCompleteTasks: return "STOP_SCHEDULING_AND_COMPLETE_TASKS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    /// The budget action to add.
    public struct BudgetActionToAdd: Swift.Sendable {
        /// A description for the budget action to add. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public var description: Swift.String?
        /// The percentage threshold for the budget action to add.
        /// This member is required.
        public var thresholdPercentage: Swift.Float?
        /// The type of budget action to add.
        /// This member is required.
        public var type: DeadlineClientTypes.BudgetActionType?

        public init(
            description: Swift.String? = nil,
            thresholdPercentage: Swift.Float? = nil,
            type: DeadlineClientTypes.BudgetActionType? = nil
        )
        {
            self.description = description
            self.thresholdPercentage = thresholdPercentage
            self.type = type
        }
    }
}

extension DeadlineClientTypes.BudgetActionToAdd: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BudgetActionToAdd(thresholdPercentage: \(Swift.String(describing: thresholdPercentage)), type: \(Swift.String(describing: type)), description: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {

    /// The budget action to remove.
    public struct BudgetActionToRemove: Swift.Sendable {
        /// The percentage threshold for the budget action to remove.
        /// This member is required.
        public var thresholdPercentage: Swift.Float?
        /// The type of budget action to remove.
        /// This member is required.
        public var type: DeadlineClientTypes.BudgetActionType?

        public init(
            thresholdPercentage: Swift.Float? = nil,
            type: DeadlineClientTypes.BudgetActionType? = nil
        )
        {
            self.thresholdPercentage = thresholdPercentage
            self.type = type
        }
    }
}

extension DeadlineClientTypes {

    /// The details of a fixed budget schedule.
    public struct FixedBudgetSchedule: Swift.Sendable {
        /// When the budget ends.
        /// This member is required.
        public var endTime: Foundation.Date?
        /// When the budget starts.
        /// This member is required.
        public var startTime: Foundation.Date?

        public init(
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }
}

extension DeadlineClientTypes {

    /// The start and end time of the budget.
    public enum BudgetSchedule: Swift.Sendable {
        /// The fixed start and end time of the budget's schedule.
        case fixed(DeadlineClientTypes.FixedBudgetSchedule)
        case sdkUnknown(Swift.String)
    }
}

extension DeadlineClientTypes {

    /// The usage details of the allotted budget.
    public enum UsageTrackingResource: Swift.Sendable {
        /// The queue ID.
        case queueid(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateBudgetInput: Swift.Sendable {
    /// The budget actions to specify what happens when the budget runs out.
    /// This member is required.
    public var actions: [DeadlineClientTypes.BudgetActionToAdd]?
    /// The dollar limit based on consumed usage.
    /// This member is required.
    public var approximateDollarLimit: Swift.Float?
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The description of the budget. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var description: Swift.String?
    /// The display name of the budget. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    /// This member is required.
    public var displayName: Swift.String?
    /// The farm ID to include in this budget.
    /// This member is required.
    public var farmId: Swift.String?
    /// The schedule to associate with this budget.
    /// This member is required.
    public var schedule: DeadlineClientTypes.BudgetSchedule?
    /// The queue ID provided to this budget to track usage.
    /// This member is required.
    public var usageTrackingResource: DeadlineClientTypes.UsageTrackingResource?

    public init(
        actions: [DeadlineClientTypes.BudgetActionToAdd]? = nil,
        approximateDollarLimit: Swift.Float? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        schedule: DeadlineClientTypes.BudgetSchedule? = nil,
        usageTrackingResource: DeadlineClientTypes.UsageTrackingResource? = nil
    )
    {
        self.actions = actions
        self.approximateDollarLimit = approximateDollarLimit
        self.clientToken = clientToken
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
        self.schedule = schedule
        self.usageTrackingResource = usageTrackingResource
    }
}

extension CreateBudgetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBudgetInput(actions: \(Swift.String(describing: actions)), approximateDollarLimit: \(Swift.String(describing: approximateDollarLimit)), clientToken: \(Swift.String(describing: clientToken)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), schedule: \(Swift.String(describing: schedule)), usageTrackingResource: \(Swift.String(describing: usageTrackingResource)), description: \"CONTENT_REDACTED\")"}
}

public struct CreateBudgetOutput: Swift.Sendable {
    /// The budget ID.
    /// This member is required.
    public var budgetId: Swift.String?

    public init(
        budgetId: Swift.String? = nil
    )
    {
        self.budgetId = budgetId
    }
}

public struct DeleteBudgetInput: Swift.Sendable {
    /// The budget ID of the budget to delete.
    /// This member is required.
    public var budgetId: Swift.String?
    /// The farm ID of the farm to remove from the budget.
    /// This member is required.
    public var farmId: Swift.String?

    public init(
        budgetId: Swift.String? = nil,
        farmId: Swift.String? = nil
    )
    {
        self.budgetId = budgetId
        self.farmId = farmId
    }
}

public struct DeleteBudgetOutput: Swift.Sendable {

    public init() { }
}

public struct GetBudgetInput: Swift.Sendable {
    /// The budget ID.
    /// This member is required.
    public var budgetId: Swift.String?
    /// The farm ID of the farm connected to the budget.
    /// This member is required.
    public var farmId: Swift.String?

    public init(
        budgetId: Swift.String? = nil,
        farmId: Swift.String? = nil
    )
    {
        self.budgetId = budgetId
        self.farmId = farmId
    }
}

extension DeadlineClientTypes {

    /// The details of a budget action.
    public struct ResponseBudgetAction: Swift.Sendable {
        /// The budget action description. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        public var description: Swift.String?
        /// The percentage threshold for the budget.
        /// This member is required.
        public var thresholdPercentage: Swift.Float?
        /// The action taken on the budget once scheduling stops.
        /// This member is required.
        public var type: DeadlineClientTypes.BudgetActionType?

        public init(
            description: Swift.String? = nil,
            thresholdPercentage: Swift.Float? = nil,
            type: DeadlineClientTypes.BudgetActionType? = nil
        )
        {
            self.description = description
            self.thresholdPercentage = thresholdPercentage
            self.type = type
        }
    }
}

extension DeadlineClientTypes.ResponseBudgetAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResponseBudgetAction(thresholdPercentage: \(Swift.String(describing: thresholdPercentage)), type: \(Swift.String(describing: type)), description: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {

    public enum BudgetStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [BudgetStatus] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    /// The consumed usage for the resource.
    public struct ConsumedUsages: Swift.Sendable {
        /// The amount of the budget consumed.
        /// This member is required.
        public var approximateDollarUsage: Swift.Float?

        public init(
            approximateDollarUsage: Swift.Float? = nil
        )
        {
            self.approximateDollarUsage = approximateDollarUsage
        }
    }
}

public struct GetBudgetOutput: Swift.Sendable {
    /// The budget actions for the budget.
    /// This member is required.
    public var actions: [DeadlineClientTypes.ResponseBudgetAction]?
    /// The consumed usage limit for the budget.
    /// This member is required.
    public var approximateDollarLimit: Swift.Float?
    /// The budget ID.
    /// This member is required.
    public var budgetId: Swift.String?
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the budget. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var description: Swift.String?
    /// The display name of the budget. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    /// This member is required.
    public var displayName: Swift.String?
    /// The date and time the queue stopped.
    public var queueStoppedAt: Foundation.Date?
    /// The budget schedule.
    /// This member is required.
    public var schedule: DeadlineClientTypes.BudgetSchedule?
    /// The status of the budget.
    ///
    /// * ACTIVEGet a budget being evaluated.
    ///
    /// * INACTIVEGet an inactive budget. This can include expired, canceled, or deleted statuses.
    /// This member is required.
    public var status: DeadlineClientTypes.BudgetStatus?
    /// The date and time the resource was updated.
    public var updatedAt: Foundation.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?
    /// The resource that the budget is tracking usage for.
    /// This member is required.
    public var usageTrackingResource: DeadlineClientTypes.UsageTrackingResource?
    /// The usages of the budget.
    /// This member is required.
    public var usages: DeadlineClientTypes.ConsumedUsages?

    public init(
        actions: [DeadlineClientTypes.ResponseBudgetAction]? = nil,
        approximateDollarLimit: Swift.Float? = nil,
        budgetId: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        queueStoppedAt: Foundation.Date? = nil,
        schedule: DeadlineClientTypes.BudgetSchedule? = nil,
        status: DeadlineClientTypes.BudgetStatus? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil,
        usageTrackingResource: DeadlineClientTypes.UsageTrackingResource? = nil,
        usages: DeadlineClientTypes.ConsumedUsages? = nil
    )
    {
        self.actions = actions
        self.approximateDollarLimit = approximateDollarLimit
        self.budgetId = budgetId
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.displayName = displayName
        self.queueStoppedAt = queueStoppedAt
        self.schedule = schedule
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
        self.usageTrackingResource = usageTrackingResource
        self.usages = usages
    }
}

extension GetBudgetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBudgetOutput(actions: \(Swift.String(describing: actions)), approximateDollarLimit: \(Swift.String(describing: approximateDollarLimit)), budgetId: \(Swift.String(describing: budgetId)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), displayName: \(Swift.String(describing: displayName)), queueStoppedAt: \(Swift.String(describing: queueStoppedAt)), schedule: \(Swift.String(describing: schedule)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), usageTrackingResource: \(Swift.String(describing: usageTrackingResource)), usages: \(Swift.String(describing: usages)), description: \"CONTENT_REDACTED\")"}
}

public struct ListBudgetsInput: Swift.Sendable {
    /// The farm ID associated with the budgets.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The status to list for the budgets.
    public var status: DeadlineClientTypes.BudgetStatus?

    public init(
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        status: DeadlineClientTypes.BudgetStatus? = nil
    )
    {
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension DeadlineClientTypes {

    /// The budget summary.
    public struct BudgetSummary: Swift.Sendable {
        /// The approximate dollar limit of the budget.
        /// This member is required.
        public var approximateDollarLimit: Swift.Float?
        /// The budget ID.
        /// This member is required.
        public var budgetId: Swift.String?
        /// The date and time the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The user or system that created this resource.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The description of the budget summary. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        @available(*, deprecated, message: "ListBudgets no longer supports description. Use GetBudget if description is needed.")
        public var description: Swift.String?
        /// The display name of the budget summary to update. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        /// This member is required.
        public var displayName: Swift.String?
        /// The status of the budget.
        ///
        /// * ACTIVEThe budget is being evaluated.
        ///
        /// * INACTIVEThe budget is inactive. This can include Expired, Canceled, or deleted Deleted statuses.
        /// This member is required.
        public var status: DeadlineClientTypes.BudgetStatus?
        /// The date and time the resource was updated.
        public var updatedAt: Foundation.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?
        /// The resource used to track expenditure in the budget.
        /// This member is required.
        public var usageTrackingResource: DeadlineClientTypes.UsageTrackingResource?
        /// The consumed usage for the budget.
        /// This member is required.
        public var usages: DeadlineClientTypes.ConsumedUsages?

        public init(
            approximateDollarLimit: Swift.Float? = nil,
            budgetId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            status: DeadlineClientTypes.BudgetStatus? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil,
            usageTrackingResource: DeadlineClientTypes.UsageTrackingResource? = nil,
            usages: DeadlineClientTypes.ConsumedUsages? = nil
        )
        {
            self.approximateDollarLimit = approximateDollarLimit
            self.budgetId = budgetId
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.displayName = displayName
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.usageTrackingResource = usageTrackingResource
            self.usages = usages
        }
    }
}

extension DeadlineClientTypes.BudgetSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BudgetSummary(approximateDollarLimit: \(Swift.String(describing: approximateDollarLimit)), budgetId: \(Swift.String(describing: budgetId)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), displayName: \(Swift.String(describing: displayName)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), usageTrackingResource: \(Swift.String(describing: usageTrackingResource)), usages: \(Swift.String(describing: usages)), description: \"CONTENT_REDACTED\")"}
}

public struct ListBudgetsOutput: Swift.Sendable {
    /// The budgets to include on the list.
    /// This member is required.
    public var budgets: [DeadlineClientTypes.BudgetSummary]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        budgets: [DeadlineClientTypes.BudgetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.budgets = budgets
        self.nextToken = nextToken
    }
}

public struct UpdateBudgetInput: Swift.Sendable {
    /// The budget actions to add. Budget actions specify what happens when the budget runs out.
    public var actionsToAdd: [DeadlineClientTypes.BudgetActionToAdd]?
    /// The budget actions to remove from the budget.
    public var actionsToRemove: [DeadlineClientTypes.BudgetActionToRemove]?
    /// The dollar limit to update on the budget. Based on consumed usage.
    public var approximateDollarLimit: Swift.Float?
    /// The budget ID to update.
    /// This member is required.
    public var budgetId: Swift.String?
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The description of the budget to update. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var description: Swift.String?
    /// The display name of the budget to update. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var displayName: Swift.String?
    /// The farm ID of the budget to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The schedule to update.
    public var schedule: DeadlineClientTypes.BudgetSchedule?
    /// Updates the status of the budget.
    ///
    /// * ACTIVEThe budget is being evaluated.
    ///
    /// * INACTIVEThe budget is inactive. This can include Expired, Canceled, or deleted Deleted statuses.
    public var status: DeadlineClientTypes.BudgetStatus?

    public init(
        actionsToAdd: [DeadlineClientTypes.BudgetActionToAdd]? = nil,
        actionsToRemove: [DeadlineClientTypes.BudgetActionToRemove]? = nil,
        approximateDollarLimit: Swift.Float? = nil,
        budgetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        schedule: DeadlineClientTypes.BudgetSchedule? = nil,
        status: DeadlineClientTypes.BudgetStatus? = nil
    )
    {
        self.actionsToAdd = actionsToAdd
        self.actionsToRemove = actionsToRemove
        self.approximateDollarLimit = approximateDollarLimit
        self.budgetId = budgetId
        self.clientToken = clientToken
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
        self.schedule = schedule
        self.status = status
    }
}

extension UpdateBudgetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBudgetInput(actionsToAdd: \(Swift.String(describing: actionsToAdd)), actionsToRemove: \(Swift.String(describing: actionsToRemove)), approximateDollarLimit: \(Swift.String(describing: approximateDollarLimit)), budgetId: \(Swift.String(describing: budgetId)), clientToken: \(Swift.String(describing: clientToken)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), schedule: \(Swift.String(describing: schedule)), status: \(Swift.String(describing: status)), description: \"CONTENT_REDACTED\")"}
}

public struct UpdateBudgetOutput: Swift.Sendable {

    public init() { }
}

extension DeadlineClientTypes {

    public enum ComparisonOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equal
        case greaterThan
        case greaterThanEqualTo
        case lessThan
        case lessThanEqualTo
        case notEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .equal,
                .greaterThan,
                .greaterThanEqualTo,
                .lessThan,
                .lessThanEqualTo,
                .notEqual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equal: return "EQUAL"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanEqualTo: return "GREATER_THAN_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanEqualTo: return "LESS_THAN_EQUAL_TO"
            case .notEqual: return "NOT_EQUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    public enum CompletedStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case failed
        case interrupted
        case neverAttempted
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [CompletedStatus] {
            return [
                .canceled,
                .failed,
                .interrupted,
                .neverAttempted,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .interrupted: return "INTERRUPTED"
            case .neverAttempted: return "NEVER_ATTEMPTED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    /// The Amazon S3 location information.
    public struct S3Location: Swift.Sendable {
        /// The name of the Amazon S3 bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The Amazon S3 object key that uniquely identifies the Amazon S3 bucket.
        /// This member is required.
        public var key: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.key = key
        }
    }
}

public struct CopyJobTemplateInput: Swift.Sendable {
    /// The farm ID to copy.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID to copy.
    /// This member is required.
    public var jobId: Swift.String?
    /// The queue ID to copy.
    /// This member is required.
    public var queueId: Swift.String?
    /// The Amazon S3 bucket name and key where you would like to add a copy of the job template.
    /// This member is required.
    public var targetS3Location: DeadlineClientTypes.S3Location?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        targetS3Location: DeadlineClientTypes.S3Location? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.queueId = queueId
        self.targetS3Location = targetS3Location
    }
}

extension DeadlineClientTypes {

    public enum JobTemplateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case yaml
        case sdkUnknown(Swift.String)

        public static var allCases: [JobTemplateType] {
            return [
                .json,
                .yaml
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .yaml: return "YAML"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CopyJobTemplateOutput: Swift.Sendable {
    /// The format of the job template, either JSON or YAML.
    /// This member is required.
    public var templateType: DeadlineClientTypes.JobTemplateType?

    public init(
        templateType: DeadlineClientTypes.JobTemplateType? = nil
    )
    {
        self.templateType = templateType
    }
}

extension DeadlineClientTypes {

    public enum CpuArchitectureType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case arm64
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [CpuArchitectureType] {
            return [
                .arm64,
                .x8664
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arm64: return "arm64"
            case .x8664: return "x86_64"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateFarmInput: Swift.Sendable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The description of the farm. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var description: Swift.String?
    /// The display name of the farm. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    /// This member is required.
    public var displayName: Swift.String?
    /// The ARN of the KMS key to use on the farm.
    public var kmsKeyArn: Swift.String?
    /// The tags to add to your farm. Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.displayName = displayName
        self.kmsKeyArn = kmsKeyArn
        self.tags = tags
    }
}

extension CreateFarmInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFarmInput(clientToken: \(Swift.String(describing: clientToken)), displayName: \(Swift.String(describing: displayName)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\")"}
}

public struct CreateFarmOutput: Swift.Sendable {
    /// The farm ID.
    /// This member is required.
    public var farmId: Swift.String?

    public init(
        farmId: Swift.String? = nil
    )
    {
        self.farmId = farmId
    }
}

extension DeadlineClientTypes {

    /// The fleet amount and attribute capabilities.
    public struct FleetAmountCapability: Swift.Sendable {
        /// The maximum amount of the fleet worker capability.
        public var max: Swift.Float?
        /// The minimum amount of fleet worker capability.
        /// This member is required.
        public var min: Swift.Float?
        /// The name of the fleet capability.
        /// This member is required.
        public var name: Swift.String?

        public init(
            max: Swift.Float? = nil,
            min: Swift.Float? = nil,
            name: Swift.String? = nil
        )
        {
            self.max = max
            self.min = min
            self.name = name
        }
    }
}

extension DeadlineClientTypes {

    /// Defines the fleet's capability name, minimum, and maximum.
    public struct FleetAttributeCapability: Swift.Sendable {
        /// The name of the fleet attribute capability for the worker.
        /// This member is required.
        public var name: Swift.String?
        /// The number of fleet attribute capabilities.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

extension DeadlineClientTypes {

    /// The range of memory in MiB.
    public struct MemoryMiBRange: Swift.Sendable {
        /// The maximum amount of memory (in MiB).
        public var max: Swift.Int?
        /// The minimum amount of memory (in MiB).
        /// This member is required.
        public var min: Swift.Int?

        public init(
            max: Swift.Int? = nil,
            min: Swift.Int? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }
}

extension DeadlineClientTypes {

    public enum CustomerManagedFleetOperatingSystemFamily: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case linux
        case macos
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomerManagedFleetOperatingSystemFamily] {
            return [
                .linux,
                .macos,
                .windows
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .macos: return "MACOS"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    /// The allowable range of vCPU processing power for the fleet.
    public struct VCpuCountRange: Swift.Sendable {
        /// The maximum amount of vCPU.
        public var max: Swift.Int?
        /// The minimum amount of vCPU.
        /// This member is required.
        public var min: Swift.Int?

        public init(
            max: Swift.Int? = nil,
            min: Swift.Int? = nil
        )
        {
            self.max = max
            self.min = min
        }
    }
}

extension DeadlineClientTypes {

    /// The worker capabilities for a customer managed workflow.
    public struct CustomerManagedWorkerCapabilities: Swift.Sendable {
        /// The range of the accelerator.
        public var acceleratorCount: DeadlineClientTypes.AcceleratorCountRange?
        /// The total memory (MiB) for the customer managed worker capabilities.
        public var acceleratorTotalMemoryMiB: DeadlineClientTypes.AcceleratorTotalMemoryMiBRange?
        /// The accelerator types for the customer managed worker capabilities.
        public var acceleratorTypes: [DeadlineClientTypes.AcceleratorType]?
        /// The CPU architecture type for the customer managed worker capabilities.
        /// This member is required.
        public var cpuArchitectureType: DeadlineClientTypes.CpuArchitectureType?
        /// Custom requirement ranges for customer managed worker capabilities.
        public var customAmounts: [DeadlineClientTypes.FleetAmountCapability]?
        /// Custom attributes for the customer manged worker capabilities.
        public var customAttributes: [DeadlineClientTypes.FleetAttributeCapability]?
        /// The memory (MiB).
        /// This member is required.
        public var memoryMiB: DeadlineClientTypes.MemoryMiBRange?
        /// The operating system (OS) family.
        /// This member is required.
        public var osFamily: DeadlineClientTypes.CustomerManagedFleetOperatingSystemFamily?
        /// The vCPU count for the customer manged worker capabilities.
        /// This member is required.
        public var vCpuCount: DeadlineClientTypes.VCpuCountRange?

        public init(
            acceleratorCount: DeadlineClientTypes.AcceleratorCountRange? = nil,
            acceleratorTotalMemoryMiB: DeadlineClientTypes.AcceleratorTotalMemoryMiBRange? = nil,
            acceleratorTypes: [DeadlineClientTypes.AcceleratorType]? = nil,
            cpuArchitectureType: DeadlineClientTypes.CpuArchitectureType? = nil,
            customAmounts: [DeadlineClientTypes.FleetAmountCapability]? = nil,
            customAttributes: [DeadlineClientTypes.FleetAttributeCapability]? = nil,
            memoryMiB: DeadlineClientTypes.MemoryMiBRange? = nil,
            osFamily: DeadlineClientTypes.CustomerManagedFleetOperatingSystemFamily? = nil,
            vCpuCount: DeadlineClientTypes.VCpuCountRange? = nil
        )
        {
            self.acceleratorCount = acceleratorCount
            self.acceleratorTotalMemoryMiB = acceleratorTotalMemoryMiB
            self.acceleratorTypes = acceleratorTypes
            self.cpuArchitectureType = cpuArchitectureType
            self.customAmounts = customAmounts
            self.customAttributes = customAttributes
            self.memoryMiB = memoryMiB
            self.osFamily = osFamily
            self.vCpuCount = vCpuCount
        }
    }
}

extension DeadlineClientTypes {

    /// The details of a customer managed fleet configuration.
    public struct CustomerManagedFleetConfiguration: Swift.Sendable {
        /// The Auto Scaling mode for the customer managed fleet configuration.
        /// This member is required.
        public var mode: DeadlineClientTypes.AutoScalingMode?
        /// The storage profile ID.
        public var storageProfileId: Swift.String?
        /// The worker capabilities for a customer managed fleet configuration.
        /// This member is required.
        public var workerCapabilities: DeadlineClientTypes.CustomerManagedWorkerCapabilities?

        public init(
            mode: DeadlineClientTypes.AutoScalingMode? = nil,
            storageProfileId: Swift.String? = nil,
            workerCapabilities: DeadlineClientTypes.CustomerManagedWorkerCapabilities? = nil
        )
        {
            self.mode = mode
            self.storageProfileId = storageProfileId
            self.workerCapabilities = workerCapabilities
        }
    }
}

extension DeadlineClientTypes {

    public enum ServiceManagedFleetOperatingSystemFamily: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case linux
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceManagedFleetOperatingSystemFamily] {
            return [
                .linux,
                .windows
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    /// Specifies the EBS volume.
    public struct Ec2EbsVolume: Swift.Sendable {
        /// The IOPS per volume.
        public var iops: Swift.Int?
        /// The EBS volume size in GiB.
        public var sizeGiB: Swift.Int?
        /// The throughput per volume in MiB.
        public var throughputMiB: Swift.Int?

        public init(
            iops: Swift.Int? = 3000,
            sizeGiB: Swift.Int? = 250,
            throughputMiB: Swift.Int? = 125
        )
        {
            self.iops = iops
            self.sizeGiB = sizeGiB
            self.throughputMiB = throughputMiB
        }
    }
}

extension DeadlineClientTypes {

    /// The Amazon EC2 instance capabilities.
    public struct ServiceManagedEc2InstanceCapabilities: Swift.Sendable {
        /// The allowable Amazon EC2 instance types.
        public var allowedInstanceTypes: [Swift.String]?
        /// The CPU architecture type.
        /// This member is required.
        public var cpuArchitectureType: DeadlineClientTypes.CpuArchitectureType?
        /// The custom capability amounts to require for instances in this fleet.
        public var customAmounts: [DeadlineClientTypes.FleetAmountCapability]?
        /// The custom capability attributes to require for instances in this fleet.
        public var customAttributes: [DeadlineClientTypes.FleetAttributeCapability]?
        /// The instance types to exclude from the fleet.
        public var excludedInstanceTypes: [Swift.String]?
        /// The memory, as MiB, for the Amazon EC2 instance type.
        /// This member is required.
        public var memoryMiB: DeadlineClientTypes.MemoryMiBRange?
        /// The operating system (OS) family.
        /// This member is required.
        public var osFamily: DeadlineClientTypes.ServiceManagedFleetOperatingSystemFamily?
        /// The root EBS volume.
        public var rootEbsVolume: DeadlineClientTypes.Ec2EbsVolume?
        /// The amount of vCPU to require for instances in this fleet.
        /// This member is required.
        public var vCpuCount: DeadlineClientTypes.VCpuCountRange?

        public init(
            allowedInstanceTypes: [Swift.String]? = nil,
            cpuArchitectureType: DeadlineClientTypes.CpuArchitectureType? = nil,
            customAmounts: [DeadlineClientTypes.FleetAmountCapability]? = nil,
            customAttributes: [DeadlineClientTypes.FleetAttributeCapability]? = nil,
            excludedInstanceTypes: [Swift.String]? = nil,
            memoryMiB: DeadlineClientTypes.MemoryMiBRange? = nil,
            osFamily: DeadlineClientTypes.ServiceManagedFleetOperatingSystemFamily? = nil,
            rootEbsVolume: DeadlineClientTypes.Ec2EbsVolume? = nil,
            vCpuCount: DeadlineClientTypes.VCpuCountRange? = nil
        )
        {
            self.allowedInstanceTypes = allowedInstanceTypes
            self.cpuArchitectureType = cpuArchitectureType
            self.customAmounts = customAmounts
            self.customAttributes = customAttributes
            self.excludedInstanceTypes = excludedInstanceTypes
            self.memoryMiB = memoryMiB
            self.osFamily = osFamily
            self.rootEbsVolume = rootEbsVolume
            self.vCpuCount = vCpuCount
        }
    }
}

extension DeadlineClientTypes {

    public enum Ec2MarketType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case onDemand
        case spot
        case sdkUnknown(Swift.String)

        public static var allCases: [Ec2MarketType] {
            return [
                .onDemand,
                .spot
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .onDemand: return "on-demand"
            case .spot: return "spot"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    /// The details of the Amazon EC2 instance market options for a service managed fleet.
    public struct ServiceManagedEc2InstanceMarketOptions: Swift.Sendable {
        /// The Amazon EC2 instance type.
        /// This member is required.
        public var type: DeadlineClientTypes.Ec2MarketType?

        public init(
            type: DeadlineClientTypes.Ec2MarketType? = nil
        )
        {
            self.type = type
        }
    }
}

extension DeadlineClientTypes {

    /// The configuration details for a service managed Amazon EC2 fleet.
    public struct ServiceManagedEc2FleetConfiguration: Swift.Sendable {
        /// The Amazon EC2 instance capabilities.
        /// This member is required.
        public var instanceCapabilities: DeadlineClientTypes.ServiceManagedEc2InstanceCapabilities?
        /// The Amazon EC2 market type.
        /// This member is required.
        public var instanceMarketOptions: DeadlineClientTypes.ServiceManagedEc2InstanceMarketOptions?

        public init(
            instanceCapabilities: DeadlineClientTypes.ServiceManagedEc2InstanceCapabilities? = nil,
            instanceMarketOptions: DeadlineClientTypes.ServiceManagedEc2InstanceMarketOptions? = nil
        )
        {
            self.instanceCapabilities = instanceCapabilities
            self.instanceMarketOptions = instanceMarketOptions
        }
    }
}

extension DeadlineClientTypes {

    /// Fleet configuration details.
    public enum FleetConfiguration: Swift.Sendable {
        /// The customer managed fleets within a fleet configuration.
        case customermanaged(DeadlineClientTypes.CustomerManagedFleetConfiguration)
        /// The service managed Amazon EC2 instances for a fleet configuration.
        case servicemanagedec2(DeadlineClientTypes.ServiceManagedEc2FleetConfiguration)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateFleetInput: Swift.Sendable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The configuration settings for the fleet. Customer managed fleets are self-managed. Service managed Amazon EC2 fleets are managed by Deadline Cloud.
    /// This member is required.
    public var configuration: DeadlineClientTypes.FleetConfiguration?
    /// The description of the fleet. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var description: Swift.String?
    /// The display name of the fleet. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    /// This member is required.
    public var displayName: Swift.String?
    /// The farm ID of the farm to connect to the fleet.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of workers for the fleet.
    /// This member is required.
    public var maxWorkerCount: Swift.Int?
    /// The minimum number of workers for the fleet.
    public var minWorkerCount: Swift.Int?
    /// The IAM role ARN for the role that the fleet's workers will use.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        configuration: DeadlineClientTypes.FleetConfiguration? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        maxWorkerCount: Swift.Int? = nil,
        minWorkerCount: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
        self.maxWorkerCount = maxWorkerCount
        self.minWorkerCount = minWorkerCount
        self.roleArn = roleArn
        self.tags = tags
    }
}

extension CreateFleetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFleetInput(clientToken: \(Swift.String(describing: clientToken)), configuration: \(Swift.String(describing: configuration)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), maxWorkerCount: \(Swift.String(describing: maxWorkerCount)), minWorkerCount: \(Swift.String(describing: minWorkerCount)), roleArn: \(Swift.String(describing: roleArn)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\")"}
}

public struct CreateFleetOutput: Swift.Sendable {
    /// The fleet ID.
    /// This member is required.
    public var fleetId: Swift.String?

    public init(
        fleetId: Swift.String? = nil
    )
    {
        self.fleetId = fleetId
    }
}

extension DeadlineClientTypes {

    public enum CreateJobTargetTaskRunStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ready
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [CreateJobTargetTaskRunStatus] {
            return [
                .ready,
                .suspended
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ready: return "READY"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateJobInput: Swift.Sendable {
    /// The attachments for the job. Attach files required for the job to run to a render job.
    public var attachments: DeadlineClientTypes.Attachments?
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The farm ID of the farm to connect to the job.
    /// This member is required.
    public var farmId: Swift.String?
    /// The number of task failures before the job stops running and is marked as FAILED.
    public var maxFailedTasksCount: Swift.Int?
    /// The maximum number of retries for each task.
    public var maxRetriesPerTask: Swift.Int?
    /// The parameters for the job.
    public var parameters: [Swift.String: DeadlineClientTypes.JobParameter]?
    /// The priority of the job on a scale of 0 to 100. The highest priority (first scheduled) is 100. When two jobs have the same priority, the oldest job is scheduled first.
    /// This member is required.
    public var priority: Swift.Int?
    /// The ID of the queue that the job is submitted to.
    /// This member is required.
    public var queueId: Swift.String?
    /// The job ID for the source job.
    public var sourceJobId: Swift.String?
    /// The storage profile ID for the storage profile to connect to the job.
    public var storageProfileId: Swift.String?
    /// The initial job status when it is created. Jobs that are created with a SUSPENDED status will not run until manually requeued.
    public var targetTaskRunStatus: DeadlineClientTypes.CreateJobTargetTaskRunStatus?
    /// The job template to use for this job.
    public var template: Swift.String?
    /// The file type for the job template.
    public var templateType: DeadlineClientTypes.JobTemplateType?

    public init(
        attachments: DeadlineClientTypes.Attachments? = nil,
        clientToken: Swift.String? = nil,
        farmId: Swift.String? = nil,
        maxFailedTasksCount: Swift.Int? = nil,
        maxRetriesPerTask: Swift.Int? = nil,
        parameters: [Swift.String: DeadlineClientTypes.JobParameter]? = nil,
        priority: Swift.Int? = nil,
        queueId: Swift.String? = nil,
        sourceJobId: Swift.String? = nil,
        storageProfileId: Swift.String? = nil,
        targetTaskRunStatus: DeadlineClientTypes.CreateJobTargetTaskRunStatus? = nil,
        template: Swift.String? = nil,
        templateType: DeadlineClientTypes.JobTemplateType? = nil
    )
    {
        self.attachments = attachments
        self.clientToken = clientToken
        self.farmId = farmId
        self.maxFailedTasksCount = maxFailedTasksCount
        self.maxRetriesPerTask = maxRetriesPerTask
        self.parameters = parameters
        self.priority = priority
        self.queueId = queueId
        self.sourceJobId = sourceJobId
        self.storageProfileId = storageProfileId
        self.targetTaskRunStatus = targetTaskRunStatus
        self.template = template
        self.templateType = templateType
    }
}

extension CreateJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateJobInput(attachments: \(Swift.String(describing: attachments)), clientToken: \(Swift.String(describing: clientToken)), farmId: \(Swift.String(describing: farmId)), maxFailedTasksCount: \(Swift.String(describing: maxFailedTasksCount)), maxRetriesPerTask: \(Swift.String(describing: maxRetriesPerTask)), priority: \(Swift.String(describing: priority)), queueId: \(Swift.String(describing: queueId)), sourceJobId: \(Swift.String(describing: sourceJobId)), storageProfileId: \(Swift.String(describing: storageProfileId)), targetTaskRunStatus: \(Swift.String(describing: targetTaskRunStatus)), templateType: \(Swift.String(describing: templateType)), parameters: \"CONTENT_REDACTED\", template: \"CONTENT_REDACTED\")"}
}

public struct CreateJobOutput: Swift.Sendable {
    /// The job ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

public struct CreateLicenseEndpointInput: Swift.Sendable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The security group IDs.
    /// This member is required.
    public var securityGroupIds: [Swift.String]?
    /// The subnet IDs.
    /// This member is required.
    public var subnetIds: [Swift.String]?
    /// Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
    public var tags: [Swift.String: Swift.String]?
    /// The VPC (virtual private cloud) ID to use with the license endpoint.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.tags = tags
        self.vpcId = vpcId
    }
}

public struct CreateLicenseEndpointOutput: Swift.Sendable {
    /// The license endpoint ID.
    /// This member is required.
    public var licenseEndpointId: Swift.String?

    public init(
        licenseEndpointId: Swift.String? = nil
    )
    {
        self.licenseEndpointId = licenseEndpointId
    }
}

public struct CreateMonitorInput: Swift.Sendable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The name that you give the monitor that is displayed in the Deadline Cloud console. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    /// This member is required.
    public var displayName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM Identity Center instance that authenticates monitor users.
    /// This member is required.
    public var identityCenterInstanceArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role that the monitor uses to connect to Deadline Cloud. Every user that signs in to the monitor using IAM Identity Center uses this role to access Deadline Cloud resources.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The subdomain to use when creating the monitor URL. The full URL of the monitor is subdomain.Region.deadlinecloud.amazonaws.com.
    /// This member is required.
    public var subdomain: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        identityCenterInstanceArn: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        subdomain: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.displayName = displayName
        self.identityCenterInstanceArn = identityCenterInstanceArn
        self.roleArn = roleArn
        self.subdomain = subdomain
    }
}

public struct CreateMonitorOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that IAM Identity Center assigns to the monitor.
    /// This member is required.
    public var identityCenterApplicationArn: Swift.String?
    /// The unique identifier of the monitor.
    /// This member is required.
    public var monitorId: Swift.String?

    public init(
        identityCenterApplicationArn: Swift.String? = nil,
        monitorId: Swift.String? = nil
    )
    {
        self.identityCenterApplicationArn = identityCenterApplicationArn
        self.monitorId = monitorId
    }
}

extension DeadlineClientTypes {

    public enum DefaultQueueBudgetAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case stopSchedulingAndCancelTasks
        case stopSchedulingAndCompleteTasks
        case sdkUnknown(Swift.String)

        public static var allCases: [DefaultQueueBudgetAction] {
            return [
                .none,
                .stopSchedulingAndCancelTasks,
                .stopSchedulingAndCompleteTasks
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .stopSchedulingAndCancelTasks: return "STOP_SCHEDULING_AND_CANCEL_TASKS"
            case .stopSchedulingAndCompleteTasks: return "STOP_SCHEDULING_AND_COMPLETE_TASKS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateQueueInput: Swift.Sendable {
    /// The storage profile IDs to include in the queue.
    public var allowedStorageProfileIds: [Swift.String]?
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The default action to take on a queue if a budget isn't configured.
    public var defaultBudgetAction: DeadlineClientTypes.DefaultQueueBudgetAction?
    /// The description of the queue. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var description: Swift.String?
    /// The display name of the queue. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    /// This member is required.
    public var displayName: Swift.String?
    /// The farm ID of the farm to connect to the queue.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job attachment settings for the queue. These are the Amazon S3 bucket name and the Amazon S3 prefix.
    public var jobAttachmentSettings: DeadlineClientTypes.JobAttachmentSettings?
    /// The jobs in the queue run as the specified POSIX user.
    public var jobRunAsUser: DeadlineClientTypes.JobRunAsUser?
    /// The file system location name to include in the queue.
    public var requiredFileSystemLocationNames: [Swift.String]?
    /// The IAM role ARN that workers will use while running jobs for this queue.
    public var roleArn: Swift.String?
    /// Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
    public var tags: [Swift.String: Swift.String]?

    public init(
        allowedStorageProfileIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        defaultBudgetAction: DeadlineClientTypes.DefaultQueueBudgetAction? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        jobAttachmentSettings: DeadlineClientTypes.JobAttachmentSettings? = nil,
        jobRunAsUser: DeadlineClientTypes.JobRunAsUser? = nil,
        requiredFileSystemLocationNames: [Swift.String]? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.allowedStorageProfileIds = allowedStorageProfileIds
        self.clientToken = clientToken
        self.defaultBudgetAction = defaultBudgetAction
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
        self.jobAttachmentSettings = jobAttachmentSettings
        self.jobRunAsUser = jobRunAsUser
        self.requiredFileSystemLocationNames = requiredFileSystemLocationNames
        self.roleArn = roleArn
        self.tags = tags
    }
}

extension CreateQueueInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateQueueInput(allowedStorageProfileIds: \(Swift.String(describing: allowedStorageProfileIds)), clientToken: \(Swift.String(describing: clientToken)), defaultBudgetAction: \(Swift.String(describing: defaultBudgetAction)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), jobAttachmentSettings: \(Swift.String(describing: jobAttachmentSettings)), jobRunAsUser: \(Swift.String(describing: jobRunAsUser)), roleArn: \(Swift.String(describing: roleArn)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", requiredFileSystemLocationNames: \"CONTENT_REDACTED\")"}
}

public struct CreateQueueOutput: Swift.Sendable {
    /// The queue ID.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        queueId: Swift.String? = nil
    )
    {
        self.queueId = queueId
    }
}

extension DeadlineClientTypes {

    public enum EnvironmentTemplateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case yaml
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentTemplateType] {
            return [
                .json,
                .yaml
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .yaml: return "YAML"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateQueueEnvironmentInput: Swift.Sendable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The farm ID of the farm to connect to the environment.
    /// This member is required.
    public var farmId: Swift.String?
    /// Sets the priority of the environments in the queue from 0 to 10,000, where 0 is the highest priority. If two environments share the same priority value, the environment created first takes higher priority.
    /// This member is required.
    public var priority: Swift.Int?
    /// The queue ID to connect the queue and environment.
    /// This member is required.
    public var queueId: Swift.String?
    /// The environment template to use in the queue.
    /// This member is required.
    public var template: Swift.String?
    /// The template's file type, JSON or YAML.
    /// This member is required.
    public var templateType: DeadlineClientTypes.EnvironmentTemplateType?

    public init(
        clientToken: Swift.String? = nil,
        farmId: Swift.String? = nil,
        priority: Swift.Int? = nil,
        queueId: Swift.String? = nil,
        template: Swift.String? = nil,
        templateType: DeadlineClientTypes.EnvironmentTemplateType? = nil
    )
    {
        self.clientToken = clientToken
        self.farmId = farmId
        self.priority = priority
        self.queueId = queueId
        self.template = template
        self.templateType = templateType
    }
}

extension CreateQueueEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateQueueEnvironmentInput(clientToken: \(Swift.String(describing: clientToken)), farmId: \(Swift.String(describing: farmId)), priority: \(Swift.String(describing: priority)), queueId: \(Swift.String(describing: queueId)), templateType: \(Swift.String(describing: templateType)), template: \"CONTENT_REDACTED\")"}
}

public struct CreateQueueEnvironmentOutput: Swift.Sendable {
    /// The queue environment ID.
    /// This member is required.
    public var queueEnvironmentId: Swift.String?

    public init(
        queueEnvironmentId: Swift.String? = nil
    )
    {
        self.queueEnvironmentId = queueEnvironmentId
    }
}

public struct CreateQueueFleetAssociationInput: Swift.Sendable {
    /// The ID of the farm that the queue and fleet belong to.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The queue ID.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.queueId = queueId
    }
}

public struct CreateQueueFleetAssociationOutput: Swift.Sendable {

    public init() { }
}

extension DeadlineClientTypes {

    public enum FileSystemLocationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case local
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [FileSystemLocationType] {
            return [
                .local,
                .shared
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .local: return "LOCAL"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    /// The details of the file system location for the resource.
    public struct FileSystemLocation: Swift.Sendable {
        /// The location name.
        /// This member is required.
        public var name: Swift.String?
        /// The file path.
        /// This member is required.
        public var path: Swift.String?
        /// The type of file.
        /// This member is required.
        public var type: DeadlineClientTypes.FileSystemLocationType?

        public init(
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            type: DeadlineClientTypes.FileSystemLocationType? = nil
        )
        {
            self.name = name
            self.path = path
            self.type = type
        }
    }
}

extension DeadlineClientTypes.FileSystemLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension DeadlineClientTypes {

    public enum StorageProfileOperatingSystemFamily: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case linux
        case macos
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageProfileOperatingSystemFamily] {
            return [
                .linux,
                .macos,
                .windows
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .macos: return "MACOS"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateStorageProfileInput: Swift.Sendable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The display name of the storage profile. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    /// This member is required.
    public var displayName: Swift.String?
    /// The farm ID of the farm to connect to the storage profile.
    /// This member is required.
    public var farmId: Swift.String?
    /// File system paths to include in the storage profile.
    public var fileSystemLocations: [DeadlineClientTypes.FileSystemLocation]?
    /// The type of operating system (OS) for the storage profile.
    /// This member is required.
    public var osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily?

    public init(
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        fileSystemLocations: [DeadlineClientTypes.FileSystemLocation]? = nil,
        osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily? = nil
    )
    {
        self.clientToken = clientToken
        self.displayName = displayName
        self.farmId = farmId
        self.fileSystemLocations = fileSystemLocations
        self.osFamily = osFamily
    }
}

extension CreateStorageProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStorageProfileInput(clientToken: \(Swift.String(describing: clientToken)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), osFamily: \(Swift.String(describing: osFamily)), fileSystemLocations: \"CONTENT_REDACTED\")"}
}

public struct CreateStorageProfileOutput: Swift.Sendable {
    /// The storage profile ID.
    /// This member is required.
    public var storageProfileId: Swift.String?

    public init(
        storageProfileId: Swift.String? = nil
    )
    {
        self.storageProfileId = storageProfileId
    }
}

extension DeadlineClientTypes {

    /// The IP addresses for a host.
    public struct IpAddresses: Swift.Sendable {
        /// The IpV4 address of the network.
        public var ipV4Addresses: [Swift.String]?
        /// The IpV6 address for the network and node component.
        public var ipV6Addresses: [Swift.String]?

        public init(
            ipV4Addresses: [Swift.String]? = nil,
            ipV6Addresses: [Swift.String]? = nil
        )
        {
            self.ipV4Addresses = ipV4Addresses
            self.ipV6Addresses = ipV6Addresses
        }
    }
}

extension DeadlineClientTypes {

    /// The host property details.
    public struct HostPropertiesRequest: Swift.Sendable {
        /// The host name.
        public var hostName: Swift.String?
        /// The IP address of the host.
        public var ipAddresses: DeadlineClientTypes.IpAddresses?

        public init(
            hostName: Swift.String? = nil,
            ipAddresses: DeadlineClientTypes.IpAddresses? = nil
        )
        {
            self.hostName = hostName
            self.ipAddresses = ipAddresses
        }
    }
}

public struct CreateWorkerInput: Swift.Sendable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The farm ID of the farm to connect to the worker.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID to connect to the worker.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The IP address and host name of the worker.
    public var hostProperties: DeadlineClientTypes.HostPropertiesRequest?

    public init(
        clientToken: Swift.String? = nil,
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        hostProperties: DeadlineClientTypes.HostPropertiesRequest? = nil
    )
    {
        self.clientToken = clientToken
        self.farmId = farmId
        self.fleetId = fleetId
        self.hostProperties = hostProperties
    }
}

public struct CreateWorkerOutput: Swift.Sendable {
    /// The worker ID.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        workerId: Swift.String? = nil
    )
    {
        self.workerId = workerId
    }
}

extension DeadlineClientTypes {

    /// The time stamp in date-time format.
    public struct DateTimeFilterExpression: Swift.Sendable {
        /// The date and time.
        /// This member is required.
        public var dateTime: Foundation.Date?
        /// The name of the date-time field to filter on.
        /// This member is required.
        public var name: Swift.String?
        /// The type of comparison to use to filter the results.
        /// This member is required.
        public var `operator`: DeadlineClientTypes.ComparisonOperator?

        public init(
            dateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            `operator`: DeadlineClientTypes.ComparisonOperator? = nil
        )
        {
            self.dateTime = dateTime
            self.name = name
            self.`operator` = `operator`
        }
    }
}

public struct DeleteQueueFleetAssociationInput: Swift.Sendable {
    /// The farm ID of the farm that holds the queue-fleet association.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID of the queue-fleet association.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The queue ID of the queue-fleet association.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.queueId = queueId
    }
}

public struct DeleteQueueFleetAssociationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFarmInput: Swift.Sendable {
    /// The farm ID of the farm to delete.
    /// This member is required.
    public var farmId: Swift.String?

    public init(
        farmId: Swift.String? = nil
    )
    {
        self.farmId = farmId
    }
}

public struct DeleteFarmOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteStorageProfileInput: Swift.Sendable {
    /// The farm ID of the farm from which to remove the storage profile.
    /// This member is required.
    public var farmId: Swift.String?
    /// The storage profile ID of the storage profile to delete.
    /// This member is required.
    public var storageProfileId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        storageProfileId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.storageProfileId = storageProfileId
    }
}

public struct DeleteStorageProfileOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateMemberFromFarmInput: Swift.Sendable {
    /// The farm ID of the farm to disassociate from the member.
    /// This member is required.
    public var farmId: Swift.String?
    /// A member's principal ID to disassociate from a farm.
    /// This member is required.
    public var principalId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        principalId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.principalId = principalId
    }
}

public struct DisassociateMemberFromFarmOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFleetInput: Swift.Sendable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The farm ID of the farm to remove from the fleet.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID of the fleet to delete.
    /// This member is required.
    public var fleetId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.farmId = farmId
        self.fleetId = fleetId
    }
}

public struct DeleteFleetOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateMemberFromFleetInput: Swift.Sendable {
    /// The farm ID of the fleet to disassociate a member from.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID of the fleet to from which to disassociate a member.
    /// This member is required.
    public var fleetId: Swift.String?
    /// A member's principal ID to disassociate from a fleet.
    /// This member is required.
    public var principalId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        principalId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.principalId = principalId
    }
}

public struct DisassociateMemberFromFleetOutput: Swift.Sendable {

    public init() { }
}

public struct GetFleetInput: Swift.Sendable {
    /// The farm ID of the farm in the fleet.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID of the fleet to get.
    /// This member is required.
    public var fleetId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
    }
}

extension DeadlineClientTypes {

    /// The amounts and attributes of fleets.
    public struct FleetCapabilities: Swift.Sendable {
        /// Amount capabilities of the fleet.
        public var amounts: [DeadlineClientTypes.FleetAmountCapability]?
        /// Attribute capabilities of the fleet.
        public var attributes: [DeadlineClientTypes.FleetAttributeCapability]?

        public init(
            amounts: [DeadlineClientTypes.FleetAmountCapability]? = nil,
            attributes: [DeadlineClientTypes.FleetAttributeCapability]? = nil
        )
        {
            self.amounts = amounts
            self.attributes = attributes
        }
    }
}

extension DeadlineClientTypes {

    public enum FleetStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case createInProgress
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetStatus] {
            return [
                .active,
                .createFailed,
                .createInProgress,
                .updateFailed,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetFleetOutput: Swift.Sendable {
    /// The Auto Scaling status of the fleet. Either GROWING, STEADY, or SHRINKING.
    public var autoScalingStatus: DeadlineClientTypes.AutoScalingStatus?
    /// Outlines what the fleet is capable of for minimums, maximums, and naming, in addition to attribute names and values.
    public var capabilities: DeadlineClientTypes.FleetCapabilities?
    /// The configuration setting for the fleet.
    /// This member is required.
    public var configuration: DeadlineClientTypes.FleetConfiguration?
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the fleet. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var description: Swift.String?
    /// The display name of the fleet. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    /// This member is required.
    public var displayName: Swift.String?
    /// The farm ID of the farm in the fleet.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The maximum number of workers specified in the fleet.
    /// This member is required.
    public var maxWorkerCount: Swift.Int?
    /// The minimum number of workers specified in the fleet.
    /// This member is required.
    public var minWorkerCount: Swift.Int?
    /// The IAM role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The Auto Scaling status of the fleet.
    /// This member is required.
    public var status: DeadlineClientTypes.FleetStatus?
    /// The number of target workers in the fleet.
    public var targetWorkerCount: Swift.Int?
    /// The date and time the resource was updated.
    public var updatedAt: Foundation.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?
    /// The number of workers in the fleet.
    /// This member is required.
    public var workerCount: Swift.Int?

    public init(
        autoScalingStatus: DeadlineClientTypes.AutoScalingStatus? = nil,
        capabilities: DeadlineClientTypes.FleetCapabilities? = nil,
        configuration: DeadlineClientTypes.FleetConfiguration? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        maxWorkerCount: Swift.Int? = nil,
        minWorkerCount: Swift.Int? = nil,
        roleArn: Swift.String? = nil,
        status: DeadlineClientTypes.FleetStatus? = nil,
        targetWorkerCount: Swift.Int? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil,
        workerCount: Swift.Int? = nil
    )
    {
        self.autoScalingStatus = autoScalingStatus
        self.capabilities = capabilities
        self.configuration = configuration
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
        self.fleetId = fleetId
        self.maxWorkerCount = maxWorkerCount
        self.minWorkerCount = minWorkerCount
        self.roleArn = roleArn
        self.status = status
        self.targetWorkerCount = targetWorkerCount
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
        self.workerCount = workerCount
    }
}

extension GetFleetOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFleetOutput(autoScalingStatus: \(Swift.String(describing: autoScalingStatus)), capabilities: \(Swift.String(describing: capabilities)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), fleetId: \(Swift.String(describing: fleetId)), maxWorkerCount: \(Swift.String(describing: maxWorkerCount)), minWorkerCount: \(Swift.String(describing: minWorkerCount)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), targetWorkerCount: \(Swift.String(describing: targetWorkerCount)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), workerCount: \(Swift.String(describing: workerCount)), description: \"CONTENT_REDACTED\")"}
}

public struct ListFleetMembersInput: Swift.Sendable {
    /// The farm ID of the fleet.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID to include on the list.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension DeadlineClientTypes {

    /// The fleet member.
    public struct FleetMember: Swift.Sendable {
        /// The farm ID.
        /// This member is required.
        public var farmId: Swift.String?
        /// The fleet ID.
        /// This member is required.
        public var fleetId: Swift.String?
        /// The identity store ID.
        /// This member is required.
        public var identityStoreId: Swift.String?
        /// The fleet member's membership level.
        /// This member is required.
        public var membershipLevel: DeadlineClientTypes.MembershipLevel?
        /// The principal ID of the fleet member.
        /// This member is required.
        public var principalId: Swift.String?
        /// The principal type of the fleet member.
        /// This member is required.
        public var principalType: DeadlineClientTypes.DeadlinePrincipalType?

        public init(
            farmId: Swift.String? = nil,
            fleetId: Swift.String? = nil,
            identityStoreId: Swift.String? = nil,
            membershipLevel: DeadlineClientTypes.MembershipLevel? = nil,
            principalId: Swift.String? = nil,
            principalType: DeadlineClientTypes.DeadlinePrincipalType? = nil
        )
        {
            self.farmId = farmId
            self.fleetId = fleetId
            self.identityStoreId = identityStoreId
            self.membershipLevel = membershipLevel
            self.principalId = principalId
            self.principalType = principalType
        }
    }
}

public struct ListFleetMembersOutput: Swift.Sendable {
    /// The members on the list.
    /// This member is required.
    public var members: [DeadlineClientTypes.FleetMember]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        members: [DeadlineClientTypes.FleetMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

public struct ListFleetsInput: Swift.Sendable {
    /// The display names of a list of fleets. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var displayName: Swift.String?
    /// The farm ID of the fleets.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The principal ID of the members to include in the fleet.
    public var principalId: Swift.String?
    /// The status of the fleet.
    public var status: DeadlineClientTypes.FleetStatus?

    public init(
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        status: DeadlineClientTypes.FleetStatus? = nil
    )
    {
        self.displayName = displayName
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalId = principalId
        self.status = status
    }
}

extension DeadlineClientTypes {

    /// The details of a fleet.
    public struct FleetSummary: Swift.Sendable {
        /// The Auto Scaling status of a fleet.
        public var autoScalingStatus: DeadlineClientTypes.AutoScalingStatus?
        /// The configuration details for the fleet.
        /// This member is required.
        public var configuration: DeadlineClientTypes.FleetConfiguration?
        /// The date and time the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The user or system that created this resource.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The display name of the fleet summary to update. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        /// This member is required.
        public var displayName: Swift.String?
        /// The farm ID.
        /// This member is required.
        public var farmId: Swift.String?
        /// The fleet ID.
        /// This member is required.
        public var fleetId: Swift.String?
        /// The maximum number of workers specified in the fleet.
        /// This member is required.
        public var maxWorkerCount: Swift.Int?
        /// The minimum number of workers in the fleet.
        /// This member is required.
        public var minWorkerCount: Swift.Int?
        /// The status of the fleet.
        /// This member is required.
        public var status: DeadlineClientTypes.FleetStatus?
        /// The target number of workers in a fleet.
        public var targetWorkerCount: Swift.Int?
        /// The date and time the resource was updated.
        public var updatedAt: Foundation.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?
        /// The number of workers in the fleet summary.
        /// This member is required.
        public var workerCount: Swift.Int?

        public init(
            autoScalingStatus: DeadlineClientTypes.AutoScalingStatus? = nil,
            configuration: DeadlineClientTypes.FleetConfiguration? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            displayName: Swift.String? = nil,
            farmId: Swift.String? = nil,
            fleetId: Swift.String? = nil,
            maxWorkerCount: Swift.Int? = nil,
            minWorkerCount: Swift.Int? = nil,
            status: DeadlineClientTypes.FleetStatus? = nil,
            targetWorkerCount: Swift.Int? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil,
            workerCount: Swift.Int? = nil
        )
        {
            self.autoScalingStatus = autoScalingStatus
            self.configuration = configuration
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.displayName = displayName
            self.farmId = farmId
            self.fleetId = fleetId
            self.maxWorkerCount = maxWorkerCount
            self.minWorkerCount = minWorkerCount
            self.status = status
            self.targetWorkerCount = targetWorkerCount
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.workerCount = workerCount
        }
    }
}

public struct ListFleetsOutput: Swift.Sendable {
    /// The fleets on the list.
    /// This member is required.
    public var fleets: [DeadlineClientTypes.FleetSummary]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        fleets: [DeadlineClientTypes.FleetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleets = fleets
        self.nextToken = nextToken
    }
}

public struct UpdateFleetInput: Swift.Sendable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The fleet configuration to update.
    public var configuration: DeadlineClientTypes.FleetConfiguration?
    /// The description of the fleet to update. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var description: Swift.String?
    /// The display name of the fleet to update. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var displayName: Swift.String?
    /// The farm ID to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID to update.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The maximum number of workers in the fleet.
    public var maxWorkerCount: Swift.Int?
    /// The minimum number of workers in the fleet.
    public var minWorkerCount: Swift.Int?
    /// The IAM role ARN that the fleet's workers assume while running jobs.
    public var roleArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        configuration: DeadlineClientTypes.FleetConfiguration? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        maxWorkerCount: Swift.Int? = nil,
        minWorkerCount: Swift.Int? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
        self.fleetId = fleetId
        self.maxWorkerCount = maxWorkerCount
        self.minWorkerCount = minWorkerCount
        self.roleArn = roleArn
    }
}

extension UpdateFleetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFleetInput(clientToken: \(Swift.String(describing: clientToken)), configuration: \(Swift.String(describing: configuration)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), fleetId: \(Swift.String(describing: fleetId)), maxWorkerCount: \(Swift.String(describing: maxWorkerCount)), minWorkerCount: \(Swift.String(describing: minWorkerCount)), roleArn: \(Swift.String(describing: roleArn)), description: \"CONTENT_REDACTED\")"}
}

public struct UpdateFleetOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteWorkerInput: Swift.Sendable {
    /// The farm ID of the worker to delete.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID of the worker to delete.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The worker ID of the worker to delete.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.workerId = workerId
    }
}

public struct DeleteWorkerOutput: Swift.Sendable {

    public init() { }
}

public struct GetWorkerInput: Swift.Sendable {
    /// The farm ID for the worker.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID of the worker.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The worker ID.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.workerId = workerId
    }
}

extension DeadlineClientTypes {

    /// The host property details.
    public struct HostPropertiesResponse: Swift.Sendable {
        /// The ARN of the host EC2 instance.
        public var ec2InstanceArn: Swift.String?
        /// The instance type of the host EC2 instance.
        public var ec2InstanceType: Swift.String?
        /// The host name.
        public var hostName: Swift.String?
        /// The IP address of the host.
        public var ipAddresses: DeadlineClientTypes.IpAddresses?

        public init(
            ec2InstanceArn: Swift.String? = nil,
            ec2InstanceType: Swift.String? = nil,
            hostName: Swift.String? = nil,
            ipAddresses: DeadlineClientTypes.IpAddresses? = nil
        )
        {
            self.ec2InstanceArn = ec2InstanceArn
            self.ec2InstanceType = ec2InstanceType
            self.hostName = hostName
            self.ipAddresses = ipAddresses
        }
    }
}

extension DeadlineClientTypes {

    public enum WorkerStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case idle
        case notCompatible
        case notResponding
        case running
        case started
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkerStatus] {
            return [
                .created,
                .idle,
                .notCompatible,
                .notResponding,
                .running,
                .started,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .idle: return "IDLE"
            case .notCompatible: return "NOT_COMPATIBLE"
            case .notResponding: return "NOT_RESPONDING"
            case .running: return "RUNNING"
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetWorkerOutput: Swift.Sendable {
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The farm ID.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The host properties for the worker.
    public var hostProperties: DeadlineClientTypes.HostPropertiesResponse?
    /// The logs for the associated worker.
    public var log: DeadlineClientTypes.LogConfiguration?
    /// The status of the worker.
    /// This member is required.
    public var status: DeadlineClientTypes.WorkerStatus?
    /// The date and time the resource was updated.
    public var updatedAt: Foundation.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?
    /// The worker ID.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        hostProperties: DeadlineClientTypes.HostPropertiesResponse? = nil,
        log: DeadlineClientTypes.LogConfiguration? = nil,
        status: DeadlineClientTypes.WorkerStatus? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.farmId = farmId
        self.fleetId = fleetId
        self.hostProperties = hostProperties
        self.log = log
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
        self.workerId = workerId
    }
}

public struct ListSessionsForWorkerInput: Swift.Sendable {
    /// The farm ID for the session.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID for the session.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The worker ID for the session.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workerId = workerId
    }
}

extension DeadlineClientTypes {

    public enum SessionLifecycleStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ended
        case started
        case updateFailed
        case updateInProgress
        case updateSucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionLifecycleStatus] {
            return [
                .ended,
                .started,
                .updateFailed,
                .updateInProgress,
                .updateSucceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ended: return "ENDED"
            case .started: return "STARTED"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case .updateSucceeded: return "UPDATE_SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    public enum SessionLifecycleTargetStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ended
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionLifecycleTargetStatus] {
            return [
                .ended
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ended: return "ENDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    /// Summarizes the session for a particular worker.
    public struct WorkerSessionSummary: Swift.Sendable {
        /// The date and time the resource ended running.
        public var endedAt: Foundation.Date?
        /// The job ID for the job associated with the worker's session.
        /// This member is required.
        public var jobId: Swift.String?
        /// The life cycle status for the worker's session.
        /// This member is required.
        public var lifecycleStatus: DeadlineClientTypes.SessionLifecycleStatus?
        /// The queue ID for the queue associated to the worker.
        /// This member is required.
        public var queueId: Swift.String?
        /// The session ID for the session action.
        /// This member is required.
        public var sessionId: Swift.String?
        /// The date and time the resource started running.
        /// This member is required.
        public var startedAt: Foundation.Date?
        /// The life cycle status
        public var targetLifecycleStatus: DeadlineClientTypes.SessionLifecycleTargetStatus?

        public init(
            endedAt: Foundation.Date? = nil,
            jobId: Swift.String? = nil,
            lifecycleStatus: DeadlineClientTypes.SessionLifecycleStatus? = nil,
            queueId: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            startedAt: Foundation.Date? = nil,
            targetLifecycleStatus: DeadlineClientTypes.SessionLifecycleTargetStatus? = nil
        )
        {
            self.endedAt = endedAt
            self.jobId = jobId
            self.lifecycleStatus = lifecycleStatus
            self.queueId = queueId
            self.sessionId = sessionId
            self.startedAt = startedAt
            self.targetLifecycleStatus = targetLifecycleStatus
        }
    }
}

public struct ListSessionsForWorkerOutput: Swift.Sendable {
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The sessions in the response.
    /// This member is required.
    public var sessions: [DeadlineClientTypes.WorkerSessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sessions: [DeadlineClientTypes.WorkerSessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

public struct ListWorkersInput: Swift.Sendable {
    /// The farm ID connected to the workers.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID of the workers.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension DeadlineClientTypes {

    /// The summary of details for a worker.
    public struct WorkerSummary: Swift.Sendable {
        /// The date and time the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The user or system that created this resource.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The farm ID.
        /// This member is required.
        public var farmId: Swift.String?
        /// The fleet ID.
        /// This member is required.
        public var fleetId: Swift.String?
        /// The host properties of the worker.
        public var hostProperties: DeadlineClientTypes.HostPropertiesResponse?
        /// The log configuration for the worker.
        public var log: DeadlineClientTypes.LogConfiguration?
        /// The status of the worker.
        /// This member is required.
        public var status: DeadlineClientTypes.WorkerStatus?
        /// The date and time the resource was updated.
        public var updatedAt: Foundation.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?
        /// The worker ID.
        /// This member is required.
        public var workerId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            farmId: Swift.String? = nil,
            fleetId: Swift.String? = nil,
            hostProperties: DeadlineClientTypes.HostPropertiesResponse? = nil,
            log: DeadlineClientTypes.LogConfiguration? = nil,
            status: DeadlineClientTypes.WorkerStatus? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil,
            workerId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.farmId = farmId
            self.fleetId = fleetId
            self.hostProperties = hostProperties
            self.log = log
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.workerId = workerId
        }
    }
}

public struct ListWorkersOutput: Swift.Sendable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The workers on the list.
    /// This member is required.
    public var workers: [DeadlineClientTypes.WorkerSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workers: [DeadlineClientTypes.WorkerSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workers = workers
    }
}

extension DeadlineClientTypes {

    /// The details of the worker amount capability.
    public struct WorkerAmountCapability: Swift.Sendable {
        /// The name of the worker amount capability.
        /// This member is required.
        public var name: Swift.String?
        /// The value of the worker amount capability.
        /// This member is required.
        public var value: Swift.Float?

        public init(
            name: Swift.String? = nil,
            value: Swift.Float? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }
}

extension DeadlineClientTypes {

    /// The details of the worker attribute capability.
    public struct WorkerAttributeCapability: Swift.Sendable {
        /// The name of the worker attribute capability.
        /// This member is required.
        public var name: Swift.String?
        /// The values of the worker amount capability.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

extension DeadlineClientTypes {

    /// The details for worker capabilities.
    public struct WorkerCapabilities: Swift.Sendable {
        /// The worker capabilities amounts on a list of worker capabilities.
        /// This member is required.
        public var amounts: [DeadlineClientTypes.WorkerAmountCapability]?
        /// The worker attribute capabilities in the list of attribute capabilities.
        /// This member is required.
        public var attributes: [DeadlineClientTypes.WorkerAttributeCapability]?

        public init(
            amounts: [DeadlineClientTypes.WorkerAmountCapability]? = nil,
            attributes: [DeadlineClientTypes.WorkerAttributeCapability]? = nil
        )
        {
            self.amounts = amounts
            self.attributes = attributes
        }
    }
}

extension DeadlineClientTypes {

    public enum UpdatedWorkerStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case started
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdatedWorkerStatus] {
            return [
                .started,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateWorkerInput: Swift.Sendable {
    /// The worker capabilities to update.
    public var capabilities: DeadlineClientTypes.WorkerCapabilities?
    /// The farm ID to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID to update.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The host properties to update.
    public var hostProperties: DeadlineClientTypes.HostPropertiesRequest?
    /// The worker status to update.
    public var status: DeadlineClientTypes.UpdatedWorkerStatus?
    /// The worker ID to update.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        capabilities: DeadlineClientTypes.WorkerCapabilities? = nil,
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        hostProperties: DeadlineClientTypes.HostPropertiesRequest? = nil,
        status: DeadlineClientTypes.UpdatedWorkerStatus? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.farmId = farmId
        self.fleetId = fleetId
        self.hostProperties = hostProperties
        self.status = status
        self.workerId = workerId
    }
}

public struct UpdateWorkerOutput: Swift.Sendable {
    /// The worker log to update.
    public var log: DeadlineClientTypes.LogConfiguration?

    public init(
        log: DeadlineClientTypes.LogConfiguration? = nil
    )
    {
        self.log = log
    }
}

extension DeadlineClientTypes {

    /// The updated session action information as it relates to completion and progress of the session.
    public struct UpdatedSessionActionInfo: Swift.Sendable {
        /// The status of the session upon completion.
        public var completedStatus: DeadlineClientTypes.CompletedStatus?
        /// The date and time the resource ended running.
        public var endedAt: Foundation.Date?
        /// The process exit code.
        public var processExitCode: Swift.Int?
        /// A message to indicate the progress of the updated session action.
        public var progressMessage: Swift.String?
        /// The percentage completed.
        public var progressPercent: Swift.Float?
        /// The date and time the resource started running.
        public var startedAt: Foundation.Date?
        /// The updated time.
        public var updatedAt: Foundation.Date?

        public init(
            completedStatus: DeadlineClientTypes.CompletedStatus? = nil,
            endedAt: Foundation.Date? = nil,
            processExitCode: Swift.Int? = nil,
            progressMessage: Swift.String? = nil,
            progressPercent: Swift.Float? = nil,
            startedAt: Foundation.Date? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.completedStatus = completedStatus
            self.endedAt = endedAt
            self.processExitCode = processExitCode
            self.progressMessage = progressMessage
            self.progressPercent = progressPercent
            self.startedAt = startedAt
            self.updatedAt = updatedAt
        }
    }
}

extension DeadlineClientTypes.UpdatedSessionActionInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatedSessionActionInfo(completedStatus: \(Swift.String(describing: completedStatus)), endedAt: \(Swift.String(describing: endedAt)), processExitCode: \(Swift.String(describing: processExitCode)), progressPercent: \(Swift.String(describing: progressPercent)), startedAt: \(Swift.String(describing: startedAt)), updatedAt: \(Swift.String(describing: updatedAt)), progressMessage: \"CONTENT_REDACTED\")"}
}

public struct UpdateWorkerScheduleInput: Swift.Sendable {
    /// The farm ID to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID to update.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The session actions associated with the worker schedule to update.
    public var updatedSessionActions: [Swift.String: DeadlineClientTypes.UpdatedSessionActionInfo]?
    /// The worker ID to update.
    /// This member is required.
    public var workerId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        updatedSessionActions: [Swift.String: DeadlineClientTypes.UpdatedSessionActionInfo]? = nil,
        workerId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.updatedSessionActions = updatedSessionActions
        self.workerId = workerId
    }
}

extension DeadlineClientTypes {

    public enum DesiredWorkerStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [DesiredWorkerStatus] {
            return [
                .stopped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateWorkerScheduleOutput: Swift.Sendable {
    /// The assigned sessions to update.
    /// This member is required.
    public var assignedSessions: [Swift.String: DeadlineClientTypes.AssignedSession]?
    /// The session actions associated with the worker schedule to cancel.
    /// This member is required.
    public var cancelSessionActions: [Swift.String: [Swift.String]]?
    /// The status to update the worker to.
    public var desiredWorkerStatus: DeadlineClientTypes.DesiredWorkerStatus?
    /// Updates the time interval (in seconds) for the schedule.
    /// This member is required.
    public var updateIntervalSeconds: Swift.Int?

    public init(
        assignedSessions: [Swift.String: DeadlineClientTypes.AssignedSession]? = nil,
        cancelSessionActions: [Swift.String: [Swift.String]]? = nil,
        desiredWorkerStatus: DeadlineClientTypes.DesiredWorkerStatus? = nil,
        updateIntervalSeconds: Swift.Int? = nil
    )
    {
        self.assignedSessions = assignedSessions
        self.cancelSessionActions = cancelSessionActions
        self.desiredWorkerStatus = desiredWorkerStatus
        self.updateIntervalSeconds = updateIntervalSeconds
    }
}

public struct GetFarmInput: Swift.Sendable {
    /// The farm ID of the farm.
    /// This member is required.
    public var farmId: Swift.String?

    public init(
        farmId: Swift.String? = nil
    )
    {
        self.farmId = farmId
    }
}

public struct GetFarmOutput: Swift.Sendable {
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the farm. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var description: Swift.String?
    /// The display name of the farm. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    /// This member is required.
    public var displayName: Swift.String?
    /// The farm ID of the farm to get.
    /// This member is required.
    public var farmId: Swift.String?
    /// The ARN of the KMS key used on the farm.
    /// This member is required.
    public var kmsKeyArn: Swift.String?
    /// The date and time the resource was updated.
    public var updatedAt: Foundation.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
        self.kmsKeyArn = kmsKeyArn
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension GetFarmOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFarmOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\")"}
}

public struct GetStorageProfileInput: Swift.Sendable {
    /// The farm ID for the storage profile.
    /// This member is required.
    public var farmId: Swift.String?
    /// The storage profile ID.
    /// This member is required.
    public var storageProfileId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        storageProfileId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.storageProfileId = storageProfileId
    }
}

public struct GetStorageProfileOutput: Swift.Sendable {
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The display name of the storage profile. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    /// This member is required.
    public var displayName: Swift.String?
    /// The location of the files for the storage profile.
    public var fileSystemLocations: [DeadlineClientTypes.FileSystemLocation]?
    /// The operating system (OS) for the storage profile.
    /// This member is required.
    public var osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily?
    /// The storage profile ID.
    /// This member is required.
    public var storageProfileId: Swift.String?
    /// The date and time the resource was updated.
    public var updatedAt: Foundation.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        displayName: Swift.String? = nil,
        fileSystemLocations: [DeadlineClientTypes.FileSystemLocation]? = nil,
        osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily? = nil,
        storageProfileId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.displayName = displayName
        self.fileSystemLocations = fileSystemLocations
        self.osFamily = osFamily
        self.storageProfileId = storageProfileId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension GetStorageProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStorageProfileOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), displayName: \(Swift.String(describing: displayName)), osFamily: \(Swift.String(describing: osFamily)), storageProfileId: \(Swift.String(describing: storageProfileId)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), fileSystemLocations: \"CONTENT_REDACTED\")"}
}

public struct ListFarmMembersInput: Swift.Sendable {
    /// The farm ID.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension DeadlineClientTypes {

    /// The member of a farm.
    public struct FarmMember: Swift.Sendable {
        /// The farm ID of the farm member.
        /// This member is required.
        public var farmId: Swift.String?
        /// The identity store ID of the farm member.
        /// This member is required.
        public var identityStoreId: Swift.String?
        /// The farm member's membership level.
        /// This member is required.
        public var membershipLevel: DeadlineClientTypes.MembershipLevel?
        /// The principal ID of the farm member.
        /// This member is required.
        public var principalId: Swift.String?
        /// The principal type of the farm member.
        /// This member is required.
        public var principalType: DeadlineClientTypes.DeadlinePrincipalType?

        public init(
            farmId: Swift.String? = nil,
            identityStoreId: Swift.String? = nil,
            membershipLevel: DeadlineClientTypes.MembershipLevel? = nil,
            principalId: Swift.String? = nil,
            principalType: DeadlineClientTypes.DeadlinePrincipalType? = nil
        )
        {
            self.farmId = farmId
            self.identityStoreId = identityStoreId
            self.membershipLevel = membershipLevel
            self.principalId = principalId
            self.principalType = principalType
        }
    }
}

public struct ListFarmMembersOutput: Swift.Sendable {
    /// The members on the list.
    /// This member is required.
    public var members: [DeadlineClientTypes.FarmMember]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        members: [DeadlineClientTypes.FarmMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

public struct ListFarmsInput: Swift.Sendable {
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The principal ID of the member to list on the farm.
    public var principalId: Swift.String?

    public init(
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        principalId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalId = principalId
    }
}

extension DeadlineClientTypes {

    /// The summary of details for a farm.
    public struct FarmSummary: Swift.Sendable {
        /// The date and time the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The user or system that created this resource.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The display name of the farm. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        /// This member is required.
        public var displayName: Swift.String?
        /// The farm ID.
        /// This member is required.
        public var farmId: Swift.String?
        /// The ARN for the KMS key.
        public var kmsKeyArn: Swift.String?
        /// The date and time the resource was updated.
        public var updatedAt: Foundation.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            displayName: Swift.String? = nil,
            farmId: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.displayName = displayName
            self.farmId = farmId
            self.kmsKeyArn = kmsKeyArn
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }
}

public struct ListFarmsOutput: Swift.Sendable {
    /// Farms on the list.
    /// This member is required.
    public var farms: [DeadlineClientTypes.FarmSummary]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        farms: [DeadlineClientTypes.FarmSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.farms = farms
        self.nextToken = nextToken
    }
}

public struct ListStorageProfilesInput: Swift.Sendable {
    /// The farm ID of the storage profile.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension DeadlineClientTypes {

    /// The details of a storage profile.
    public struct StorageProfileSummary: Swift.Sendable {
        /// The display name of the storage profile summary to update. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        /// This member is required.
        public var displayName: Swift.String?
        /// The operating system (OS) family.
        /// This member is required.
        public var osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily?
        /// The storage profile ID.
        /// This member is required.
        public var storageProfileId: Swift.String?

        public init(
            displayName: Swift.String? = nil,
            osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily? = nil,
            storageProfileId: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.osFamily = osFamily
            self.storageProfileId = storageProfileId
        }
    }
}

public struct ListStorageProfilesOutput: Swift.Sendable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The storage profiles.
    /// This member is required.
    public var storageProfiles: [DeadlineClientTypes.StorageProfileSummary]?

    public init(
        nextToken: Swift.String? = nil,
        storageProfiles: [DeadlineClientTypes.StorageProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.storageProfiles = storageProfiles
    }
}

public struct DeleteQueueInput: Swift.Sendable {
    /// The ID of the farm from which to remove the queue.
    /// This member is required.
    public var farmId: Swift.String?
    /// The queue ID of the queue to delete.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.queueId = queueId
    }
}

public struct DeleteQueueOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteQueueEnvironmentInput: Swift.Sendable {
    /// The farm ID of the farm from which to remove the queue environment.
    /// This member is required.
    public var farmId: Swift.String?
    /// The queue environment ID of the queue environment to delete.
    /// This member is required.
    public var queueEnvironmentId: Swift.String?
    /// The queue ID of the queue environment to delete.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        queueEnvironmentId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.queueEnvironmentId = queueEnvironmentId
        self.queueId = queueId
    }
}

public struct DeleteQueueEnvironmentOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateMemberFromQueueInput: Swift.Sendable {
    /// The farm ID for the queue to disassociate from a member.
    /// This member is required.
    public var farmId: Swift.String?
    /// A member's principal ID to disassociate from a queue.
    /// This member is required.
    public var principalId: Swift.String?
    /// The queue ID of the queue in which you're disassociating from a member.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        principalId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.principalId = principalId
        self.queueId = queueId
    }
}

public struct DisassociateMemberFromQueueOutput: Swift.Sendable {

    public init() { }
}

public struct GetQueueInput: Swift.Sendable {
    /// The farm ID of the farm in the queue.
    /// This member is required.
    public var farmId: Swift.String?
    /// The queue ID for the queue to retrieve.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.queueId = queueId
    }
}

extension DeadlineClientTypes {

    public enum QueueBlockedReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case budgetThresholdReached
        case noBudgetConfigured
        case sdkUnknown(Swift.String)

        public static var allCases: [QueueBlockedReason] {
            return [
                .budgetThresholdReached,
                .noBudgetConfigured
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .budgetThresholdReached: return "BUDGET_THRESHOLD_REACHED"
            case .noBudgetConfigured: return "NO_BUDGET_CONFIGURED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    public enum QueueStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case idle
        case scheduling
        case schedulingBlocked
        case sdkUnknown(Swift.String)

        public static var allCases: [QueueStatus] {
            return [
                .idle,
                .scheduling,
                .schedulingBlocked
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .idle: return "IDLE"
            case .scheduling: return "SCHEDULING"
            case .schedulingBlocked: return "SCHEDULING_BLOCKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetQueueOutput: Swift.Sendable {
    /// The storage profile IDs for the queue.
    public var allowedStorageProfileIds: [Swift.String]?
    /// The reason the queue was blocked.
    public var blockedReason: DeadlineClientTypes.QueueBlockedReason?
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The default action taken on a queue if a budget wasn't configured.
    /// This member is required.
    public var defaultBudgetAction: DeadlineClientTypes.DefaultQueueBudgetAction?
    /// The description of the queue. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var description: Swift.String?
    /// The display name of the queue. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    /// This member is required.
    public var displayName: Swift.String?
    /// The farm ID for the queue.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job attachment settings for the queue.
    public var jobAttachmentSettings: DeadlineClientTypes.JobAttachmentSettings?
    /// The jobs in the queue ran as this specified POSIX user.
    public var jobRunAsUser: DeadlineClientTypes.JobRunAsUser?
    /// The queue ID.
    /// This member is required.
    public var queueId: Swift.String?
    /// A list of the required file system location names in the queue.
    public var requiredFileSystemLocationNames: [Swift.String]?
    /// The IAM role ARN.
    public var roleArn: Swift.String?
    /// The status of the queue.
    ///
    /// * ACTIVEThe queue is active.
    ///
    /// * SCHEDULINGThe queue is scheduling.
    ///
    /// * SCHEDULING_BLOCKEDThe queue scheduling is blocked. See the provided reason.
    /// This member is required.
    public var status: DeadlineClientTypes.QueueStatus?
    /// The date and time the resource was updated.
    public var updatedAt: Foundation.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?

    public init(
        allowedStorageProfileIds: [Swift.String]? = nil,
        blockedReason: DeadlineClientTypes.QueueBlockedReason? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        defaultBudgetAction: DeadlineClientTypes.DefaultQueueBudgetAction? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        jobAttachmentSettings: DeadlineClientTypes.JobAttachmentSettings? = nil,
        jobRunAsUser: DeadlineClientTypes.JobRunAsUser? = nil,
        queueId: Swift.String? = nil,
        requiredFileSystemLocationNames: [Swift.String]? = nil,
        roleArn: Swift.String? = nil,
        status: DeadlineClientTypes.QueueStatus? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.allowedStorageProfileIds = allowedStorageProfileIds
        self.blockedReason = blockedReason
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.defaultBudgetAction = defaultBudgetAction
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
        self.jobAttachmentSettings = jobAttachmentSettings
        self.jobRunAsUser = jobRunAsUser
        self.queueId = queueId
        self.requiredFileSystemLocationNames = requiredFileSystemLocationNames
        self.roleArn = roleArn
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension GetQueueOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetQueueOutput(allowedStorageProfileIds: \(Swift.String(describing: allowedStorageProfileIds)), blockedReason: \(Swift.String(describing: blockedReason)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), defaultBudgetAction: \(Swift.String(describing: defaultBudgetAction)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), jobAttachmentSettings: \(Swift.String(describing: jobAttachmentSettings)), jobRunAsUser: \(Swift.String(describing: jobRunAsUser)), queueId: \(Swift.String(describing: queueId)), roleArn: \(Swift.String(describing: roleArn)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\", requiredFileSystemLocationNames: \"CONTENT_REDACTED\")"}
}

public struct GetQueueEnvironmentInput: Swift.Sendable {
    /// The farm ID for the queue environment.
    /// This member is required.
    public var farmId: Swift.String?
    /// The queue environment ID.
    /// This member is required.
    public var queueEnvironmentId: Swift.String?
    /// The queue ID for the queue environment.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        queueEnvironmentId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.queueEnvironmentId = queueEnvironmentId
        self.queueId = queueId
    }
}

public struct GetQueueEnvironmentOutput: Swift.Sendable {
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user or system that created this resource.>
    /// This member is required.
    public var createdBy: Swift.String?
    /// The name of the queue environment.
    /// This member is required.
    public var name: Swift.String?
    /// The priority of the queue environment.
    /// This member is required.
    public var priority: Swift.Int?
    /// The queue environment ID.
    /// This member is required.
    public var queueEnvironmentId: Swift.String?
    /// The template for the queue environment.
    /// This member is required.
    public var template: Swift.String?
    /// The type of template for the queue environment.
    /// This member is required.
    public var templateType: DeadlineClientTypes.EnvironmentTemplateType?
    /// The date and time the resource was updated.
    public var updatedAt: Foundation.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        queueEnvironmentId: Swift.String? = nil,
        template: Swift.String? = nil,
        templateType: DeadlineClientTypes.EnvironmentTemplateType? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.name = name
        self.priority = priority
        self.queueEnvironmentId = queueEnvironmentId
        self.template = template
        self.templateType = templateType
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension GetQueueEnvironmentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetQueueEnvironmentOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), name: \(Swift.String(describing: name)), priority: \(Swift.String(describing: priority)), queueEnvironmentId: \(Swift.String(describing: queueEnvironmentId)), templateType: \(Swift.String(describing: templateType)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), template: \"CONTENT_REDACTED\")"}
}

public struct GetStorageProfileForQueueInput: Swift.Sendable {
    /// The farm ID for the queue in storage profile.
    /// This member is required.
    public var farmId: Swift.String?
    /// The queue ID the queue in the storage profile.
    /// This member is required.
    public var queueId: Swift.String?
    /// The storage profile ID for the storage profile in the queue.
    /// This member is required.
    public var storageProfileId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        storageProfileId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.queueId = queueId
        self.storageProfileId = storageProfileId
    }
}

public struct GetStorageProfileForQueueOutput: Swift.Sendable {
    /// The display name of the storage profile connected to a queue. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    /// This member is required.
    public var displayName: Swift.String?
    /// The location of the files for the storage profile within the queue.
    public var fileSystemLocations: [DeadlineClientTypes.FileSystemLocation]?
    /// The operating system of the storage profile in the queue.
    /// This member is required.
    public var osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily?
    /// The storage profile ID.
    /// This member is required.
    public var storageProfileId: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        fileSystemLocations: [DeadlineClientTypes.FileSystemLocation]? = nil,
        osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily? = nil,
        storageProfileId: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.fileSystemLocations = fileSystemLocations
        self.osFamily = osFamily
        self.storageProfileId = storageProfileId
    }
}

extension GetStorageProfileForQueueOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStorageProfileForQueueOutput(displayName: \(Swift.String(describing: displayName)), osFamily: \(Swift.String(describing: osFamily)), storageProfileId: \(Swift.String(describing: storageProfileId)), fileSystemLocations: \"CONTENT_REDACTED\")"}
}

public struct DisassociateMemberFromJobInput: Swift.Sendable {
    /// The farm ID for the job to disassociate from the member.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID to disassociate from a member in a job.
    /// This member is required.
    public var jobId: Swift.String?
    /// A member's principal ID to disassociate from a job.
    /// This member is required.
    public var principalId: Swift.String?
    /// The queue ID connected to a job for which you're disassociating a member.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        principalId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.principalId = principalId
        self.queueId = queueId
    }
}

public struct DisassociateMemberFromJobOutput: Swift.Sendable {

    public init() { }
}

public struct GetJobInput: Swift.Sendable {
    /// The farm ID of the farm in the job.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The queue ID associated with the job.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.queueId = queueId
    }
}

extension DeadlineClientTypes {

    public enum JobLifecycleStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case archived
        case createComplete
        case createFailed
        case createInProgress
        case updateFailed
        case updateInProgress
        case updateSucceeded
        case uploadFailed
        case uploadInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [JobLifecycleStatus] {
            return [
                .archived,
                .createComplete,
                .createFailed,
                .createInProgress,
                .updateFailed,
                .updateInProgress,
                .updateSucceeded,
                .uploadFailed,
                .uploadInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .archived: return "ARCHIVED"
            case .createComplete: return "CREATE_COMPLETE"
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case .updateSucceeded: return "UPDATE_SUCCEEDED"
            case .uploadFailed: return "UPLOAD_FAILED"
            case .uploadInProgress: return "UPLOAD_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    public enum JobTargetTaskRunStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case failed
        case pending
        case ready
        case succeeded
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [JobTargetTaskRunStatus] {
            return [
                .canceled,
                .failed,
                .pending,
                .ready,
                .succeeded,
                .suspended
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .ready: return "READY"
            case .succeeded: return "SUCCEEDED"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    public enum TaskRunStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assigned
        case canceled
        case failed
        case interrupting
        case notCompatible
        case pending
        case ready
        case running
        case scheduled
        case starting
        case succeeded
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskRunStatus] {
            return [
                .assigned,
                .canceled,
                .failed,
                .interrupting,
                .notCompatible,
                .pending,
                .ready,
                .running,
                .scheduled,
                .starting,
                .succeeded,
                .suspended
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assigned: return "ASSIGNED"
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .interrupting: return "INTERRUPTING"
            case .notCompatible: return "NOT_COMPATIBLE"
            case .pending: return "PENDING"
            case .ready: return "READY"
            case .running: return "RUNNING"
            case .scheduled: return "SCHEDULED"
            case .starting: return "STARTING"
            case .succeeded: return "SUCCEEDED"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetJobOutput: Swift.Sendable {
    /// The attachments for the job.
    public var attachments: DeadlineClientTypes.Attachments?
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The description of the job. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var description: Swift.String?
    /// The date and time the resource ended running.
    public var endedAt: Foundation.Date?
    /// The job ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The life cycle status for the job.
    /// This member is required.
    public var lifecycleStatus: DeadlineClientTypes.JobLifecycleStatus?
    /// A message that communicates the status of the life cycle for the job.
    /// This member is required.
    public var lifecycleStatusMessage: Swift.String?
    /// The number of task failures before the job stops running and is marked as FAILED.
    public var maxFailedTasksCount: Swift.Int?
    /// The maximum number of retries per failed tasks.
    public var maxRetriesPerTask: Swift.Int?
    /// The name of the job.
    /// This member is required.
    public var name: Swift.String?
    /// The parameters for the job.
    public var parameters: [Swift.String: DeadlineClientTypes.JobParameter]?
    /// The job priority.
    /// This member is required.
    public var priority: Swift.Int?
    /// The job ID for the source job.
    public var sourceJobId: Swift.String?
    /// The date and time the resource started running.
    public var startedAt: Foundation.Date?
    /// The storage profile ID associated with the job.
    public var storageProfileId: Swift.String?
    /// The task status with which the job started.
    public var targetTaskRunStatus: DeadlineClientTypes.JobTargetTaskRunStatus?
    /// The task run status for the job.
    public var taskRunStatus: DeadlineClientTypes.TaskRunStatus?
    /// The number of tasks running on the job.
    public var taskRunStatusCounts: [Swift.String: Swift.Int]?
    /// The date and time the resource was updated.
    public var updatedAt: Foundation.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?

    public init(
        attachments: DeadlineClientTypes.Attachments? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        endedAt: Foundation.Date? = nil,
        jobId: Swift.String? = nil,
        lifecycleStatus: DeadlineClientTypes.JobLifecycleStatus? = nil,
        lifecycleStatusMessage: Swift.String? = nil,
        maxFailedTasksCount: Swift.Int? = nil,
        maxRetriesPerTask: Swift.Int? = nil,
        name: Swift.String? = nil,
        parameters: [Swift.String: DeadlineClientTypes.JobParameter]? = nil,
        priority: Swift.Int? = nil,
        sourceJobId: Swift.String? = nil,
        startedAt: Foundation.Date? = nil,
        storageProfileId: Swift.String? = nil,
        targetTaskRunStatus: DeadlineClientTypes.JobTargetTaskRunStatus? = nil,
        taskRunStatus: DeadlineClientTypes.TaskRunStatus? = nil,
        taskRunStatusCounts: [Swift.String: Swift.Int]? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.attachments = attachments
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.endedAt = endedAt
        self.jobId = jobId
        self.lifecycleStatus = lifecycleStatus
        self.lifecycleStatusMessage = lifecycleStatusMessage
        self.maxFailedTasksCount = maxFailedTasksCount
        self.maxRetriesPerTask = maxRetriesPerTask
        self.name = name
        self.parameters = parameters
        self.priority = priority
        self.sourceJobId = sourceJobId
        self.startedAt = startedAt
        self.storageProfileId = storageProfileId
        self.targetTaskRunStatus = targetTaskRunStatus
        self.taskRunStatus = taskRunStatus
        self.taskRunStatusCounts = taskRunStatusCounts
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension GetJobOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetJobOutput(attachments: \(Swift.String(describing: attachments)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), endedAt: \(Swift.String(describing: endedAt)), jobId: \(Swift.String(describing: jobId)), lifecycleStatus: \(Swift.String(describing: lifecycleStatus)), lifecycleStatusMessage: \(Swift.String(describing: lifecycleStatusMessage)), maxFailedTasksCount: \(Swift.String(describing: maxFailedTasksCount)), maxRetriesPerTask: \(Swift.String(describing: maxRetriesPerTask)), name: \(Swift.String(describing: name)), priority: \(Swift.String(describing: priority)), sourceJobId: \(Swift.String(describing: sourceJobId)), startedAt: \(Swift.String(describing: startedAt)), storageProfileId: \(Swift.String(describing: storageProfileId)), targetTaskRunStatus: \(Swift.String(describing: targetTaskRunStatus)), taskRunStatus: \(Swift.String(describing: taskRunStatus)), taskRunStatusCounts: \(Swift.String(describing: taskRunStatusCounts)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\", parameters: \"CONTENT_REDACTED\")"}
}

public struct GetSessionInput: Swift.Sendable {
    /// The farm ID for the session.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID for the session.
    /// This member is required.
    public var jobId: Swift.String?
    /// The queue ID for the session.
    /// This member is required.
    public var queueId: Swift.String?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.queueId = queueId
        self.sessionId = sessionId
    }
}

public struct GetSessionOutput: Swift.Sendable {
    /// The date and time the resource ended running.
    public var endedAt: Foundation.Date?
    /// The fleet ID for the session.
    /// This member is required.
    public var fleetId: Swift.String?
    /// Provides the Amazon EC2 properties of the host.
    public var hostProperties: DeadlineClientTypes.HostPropertiesResponse?
    /// The life cycle status of the session.
    /// This member is required.
    public var lifecycleStatus: DeadlineClientTypes.SessionLifecycleStatus?
    /// The session log.
    /// This member is required.
    public var log: DeadlineClientTypes.LogConfiguration?
    /// The session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The date and time the resource started running.
    /// This member is required.
    public var startedAt: Foundation.Date?
    /// The life cycle status with which the session started.
    public var targetLifecycleStatus: DeadlineClientTypes.SessionLifecycleTargetStatus?
    /// The date and time the resource was updated.
    public var updatedAt: Foundation.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?
    /// The worker ID for the session.
    /// This member is required.
    public var workerId: Swift.String?
    /// The worker log for the session.
    public var workerLog: DeadlineClientTypes.LogConfiguration?

    public init(
        endedAt: Foundation.Date? = nil,
        fleetId: Swift.String? = nil,
        hostProperties: DeadlineClientTypes.HostPropertiesResponse? = nil,
        lifecycleStatus: DeadlineClientTypes.SessionLifecycleStatus? = nil,
        log: DeadlineClientTypes.LogConfiguration? = nil,
        sessionId: Swift.String? = nil,
        startedAt: Foundation.Date? = nil,
        targetLifecycleStatus: DeadlineClientTypes.SessionLifecycleTargetStatus? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil,
        workerId: Swift.String? = nil,
        workerLog: DeadlineClientTypes.LogConfiguration? = nil
    )
    {
        self.endedAt = endedAt
        self.fleetId = fleetId
        self.hostProperties = hostProperties
        self.lifecycleStatus = lifecycleStatus
        self.log = log
        self.sessionId = sessionId
        self.startedAt = startedAt
        self.targetLifecycleStatus = targetLifecycleStatus
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
        self.workerId = workerId
        self.workerLog = workerLog
    }
}

public struct GetSessionActionInput: Swift.Sendable {
    /// The farm ID for the session action.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID for the session.
    /// This member is required.
    public var jobId: Swift.String?
    /// The queue ID for the session action.
    /// This member is required.
    public var queueId: Swift.String?
    /// The session action ID for the session.
    /// This member is required.
    public var sessionActionId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        sessionActionId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.queueId = queueId
        self.sessionActionId = sessionActionId
    }
}

extension DeadlineClientTypes {

    /// The environment ID to use to enter a session action.
    public struct EnvironmentEnterSessionActionDefinition: Swift.Sendable {
        /// The environment ID.
        /// This member is required.
        public var environmentId: Swift.String?

        public init(
            environmentId: Swift.String? = nil
        )
        {
            self.environmentId = environmentId
        }
    }
}

extension DeadlineClientTypes {

    /// Defines the environment a session action exits from.
    public struct EnvironmentExitSessionActionDefinition: Swift.Sendable {
        /// The environment ID.
        /// This member is required.
        public var environmentId: Swift.String?

        public init(
            environmentId: Swift.String? = nil
        )
        {
            self.environmentId = environmentId
        }
    }
}

extension DeadlineClientTypes {

    /// The job attachment in a session action to sync.
    public struct SyncInputJobAttachmentsSessionActionDefinition: Swift.Sendable {
        /// The step ID for the step in the job attachment.
        public var stepId: Swift.String?

        public init(
            stepId: Swift.String? = nil
        )
        {
            self.stepId = stepId
        }
    }
}

extension DeadlineClientTypes {

    /// The task, step, and parameters for the task run in the session action.
    public struct TaskRunSessionActionDefinition: Swift.Sendable {
        /// The task parameters.
        /// This member is required.
        public var parameters: [Swift.String: DeadlineClientTypes.TaskParameterValue]?
        /// The step ID.
        /// This member is required.
        public var stepId: Swift.String?
        /// The task ID.
        /// This member is required.
        public var taskId: Swift.String?

        public init(
            parameters: [Swift.String: DeadlineClientTypes.TaskParameterValue]? = nil,
            stepId: Swift.String? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.parameters = parameters
            self.stepId = stepId
            self.taskId = taskId
        }
    }
}

extension DeadlineClientTypes.TaskRunSessionActionDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TaskRunSessionActionDefinition(stepId: \(Swift.String(describing: stepId)), taskId: \(Swift.String(describing: taskId)), parameters: \"CONTENT_REDACTED\")"}
}

extension DeadlineClientTypes {

    /// The definition of the session action.
    public enum SessionActionDefinition: Swift.Sendable {
        /// The environment to enter into.
        case enventer(DeadlineClientTypes.EnvironmentEnterSessionActionDefinition)
        /// The environment to exit from.
        case envexit(DeadlineClientTypes.EnvironmentExitSessionActionDefinition)
        /// The task run in the session.
        case taskrun(DeadlineClientTypes.TaskRunSessionActionDefinition)
        /// The job attachments to sync with a session action.
        case syncinputjobattachments(DeadlineClientTypes.SyncInputJobAttachmentsSessionActionDefinition)
        case sdkUnknown(Swift.String)
    }
}

extension DeadlineClientTypes {

    public enum SessionActionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assigned
        case canceled
        case canceling
        case failed
        case interrupted
        case neverAttempted
        case reclaimed
        case reclaiming
        case running
        case scheduled
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionActionStatus] {
            return [
                .assigned,
                .canceled,
                .canceling,
                .failed,
                .interrupted,
                .neverAttempted,
                .reclaimed,
                .reclaiming,
                .running,
                .scheduled,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assigned: return "ASSIGNED"
            case .canceled: return "CANCELED"
            case .canceling: return "CANCELING"
            case .failed: return "FAILED"
            case .interrupted: return "INTERRUPTED"
            case .neverAttempted: return "NEVER_ATTEMPTED"
            case .reclaimed: return "RECLAIMED"
            case .reclaiming: return "RECLAIMING"
            case .running: return "RUNNING"
            case .scheduled: return "SCHEDULED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSessionActionOutput: Swift.Sendable {
    /// The session action definition.
    /// This member is required.
    public var definition: DeadlineClientTypes.SessionActionDefinition?
    /// The date and time the resource ended running.
    public var endedAt: Foundation.Date?
    /// The exit code to exit the session.
    public var processExitCode: Swift.Int?
    /// The message that communicates the progress of the session action.
    public var progressMessage: Swift.String?
    /// The percentage completed for a session action.
    public var progressPercent: Swift.Float?
    /// The session action ID.
    /// This member is required.
    public var sessionActionId: Swift.String?
    /// The session ID for the session action.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The date and time the resource started running.
    public var startedAt: Foundation.Date?
    /// The status of the session action.
    /// This member is required.
    public var status: DeadlineClientTypes.SessionActionStatus?
    /// The Linux timestamp of the date and time the session action was last updated.
    public var workerUpdatedAt: Foundation.Date?

    public init(
        definition: DeadlineClientTypes.SessionActionDefinition? = nil,
        endedAt: Foundation.Date? = nil,
        processExitCode: Swift.Int? = nil,
        progressMessage: Swift.String? = nil,
        progressPercent: Swift.Float? = nil,
        sessionActionId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        startedAt: Foundation.Date? = nil,
        status: DeadlineClientTypes.SessionActionStatus? = nil,
        workerUpdatedAt: Foundation.Date? = nil
    )
    {
        self.definition = definition
        self.endedAt = endedAt
        self.processExitCode = processExitCode
        self.progressMessage = progressMessage
        self.progressPercent = progressPercent
        self.sessionActionId = sessionActionId
        self.sessionId = sessionId
        self.startedAt = startedAt
        self.status = status
        self.workerUpdatedAt = workerUpdatedAt
    }
}

extension GetSessionActionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSessionActionOutput(definition: \(Swift.String(describing: definition)), endedAt: \(Swift.String(describing: endedAt)), processExitCode: \(Swift.String(describing: processExitCode)), progressPercent: \(Swift.String(describing: progressPercent)), sessionActionId: \(Swift.String(describing: sessionActionId)), sessionId: \(Swift.String(describing: sessionId)), startedAt: \(Swift.String(describing: startedAt)), status: \(Swift.String(describing: status)), workerUpdatedAt: \(Swift.String(describing: workerUpdatedAt)), progressMessage: \"CONTENT_REDACTED\")"}
}

public struct GetStepInput: Swift.Sendable {
    /// The farm ID for the step.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID for the step.
    /// This member is required.
    public var jobId: Swift.String?
    /// The queue ID for the step.
    /// This member is required.
    public var queueId: Swift.String?
    /// The step ID.
    /// This member is required.
    public var stepId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        stepId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.queueId = queueId
        self.stepId = stepId
    }
}

extension DeadlineClientTypes {

    /// The number of dependencies for the consumer.
    public struct DependencyCounts: Swift.Sendable {
        /// The number of consumers resolved.
        /// This member is required.
        public var consumersResolved: Swift.Int?
        /// The number of unresolved consumers.
        /// This member is required.
        public var consumersUnresolved: Swift.Int?
        /// The number of resolved dependencies.
        /// This member is required.
        public var dependenciesResolved: Swift.Int?
        /// The number of unresolved dependencies.
        /// This member is required.
        public var dependenciesUnresolved: Swift.Int?

        public init(
            consumersResolved: Swift.Int? = nil,
            consumersUnresolved: Swift.Int? = nil,
            dependenciesResolved: Swift.Int? = nil,
            dependenciesUnresolved: Swift.Int? = nil
        )
        {
            self.consumersResolved = consumersResolved
            self.consumersUnresolved = consumersUnresolved
            self.dependenciesResolved = dependenciesResolved
            self.dependenciesUnresolved = dependenciesUnresolved
        }
    }
}

extension DeadlineClientTypes {

    public enum StepLifecycleStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createComplete
        case updateFailed
        case updateInProgress
        case updateSucceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [StepLifecycleStatus] {
            return [
                .createComplete,
                .updateFailed,
                .updateInProgress,
                .updateSucceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createComplete: return "CREATE_COMPLETE"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case .updateSucceeded: return "UPDATE_SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    public enum StepParameterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case float
        case int
        case path
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [StepParameterType] {
            return [
                .float,
                .int,
                .path,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .float: return "FLOAT"
            case .int: return "INT"
            case .path: return "PATH"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    /// The details of a step parameter.
    public struct StepParameter: Swift.Sendable {
        /// The name of the parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The data type of the parameter.
        /// This member is required.
        public var type: DeadlineClientTypes.StepParameterType?

        public init(
            name: Swift.String? = nil,
            type: DeadlineClientTypes.StepParameterType? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }
}

extension DeadlineClientTypes {

    /// The details of a search for two or more step parameters.
    public struct ParameterSpace: Swift.Sendable {
        /// The combination expression to use in the search.
        public var combination: Swift.String?
        /// The parameters to search for.
        /// This member is required.
        public var parameters: [DeadlineClientTypes.StepParameter]?

        public init(
            combination: Swift.String? = nil,
            parameters: [DeadlineClientTypes.StepParameter]? = nil
        )
        {
            self.combination = combination
            self.parameters = parameters
        }
    }
}

extension DeadlineClientTypes {

    /// The details outlining the minimum and maximum capability of a step.
    public struct StepAmountCapability: Swift.Sendable {
        /// The maximum amount.
        public var max: Swift.Double?
        /// The minimum amount.
        public var min: Swift.Double?
        /// The name of the step.
        /// This member is required.
        public var name: Swift.String?
        /// The amount value.
        public var value: Swift.Double?

        public init(
            max: Swift.Double? = nil,
            min: Swift.Double? = nil,
            name: Swift.String? = nil,
            value: Swift.Double? = nil
        )
        {
            self.max = max
            self.min = min
            self.name = name
            self.value = value
        }
    }
}

extension DeadlineClientTypes {

    /// The list of step attributes.
    public struct StepAttributeCapability: Swift.Sendable {
        /// Requires all of the step attribute values.
        public var allOf: [Swift.String]?
        /// Requires any of the step attributes in a given list.
        public var anyOf: [Swift.String]?
        /// The name of the step attribute.
        /// This member is required.
        public var name: Swift.String?

        public init(
            allOf: [Swift.String]? = nil,
            anyOf: [Swift.String]? = nil,
            name: Swift.String? = nil
        )
        {
            self.allOf = allOf
            self.anyOf = anyOf
            self.name = name
        }
    }
}

extension DeadlineClientTypes {

    /// The details of required step capabilities.
    public struct StepRequiredCapabilities: Swift.Sendable {
        /// The capability amounts that the step requires.
        /// This member is required.
        public var amounts: [DeadlineClientTypes.StepAmountCapability]?
        /// The capability attributes that the step requires.
        /// This member is required.
        public var attributes: [DeadlineClientTypes.StepAttributeCapability]?

        public init(
            amounts: [DeadlineClientTypes.StepAmountCapability]? = nil,
            attributes: [DeadlineClientTypes.StepAttributeCapability]? = nil
        )
        {
            self.amounts = amounts
            self.attributes = attributes
        }
    }
}

extension DeadlineClientTypes {

    public enum StepTargetTaskRunStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case failed
        case pending
        case ready
        case succeeded
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [StepTargetTaskRunStatus] {
            return [
                .canceled,
                .failed,
                .pending,
                .ready,
                .succeeded,
                .suspended
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .ready: return "READY"
            case .succeeded: return "SUCCEEDED"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetStepOutput: Swift.Sendable {
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The number of dependencies in the step.
    public var dependencyCounts: DeadlineClientTypes.DependencyCounts?
    /// The description of the step. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var description: Swift.String?
    /// The date and time the resource ended running.
    public var endedAt: Foundation.Date?
    /// The life cycle status of the step.
    /// This member is required.
    public var lifecycleStatus: DeadlineClientTypes.StepLifecycleStatus?
    /// A message that describes the lifecycle status of the step.
    public var lifecycleStatusMessage: Swift.String?
    /// The name of the step.
    /// This member is required.
    public var name: Swift.String?
    /// A list of step parameters and the combination expression for the step.
    public var parameterSpace: DeadlineClientTypes.ParameterSpace?
    /// The required capabilities of the step.
    public var requiredCapabilities: DeadlineClientTypes.StepRequiredCapabilities?
    /// The date and time the resource started running.
    public var startedAt: Foundation.Date?
    /// The step ID.
    /// This member is required.
    public var stepId: Swift.String?
    /// The task status with which the job started.
    public var targetTaskRunStatus: DeadlineClientTypes.StepTargetTaskRunStatus?
    /// The task run status for the job.
    /// This member is required.
    public var taskRunStatus: DeadlineClientTypes.TaskRunStatus?
    /// The number of tasks running on the job.
    /// This member is required.
    public var taskRunStatusCounts: [Swift.String: Swift.Int]?
    /// The date and time the resource was updated.
    public var updatedAt: Foundation.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        dependencyCounts: DeadlineClientTypes.DependencyCounts? = nil,
        description: Swift.String? = nil,
        endedAt: Foundation.Date? = nil,
        lifecycleStatus: DeadlineClientTypes.StepLifecycleStatus? = nil,
        lifecycleStatusMessage: Swift.String? = nil,
        name: Swift.String? = nil,
        parameterSpace: DeadlineClientTypes.ParameterSpace? = nil,
        requiredCapabilities: DeadlineClientTypes.StepRequiredCapabilities? = nil,
        startedAt: Foundation.Date? = nil,
        stepId: Swift.String? = nil,
        targetTaskRunStatus: DeadlineClientTypes.StepTargetTaskRunStatus? = nil,
        taskRunStatus: DeadlineClientTypes.TaskRunStatus? = nil,
        taskRunStatusCounts: [Swift.String: Swift.Int]? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.dependencyCounts = dependencyCounts
        self.description = description
        self.endedAt = endedAt
        self.lifecycleStatus = lifecycleStatus
        self.lifecycleStatusMessage = lifecycleStatusMessage
        self.name = name
        self.parameterSpace = parameterSpace
        self.requiredCapabilities = requiredCapabilities
        self.startedAt = startedAt
        self.stepId = stepId
        self.targetTaskRunStatus = targetTaskRunStatus
        self.taskRunStatus = taskRunStatus
        self.taskRunStatusCounts = taskRunStatusCounts
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension GetStepOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStepOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), dependencyCounts: \(Swift.String(describing: dependencyCounts)), endedAt: \(Swift.String(describing: endedAt)), lifecycleStatus: \(Swift.String(describing: lifecycleStatus)), lifecycleStatusMessage: \(Swift.String(describing: lifecycleStatusMessage)), name: \(Swift.String(describing: name)), parameterSpace: \(Swift.String(describing: parameterSpace)), requiredCapabilities: \(Swift.String(describing: requiredCapabilities)), startedAt: \(Swift.String(describing: startedAt)), stepId: \(Swift.String(describing: stepId)), targetTaskRunStatus: \(Swift.String(describing: targetTaskRunStatus)), taskRunStatus: \(Swift.String(describing: taskRunStatus)), taskRunStatusCounts: \(Swift.String(describing: taskRunStatusCounts)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\")"}
}

public struct GetTaskInput: Swift.Sendable {
    /// The farm ID of the farm connected to the task.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID of the job connected to the task.
    /// This member is required.
    public var jobId: Swift.String?
    /// The queue ID for the queue connected to the task.
    /// This member is required.
    public var queueId: Swift.String?
    /// The step ID for the step connected to the task.
    /// This member is required.
    public var stepId: Swift.String?
    /// The task ID.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        stepId: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.queueId = queueId
        self.stepId = stepId
        self.taskId = taskId
    }
}

extension DeadlineClientTypes {

    public enum TaskTargetRunStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case failed
        case pending
        case ready
        case succeeded
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskTargetRunStatus] {
            return [
                .canceled,
                .failed,
                .pending,
                .ready,
                .succeeded,
                .suspended
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .ready: return "READY"
            case .succeeded: return "SUCCEEDED"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetTaskOutput: Swift.Sendable {
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The date and time the resource ended running.
    public var endedAt: Foundation.Date?
    /// The number of times that the task failed and was retried.
    public var failureRetryCount: Swift.Int?
    /// The latest session ID for the task.
    public var latestSessionActionId: Swift.String?
    /// The parameters for the task.
    public var parameters: [Swift.String: DeadlineClientTypes.TaskParameterValue]?
    /// The run status for the task.
    /// This member is required.
    public var runStatus: DeadlineClientTypes.TaskRunStatus?
    /// The date and time the resource started running.
    public var startedAt: Foundation.Date?
    /// The run status with which to start the task.
    public var targetRunStatus: DeadlineClientTypes.TaskTargetRunStatus?
    /// The task ID.
    /// This member is required.
    public var taskId: Swift.String?
    /// The date and time the resource was updated.
    public var updatedAt: Foundation.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        endedAt: Foundation.Date? = nil,
        failureRetryCount: Swift.Int? = nil,
        latestSessionActionId: Swift.String? = nil,
        parameters: [Swift.String: DeadlineClientTypes.TaskParameterValue]? = nil,
        runStatus: DeadlineClientTypes.TaskRunStatus? = nil,
        startedAt: Foundation.Date? = nil,
        targetRunStatus: DeadlineClientTypes.TaskTargetRunStatus? = nil,
        taskId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.endedAt = endedAt
        self.failureRetryCount = failureRetryCount
        self.latestSessionActionId = latestSessionActionId
        self.parameters = parameters
        self.runStatus = runStatus
        self.startedAt = startedAt
        self.targetRunStatus = targetRunStatus
        self.taskId = taskId
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

extension GetTaskOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetTaskOutput(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), endedAt: \(Swift.String(describing: endedAt)), failureRetryCount: \(Swift.String(describing: failureRetryCount)), latestSessionActionId: \(Swift.String(describing: latestSessionActionId)), runStatus: \(Swift.String(describing: runStatus)), startedAt: \(Swift.String(describing: startedAt)), targetRunStatus: \(Swift.String(describing: targetRunStatus)), taskId: \(Swift.String(describing: taskId)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), parameters: \"CONTENT_REDACTED\")"}
}

public struct ListJobMembersInput: Swift.Sendable {
    /// The farm ID of the job to list.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID to include on the list.
    /// This member is required.
    public var jobId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID to include on the list.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
    }
}

extension DeadlineClientTypes {

    /// The details for a job member.
    public struct JobMember: Swift.Sendable {
        /// The farm ID.
        /// This member is required.
        public var farmId: Swift.String?
        /// The identity store ID.
        /// This member is required.
        public var identityStoreId: Swift.String?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The job member's membership level.
        /// This member is required.
        public var membershipLevel: DeadlineClientTypes.MembershipLevel?
        /// The principal ID of the job member.
        /// This member is required.
        public var principalId: Swift.String?
        /// The principal type of the job member.
        /// This member is required.
        public var principalType: DeadlineClientTypes.DeadlinePrincipalType?
        /// The queue ID.
        /// This member is required.
        public var queueId: Swift.String?

        public init(
            farmId: Swift.String? = nil,
            identityStoreId: Swift.String? = nil,
            jobId: Swift.String? = nil,
            membershipLevel: DeadlineClientTypes.MembershipLevel? = nil,
            principalId: Swift.String? = nil,
            principalType: DeadlineClientTypes.DeadlinePrincipalType? = nil,
            queueId: Swift.String? = nil
        )
        {
            self.farmId = farmId
            self.identityStoreId = identityStoreId
            self.jobId = jobId
            self.membershipLevel = membershipLevel
            self.principalId = principalId
            self.principalType = principalType
            self.queueId = queueId
        }
    }
}

public struct ListJobMembersOutput: Swift.Sendable {
    /// The members on the list.
    /// This member is required.
    public var members: [DeadlineClientTypes.JobMember]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        members: [DeadlineClientTypes.JobMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

public struct ListJobParameterDefinitionsInput: Swift.Sendable {
    /// The farm ID of the job to list.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID to include on the list.
    /// This member is required.
    public var jobId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID to include on the list.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
    }
}

public struct ListJobParameterDefinitionsOutput: Swift.Sendable {
    /// Lists parameter definitions of a job.
    /// This member is required.
    public var jobParameterDefinitions: [Smithy.Document]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        jobParameterDefinitions: [Smithy.Document]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobParameterDefinitions = jobParameterDefinitions
        self.nextToken = nextToken
    }
}

public struct ListJobsInput: Swift.Sendable {
    /// The farm ID for the jobs.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The principal ID of the members on the jobs.
    public var principalId: Swift.String?
    /// The queue ID for the job.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalId = principalId
        self.queueId = queueId
    }
}

extension DeadlineClientTypes {

    /// A summary of job details.
    public struct JobSummary: Swift.Sendable {
        /// The date and time the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The user or system that created this resource.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The date and time the resource ended running.
        public var endedAt: Foundation.Date?
        /// The job ID.
        /// This member is required.
        public var jobId: Swift.String?
        /// The life cycle status.
        /// This member is required.
        public var lifecycleStatus: DeadlineClientTypes.JobLifecycleStatus?
        /// The life cycle status message.
        /// This member is required.
        public var lifecycleStatusMessage: Swift.String?
        /// The number of task failures before the job stops running and is marked as FAILED.
        public var maxFailedTasksCount: Swift.Int?
        /// The maximum number of retries for a job.
        public var maxRetriesPerTask: Swift.Int?
        /// The job name.
        /// This member is required.
        public var name: Swift.String?
        /// The job priority.
        /// This member is required.
        public var priority: Swift.Int?
        /// The job ID for the source job.
        public var sourceJobId: Swift.String?
        /// The date and time the resource started running.
        public var startedAt: Foundation.Date?
        /// The task status to start with on the job.
        public var targetTaskRunStatus: DeadlineClientTypes.JobTargetTaskRunStatus?
        /// The task run status for the job.
        ///
        /// * PENDINGpending and waiting for resources.
        ///
        /// * READYready to be processed.
        ///
        /// * ASSIGNEDassigned and will run next on a worker.
        ///
        /// * SCHEDULEDscheduled to be run on a worker.
        ///
        /// * INTERRUPTINGbeing interrupted.
        ///
        /// * RUNNINGrunning on a worker.
        ///
        /// * SUSPENDEDthe task is suspended.
        ///
        /// * CANCELEDthe task has been canceled.
        ///
        /// * FAILEDthe task has failed.
        ///
        /// * SUCCEEDEDthe task has succeeded.
        public var taskRunStatus: DeadlineClientTypes.TaskRunStatus?
        /// The number of tasks running on the job.
        public var taskRunStatusCounts: [Swift.String: Swift.Int]?
        /// The date and time the resource was updated.
        public var updatedAt: Foundation.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            endedAt: Foundation.Date? = nil,
            jobId: Swift.String? = nil,
            lifecycleStatus: DeadlineClientTypes.JobLifecycleStatus? = nil,
            lifecycleStatusMessage: Swift.String? = nil,
            maxFailedTasksCount: Swift.Int? = nil,
            maxRetriesPerTask: Swift.Int? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            sourceJobId: Swift.String? = nil,
            startedAt: Foundation.Date? = nil,
            targetTaskRunStatus: DeadlineClientTypes.JobTargetTaskRunStatus? = nil,
            taskRunStatus: DeadlineClientTypes.TaskRunStatus? = nil,
            taskRunStatusCounts: [Swift.String: Swift.Int]? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.endedAt = endedAt
            self.jobId = jobId
            self.lifecycleStatus = lifecycleStatus
            self.lifecycleStatusMessage = lifecycleStatusMessage
            self.maxFailedTasksCount = maxFailedTasksCount
            self.maxRetriesPerTask = maxRetriesPerTask
            self.name = name
            self.priority = priority
            self.sourceJobId = sourceJobId
            self.startedAt = startedAt
            self.targetTaskRunStatus = targetTaskRunStatus
            self.taskRunStatus = taskRunStatus
            self.taskRunStatusCounts = taskRunStatusCounts
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }
}

public struct ListJobsOutput: Swift.Sendable {
    /// The jobs on the list.
    /// This member is required.
    public var jobs: [DeadlineClientTypes.JobSummary]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        jobs: [DeadlineClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

public struct ListSessionActionsInput: Swift.Sendable {
    /// The farm ID for the session actions list.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID for the session actions list.
    /// This member is required.
    public var jobId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID for the session actions list.
    /// This member is required.
    public var queueId: Swift.String?
    /// The session ID to include on the sessions action list.
    public var sessionId: Swift.String?
    /// The task ID for the session actions list.
    public var taskId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
        self.sessionId = sessionId
        self.taskId = taskId
    }
}

extension DeadlineClientTypes {

    /// Defines the environment a session action enters in.
    public struct EnvironmentEnterSessionActionDefinitionSummary: Swift.Sendable {
        /// The environment ID.
        /// This member is required.
        public var environmentId: Swift.String?

        public init(
            environmentId: Swift.String? = nil
        )
        {
            self.environmentId = environmentId
        }
    }
}

extension DeadlineClientTypes {

    /// A summary of the environment details for which a session action to exits.
    public struct EnvironmentExitSessionActionDefinitionSummary: Swift.Sendable {
        /// The environment ID.
        /// This member is required.
        public var environmentId: Swift.String?

        public init(
            environmentId: Swift.String? = nil
        )
        {
            self.environmentId = environmentId
        }
    }
}

extension DeadlineClientTypes {

    /// The details of a synced job attachment.
    public struct SyncInputJobAttachmentsSessionActionDefinitionSummary: Swift.Sendable {
        /// The step ID of the step in the job attachment.
        public var stepId: Swift.String?

        public init(
            stepId: Swift.String? = nil
        )
        {
            self.stepId = stepId
        }
    }
}

extension DeadlineClientTypes {

    /// The details of a task run in a session action.
    public struct TaskRunSessionActionDefinitionSummary: Swift.Sendable {
        /// The step ID.
        /// This member is required.
        public var stepId: Swift.String?
        /// The task ID.
        /// This member is required.
        public var taskId: Swift.String?

        public init(
            stepId: Swift.String? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.stepId = stepId
            self.taskId = taskId
        }
    }
}

extension DeadlineClientTypes {

    /// The details of a session action definition.
    public enum SessionActionDefinitionSummary: Swift.Sendable {
        /// The environment to enter into.
        case enventer(DeadlineClientTypes.EnvironmentEnterSessionActionDefinitionSummary)
        /// The environment to exit from.
        case envexit(DeadlineClientTypes.EnvironmentExitSessionActionDefinitionSummary)
        /// The task run.
        case taskrun(DeadlineClientTypes.TaskRunSessionActionDefinitionSummary)
        /// The job attachments to sync with the session action definition.
        case syncinputjobattachments(DeadlineClientTypes.SyncInputJobAttachmentsSessionActionDefinitionSummary)
        case sdkUnknown(Swift.String)
    }
}

extension DeadlineClientTypes {

    /// The details of a session action.
    public struct SessionActionSummary: Swift.Sendable {
        /// The session action definition.
        /// This member is required.
        public var definition: DeadlineClientTypes.SessionActionDefinitionSummary?
        /// The date and time the resource ended running.
        public var endedAt: Foundation.Date?
        /// The completion percentage for the session action.
        public var progressPercent: Swift.Float?
        /// The session action ID.
        /// This member is required.
        public var sessionActionId: Swift.String?
        /// The date and time the resource started running.
        public var startedAt: Foundation.Date?
        /// The status of the session action.
        /// This member is required.
        public var status: DeadlineClientTypes.SessionActionStatus?
        /// The Linux timestamp of the last date and time that the session action was updated.
        public var workerUpdatedAt: Foundation.Date?

        public init(
            definition: DeadlineClientTypes.SessionActionDefinitionSummary? = nil,
            endedAt: Foundation.Date? = nil,
            progressPercent: Swift.Float? = nil,
            sessionActionId: Swift.String? = nil,
            startedAt: Foundation.Date? = nil,
            status: DeadlineClientTypes.SessionActionStatus? = nil,
            workerUpdatedAt: Foundation.Date? = nil
        )
        {
            self.definition = definition
            self.endedAt = endedAt
            self.progressPercent = progressPercent
            self.sessionActionId = sessionActionId
            self.startedAt = startedAt
            self.status = status
            self.workerUpdatedAt = workerUpdatedAt
        }
    }
}

public struct ListSessionActionsOutput: Swift.Sendable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The session actions.
    /// This member is required.
    public var sessionActions: [DeadlineClientTypes.SessionActionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sessionActions: [DeadlineClientTypes.SessionActionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessionActions = sessionActions
    }
}

public struct ListSessionsInput: Swift.Sendable {
    /// The farm ID for the list of sessions.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID for the list of sessions.
    /// This member is required.
    public var jobId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID for the list of sessions
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
    }
}

extension DeadlineClientTypes {

    /// The summary of a session.
    public struct SessionSummary: Swift.Sendable {
        /// The date and time the resource ended running.
        public var endedAt: Foundation.Date?
        /// The fleet ID.
        /// This member is required.
        public var fleetId: Swift.String?
        /// The life cycle status for the session.
        /// This member is required.
        public var lifecycleStatus: DeadlineClientTypes.SessionLifecycleStatus?
        /// The session ID.
        /// This member is required.
        public var sessionId: Swift.String?
        /// The date and time the resource started running.
        /// This member is required.
        public var startedAt: Foundation.Date?
        /// The target life cycle status for the session.
        public var targetLifecycleStatus: DeadlineClientTypes.SessionLifecycleTargetStatus?
        /// The date and time the resource was updated.
        public var updatedAt: Foundation.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?
        /// The worker ID.
        /// This member is required.
        public var workerId: Swift.String?

        public init(
            endedAt: Foundation.Date? = nil,
            fleetId: Swift.String? = nil,
            lifecycleStatus: DeadlineClientTypes.SessionLifecycleStatus? = nil,
            sessionId: Swift.String? = nil,
            startedAt: Foundation.Date? = nil,
            targetLifecycleStatus: DeadlineClientTypes.SessionLifecycleTargetStatus? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil,
            workerId: Swift.String? = nil
        )
        {
            self.endedAt = endedAt
            self.fleetId = fleetId
            self.lifecycleStatus = lifecycleStatus
            self.sessionId = sessionId
            self.startedAt = startedAt
            self.targetLifecycleStatus = targetLifecycleStatus
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.workerId = workerId
        }
    }
}

public struct ListSessionsOutput: Swift.Sendable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The sessions on the list.
    /// This member is required.
    public var sessions: [DeadlineClientTypes.SessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sessions: [DeadlineClientTypes.SessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

public struct ListStepConsumersInput: Swift.Sendable {
    /// The farm ID for the list of step consumers.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID for the step consumer.
    /// This member is required.
    public var jobId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID for the step consumer.
    /// This member is required.
    public var queueId: Swift.String?
    /// The step ID to include on the list.
    /// This member is required.
    public var stepId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil,
        stepId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
        self.stepId = stepId
    }
}

extension DeadlineClientTypes {

    public enum DependencyConsumerResolutionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case resolved
        case unresolved
        case sdkUnknown(Swift.String)

        public static var allCases: [DependencyConsumerResolutionStatus] {
            return [
                .resolved,
                .unresolved
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .resolved: return "RESOLVED"
            case .unresolved: return "UNRESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    /// The details of a step consumer.
    public struct StepConsumer: Swift.Sendable {
        /// The step consumer status.
        /// This member is required.
        public var status: DeadlineClientTypes.DependencyConsumerResolutionStatus?
        /// The step ID.
        /// This member is required.
        public var stepId: Swift.String?

        public init(
            status: DeadlineClientTypes.DependencyConsumerResolutionStatus? = nil,
            stepId: Swift.String? = nil
        )
        {
            self.status = status
            self.stepId = stepId
        }
    }
}

public struct ListStepConsumersOutput: Swift.Sendable {
    /// The consumers on the list.
    /// This member is required.
    public var consumers: [DeadlineClientTypes.StepConsumer]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        consumers: [DeadlineClientTypes.StepConsumer]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.consumers = consumers
        self.nextToken = nextToken
    }
}

public struct ListStepDependenciesInput: Swift.Sendable {
    /// The farm ID for the step dependencies list.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID for the step dependencies list.
    /// This member is required.
    public var jobId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID for the step dependencies list.
    /// This member is required.
    public var queueId: Swift.String?
    /// The step ID to include on the list.
    /// This member is required.
    public var stepId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil,
        stepId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
        self.stepId = stepId
    }
}

extension DeadlineClientTypes {

    /// The details of step dependency.
    public struct StepDependency: Swift.Sendable {
        /// The step dependency status.
        /// This member is required.
        public var status: DeadlineClientTypes.DependencyConsumerResolutionStatus?
        /// The step ID.
        /// This member is required.
        public var stepId: Swift.String?

        public init(
            status: DeadlineClientTypes.DependencyConsumerResolutionStatus? = nil,
            stepId: Swift.String? = nil
        )
        {
            self.status = status
            self.stepId = stepId
        }
    }
}

public struct ListStepDependenciesOutput: Swift.Sendable {
    /// The dependencies on the list.
    /// This member is required.
    public var dependencies: [DeadlineClientTypes.StepDependency]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        dependencies: [DeadlineClientTypes.StepDependency]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dependencies = dependencies
        self.nextToken = nextToken
    }
}

public struct ListStepsInput: Swift.Sendable {
    /// The farm ID to include on the list of steps.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID to include on the list of steps.
    /// This member is required.
    public var jobId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID to include on the list of steps.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
    }
}

extension DeadlineClientTypes {

    /// The details for a step.
    public struct StepSummary: Swift.Sendable {
        /// The date and time the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The user or system that created this resource.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The number of dependencies for the step.
        public var dependencyCounts: DeadlineClientTypes.DependencyCounts?
        /// The date and time the resource ended running.
        public var endedAt: Foundation.Date?
        /// The life cycle status.
        /// This member is required.
        public var lifecycleStatus: DeadlineClientTypes.StepLifecycleStatus?
        /// A message that describes the lifecycle of the step.
        public var lifecycleStatusMessage: Swift.String?
        /// The name of the step.
        /// This member is required.
        public var name: Swift.String?
        /// The date and time the resource started running.
        public var startedAt: Foundation.Date?
        /// The step ID.
        /// This member is required.
        public var stepId: Swift.String?
        /// The task status to start with on the job.
        public var targetTaskRunStatus: DeadlineClientTypes.StepTargetTaskRunStatus?
        /// The task run status for the job.
        ///
        /// * PENDINGpending and waiting for resources.
        ///
        /// * READYready to process.
        ///
        /// * ASSIGNEDassigned and will run next on a worker.
        ///
        /// * SCHEDULEDscheduled to run on a worker.
        ///
        /// * INTERRUPTINGbeing interrupted.
        ///
        /// * RUNNINGrunning on a worker.
        ///
        /// * SUSPENDEDthe task is suspended.
        ///
        /// * CANCELEDthe task has been canceled.
        ///
        /// * FAILEDthe task has failed.
        ///
        /// * SUCCEEDEDthe task has succeeded.
        /// This member is required.
        public var taskRunStatus: DeadlineClientTypes.TaskRunStatus?
        /// The number of tasks running on the job.
        /// This member is required.
        public var taskRunStatusCounts: [Swift.String: Swift.Int]?
        /// The date and time the resource was updated.
        public var updatedAt: Foundation.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            dependencyCounts: DeadlineClientTypes.DependencyCounts? = nil,
            endedAt: Foundation.Date? = nil,
            lifecycleStatus: DeadlineClientTypes.StepLifecycleStatus? = nil,
            lifecycleStatusMessage: Swift.String? = nil,
            name: Swift.String? = nil,
            startedAt: Foundation.Date? = nil,
            stepId: Swift.String? = nil,
            targetTaskRunStatus: DeadlineClientTypes.StepTargetTaskRunStatus? = nil,
            taskRunStatus: DeadlineClientTypes.TaskRunStatus? = nil,
            taskRunStatusCounts: [Swift.String: Swift.Int]? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.dependencyCounts = dependencyCounts
            self.endedAt = endedAt
            self.lifecycleStatus = lifecycleStatus
            self.lifecycleStatusMessage = lifecycleStatusMessage
            self.name = name
            self.startedAt = startedAt
            self.stepId = stepId
            self.targetTaskRunStatus = targetTaskRunStatus
            self.taskRunStatus = taskRunStatus
            self.taskRunStatusCounts = taskRunStatusCounts
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }
}

public struct ListStepsOutput: Swift.Sendable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The steps on the list.
    /// This member is required.
    public var steps: [DeadlineClientTypes.StepSummary]?

    public init(
        nextToken: Swift.String? = nil,
        steps: [DeadlineClientTypes.StepSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.steps = steps
    }
}

public struct ListTasksInput: Swift.Sendable {
    /// The farm ID connected to the tasks.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID for the tasks.
    /// This member is required.
    public var jobId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID connected to the tasks.
    /// This member is required.
    public var queueId: Swift.String?
    /// The step ID for the tasks.
    /// This member is required.
    public var stepId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil,
        stepId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
        self.stepId = stepId
    }
}

extension DeadlineClientTypes {

    /// The details of a task.
    public struct TaskSummary: Swift.Sendable {
        /// The date and time the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The user or system that created this resource.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The date and time the resource ended running.
        public var endedAt: Foundation.Date?
        /// The number of times that the task failed and was retried.
        public var failureRetryCount: Swift.Int?
        /// The latest session action for the task.
        public var latestSessionActionId: Swift.String?
        /// The task parameters.
        public var parameters: [Swift.String: DeadlineClientTypes.TaskParameterValue]?
        /// The run status of the task.
        /// This member is required.
        public var runStatus: DeadlineClientTypes.TaskRunStatus?
        /// The date and time the resource started running.
        public var startedAt: Foundation.Date?
        /// The run status on which the started.
        public var targetRunStatus: DeadlineClientTypes.TaskTargetRunStatus?
        /// The task ID.
        /// This member is required.
        public var taskId: Swift.String?
        /// The date and time the resource was updated.
        public var updatedAt: Foundation.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            endedAt: Foundation.Date? = nil,
            failureRetryCount: Swift.Int? = nil,
            latestSessionActionId: Swift.String? = nil,
            parameters: [Swift.String: DeadlineClientTypes.TaskParameterValue]? = nil,
            runStatus: DeadlineClientTypes.TaskRunStatus? = nil,
            startedAt: Foundation.Date? = nil,
            targetRunStatus: DeadlineClientTypes.TaskTargetRunStatus? = nil,
            taskId: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.endedAt = endedAt
            self.failureRetryCount = failureRetryCount
            self.latestSessionActionId = latestSessionActionId
            self.parameters = parameters
            self.runStatus = runStatus
            self.startedAt = startedAt
            self.targetRunStatus = targetRunStatus
            self.taskId = taskId
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }
}

extension DeadlineClientTypes.TaskSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TaskSummary(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), endedAt: \(Swift.String(describing: endedAt)), failureRetryCount: \(Swift.String(describing: failureRetryCount)), latestSessionActionId: \(Swift.String(describing: latestSessionActionId)), runStatus: \(Swift.String(describing: runStatus)), startedAt: \(Swift.String(describing: startedAt)), targetRunStatus: \(Swift.String(describing: targetRunStatus)), taskId: \(Swift.String(describing: taskId)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), parameters: \"CONTENT_REDACTED\")"}
}

public struct ListTasksOutput: Swift.Sendable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// Tasks for the job.
    /// This member is required.
    public var tasks: [DeadlineClientTypes.TaskSummary]?

    public init(
        nextToken: Swift.String? = nil,
        tasks: [DeadlineClientTypes.TaskSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

extension DeadlineClientTypes {

    public enum UpdateJobLifecycleStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case archived
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateJobLifecycleStatus] {
            return [
                .archived
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .archived: return "ARCHIVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateJobInput: Swift.Sendable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The farm ID of the job to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID to update.
    /// This member is required.
    public var jobId: Swift.String?
    /// The status of a job in its lifecycle. When you change the status of the job to ARCHIVED, the job can't be scheduled or archived. An archived jobs and its steps and tasks are deleted after 120 days. The job can't be recovered.
    public var lifecycleStatus: DeadlineClientTypes.UpdateJobLifecycleStatus?
    /// The number of task failures before the job stops running and is marked as FAILED.
    public var maxFailedTasksCount: Swift.Int?
    /// The maximum number of retries for a job.
    public var maxRetriesPerTask: Swift.Int?
    /// The job priority to update.
    public var priority: Swift.Int?
    /// The queue ID of the job to update.
    /// This member is required.
    public var queueId: Swift.String?
    /// The task status to update the job's tasks to.
    public var targetTaskRunStatus: DeadlineClientTypes.JobTargetTaskRunStatus?

    public init(
        clientToken: Swift.String? = nil,
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        lifecycleStatus: DeadlineClientTypes.UpdateJobLifecycleStatus? = nil,
        maxFailedTasksCount: Swift.Int? = nil,
        maxRetriesPerTask: Swift.Int? = nil,
        priority: Swift.Int? = nil,
        queueId: Swift.String? = nil,
        targetTaskRunStatus: DeadlineClientTypes.JobTargetTaskRunStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.farmId = farmId
        self.jobId = jobId
        self.lifecycleStatus = lifecycleStatus
        self.maxFailedTasksCount = maxFailedTasksCount
        self.maxRetriesPerTask = maxRetriesPerTask
        self.priority = priority
        self.queueId = queueId
        self.targetTaskRunStatus = targetTaskRunStatus
    }
}

public struct UpdateJobOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateSessionInput: Swift.Sendable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The farm ID to update in the session.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID to update in the session.
    /// This member is required.
    public var jobId: Swift.String?
    /// The queue ID to update in the session.
    /// This member is required.
    public var queueId: Swift.String?
    /// The session ID to update.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The life cycle status to update in the session.
    /// This member is required.
    public var targetLifecycleStatus: DeadlineClientTypes.SessionLifecycleTargetStatus?

    public init(
        clientToken: Swift.String? = nil,
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        targetLifecycleStatus: DeadlineClientTypes.SessionLifecycleTargetStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.farmId = farmId
        self.jobId = jobId
        self.queueId = queueId
        self.sessionId = sessionId
        self.targetLifecycleStatus = targetLifecycleStatus
    }
}

public struct UpdateSessionOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateStepInput: Swift.Sendable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The farm ID to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID to update.
    /// This member is required.
    public var jobId: Swift.String?
    /// The queue ID to update.
    /// This member is required.
    public var queueId: Swift.String?
    /// The step ID to update.
    /// This member is required.
    public var stepId: Swift.String?
    /// The task status to update the step's tasks to.
    /// This member is required.
    public var targetTaskRunStatus: DeadlineClientTypes.StepTargetTaskRunStatus?

    public init(
        clientToken: Swift.String? = nil,
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        stepId: Swift.String? = nil,
        targetTaskRunStatus: DeadlineClientTypes.StepTargetTaskRunStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.farmId = farmId
        self.jobId = jobId
        self.queueId = queueId
        self.stepId = stepId
        self.targetTaskRunStatus = targetTaskRunStatus
    }
}

public struct UpdateStepOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateTaskInput: Swift.Sendable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The farm ID to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job ID to update.
    /// This member is required.
    public var jobId: Swift.String?
    /// The queue ID to update.
    /// This member is required.
    public var queueId: Swift.String?
    /// The step ID to update.
    /// This member is required.
    public var stepId: Swift.String?
    /// The run status with which to start the task.
    /// This member is required.
    public var targetRunStatus: DeadlineClientTypes.TaskTargetRunStatus?
    /// The task ID to update.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        farmId: Swift.String? = nil,
        jobId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        stepId: Swift.String? = nil,
        targetRunStatus: DeadlineClientTypes.TaskTargetRunStatus? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.farmId = farmId
        self.jobId = jobId
        self.queueId = queueId
        self.stepId = stepId
        self.targetRunStatus = targetRunStatus
        self.taskId = taskId
    }
}

public struct UpdateTaskOutput: Swift.Sendable {

    public init() { }
}

public struct ListQueueEnvironmentsInput: Swift.Sendable {
    /// The farm ID for the queue environment list.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID for the queue environment list.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
    }
}

extension DeadlineClientTypes {

    /// The summary of a queue environment.
    public struct QueueEnvironmentSummary: Swift.Sendable {
        /// The name of the queue environment.
        /// This member is required.
        public var name: Swift.String?
        /// The queue environment's priority.
        /// This member is required.
        public var priority: Swift.Int?
        /// The queue environment ID.
        /// This member is required.
        public var queueEnvironmentId: Swift.String?

        public init(
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            queueEnvironmentId: Swift.String? = nil
        )
        {
            self.name = name
            self.priority = priority
            self.queueEnvironmentId = queueEnvironmentId
        }
    }
}

public struct ListQueueEnvironmentsOutput: Swift.Sendable {
    /// The environments to include in the queue environments list.
    /// This member is required.
    public var environments: [DeadlineClientTypes.QueueEnvironmentSummary]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        environments: [DeadlineClientTypes.QueueEnvironmentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environments = environments
        self.nextToken = nextToken
    }
}

public struct ListQueueMembersInput: Swift.Sendable {
    /// The farm ID for the queue.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID to include on the list.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
    }
}

extension DeadlineClientTypes {

    /// The details of a queue member.
    public struct QueueMember: Swift.Sendable {
        /// The farm ID.
        /// This member is required.
        public var farmId: Swift.String?
        /// The identity store ID.
        /// This member is required.
        public var identityStoreId: Swift.String?
        /// The queue member's membership level.
        /// This member is required.
        public var membershipLevel: DeadlineClientTypes.MembershipLevel?
        /// The principal ID of the queue member.
        /// This member is required.
        public var principalId: Swift.String?
        /// The principal type of the queue member.
        /// This member is required.
        public var principalType: DeadlineClientTypes.DeadlinePrincipalType?
        /// The queue ID.
        /// This member is required.
        public var queueId: Swift.String?

        public init(
            farmId: Swift.String? = nil,
            identityStoreId: Swift.String? = nil,
            membershipLevel: DeadlineClientTypes.MembershipLevel? = nil,
            principalId: Swift.String? = nil,
            principalType: DeadlineClientTypes.DeadlinePrincipalType? = nil,
            queueId: Swift.String? = nil
        )
        {
            self.farmId = farmId
            self.identityStoreId = identityStoreId
            self.membershipLevel = membershipLevel
            self.principalId = principalId
            self.principalType = principalType
            self.queueId = queueId
        }
    }
}

public struct ListQueueMembersOutput: Swift.Sendable {
    /// The members on the list.
    /// This member is required.
    public var members: [DeadlineClientTypes.QueueMember]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        members: [DeadlineClientTypes.QueueMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

public struct ListQueuesInput: Swift.Sendable {
    /// The farm ID of the queue.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The principal IDs to include in the list of queues.
    public var principalId: Swift.String?
    /// The status of the queues listed.
    ///
    /// * ACTIVEThe queues are active.
    ///
    /// * SCHEDULINGThe queues are scheduling.
    ///
    /// * SCHEDULING_BLOCKEDThe queue scheduling is blocked for these queues.
    public var status: DeadlineClientTypes.QueueStatus?

    public init(
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        status: DeadlineClientTypes.QueueStatus? = nil
    )
    {
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalId = principalId
        self.status = status
    }
}

extension DeadlineClientTypes {

    /// The details of a queue summary.
    public struct QueueSummary: Swift.Sendable {
        /// The reason the queue is blocked, if applicable.
        public var blockedReason: DeadlineClientTypes.QueueBlockedReason?
        /// The date and time the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The user or system that created this resource.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The default action taken on a queue summary if a budget wasn't configured.
        /// This member is required.
        public var defaultBudgetAction: DeadlineClientTypes.DefaultQueueBudgetAction?
        /// The display name of the queue summary to update. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        /// This member is required.
        public var displayName: Swift.String?
        /// The farm ID.
        /// This member is required.
        public var farmId: Swift.String?
        /// The queue ID.
        /// This member is required.
        public var queueId: Swift.String?
        /// That status of the queue.
        /// This member is required.
        public var status: DeadlineClientTypes.QueueStatus?
        /// The date and time the resource was updated.
        public var updatedAt: Foundation.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?

        public init(
            blockedReason: DeadlineClientTypes.QueueBlockedReason? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            defaultBudgetAction: DeadlineClientTypes.DefaultQueueBudgetAction? = nil,
            displayName: Swift.String? = nil,
            farmId: Swift.String? = nil,
            queueId: Swift.String? = nil,
            status: DeadlineClientTypes.QueueStatus? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.blockedReason = blockedReason
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.defaultBudgetAction = defaultBudgetAction
            self.displayName = displayName
            self.farmId = farmId
            self.queueId = queueId
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }
}

public struct ListQueuesOutput: Swift.Sendable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The queues on the list.
    /// This member is required.
    public var queues: [DeadlineClientTypes.QueueSummary]?

    public init(
        nextToken: Swift.String? = nil,
        queues: [DeadlineClientTypes.QueueSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.queues = queues
    }
}

public struct ListStorageProfilesForQueueInput: Swift.Sendable {
    /// The farm ID of the queue's storage profile.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID for the storage profile.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
    }
}

public struct ListStorageProfilesForQueueOutput: Swift.Sendable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The storage profiles in the queue.
    /// This member is required.
    public var storageProfiles: [DeadlineClientTypes.StorageProfileSummary]?

    public init(
        nextToken: Swift.String? = nil,
        storageProfiles: [DeadlineClientTypes.StorageProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.storageProfiles = storageProfiles
    }
}

public struct UpdateQueueInput: Swift.Sendable {
    /// The storage profile IDs to add.
    public var allowedStorageProfileIdsToAdd: [Swift.String]?
    /// The storage profile ID to remove.
    public var allowedStorageProfileIdsToRemove: [Swift.String]?
    /// The idempotency token to update in the queue.
    public var clientToken: Swift.String?
    /// The default action to take for a queue update if a budget isn't configured.
    public var defaultBudgetAction: DeadlineClientTypes.DefaultQueueBudgetAction?
    /// The description of the queue to update. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var description: Swift.String?
    /// The display name of the queue to update. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var displayName: Swift.String?
    /// The farm ID to update in the queue.
    /// This member is required.
    public var farmId: Swift.String?
    /// The job attachment settings to update for the queue.
    public var jobAttachmentSettings: DeadlineClientTypes.JobAttachmentSettings?
    /// Update the jobs in the queue to run as a specified POSIX user.
    public var jobRunAsUser: DeadlineClientTypes.JobRunAsUser?
    /// The queue ID to update.
    /// This member is required.
    public var queueId: Swift.String?
    /// The required file system location names to add to the queue.
    public var requiredFileSystemLocationNamesToAdd: [Swift.String]?
    /// The required file system location names to remove from the queue.
    public var requiredFileSystemLocationNamesToRemove: [Swift.String]?
    /// The IAM role ARN that's used to run jobs from this queue.
    public var roleArn: Swift.String?

    public init(
        allowedStorageProfileIdsToAdd: [Swift.String]? = nil,
        allowedStorageProfileIdsToRemove: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        defaultBudgetAction: DeadlineClientTypes.DefaultQueueBudgetAction? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        jobAttachmentSettings: DeadlineClientTypes.JobAttachmentSettings? = nil,
        jobRunAsUser: DeadlineClientTypes.JobRunAsUser? = nil,
        queueId: Swift.String? = nil,
        requiredFileSystemLocationNamesToAdd: [Swift.String]? = nil,
        requiredFileSystemLocationNamesToRemove: [Swift.String]? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.allowedStorageProfileIdsToAdd = allowedStorageProfileIdsToAdd
        self.allowedStorageProfileIdsToRemove = allowedStorageProfileIdsToRemove
        self.clientToken = clientToken
        self.defaultBudgetAction = defaultBudgetAction
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
        self.jobAttachmentSettings = jobAttachmentSettings
        self.jobRunAsUser = jobRunAsUser
        self.queueId = queueId
        self.requiredFileSystemLocationNamesToAdd = requiredFileSystemLocationNamesToAdd
        self.requiredFileSystemLocationNamesToRemove = requiredFileSystemLocationNamesToRemove
        self.roleArn = roleArn
    }
}

extension UpdateQueueInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateQueueInput(allowedStorageProfileIdsToAdd: \(Swift.String(describing: allowedStorageProfileIdsToAdd)), allowedStorageProfileIdsToRemove: \(Swift.String(describing: allowedStorageProfileIdsToRemove)), clientToken: \(Swift.String(describing: clientToken)), defaultBudgetAction: \(Swift.String(describing: defaultBudgetAction)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), jobAttachmentSettings: \(Swift.String(describing: jobAttachmentSettings)), jobRunAsUser: \(Swift.String(describing: jobRunAsUser)), queueId: \(Swift.String(describing: queueId)), roleArn: \(Swift.String(describing: roleArn)), description: \"CONTENT_REDACTED\", requiredFileSystemLocationNamesToAdd: \"CONTENT_REDACTED\", requiredFileSystemLocationNamesToRemove: \"CONTENT_REDACTED\")"}
}

public struct UpdateQueueOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateQueueEnvironmentInput: Swift.Sendable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The farm ID of the queue environment to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The priority to update.
    public var priority: Swift.Int?
    /// The queue environment ID to update.
    /// This member is required.
    public var queueEnvironmentId: Swift.String?
    /// The queue ID of the queue environment to update.
    /// This member is required.
    public var queueId: Swift.String?
    /// The template to update.
    public var template: Swift.String?
    /// The template type to update.
    public var templateType: DeadlineClientTypes.EnvironmentTemplateType?

    public init(
        clientToken: Swift.String? = nil,
        farmId: Swift.String? = nil,
        priority: Swift.Int? = nil,
        queueEnvironmentId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        template: Swift.String? = nil,
        templateType: DeadlineClientTypes.EnvironmentTemplateType? = nil
    )
    {
        self.clientToken = clientToken
        self.farmId = farmId
        self.priority = priority
        self.queueEnvironmentId = queueEnvironmentId
        self.queueId = queueId
        self.template = template
        self.templateType = templateType
    }
}

extension UpdateQueueEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateQueueEnvironmentInput(clientToken: \(Swift.String(describing: clientToken)), farmId: \(Swift.String(describing: farmId)), priority: \(Swift.String(describing: priority)), queueEnvironmentId: \(Swift.String(describing: queueEnvironmentId)), queueId: \(Swift.String(describing: queueId)), templateType: \(Swift.String(describing: templateType)), template: \"CONTENT_REDACTED\")"}
}

public struct UpdateQueueEnvironmentOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateFarmInput: Swift.Sendable {
    /// The description of the farm to update. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var description: Swift.String?
    /// The display name of the farm to update. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var displayName: Swift.String?
    /// The farm ID to update.
    /// This member is required.
    public var farmId: Swift.String?

    public init(
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.farmId = farmId
    }
}

extension UpdateFarmInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFarmInput(displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), description: \"CONTENT_REDACTED\")"}
}

public struct UpdateFarmOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateStorageProfileInput: Swift.Sendable {
    /// The unique token which the server uses to recognize retries of the same request.
    public var clientToken: Swift.String?
    /// The display name of the storage profile to update. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var displayName: Swift.String?
    /// The farm ID to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The file system location names to add.
    public var fileSystemLocationsToAdd: [DeadlineClientTypes.FileSystemLocation]?
    /// The file system location names to remove.
    public var fileSystemLocationsToRemove: [DeadlineClientTypes.FileSystemLocation]?
    /// The OS system to update.
    public var osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily?
    /// The storage profile ID to update.
    /// This member is required.
    public var storageProfileId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        farmId: Swift.String? = nil,
        fileSystemLocationsToAdd: [DeadlineClientTypes.FileSystemLocation]? = nil,
        fileSystemLocationsToRemove: [DeadlineClientTypes.FileSystemLocation]? = nil,
        osFamily: DeadlineClientTypes.StorageProfileOperatingSystemFamily? = nil,
        storageProfileId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.displayName = displayName
        self.farmId = farmId
        self.fileSystemLocationsToAdd = fileSystemLocationsToAdd
        self.fileSystemLocationsToRemove = fileSystemLocationsToRemove
        self.osFamily = osFamily
        self.storageProfileId = storageProfileId
    }
}

extension UpdateStorageProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStorageProfileInput(clientToken: \(Swift.String(describing: clientToken)), displayName: \(Swift.String(describing: displayName)), farmId: \(Swift.String(describing: farmId)), osFamily: \(Swift.String(describing: osFamily)), storageProfileId: \(Swift.String(describing: storageProfileId)), fileSystemLocationsToAdd: \"CONTENT_REDACTED\", fileSystemLocationsToRemove: \"CONTENT_REDACTED\")"}
}

public struct UpdateStorageProfileOutput: Swift.Sendable {

    public init() { }
}

public struct GetQueueFleetAssociationInput: Swift.Sendable {
    /// The farm ID of the farm that contains the queue-fleet association.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID for the queue-fleet association.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The queue ID for the queue-fleet association.
    /// This member is required.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.queueId = queueId
    }
}

extension DeadlineClientTypes {

    public enum QueueFleetAssociationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case stopped
        case stopSchedulingAndCancelTasks
        case stopSchedulingAndCompleteTasks
        case sdkUnknown(Swift.String)

        public static var allCases: [QueueFleetAssociationStatus] {
            return [
                .active,
                .stopped,
                .stopSchedulingAndCancelTasks,
                .stopSchedulingAndCompleteTasks
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .stopped: return "STOPPED"
            case .stopSchedulingAndCancelTasks: return "STOP_SCHEDULING_AND_CANCEL_TASKS"
            case .stopSchedulingAndCompleteTasks: return "STOP_SCHEDULING_AND_COMPLETE_TASKS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetQueueFleetAssociationOutput: Swift.Sendable {
    /// The date and time the resource was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user or system that created this resource.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The fleet ID for the queue-fleet association.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The queue ID for the queue-fleet association.
    /// This member is required.
    public var queueId: Swift.String?
    /// The status of the queue-fleet association.
    /// This member is required.
    public var status: DeadlineClientTypes.QueueFleetAssociationStatus?
    /// The date and time the resource was updated.
    public var updatedAt: Foundation.Date?
    /// The user or system that updated this resource.
    public var updatedBy: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        status: DeadlineClientTypes.QueueFleetAssociationStatus? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.fleetId = fleetId
        self.queueId = queueId
        self.status = status
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
    }
}

public struct GetSessionsStatisticsAggregationInput: Swift.Sendable {
    /// The identifier returned by the StartSessionsStatisticsAggregation operation that identifies the aggregated statistics.
    /// This member is required.
    public var aggregationId: Swift.String?
    /// The identifier of the farm to include in the statistics. This should be the same as the farm ID used in the call to the StartSessionsStatisticsAggregation operation.
    /// This member is required.
    public var farmId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?

    public init(
        aggregationId: Swift.String? = nil,
        farmId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregationId = aggregationId
        self.farmId = farmId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension DeadlineClientTypes {

    /// The minimum, maximum, average, and sum.
    public struct Stats: Swift.Sendable {
        /// The average of the usage statistics.
        public var avg: Swift.Double?
        /// The maximum among the usage statistics.
        public var max: Swift.Double?
        /// The minimum of the usage statistics.
        public var min: Swift.Double?
        /// The sum of the usage statistics.
        public var sum: Swift.Double?

        public init(
            avg: Swift.Double? = nil,
            max: Swift.Double? = nil,
            min: Swift.Double? = nil,
            sum: Swift.Double? = nil
        )
        {
            self.avg = avg
            self.max = max
            self.min = min
            self.sum = sum
        }
    }
}

extension DeadlineClientTypes {

    public enum UsageType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case compute
        case license
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageType] {
            return [
                .compute,
                .license
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .compute: return "COMPUTE"
            case .license: return "LICENSE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    /// A list of statistics for a session.
    public struct Statistics: Swift.Sendable {
        /// The end time for the aggregation.
        public var aggregationEndTime: Foundation.Date?
        /// The start time for the aggregation.
        public var aggregationStartTime: Foundation.Date?
        /// How the statistics should appear in USD. Options include: minimum, maximum, average or sum.
        /// This member is required.
        public var costInUsd: DeadlineClientTypes.Stats?
        /// The number of instances in a list of statistics.
        /// This member is required.
        public var count: Swift.Int?
        /// The fleet ID.
        public var fleetId: Swift.String?
        /// The type of instance.
        public var instanceType: Swift.String?
        /// The job ID.
        public var jobId: Swift.String?
        /// The job name.
        public var jobName: Swift.String?
        /// The licensed product.
        public var licenseProduct: Swift.String?
        /// The queue ID.
        public var queueId: Swift.String?
        /// The total aggregated runtime.
        /// This member is required.
        public var runtimeInSeconds: DeadlineClientTypes.Stats?
        /// The type of usage for the statistics.
        public var usageType: DeadlineClientTypes.UsageType?
        /// The user ID.
        public var userId: Swift.String?

        public init(
            aggregationEndTime: Foundation.Date? = nil,
            aggregationStartTime: Foundation.Date? = nil,
            costInUsd: DeadlineClientTypes.Stats? = nil,
            count: Swift.Int? = nil,
            fleetId: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            licenseProduct: Swift.String? = nil,
            queueId: Swift.String? = nil,
            runtimeInSeconds: DeadlineClientTypes.Stats? = nil,
            usageType: DeadlineClientTypes.UsageType? = nil,
            userId: Swift.String? = nil
        )
        {
            self.aggregationEndTime = aggregationEndTime
            self.aggregationStartTime = aggregationStartTime
            self.costInUsd = costInUsd
            self.count = count
            self.fleetId = fleetId
            self.instanceType = instanceType
            self.jobId = jobId
            self.jobName = jobName
            self.licenseProduct = licenseProduct
            self.queueId = queueId
            self.runtimeInSeconds = runtimeInSeconds
            self.usageType = usageType
            self.userId = userId
        }
    }
}

extension DeadlineClientTypes {

    public enum SessionsStatisticsAggregationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case timeout
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionsStatisticsAggregationStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .timeout
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .timeout: return "TIMEOUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSessionsStatisticsAggregationOutput: Swift.Sendable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The statistics for the specified fleets or queues.
    public var statistics: [DeadlineClientTypes.Statistics]?
    /// The status of the aggregated results. An aggregation may fail or time out if the results are too large. If this happens, you can call the StartSessionsStatisticsAggregation operation after you reduce the aggregation time frame, reduce the number of queues or fleets in the aggregation, or increase the period length. If you call the StartSessionsStatisticsAggregation  operation when the status is IN_PROGRESS, you will receive a ThrottlingException.
    /// This member is required.
    public var status: DeadlineClientTypes.SessionsStatisticsAggregationStatus?
    /// A message that describes the status.
    public var statusMessage: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        statistics: [DeadlineClientTypes.Statistics]? = nil,
        status: DeadlineClientTypes.SessionsStatisticsAggregationStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.statistics = statistics
        self.status = status
        self.statusMessage = statusMessage
    }
}

public struct DeleteLicenseEndpointInput: Swift.Sendable {
    /// The license endpoint ID of the license endpoint to delete.
    /// This member is required.
    public var licenseEndpointId: Swift.String?

    public init(
        licenseEndpointId: Swift.String? = nil
    )
    {
        self.licenseEndpointId = licenseEndpointId
    }
}

public struct DeleteLicenseEndpointOutput: Swift.Sendable {

    public init() { }
}

public struct GetLicenseEndpointInput: Swift.Sendable {
    /// The license endpoint ID.
    /// This member is required.
    public var licenseEndpointId: Swift.String?

    public init(
        licenseEndpointId: Swift.String? = nil
    )
    {
        self.licenseEndpointId = licenseEndpointId
    }
}

extension DeadlineClientTypes {

    public enum LicenseEndpointStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createInProgress
        case deleteInProgress
        case notReady
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseEndpointStatus] {
            return [
                .createInProgress,
                .deleteInProgress,
                .notReady,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .notReady: return "NOT_READY"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetLicenseEndpointOutput: Swift.Sendable {
    /// The DNS name.
    public var dnsName: Swift.String?
    /// The license endpoint ID.
    /// This member is required.
    public var licenseEndpointId: Swift.String?
    /// The security group IDs for the license endpoint.
    public var securityGroupIds: [Swift.String]?
    /// The status of the license endpoint.
    /// This member is required.
    public var status: DeadlineClientTypes.LicenseEndpointStatus?
    /// The status message of the license endpoint.
    /// This member is required.
    public var statusMessage: Swift.String?
    /// The subnet IDs.
    public var subnetIds: [Swift.String]?
    /// The VCP(virtual private cloud) ID associated with the license endpoint.
    public var vpcId: Swift.String?

    public init(
        dnsName: Swift.String? = nil,
        licenseEndpointId: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        status: DeadlineClientTypes.LicenseEndpointStatus? = nil,
        statusMessage: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.dnsName = dnsName
        self.licenseEndpointId = licenseEndpointId
        self.securityGroupIds = securityGroupIds
        self.status = status
        self.statusMessage = statusMessage
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}

public struct ListLicenseEndpointsInput: Swift.Sendable {
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension DeadlineClientTypes {

    /// The details for a license endpoint.
    public struct LicenseEndpointSummary: Swift.Sendable {
        /// The license endpoint ID.
        public var licenseEndpointId: Swift.String?
        /// The status of the license endpoint.
        public var status: DeadlineClientTypes.LicenseEndpointStatus?
        /// The status message of the license endpoint.
        public var statusMessage: Swift.String?
        /// The VCP(virtual private cloud) ID associated with the license endpoint.
        public var vpcId: Swift.String?

        public init(
            licenseEndpointId: Swift.String? = nil,
            status: DeadlineClientTypes.LicenseEndpointStatus? = nil,
            statusMessage: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.licenseEndpointId = licenseEndpointId
            self.status = status
            self.statusMessage = statusMessage
            self.vpcId = vpcId
        }
    }
}

public struct ListLicenseEndpointsOutput: Swift.Sendable {
    /// The license endpoints.
    /// This member is required.
    public var licenseEndpoints: [DeadlineClientTypes.LicenseEndpointSummary]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        licenseEndpoints: [DeadlineClientTypes.LicenseEndpointSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseEndpoints = licenseEndpoints
        self.nextToken = nextToken
    }
}

public struct DeleteMeteredProductInput: Swift.Sendable {
    /// The ID of the license endpoint from which to remove the metered product.
    /// This member is required.
    public var licenseEndpointId: Swift.String?
    /// The product ID to remove from the license endpoint.
    /// This member is required.
    public var productId: Swift.String?

    public init(
        licenseEndpointId: Swift.String? = nil,
        productId: Swift.String? = nil
    )
    {
        self.licenseEndpointId = licenseEndpointId
        self.productId = productId
    }
}

public struct DeleteMeteredProductOutput: Swift.Sendable {

    public init() { }
}

public struct ListMeteredProductsInput: Swift.Sendable {
    /// The license endpoint ID to include on the list of metered products.
    /// This member is required.
    public var licenseEndpointId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?

    public init(
        licenseEndpointId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil
    )
    {
        self.licenseEndpointId = licenseEndpointId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension DeadlineClientTypes {

    /// The details of a metered product.
    public struct MeteredProductSummary: Swift.Sendable {
        /// The family to which the metered product belongs.
        /// This member is required.
        public var family: Swift.String?
        /// The port on which the metered product should run.
        /// This member is required.
        public var port: Swift.Int?
        /// The product ID.
        /// This member is required.
        public var productId: Swift.String?
        /// The vendor.
        /// This member is required.
        public var vendor: Swift.String?

        public init(
            family: Swift.String? = nil,
            port: Swift.Int? = nil,
            productId: Swift.String? = nil,
            vendor: Swift.String? = nil
        )
        {
            self.family = family
            self.port = port
            self.productId = productId
            self.vendor = vendor
        }
    }
}

public struct ListMeteredProductsOutput: Swift.Sendable {
    /// The metered products to list.
    /// This member is required.
    public var meteredProducts: [DeadlineClientTypes.MeteredProductSummary]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        meteredProducts: [DeadlineClientTypes.MeteredProductSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.meteredProducts = meteredProducts
        self.nextToken = nextToken
    }
}

public struct PutMeteredProductInput: Swift.Sendable {
    /// The license endpoint ID to add to the metered product.
    /// This member is required.
    public var licenseEndpointId: Swift.String?
    /// The product ID to add to the metered product.
    /// This member is required.
    public var productId: Swift.String?

    public init(
        licenseEndpointId: Swift.String? = nil,
        productId: Swift.String? = nil
    )
    {
        self.licenseEndpointId = licenseEndpointId
        self.productId = productId
    }
}

public struct PutMeteredProductOutput: Swift.Sendable {

    public init() { }
}

public struct ListAvailableMeteredProductsInput: Swift.Sendable {
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAvailableMeteredProductsOutput: Swift.Sendable {
    /// The metered products.
    /// This member is required.
    public var meteredProducts: [DeadlineClientTypes.MeteredProductSummary]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        meteredProducts: [DeadlineClientTypes.MeteredProductSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.meteredProducts = meteredProducts
        self.nextToken = nextToken
    }
}

public struct ListQueueFleetAssociationsInput: Swift.Sendable {
    /// The farm ID for the queue-fleet association list.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID for the queue-fleet association list.
    public var fleetId: Swift.String?
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?
    /// The queue ID for the queue-fleet association list.
    public var queueId: Swift.String?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        queueId: Swift.String? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queueId = queueId
    }
}

extension DeadlineClientTypes {

    /// The details of a queue-fleet association.
    public struct QueueFleetAssociationSummary: Swift.Sendable {
        /// The date and time the resource was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The user or system that created this resource.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The fleet ID.
        /// This member is required.
        public var fleetId: Swift.String?
        /// The queue ID.
        /// This member is required.
        public var queueId: Swift.String?
        /// The status of task scheduling in the queue-fleet association.
        ///
        /// * ACTIVEAssociation is active.
        ///
        /// * STOP_SCHEDULING_AND_COMPLETE_TASKSAssociation has stopped scheduling new tasks and is completing current tasks.
        ///
        /// * STOP_SCHEDULING_AND_CANCEL_TASKSAssociation has stopped scheduling new tasks and is canceling current tasks.
        ///
        /// * STOPPEDAssociation has been stopped.
        /// This member is required.
        public var status: DeadlineClientTypes.QueueFleetAssociationStatus?
        /// The date and time the resource was updated.
        public var updatedAt: Foundation.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            fleetId: Swift.String? = nil,
            queueId: Swift.String? = nil,
            status: DeadlineClientTypes.QueueFleetAssociationStatus? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.fleetId = fleetId
            self.queueId = queueId
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }
}

public struct ListQueueFleetAssociationsOutput: Swift.Sendable {
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?
    /// The queue-fleet associations on the list.
    /// This member is required.
    public var queueFleetAssociations: [DeadlineClientTypes.QueueFleetAssociationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        queueFleetAssociations: [DeadlineClientTypes.QueueFleetAssociationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.queueFleetAssociations = queueFleetAssociations
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The resource ARN to list tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct DeleteMonitorInput: Swift.Sendable {
    /// The unique identifier of the monitor to delete. This ID is returned by the CreateMonitor operation, and is included in the response to the GetMonitor operation.
    /// This member is required.
    public var monitorId: Swift.String?

    public init(
        monitorId: Swift.String? = nil
    )
    {
        self.monitorId = monitorId
    }
}

public struct DeleteMonitorOutput: Swift.Sendable {

    public init() { }
}

public struct GetMonitorInput: Swift.Sendable {
    /// The unique identifier for the monitor. This ID is returned by the CreateMonitor operation.
    /// This member is required.
    public var monitorId: Swift.String?

    public init(
        monitorId: Swift.String? = nil
    )
    {
        self.monitorId = monitorId
    }
}

public struct GetMonitorOutput: Swift.Sendable {
    /// The UNIX timestamp of the date and time that the monitor was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The user name of the person that created the monitor.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The name used to identify the monitor on the Deadline Cloud console. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    /// This member is required.
    public var displayName: Swift.String?
    /// The Amazon Resource Name (ARN) that the IAM Identity Center assigned to the monitor when it was created.
    /// This member is required.
    public var identityCenterApplicationArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM Identity Center instance responsible for authenticating monitor users.
    /// This member is required.
    public var identityCenterInstanceArn: Swift.String?
    /// The unique identifier for the monitor.
    /// This member is required.
    public var monitorId: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role for the monitor. Users of the monitor use this role to access Deadline Cloud resources.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The subdomain used for the monitor URL. The full URL of the monitor is subdomain.Region.deadlinecloud.amazonaws.com.
    /// This member is required.
    public var subdomain: Swift.String?
    /// The UNIX timestamp of the last date and time that the monitor was updated.
    public var updatedAt: Foundation.Date?
    /// The user name of the person that last updated the monitor.
    public var updatedBy: Swift.String?
    /// The complete URL of the monitor. The full URL of the monitor is subdomain.Region.deadlinecloud.amazonaws.com.
    /// This member is required.
    public var url: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        displayName: Swift.String? = nil,
        identityCenterApplicationArn: Swift.String? = nil,
        identityCenterInstanceArn: Swift.String? = nil,
        monitorId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        subdomain: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        updatedBy: Swift.String? = nil,
        url: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.displayName = displayName
        self.identityCenterApplicationArn = identityCenterApplicationArn
        self.identityCenterInstanceArn = identityCenterInstanceArn
        self.monitorId = monitorId
        self.roleArn = roleArn
        self.subdomain = subdomain
        self.updatedAt = updatedAt
        self.updatedBy = updatedBy
        self.url = url
    }
}

public struct ListMonitorsInput: Swift.Sendable {
    /// The maximum number of results to return. Use this parameter with NextToken to get results as a set of sequential pages.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null to start from the beginning.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension DeadlineClientTypes {

    /// Provides information about a monitor in Deadline Cloud.
    public struct MonitorSummary: Swift.Sendable {
        /// The UNIX timestamp of the date and time that the monitor was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The user name of the person that created the monitor.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The name of the monitor that displays on the Deadline Cloud console. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
        /// This member is required.
        public var displayName: Swift.String?
        /// The Amazon Resource Name (ARN) that the IAM Identity Center assigned to the monitor when it was created.
        /// This member is required.
        public var identityCenterApplicationArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM Identity Center instance responsible for authenticating monitor users.
        /// This member is required.
        public var identityCenterInstanceArn: Swift.String?
        /// The unique identifier for the monitor.
        /// This member is required.
        public var monitorId: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role for the monitor. Users of the monitor use this role to access Deadline Cloud resources.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The subdomain used for the monitor URL. The full URL of the monitor is subdomain.Region.deadlinecloud.amazonaws.com.
        /// This member is required.
        public var subdomain: Swift.String?
        /// The UNIX timestamp of the date and time that the monitor was last updated.
        public var updatedAt: Foundation.Date?
        /// The user name of the person that last updated the monitor.
        public var updatedBy: Swift.String?
        /// The complete URL of the monitor. The full URL of the monitor is subdomain.Region.deadlinecloud.amazonaws.com.
        /// This member is required.
        public var url: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            displayName: Swift.String? = nil,
            identityCenterApplicationArn: Swift.String? = nil,
            identityCenterInstanceArn: Swift.String? = nil,
            monitorId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            subdomain: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.displayName = displayName
            self.identityCenterApplicationArn = identityCenterApplicationArn
            self.identityCenterInstanceArn = identityCenterInstanceArn
            self.monitorId = monitorId
            self.roleArn = roleArn
            self.subdomain = subdomain
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.url = url
        }
    }
}

public struct ListMonitorsOutput: Swift.Sendable {
    /// A list of MonitorSummary objects that describe your monitors in the Deadline Cloud.
    /// This member is required.
    public var monitors: [DeadlineClientTypes.MonitorSummary]?
    /// If Deadline Cloud returns nextToken, then there are more results available. The value of nextToken is a unique pagination token for each page. To retrieve the next page, call the operation again using the returned token. Keep all other arguments unchanged. If no results remain, then nextToken is set to null. Each pagination token expires after 24 hours. If you provide a token that isn't valid, then you receive an HTTP 400 ValidationException error.
    public var nextToken: Swift.String?

    public init(
        monitors: [DeadlineClientTypes.MonitorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.monitors = monitors
        self.nextToken = nextToken
    }
}

public struct UpdateMonitorInput: Swift.Sendable {
    /// The new value to use for the monitor's display name. This field can store any content. Escape or encode this content before displaying it on a webpage or any other system that might interpret the content of this field.
    public var displayName: Swift.String?
    /// The unique identifier of the monitor to update.
    /// This member is required.
    public var monitorId: Swift.String?
    /// The Amazon Resource Name (ARN) of the new IAM role to use with the monitor.
    public var roleArn: Swift.String?
    /// The new value of the subdomain to use when forming the monitor URL.
    public var subdomain: Swift.String?

    public init(
        displayName: Swift.String? = nil,
        monitorId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        subdomain: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.monitorId = monitorId
        self.roleArn = roleArn
        self.subdomain = subdomain
    }
}

public struct UpdateMonitorOutput: Swift.Sendable {

    public init() { }
}

extension DeadlineClientTypes {

    /// The details of a filtered search for parameters.
    public struct ParameterFilterExpression: Swift.Sendable {
        /// The name of the parameter to filter on.
        /// This member is required.
        public var name: Swift.String?
        /// The type of comparison to use to filter results.
        /// This member is required.
        public var `operator`: DeadlineClientTypes.ComparisonOperator?
        /// The parameter's value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            `operator`: DeadlineClientTypes.ComparisonOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }
}

extension DeadlineClientTypes {

    /// Searches for a particular search term.
    public struct SearchTermFilterExpression: Swift.Sendable {
        /// The term to search for.
        /// This member is required.
        public var searchTerm: Swift.String?

        public init(
            searchTerm: Swift.String? = nil
        )
        {
            self.searchTerm = searchTerm
        }
    }
}

extension DeadlineClientTypes {

    /// Searches for a particular string.
    public struct StringFilterExpression: Swift.Sendable {
        /// The field name to search.
        /// This member is required.
        public var name: Swift.String?
        /// The type of comparison to use for this search.
        /// This member is required.
        public var `operator`: DeadlineClientTypes.ComparisonOperator?
        /// The string to search for.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            `operator`: DeadlineClientTypes.ComparisonOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.`operator` = `operator`
            self.value = value
        }
    }
}

extension DeadlineClientTypes {

    public enum LogicalOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case and
        case or
        case sdkUnknown(Swift.String)

        public static var allCases: [LogicalOperator] {
            return [
                .and,
                .or
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .and: return "AND"
            case .or: return "OR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    public enum SortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    /// The field sorting order and name of the field.
    public struct FieldSortExpression: Swift.Sendable {
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?
        /// The sort order for the field.
        /// This member is required.
        public var sortOrder: DeadlineClientTypes.SortOrder?

        public init(
            name: Swift.String? = nil,
            sortOrder: DeadlineClientTypes.SortOrder? = nil
        )
        {
            self.name = name
            self.sortOrder = sortOrder
        }
    }
}

extension DeadlineClientTypes {

    /// Organizes parameters according to your specifications.
    public struct ParameterSortExpression: Swift.Sendable {
        /// The parameter name to sort by.
        /// This member is required.
        public var name: Swift.String?
        /// The sort order for the parameter.
        /// This member is required.
        public var sortOrder: DeadlineClientTypes.SortOrder?

        public init(
            name: Swift.String? = nil,
            sortOrder: DeadlineClientTypes.SortOrder? = nil
        )
        {
            self.name = name
            self.sortOrder = sortOrder
        }
    }
}

extension DeadlineClientTypes {

    /// Allows setting a specific user's job to run first.
    public struct UserJobsFirst: Swift.Sendable {
        /// The user's ID.
        /// This member is required.
        public var userIdentityId: Swift.String?

        public init(
            userIdentityId: Swift.String? = nil
        )
        {
            self.userIdentityId = userIdentityId
        }
    }
}

extension DeadlineClientTypes {

    /// The resources to search.
    public enum SearchSortExpression: Swift.Sendable {
        /// Options for sorting a particular user's jobs first.
        case userjobsfirst(DeadlineClientTypes.UserJobsFirst)
        /// Options for sorting by a field.
        case fieldsort(DeadlineClientTypes.FieldSortExpression)
        /// Options for sorting by a parameter.
        case parametersort(DeadlineClientTypes.ParameterSortExpression)
        case sdkUnknown(Swift.String)
    }
}

extension DeadlineClientTypes {

    /// The details of a job search.
    public struct JobSearchSummary: Swift.Sendable {
        /// The date and time the resource was created.
        public var createdAt: Foundation.Date?
        /// The user or system that created this resource.
        public var createdBy: Swift.String?
        /// The date and time the resource ended running.
        public var endedAt: Foundation.Date?
        /// The job ID.
        public var jobId: Swift.String?
        /// The job parameters.
        public var jobParameters: [Swift.String: DeadlineClientTypes.JobParameter]?
        /// The life cycle status.
        public var lifecycleStatus: DeadlineClientTypes.JobLifecycleStatus?
        /// The life cycle status message.
        public var lifecycleStatusMessage: Swift.String?
        /// The number of task failures before the job stops running and is marked as FAILED.
        public var maxFailedTasksCount: Swift.Int?
        /// The maximum number of retries for a job.
        public var maxRetriesPerTask: Swift.Int?
        /// The job name.
        public var name: Swift.String?
        /// The job priority.
        public var priority: Swift.Int?
        /// The queue ID.
        public var queueId: Swift.String?
        /// The job ID for the source job.
        public var sourceJobId: Swift.String?
        /// The date and time the resource started running.
        public var startedAt: Foundation.Date?
        /// The task status to start with on the job.
        public var targetTaskRunStatus: DeadlineClientTypes.JobTargetTaskRunStatus?
        /// The task run status for the job.
        ///
        /// * PENDINGpending and waiting for resources.
        ///
        /// * READYready to be processed.
        ///
        /// * ASSIGNEDassigned and will run next on a worker.
        ///
        /// * SCHEDULEDscheduled to be run on a worker.
        ///
        /// * INTERRUPTINGbeing interrupted.
        ///
        /// * RUNNINGrunning on a worker.
        ///
        /// * SUSPENDEDthe task is suspended.
        ///
        /// * CANCELEDthe task has been canceled.
        ///
        /// * FAILEDthe task has failed.
        ///
        /// * SUCCEEDEDthe task has succeeded.
        public var taskRunStatus: DeadlineClientTypes.TaskRunStatus?
        /// The number of tasks running on the job.
        public var taskRunStatusCounts: [Swift.String: Swift.Int]?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            endedAt: Foundation.Date? = nil,
            jobId: Swift.String? = nil,
            jobParameters: [Swift.String: DeadlineClientTypes.JobParameter]? = nil,
            lifecycleStatus: DeadlineClientTypes.JobLifecycleStatus? = nil,
            lifecycleStatusMessage: Swift.String? = nil,
            maxFailedTasksCount: Swift.Int? = nil,
            maxRetriesPerTask: Swift.Int? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            queueId: Swift.String? = nil,
            sourceJobId: Swift.String? = nil,
            startedAt: Foundation.Date? = nil,
            targetTaskRunStatus: DeadlineClientTypes.JobTargetTaskRunStatus? = nil,
            taskRunStatus: DeadlineClientTypes.TaskRunStatus? = nil,
            taskRunStatusCounts: [Swift.String: Swift.Int]? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.endedAt = endedAt
            self.jobId = jobId
            self.jobParameters = jobParameters
            self.lifecycleStatus = lifecycleStatus
            self.lifecycleStatusMessage = lifecycleStatusMessage
            self.maxFailedTasksCount = maxFailedTasksCount
            self.maxRetriesPerTask = maxRetriesPerTask
            self.name = name
            self.priority = priority
            self.queueId = queueId
            self.sourceJobId = sourceJobId
            self.startedAt = startedAt
            self.targetTaskRunStatus = targetTaskRunStatus
            self.taskRunStatus = taskRunStatus
            self.taskRunStatusCounts = taskRunStatusCounts
        }
    }
}

extension DeadlineClientTypes.JobSearchSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobSearchSummary(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), endedAt: \(Swift.String(describing: endedAt)), jobId: \(Swift.String(describing: jobId)), lifecycleStatus: \(Swift.String(describing: lifecycleStatus)), lifecycleStatusMessage: \(Swift.String(describing: lifecycleStatusMessage)), maxFailedTasksCount: \(Swift.String(describing: maxFailedTasksCount)), maxRetriesPerTask: \(Swift.String(describing: maxRetriesPerTask)), name: \(Swift.String(describing: name)), priority: \(Swift.String(describing: priority)), queueId: \(Swift.String(describing: queueId)), sourceJobId: \(Swift.String(describing: sourceJobId)), startedAt: \(Swift.String(describing: startedAt)), targetTaskRunStatus: \(Swift.String(describing: targetTaskRunStatus)), taskRunStatus: \(Swift.String(describing: taskRunStatus)), taskRunStatusCounts: \(Swift.String(describing: taskRunStatusCounts)), jobParameters: \"CONTENT_REDACTED\")"}
}

public struct SearchJobsOutput: Swift.Sendable {
    /// The jobs in the search.
    /// This member is required.
    public var jobs: [DeadlineClientTypes.JobSearchSummary]?
    /// The next incremental starting point after the defined itemOffset.
    public var nextItemOffset: Swift.Int?
    /// The total number of results in the search.
    /// This member is required.
    public var totalResults: Swift.Int?

    public init(
        jobs: [DeadlineClientTypes.JobSearchSummary]? = nil,
        nextItemOffset: Swift.Int? = nil,
        totalResults: Swift.Int? = nil
    )
    {
        self.jobs = jobs
        self.nextItemOffset = nextItemOffset
        self.totalResults = totalResults
    }
}

extension DeadlineClientTypes {

    /// The details of a step search.
    public struct StepSearchSummary: Swift.Sendable {
        /// The date and time the resource was created.
        public var createdAt: Foundation.Date?
        /// The date and time the resource ended running.
        public var endedAt: Foundation.Date?
        /// The job ID.
        public var jobId: Swift.String?
        /// The life cycle status.
        public var lifecycleStatus: DeadlineClientTypes.StepLifecycleStatus?
        /// The life cycle status message.
        public var lifecycleStatusMessage: Swift.String?
        /// The step name.
        public var name: Swift.String?
        /// The parameters and combination expressions for the search.
        public var parameterSpace: DeadlineClientTypes.ParameterSpace?
        /// The queue ID.
        public var queueId: Swift.String?
        /// The date and time the resource started running.
        public var startedAt: Foundation.Date?
        /// The step ID.
        public var stepId: Swift.String?
        /// The task status to start with on the job.
        public var targetTaskRunStatus: DeadlineClientTypes.StepTargetTaskRunStatus?
        /// The task run status for the job.
        ///
        /// * PENDINGpending and waiting for resources.
        ///
        /// * READYready to be processed.
        ///
        /// * ASSIGNEDassigned and will run next on a worker.
        ///
        /// * SCHEDULEDscheduled to be run on a worker.
        ///
        /// * INTERRUPTINGbeing interrupted.
        ///
        /// * RUNNINGrunning on a worker.
        ///
        /// * SUSPENDEDthe task is suspended.
        ///
        /// * CANCELEDthe task has been canceled.
        ///
        /// * FAILEDthe task has failed.
        ///
        /// * SUCCEEDEDthe task has succeeded.
        public var taskRunStatus: DeadlineClientTypes.TaskRunStatus?
        /// The number of tasks running on the job.
        public var taskRunStatusCounts: [Swift.String: Swift.Int]?

        public init(
            createdAt: Foundation.Date? = nil,
            endedAt: Foundation.Date? = nil,
            jobId: Swift.String? = nil,
            lifecycleStatus: DeadlineClientTypes.StepLifecycleStatus? = nil,
            lifecycleStatusMessage: Swift.String? = nil,
            name: Swift.String? = nil,
            parameterSpace: DeadlineClientTypes.ParameterSpace? = nil,
            queueId: Swift.String? = nil,
            startedAt: Foundation.Date? = nil,
            stepId: Swift.String? = nil,
            targetTaskRunStatus: DeadlineClientTypes.StepTargetTaskRunStatus? = nil,
            taskRunStatus: DeadlineClientTypes.TaskRunStatus? = nil,
            taskRunStatusCounts: [Swift.String: Swift.Int]? = nil
        )
        {
            self.createdAt = createdAt
            self.endedAt = endedAt
            self.jobId = jobId
            self.lifecycleStatus = lifecycleStatus
            self.lifecycleStatusMessage = lifecycleStatusMessage
            self.name = name
            self.parameterSpace = parameterSpace
            self.queueId = queueId
            self.startedAt = startedAt
            self.stepId = stepId
            self.targetTaskRunStatus = targetTaskRunStatus
            self.taskRunStatus = taskRunStatus
            self.taskRunStatusCounts = taskRunStatusCounts
        }
    }
}

public struct SearchStepsOutput: Swift.Sendable {
    /// The next incremental starting point after the defined itemOffset.
    public var nextItemOffset: Swift.Int?
    /// The steps in the search.
    /// This member is required.
    public var steps: [DeadlineClientTypes.StepSearchSummary]?
    /// The total number of results in the search.
    /// This member is required.
    public var totalResults: Swift.Int?

    public init(
        nextItemOffset: Swift.Int? = nil,
        steps: [DeadlineClientTypes.StepSearchSummary]? = nil,
        totalResults: Swift.Int? = nil
    )
    {
        self.nextItemOffset = nextItemOffset
        self.steps = steps
        self.totalResults = totalResults
    }
}

extension DeadlineClientTypes {

    /// The details of a task search.
    public struct TaskSearchSummary: Swift.Sendable {
        /// The date and time the resource ended running.
        public var endedAt: Foundation.Date?
        /// The number of times that the task failed and was retried.
        public var failureRetryCount: Swift.Int?
        /// The job ID.
        public var jobId: Swift.String?
        /// The parameters to search for.
        public var parameters: [Swift.String: DeadlineClientTypes.TaskParameterValue]?
        /// The queue ID.
        public var queueId: Swift.String?
        /// The run status of the task.
        public var runStatus: DeadlineClientTypes.TaskRunStatus?
        /// The date and time the resource started running.
        public var startedAt: Foundation.Date?
        /// The step ID.
        public var stepId: Swift.String?
        /// The run status that the task is being updated to.
        public var targetRunStatus: DeadlineClientTypes.TaskTargetRunStatus?
        /// The task ID.
        public var taskId: Swift.String?

        public init(
            endedAt: Foundation.Date? = nil,
            failureRetryCount: Swift.Int? = nil,
            jobId: Swift.String? = nil,
            parameters: [Swift.String: DeadlineClientTypes.TaskParameterValue]? = nil,
            queueId: Swift.String? = nil,
            runStatus: DeadlineClientTypes.TaskRunStatus? = nil,
            startedAt: Foundation.Date? = nil,
            stepId: Swift.String? = nil,
            targetRunStatus: DeadlineClientTypes.TaskTargetRunStatus? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.endedAt = endedAt
            self.failureRetryCount = failureRetryCount
            self.jobId = jobId
            self.parameters = parameters
            self.queueId = queueId
            self.runStatus = runStatus
            self.startedAt = startedAt
            self.stepId = stepId
            self.targetRunStatus = targetRunStatus
            self.taskId = taskId
        }
    }
}

extension DeadlineClientTypes.TaskSearchSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TaskSearchSummary(endedAt: \(Swift.String(describing: endedAt)), failureRetryCount: \(Swift.String(describing: failureRetryCount)), jobId: \(Swift.String(describing: jobId)), queueId: \(Swift.String(describing: queueId)), runStatus: \(Swift.String(describing: runStatus)), startedAt: \(Swift.String(describing: startedAt)), stepId: \(Swift.String(describing: stepId)), targetRunStatus: \(Swift.String(describing: targetRunStatus)), taskId: \(Swift.String(describing: taskId)), parameters: \"CONTENT_REDACTED\")"}
}

public struct SearchTasksOutput: Swift.Sendable {
    /// The next incremental starting point after the defined itemOffset.
    public var nextItemOffset: Swift.Int?
    /// Tasks in the search.
    /// This member is required.
    public var tasks: [DeadlineClientTypes.TaskSearchSummary]?
    /// The total number of results in the search.
    /// This member is required.
    public var totalResults: Swift.Int?

    public init(
        nextItemOffset: Swift.Int? = nil,
        tasks: [DeadlineClientTypes.TaskSearchSummary]? = nil,
        totalResults: Swift.Int? = nil
    )
    {
        self.nextItemOffset = nextItemOffset
        self.tasks = tasks
        self.totalResults = totalResults
    }
}

extension DeadlineClientTypes {

    /// The details of a worker search.
    public struct WorkerSearchSummary: Swift.Sendable {
        /// The date and time the resource was created.
        public var createdAt: Foundation.Date?
        /// The user or system that created this resource.
        public var createdBy: Swift.String?
        /// The fleet ID.
        public var fleetId: Swift.String?
        /// Provides the Amazon EC2 instance properties of the worker host.
        public var hostProperties: DeadlineClientTypes.HostPropertiesResponse?
        /// The status of the worker search.
        public var status: DeadlineClientTypes.WorkerStatus?
        /// The date and time the resource was updated.
        public var updatedAt: Foundation.Date?
        /// The user or system that updated this resource.
        public var updatedBy: Swift.String?
        /// The worker ID.
        public var workerId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            fleetId: Swift.String? = nil,
            hostProperties: DeadlineClientTypes.HostPropertiesResponse? = nil,
            status: DeadlineClientTypes.WorkerStatus? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil,
            workerId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.fleetId = fleetId
            self.hostProperties = hostProperties
            self.status = status
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.workerId = workerId
        }
    }
}

public struct SearchWorkersOutput: Swift.Sendable {
    /// The next incremental starting point after the defined itemOffset.
    public var nextItemOffset: Swift.Int?
    /// The total number of results in the search.
    /// This member is required.
    public var totalResults: Swift.Int?
    /// The workers for the search.
    /// This member is required.
    public var workers: [DeadlineClientTypes.WorkerSearchSummary]?

    public init(
        nextItemOffset: Swift.Int? = nil,
        totalResults: Swift.Int? = nil,
        workers: [DeadlineClientTypes.WorkerSearchSummary]? = nil
    )
    {
        self.nextItemOffset = nextItemOffset
        self.totalResults = totalResults
        self.workers = workers
    }
}

extension DeadlineClientTypes {

    public enum UsageGroupByField: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fleetId
        case instanceType
        case jobId
        case licenseProduct
        case queueId
        case usageType
        case userId
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageGroupByField] {
            return [
                .fleetId,
                .instanceType,
                .jobId,
                .licenseProduct,
                .queueId,
                .usageType,
                .userId
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fleetId: return "FLEET_ID"
            case .instanceType: return "INSTANCE_TYPE"
            case .jobId: return "JOB_ID"
            case .licenseProduct: return "LICENSE_PRODUCT"
            case .queueId: return "QUEUE_ID"
            case .usageType: return "USAGE_TYPE"
            case .userId: return "USER_ID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    public enum Period: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case daily
        case hourly
        case monthly
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [Period] {
            return [
                .daily,
                .hourly,
                .monthly,
                .weekly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case .hourly: return "HOURLY"
            case .monthly: return "MONTHLY"
            case .weekly: return "WEEKLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeadlineClientTypes {

    /// Specifies the fleet IDs or queue IDs to return statistics. You can specify only fleet IDs or queue IDS, not both.
    public enum SessionsStatisticsResources: Swift.Sendable {
        /// One to 10 queue IDs that specify the queues to return statistics for. If you specify the queueIds field, you can't specify the fleetIds field.
        case queueids([Swift.String])
        /// One to 10 fleet IDs that specify the fleets to return statistics for. If you specify the fleetIds field, you can't specify the queueIds field.
        case fleetids([Swift.String])
        case sdkUnknown(Swift.String)
    }
}

extension DeadlineClientTypes {

    public enum UsageStatistic: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case avg
        case max
        case min
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageStatistic] {
            return [
                .avg,
                .max,
                .min,
                .sum
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .avg: return "AVG"
            case .max: return "MAX"
            case .min: return "MIN"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StartSessionsStatisticsAggregationInput: Swift.Sendable {
    /// The Linux timestamp of the date and time that the statistics end.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// The identifier of the farm that contains queues or fleets to return statistics for.
    /// This member is required.
    public var farmId: Swift.String?
    /// The field to use to group the statistics.
    /// This member is required.
    public var groupBy: [DeadlineClientTypes.UsageGroupByField]?
    /// The period to aggregate the statistics.
    public var period: DeadlineClientTypes.Period?
    /// A list of fleet IDs or queue IDs to gather statistics for.
    /// This member is required.
    public var resourceIds: DeadlineClientTypes.SessionsStatisticsResources?
    /// The Linux timestamp of the date and time that the statistics start.
    /// This member is required.
    public var startTime: Foundation.Date?
    /// One to four statistics to return.
    /// This member is required.
    public var statistics: [DeadlineClientTypes.UsageStatistic]?
    /// The timezone to use for the statistics. Use UTC notation such as "UTC+8."
    public var timezone: Swift.String?

    public init(
        endTime: Foundation.Date? = nil,
        farmId: Swift.String? = nil,
        groupBy: [DeadlineClientTypes.UsageGroupByField]? = nil,
        period: DeadlineClientTypes.Period? = nil,
        resourceIds: DeadlineClientTypes.SessionsStatisticsResources? = nil,
        startTime: Foundation.Date? = nil,
        statistics: [DeadlineClientTypes.UsageStatistic]? = nil,
        timezone: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.farmId = farmId
        self.groupBy = groupBy
        self.period = period
        self.resourceIds = resourceIds
        self.startTime = startTime
        self.statistics = statistics
        self.timezone = timezone
    }
}

public struct StartSessionsStatisticsAggregationOutput: Swift.Sendable {
    /// A unique identifier for the aggregated statistics. Use this identifier with the GetAggregatedStatisticsForSessions operation to return the statistics.
    /// This member is required.
    public var aggregationId: Swift.String?

    public init(
        aggregationId: Swift.String? = nil
    )
    {
        self.aggregationId = aggregationId
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the resource to apply tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Each tag consists of a tag key and a tag value. Tag keys and values are both required, but tag values can be empty strings.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the resource to remove the tag from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// They keys of the tag.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension DeadlineClientTypes {

    public enum UpdateQueueFleetAssociationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case stopSchedulingAndCancelTasks
        case stopSchedulingAndCompleteTasks
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateQueueFleetAssociationStatus] {
            return [
                .active,
                .stopSchedulingAndCancelTasks,
                .stopSchedulingAndCompleteTasks
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .stopSchedulingAndCancelTasks: return "STOP_SCHEDULING_AND_CANCEL_TASKS"
            case .stopSchedulingAndCompleteTasks: return "STOP_SCHEDULING_AND_COMPLETE_TASKS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateQueueFleetAssociationInput: Swift.Sendable {
    /// The farm ID to update.
    /// This member is required.
    public var farmId: Swift.String?
    /// The fleet ID to update.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The queue ID to update.
    /// This member is required.
    public var queueId: Swift.String?
    /// The status to update.
    /// This member is required.
    public var status: DeadlineClientTypes.UpdateQueueFleetAssociationStatus?

    public init(
        farmId: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        queueId: Swift.String? = nil,
        status: DeadlineClientTypes.UpdateQueueFleetAssociationStatus? = nil
    )
    {
        self.farmId = farmId
        self.fleetId = fleetId
        self.queueId = queueId
        self.status = status
    }
}

public struct UpdateQueueFleetAssociationOutput: Swift.Sendable {

    public init() { }
}

extension DeadlineClientTypes {

    /// The type of search filter to apply.
    public indirect enum SearchFilterExpression: Swift.Sendable {
        /// Filters based on date and time.
        case datetimefilter(DeadlineClientTypes.DateTimeFilterExpression)
        /// Filters by parameter.
        case parameterfilter(DeadlineClientTypes.ParameterFilterExpression)
        /// Filters by a specified search term.
        case searchtermfilter(DeadlineClientTypes.SearchTermFilterExpression)
        /// Filters by a string.
        case stringfilter(DeadlineClientTypes.StringFilterExpression)
        /// Filters by group.
        case groupfilter(DeadlineClientTypes.SearchGroupedFilterExpressions)
        case sdkUnknown(Swift.String)
    }
}

extension DeadlineClientTypes {

    /// The filter expression, AND or OR, to use when searching among a group of search strings in a resource. You can use two groupings per search each within parenthesis ().
    public struct SearchGroupedFilterExpressions: Swift.Sendable {
        /// The filters to use for the search.
        /// This member is required.
        public var filters: [DeadlineClientTypes.SearchFilterExpression]?
        /// The operators to include in the search.
        /// This member is required.
        public var `operator`: DeadlineClientTypes.LogicalOperator?

        public init(
            filters: [DeadlineClientTypes.SearchFilterExpression]? = nil,
            `operator`: DeadlineClientTypes.LogicalOperator? = nil
        )
        {
            self.filters = filters
            self.`operator` = `operator`
        }
    }
}

public struct SearchJobsInput: Swift.Sendable {
    /// The farm ID of the job.
    /// This member is required.
    public var farmId: Swift.String?
    /// The filter expression, AND or OR, to use when searching among a group of search strings in a resource. You can use two groupings per search each within parenthesis ().
    public var filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions?
    /// Defines how far into the scrollable list to start the return of results.
    /// This member is required.
    public var itemOffset: Swift.Int?
    /// Specifies the number of items per page for the resource.
    public var pageSize: Swift.Int?
    /// The queue ID to use in the job search.
    /// This member is required.
    public var queueIds: [Swift.String]?
    /// The search terms for a resource.
    public var sortExpressions: [DeadlineClientTypes.SearchSortExpression]?

    public init(
        farmId: Swift.String? = nil,
        filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions? = nil,
        itemOffset: Swift.Int? = nil,
        pageSize: Swift.Int? = nil,
        queueIds: [Swift.String]? = nil,
        sortExpressions: [DeadlineClientTypes.SearchSortExpression]? = nil
    )
    {
        self.farmId = farmId
        self.filterExpressions = filterExpressions
        self.itemOffset = itemOffset
        self.pageSize = pageSize
        self.queueIds = queueIds
        self.sortExpressions = sortExpressions
    }
}

public struct SearchStepsInput: Swift.Sendable {
    /// The farm ID to use for the step search.
    /// This member is required.
    public var farmId: Swift.String?
    /// The filter expression, AND or OR, to use when searching among a group of search strings in a resource. You can use two groupings per search each within parenthesis ().
    public var filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions?
    /// Defines how far into the scrollable list to start the return of results.
    /// This member is required.
    public var itemOffset: Swift.Int?
    /// The job ID to use in the step search.
    public var jobId: Swift.String?
    /// Specifies the number of items per page for the resource.
    public var pageSize: Swift.Int?
    /// The queue IDs in the step search.
    /// This member is required.
    public var queueIds: [Swift.String]?
    /// The search terms for a resource.
    public var sortExpressions: [DeadlineClientTypes.SearchSortExpression]?

    public init(
        farmId: Swift.String? = nil,
        filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions? = nil,
        itemOffset: Swift.Int? = nil,
        jobId: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        queueIds: [Swift.String]? = nil,
        sortExpressions: [DeadlineClientTypes.SearchSortExpression]? = nil
    )
    {
        self.farmId = farmId
        self.filterExpressions = filterExpressions
        self.itemOffset = itemOffset
        self.jobId = jobId
        self.pageSize = pageSize
        self.queueIds = queueIds
        self.sortExpressions = sortExpressions
    }
}

public struct SearchTasksInput: Swift.Sendable {
    /// The farm ID of the task.
    /// This member is required.
    public var farmId: Swift.String?
    /// The filter expression, AND or OR, to use when searching among a group of search strings in a resource. You can use two groupings per search each within parenthesis ().
    public var filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions?
    /// Defines how far into the scrollable list to start the return of results.
    /// This member is required.
    public var itemOffset: Swift.Int?
    /// The job ID for the task search.
    public var jobId: Swift.String?
    /// Specifies the number of items per page for the resource.
    public var pageSize: Swift.Int?
    /// The queue IDs to include in the search.
    /// This member is required.
    public var queueIds: [Swift.String]?
    /// The search terms for a resource.
    public var sortExpressions: [DeadlineClientTypes.SearchSortExpression]?

    public init(
        farmId: Swift.String? = nil,
        filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions? = nil,
        itemOffset: Swift.Int? = nil,
        jobId: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        queueIds: [Swift.String]? = nil,
        sortExpressions: [DeadlineClientTypes.SearchSortExpression]? = nil
    )
    {
        self.farmId = farmId
        self.filterExpressions = filterExpressions
        self.itemOffset = itemOffset
        self.jobId = jobId
        self.pageSize = pageSize
        self.queueIds = queueIds
        self.sortExpressions = sortExpressions
    }
}

public struct SearchWorkersInput: Swift.Sendable {
    /// The farm ID in the workers search.
    /// This member is required.
    public var farmId: Swift.String?
    /// The filter expression, AND or OR, to use when searching among a group of search strings in a resource. You can use two groupings per search each within parenthesis ().
    public var filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions?
    /// The fleet ID of the workers to search for.
    /// This member is required.
    public var fleetIds: [Swift.String]?
    /// Defines how far into the scrollable list to start the return of results.
    /// This member is required.
    public var itemOffset: Swift.Int?
    /// Specifies the number of items per page for the resource.
    public var pageSize: Swift.Int?
    /// The search terms for a resource.
    public var sortExpressions: [DeadlineClientTypes.SearchSortExpression]?

    public init(
        farmId: Swift.String? = nil,
        filterExpressions: DeadlineClientTypes.SearchGroupedFilterExpressions? = nil,
        fleetIds: [Swift.String]? = nil,
        itemOffset: Swift.Int? = nil,
        pageSize: Swift.Int? = nil,
        sortExpressions: [DeadlineClientTypes.SearchSortExpression]? = nil
    )
    {
        self.farmId = farmId
        self.filterExpressions = filterExpressions
        self.fleetIds = fleetIds
        self.itemOffset = itemOffset
        self.pageSize = pageSize
        self.sortExpressions = sortExpressions
    }
}

extension AssociateMemberToFarmInput {

    static func urlPathProvider(_ value: AssociateMemberToFarmInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/members/\(principalId.urlPercentEncoding())"
    }
}

extension AssociateMemberToFleetInput {

    static func urlPathProvider(_ value: AssociateMemberToFleetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/members/\(principalId.urlPercentEncoding())"
    }
}

extension AssociateMemberToJobInput {

    static func urlPathProvider(_ value: AssociateMemberToJobInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/members/\(principalId.urlPercentEncoding())"
    }
}

extension AssociateMemberToQueueInput {

    static func urlPathProvider(_ value: AssociateMemberToQueueInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/members/\(principalId.urlPercentEncoding())"
    }
}

extension AssumeFleetRoleForReadInput {

    static func urlPathProvider(_ value: AssumeFleetRoleForReadInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/read-roles"
    }
}

extension AssumeFleetRoleForWorkerInput {

    static func urlPathProvider(_ value: AssumeFleetRoleForWorkerInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let workerId = value.workerId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers/\(workerId.urlPercentEncoding())/fleet-roles"
    }
}

extension AssumeQueueRoleForReadInput {

    static func urlPathProvider(_ value: AssumeQueueRoleForReadInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/read-roles"
    }
}

extension AssumeQueueRoleForUserInput {

    static func urlPathProvider(_ value: AssumeQueueRoleForUserInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/user-roles"
    }
}

extension AssumeQueueRoleForWorkerInput {

    static func urlPathProvider(_ value: AssumeQueueRoleForWorkerInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let workerId = value.workerId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers/\(workerId.urlPercentEncoding())/queue-roles"
    }
}

extension AssumeQueueRoleForWorkerInput {

    static func queryItemProvider(_ value: AssumeQueueRoleForWorkerInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let queueId = value.queueId else {
            let message = "Creating a URL Query Item failed. queueId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let queueIdQueryItem = Smithy.URIQueryItem(name: "queueId".urlPercentEncoding(), value: Swift.String(queueId).urlPercentEncoding())
        items.append(queueIdQueryItem)
        return items
    }
}

extension BatchGetJobEntityInput {

    static func urlPathProvider(_ value: BatchGetJobEntityInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let workerId = value.workerId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers/\(workerId.urlPercentEncoding())/batchGetJobEntity"
    }
}

extension CopyJobTemplateInput {

    static func urlPathProvider(_ value: CopyJobTemplateInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/template"
    }
}

extension CreateBudgetInput {

    static func urlPathProvider(_ value: CreateBudgetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/budgets"
    }
}

extension CreateBudgetInput {

    static func headerProvider(_ value: CreateBudgetInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateFarmInput {

    static func urlPathProvider(_ value: CreateFarmInput) -> Swift.String? {
        return "/2023-10-12/farms"
    }
}

extension CreateFarmInput {

    static func headerProvider(_ value: CreateFarmInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateFleetInput {

    static func urlPathProvider(_ value: CreateFleetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets"
    }
}

extension CreateFleetInput {

    static func headerProvider(_ value: CreateFleetInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateJobInput {

    static func urlPathProvider(_ value: CreateJobInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs"
    }
}

extension CreateJobInput {

    static func headerProvider(_ value: CreateJobInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateLicenseEndpointInput {

    static func urlPathProvider(_ value: CreateLicenseEndpointInput) -> Swift.String? {
        return "/2023-10-12/license-endpoints"
    }
}

extension CreateLicenseEndpointInput {

    static func headerProvider(_ value: CreateLicenseEndpointInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateMonitorInput {

    static func urlPathProvider(_ value: CreateMonitorInput) -> Swift.String? {
        return "/2023-10-12/monitors"
    }
}

extension CreateMonitorInput {

    static func headerProvider(_ value: CreateMonitorInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateQueueInput {

    static func urlPathProvider(_ value: CreateQueueInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues"
    }
}

extension CreateQueueInput {

    static func headerProvider(_ value: CreateQueueInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateQueueEnvironmentInput {

    static func urlPathProvider(_ value: CreateQueueEnvironmentInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/environments"
    }
}

extension CreateQueueEnvironmentInput {

    static func headerProvider(_ value: CreateQueueEnvironmentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateQueueFleetAssociationInput {

    static func urlPathProvider(_ value: CreateQueueFleetAssociationInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queue-fleet-associations"
    }
}

extension CreateStorageProfileInput {

    static func urlPathProvider(_ value: CreateStorageProfileInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/storage-profiles"
    }
}

extension CreateStorageProfileInput {

    static func headerProvider(_ value: CreateStorageProfileInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateWorkerInput {

    static func urlPathProvider(_ value: CreateWorkerInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers"
    }
}

extension CreateWorkerInput {

    static func headerProvider(_ value: CreateWorkerInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteBudgetInput {

    static func urlPathProvider(_ value: DeleteBudgetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let budgetId = value.budgetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/budgets/\(budgetId.urlPercentEncoding())"
    }
}

extension DeleteFarmInput {

    static func urlPathProvider(_ value: DeleteFarmInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())"
    }
}

extension DeleteFleetInput {

    static func urlPathProvider(_ value: DeleteFleetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())"
    }
}

extension DeleteFleetInput {

    static func headerProvider(_ value: DeleteFleetInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteLicenseEndpointInput {

    static func urlPathProvider(_ value: DeleteLicenseEndpointInput) -> Swift.String? {
        guard let licenseEndpointId = value.licenseEndpointId else {
            return nil
        }
        return "/2023-10-12/license-endpoints/\(licenseEndpointId.urlPercentEncoding())"
    }
}

extension DeleteMeteredProductInput {

    static func urlPathProvider(_ value: DeleteMeteredProductInput) -> Swift.String? {
        guard let licenseEndpointId = value.licenseEndpointId else {
            return nil
        }
        guard let productId = value.productId else {
            return nil
        }
        return "/2023-10-12/license-endpoints/\(licenseEndpointId.urlPercentEncoding())/metered-products/\(productId.urlPercentEncoding())"
    }
}

extension DeleteMonitorInput {

    static func urlPathProvider(_ value: DeleteMonitorInput) -> Swift.String? {
        guard let monitorId = value.monitorId else {
            return nil
        }
        return "/2023-10-12/monitors/\(monitorId.urlPercentEncoding())"
    }
}

extension DeleteQueueInput {

    static func urlPathProvider(_ value: DeleteQueueInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())"
    }
}

extension DeleteQueueEnvironmentInput {

    static func urlPathProvider(_ value: DeleteQueueEnvironmentInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let queueEnvironmentId = value.queueEnvironmentId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/environments/\(queueEnvironmentId.urlPercentEncoding())"
    }
}

extension DeleteQueueFleetAssociationInput {

    static func urlPathProvider(_ value: DeleteQueueFleetAssociationInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queue-fleet-associations/\(queueId.urlPercentEncoding())/\(fleetId.urlPercentEncoding())"
    }
}

extension DeleteStorageProfileInput {

    static func urlPathProvider(_ value: DeleteStorageProfileInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let storageProfileId = value.storageProfileId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/storage-profiles/\(storageProfileId.urlPercentEncoding())"
    }
}

extension DeleteWorkerInput {

    static func urlPathProvider(_ value: DeleteWorkerInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let workerId = value.workerId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers/\(workerId.urlPercentEncoding())"
    }
}

extension DisassociateMemberFromFarmInput {

    static func urlPathProvider(_ value: DisassociateMemberFromFarmInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/members/\(principalId.urlPercentEncoding())"
    }
}

extension DisassociateMemberFromFleetInput {

    static func urlPathProvider(_ value: DisassociateMemberFromFleetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/members/\(principalId.urlPercentEncoding())"
    }
}

extension DisassociateMemberFromJobInput {

    static func urlPathProvider(_ value: DisassociateMemberFromJobInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/members/\(principalId.urlPercentEncoding())"
    }
}

extension DisassociateMemberFromQueueInput {

    static func urlPathProvider(_ value: DisassociateMemberFromQueueInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/members/\(principalId.urlPercentEncoding())"
    }
}

extension GetBudgetInput {

    static func urlPathProvider(_ value: GetBudgetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let budgetId = value.budgetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/budgets/\(budgetId.urlPercentEncoding())"
    }
}

extension GetFarmInput {

    static func urlPathProvider(_ value: GetFarmInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())"
    }
}

extension GetFleetInput {

    static func urlPathProvider(_ value: GetFleetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())"
    }
}

extension GetJobInput {

    static func urlPathProvider(_ value: GetJobInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())"
    }
}

extension GetLicenseEndpointInput {

    static func urlPathProvider(_ value: GetLicenseEndpointInput) -> Swift.String? {
        guard let licenseEndpointId = value.licenseEndpointId else {
            return nil
        }
        return "/2023-10-12/license-endpoints/\(licenseEndpointId.urlPercentEncoding())"
    }
}

extension GetMonitorInput {

    static func urlPathProvider(_ value: GetMonitorInput) -> Swift.String? {
        guard let monitorId = value.monitorId else {
            return nil
        }
        return "/2023-10-12/monitors/\(monitorId.urlPercentEncoding())"
    }
}

extension GetQueueInput {

    static func urlPathProvider(_ value: GetQueueInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())"
    }
}

extension GetQueueEnvironmentInput {

    static func urlPathProvider(_ value: GetQueueEnvironmentInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let queueEnvironmentId = value.queueEnvironmentId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/environments/\(queueEnvironmentId.urlPercentEncoding())"
    }
}

extension GetQueueFleetAssociationInput {

    static func urlPathProvider(_ value: GetQueueFleetAssociationInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queue-fleet-associations/\(queueId.urlPercentEncoding())/\(fleetId.urlPercentEncoding())"
    }
}

extension GetSessionInput {

    static func urlPathProvider(_ value: GetSessionInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())"
    }
}

extension GetSessionActionInput {

    static func urlPathProvider(_ value: GetSessionActionInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let sessionActionId = value.sessionActionId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/session-actions/\(sessionActionId.urlPercentEncoding())"
    }
}

extension GetSessionsStatisticsAggregationInput {

    static func urlPathProvider(_ value: GetSessionsStatisticsAggregationInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/sessions-statistics-aggregation"
    }
}

extension GetSessionsStatisticsAggregationInput {

    static func queryItemProvider(_ value: GetSessionsStatisticsAggregationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        guard let aggregationId = value.aggregationId else {
            let message = "Creating a URL Query Item failed. aggregationId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let aggregationIdQueryItem = Smithy.URIQueryItem(name: "aggregationId".urlPercentEncoding(), value: Swift.String(aggregationId).urlPercentEncoding())
        items.append(aggregationIdQueryItem)
        return items
    }
}

extension GetStepInput {

    static func urlPathProvider(_ value: GetStepInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let stepId = value.stepId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/steps/\(stepId.urlPercentEncoding())"
    }
}

extension GetStorageProfileInput {

    static func urlPathProvider(_ value: GetStorageProfileInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let storageProfileId = value.storageProfileId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/storage-profiles/\(storageProfileId.urlPercentEncoding())"
    }
}

extension GetStorageProfileForQueueInput {

    static func urlPathProvider(_ value: GetStorageProfileForQueueInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let storageProfileId = value.storageProfileId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/storage-profiles/\(storageProfileId.urlPercentEncoding())"
    }
}

extension GetTaskInput {

    static func urlPathProvider(_ value: GetTaskInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let stepId = value.stepId else {
            return nil
        }
        guard let taskId = value.taskId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/steps/\(stepId.urlPercentEncoding())/tasks/\(taskId.urlPercentEncoding())"
    }
}

extension GetWorkerInput {

    static func urlPathProvider(_ value: GetWorkerInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let workerId = value.workerId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers/\(workerId.urlPercentEncoding())"
    }
}

extension ListAvailableMeteredProductsInput {

    static func urlPathProvider(_ value: ListAvailableMeteredProductsInput) -> Swift.String? {
        return "/2023-10-12/metered-products"
    }
}

extension ListAvailableMeteredProductsInput {

    static func queryItemProvider(_ value: ListAvailableMeteredProductsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListBudgetsInput {

    static func urlPathProvider(_ value: ListBudgetsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/budgets"
    }
}

extension ListBudgetsInput {

    static func queryItemProvider(_ value: ListBudgetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListFarmMembersInput {

    static func urlPathProvider(_ value: ListFarmMembersInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/members"
    }
}

extension ListFarmMembersInput {

    static func queryItemProvider(_ value: ListFarmMembersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFarmsInput {

    static func urlPathProvider(_ value: ListFarmsInput) -> Swift.String? {
        return "/2023-10-12/farms"
    }
}

extension ListFarmsInput {

    static func queryItemProvider(_ value: ListFarmsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let principalId = value.principalId {
            let principalIdQueryItem = Smithy.URIQueryItem(name: "principalId".urlPercentEncoding(), value: Swift.String(principalId).urlPercentEncoding())
            items.append(principalIdQueryItem)
        }
        return items
    }
}

extension ListFleetMembersInput {

    static func urlPathProvider(_ value: ListFleetMembersInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/members"
    }
}

extension ListFleetMembersInput {

    static func queryItemProvider(_ value: ListFleetMembersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFleetsInput {

    static func urlPathProvider(_ value: ListFleetsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets"
    }
}

extension ListFleetsInput {

    static func queryItemProvider(_ value: ListFleetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let displayName = value.displayName {
            let displayNameQueryItem = Smithy.URIQueryItem(name: "displayName".urlPercentEncoding(), value: Swift.String(displayName).urlPercentEncoding())
            items.append(displayNameQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let principalId = value.principalId {
            let principalIdQueryItem = Smithy.URIQueryItem(name: "principalId".urlPercentEncoding(), value: Swift.String(principalId).urlPercentEncoding())
            items.append(principalIdQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListJobMembersInput {

    static func urlPathProvider(_ value: ListJobMembersInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/members"
    }
}

extension ListJobMembersInput {

    static func queryItemProvider(_ value: ListJobMembersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListJobParameterDefinitionsInput {

    static func urlPathProvider(_ value: ListJobParameterDefinitionsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/parameter-definitions"
    }
}

extension ListJobParameterDefinitionsInput {

    static func queryItemProvider(_ value: ListJobParameterDefinitionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListJobsInput {

    static func urlPathProvider(_ value: ListJobsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs"
    }
}

extension ListJobsInput {

    static func queryItemProvider(_ value: ListJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let principalId = value.principalId {
            let principalIdQueryItem = Smithy.URIQueryItem(name: "principalId".urlPercentEncoding(), value: Swift.String(principalId).urlPercentEncoding())
            items.append(principalIdQueryItem)
        }
        return items
    }
}

extension ListLicenseEndpointsInput {

    static func urlPathProvider(_ value: ListLicenseEndpointsInput) -> Swift.String? {
        return "/2023-10-12/license-endpoints"
    }
}

extension ListLicenseEndpointsInput {

    static func queryItemProvider(_ value: ListLicenseEndpointsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMeteredProductsInput {

    static func urlPathProvider(_ value: ListMeteredProductsInput) -> Swift.String? {
        guard let licenseEndpointId = value.licenseEndpointId else {
            return nil
        }
        return "/2023-10-12/license-endpoints/\(licenseEndpointId.urlPercentEncoding())/metered-products"
    }
}

extension ListMeteredProductsInput {

    static func queryItemProvider(_ value: ListMeteredProductsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMonitorsInput {

    static func urlPathProvider(_ value: ListMonitorsInput) -> Swift.String? {
        return "/2023-10-12/monitors"
    }
}

extension ListMonitorsInput {

    static func queryItemProvider(_ value: ListMonitorsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListQueueEnvironmentsInput {

    static func urlPathProvider(_ value: ListQueueEnvironmentsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/environments"
    }
}

extension ListQueueEnvironmentsInput {

    static func queryItemProvider(_ value: ListQueueEnvironmentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListQueueFleetAssociationsInput {

    static func urlPathProvider(_ value: ListQueueFleetAssociationsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queue-fleet-associations"
    }
}

extension ListQueueFleetAssociationsInput {

    static func queryItemProvider(_ value: ListQueueFleetAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let queueId = value.queueId {
            let queueIdQueryItem = Smithy.URIQueryItem(name: "queueId".urlPercentEncoding(), value: Swift.String(queueId).urlPercentEncoding())
            items.append(queueIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let fleetId = value.fleetId {
            let fleetIdQueryItem = Smithy.URIQueryItem(name: "fleetId".urlPercentEncoding(), value: Swift.String(fleetId).urlPercentEncoding())
            items.append(fleetIdQueryItem)
        }
        return items
    }
}

extension ListQueueMembersInput {

    static func urlPathProvider(_ value: ListQueueMembersInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/members"
    }
}

extension ListQueueMembersInput {

    static func queryItemProvider(_ value: ListQueueMembersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListQueuesInput {

    static func urlPathProvider(_ value: ListQueuesInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues"
    }
}

extension ListQueuesInput {

    static func queryItemProvider(_ value: ListQueuesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let principalId = value.principalId {
            let principalIdQueryItem = Smithy.URIQueryItem(name: "principalId".urlPercentEncoding(), value: Swift.String(principalId).urlPercentEncoding())
            items.append(principalIdQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListSessionActionsInput {

    static func urlPathProvider(_ value: ListSessionActionsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/session-actions"
    }
}

extension ListSessionActionsInput {

    static func queryItemProvider(_ value: ListSessionActionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let sessionId = value.sessionId {
            let sessionIdQueryItem = Smithy.URIQueryItem(name: "sessionId".urlPercentEncoding(), value: Swift.String(sessionId).urlPercentEncoding())
            items.append(sessionIdQueryItem)
        }
        if let taskId = value.taskId {
            let taskIdQueryItem = Smithy.URIQueryItem(name: "taskId".urlPercentEncoding(), value: Swift.String(taskId).urlPercentEncoding())
            items.append(taskIdQueryItem)
        }
        return items
    }
}

extension ListSessionsInput {

    static func urlPathProvider(_ value: ListSessionsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/sessions"
    }
}

extension ListSessionsInput {

    static func queryItemProvider(_ value: ListSessionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSessionsForWorkerInput {

    static func urlPathProvider(_ value: ListSessionsForWorkerInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let workerId = value.workerId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers/\(workerId.urlPercentEncoding())/sessions"
    }
}

extension ListSessionsForWorkerInput {

    static func queryItemProvider(_ value: ListSessionsForWorkerInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListStepConsumersInput {

    static func urlPathProvider(_ value: ListStepConsumersInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let stepId = value.stepId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/steps/\(stepId.urlPercentEncoding())/consumers"
    }
}

extension ListStepConsumersInput {

    static func queryItemProvider(_ value: ListStepConsumersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListStepDependenciesInput {

    static func urlPathProvider(_ value: ListStepDependenciesInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let stepId = value.stepId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/steps/\(stepId.urlPercentEncoding())/dependencies"
    }
}

extension ListStepDependenciesInput {

    static func queryItemProvider(_ value: ListStepDependenciesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListStepsInput {

    static func urlPathProvider(_ value: ListStepsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/steps"
    }
}

extension ListStepsInput {

    static func queryItemProvider(_ value: ListStepsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListStorageProfilesInput {

    static func urlPathProvider(_ value: ListStorageProfilesInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/storage-profiles"
    }
}

extension ListStorageProfilesInput {

    static func queryItemProvider(_ value: ListStorageProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListStorageProfilesForQueueInput {

    static func urlPathProvider(_ value: ListStorageProfilesForQueueInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/storage-profiles"
    }
}

extension ListStorageProfilesForQueueInput {

    static func queryItemProvider(_ value: ListStorageProfilesForQueueInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/2023-10-12/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListTasksInput {

    static func urlPathProvider(_ value: ListTasksInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let stepId = value.stepId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/steps/\(stepId.urlPercentEncoding())/tasks"
    }
}

extension ListTasksInput {

    static func queryItemProvider(_ value: ListTasksInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListWorkersInput {

    static func urlPathProvider(_ value: ListWorkersInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers"
    }
}

extension ListWorkersInput {

    static func queryItemProvider(_ value: ListWorkersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension PutMeteredProductInput {

    static func urlPathProvider(_ value: PutMeteredProductInput) -> Swift.String? {
        guard let licenseEndpointId = value.licenseEndpointId else {
            return nil
        }
        guard let productId = value.productId else {
            return nil
        }
        return "/2023-10-12/license-endpoints/\(licenseEndpointId.urlPercentEncoding())/metered-products/\(productId.urlPercentEncoding())"
    }
}

extension SearchJobsInput {

    static func urlPathProvider(_ value: SearchJobsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/search/jobs"
    }
}

extension SearchStepsInput {

    static func urlPathProvider(_ value: SearchStepsInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/search/steps"
    }
}

extension SearchTasksInput {

    static func urlPathProvider(_ value: SearchTasksInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/search/tasks"
    }
}

extension SearchWorkersInput {

    static func urlPathProvider(_ value: SearchWorkersInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/search/workers"
    }
}

extension StartSessionsStatisticsAggregationInput {

    static func urlPathProvider(_ value: StartSessionsStatisticsAggregationInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/sessions-statistics-aggregation"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/2023-10-12/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/2023-10-12/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateBudgetInput {

    static func urlPathProvider(_ value: UpdateBudgetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let budgetId = value.budgetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/budgets/\(budgetId.urlPercentEncoding())"
    }
}

extension UpdateBudgetInput {

    static func headerProvider(_ value: UpdateBudgetInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateFarmInput {

    static func urlPathProvider(_ value: UpdateFarmInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())"
    }
}

extension UpdateFleetInput {

    static func urlPathProvider(_ value: UpdateFleetInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())"
    }
}

extension UpdateFleetInput {

    static func headerProvider(_ value: UpdateFleetInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateJobInput {

    static func urlPathProvider(_ value: UpdateJobInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())"
    }
}

extension UpdateJobInput {

    static func headerProvider(_ value: UpdateJobInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateMonitorInput {

    static func urlPathProvider(_ value: UpdateMonitorInput) -> Swift.String? {
        guard let monitorId = value.monitorId else {
            return nil
        }
        return "/2023-10-12/monitors/\(monitorId.urlPercentEncoding())"
    }
}

extension UpdateQueueInput {

    static func urlPathProvider(_ value: UpdateQueueInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())"
    }
}

extension UpdateQueueInput {

    static func headerProvider(_ value: UpdateQueueInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateQueueEnvironmentInput {

    static func urlPathProvider(_ value: UpdateQueueEnvironmentInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let queueEnvironmentId = value.queueEnvironmentId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/environments/\(queueEnvironmentId.urlPercentEncoding())"
    }
}

extension UpdateQueueEnvironmentInput {

    static func headerProvider(_ value: UpdateQueueEnvironmentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateQueueFleetAssociationInput {

    static func urlPathProvider(_ value: UpdateQueueFleetAssociationInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queue-fleet-associations/\(queueId.urlPercentEncoding())/\(fleetId.urlPercentEncoding())"
    }
}

extension UpdateSessionInput {

    static func urlPathProvider(_ value: UpdateSessionInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/sessions/\(sessionId.urlPercentEncoding())"
    }
}

extension UpdateSessionInput {

    static func headerProvider(_ value: UpdateSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateStepInput {

    static func urlPathProvider(_ value: UpdateStepInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let stepId = value.stepId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/steps/\(stepId.urlPercentEncoding())"
    }
}

extension UpdateStepInput {

    static func headerProvider(_ value: UpdateStepInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateStorageProfileInput {

    static func urlPathProvider(_ value: UpdateStorageProfileInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let storageProfileId = value.storageProfileId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/storage-profiles/\(storageProfileId.urlPercentEncoding())"
    }
}

extension UpdateStorageProfileInput {

    static func headerProvider(_ value: UpdateStorageProfileInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateTaskInput {

    static func urlPathProvider(_ value: UpdateTaskInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let queueId = value.queueId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        guard let stepId = value.stepId else {
            return nil
        }
        guard let taskId = value.taskId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/queues/\(queueId.urlPercentEncoding())/jobs/\(jobId.urlPercentEncoding())/steps/\(stepId.urlPercentEncoding())/tasks/\(taskId.urlPercentEncoding())"
    }
}

extension UpdateTaskInput {

    static func headerProvider(_ value: UpdateTaskInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateWorkerInput {

    static func urlPathProvider(_ value: UpdateWorkerInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let workerId = value.workerId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers/\(workerId.urlPercentEncoding())"
    }
}

extension UpdateWorkerScheduleInput {

    static func urlPathProvider(_ value: UpdateWorkerScheduleInput) -> Swift.String? {
        guard let farmId = value.farmId else {
            return nil
        }
        guard let fleetId = value.fleetId else {
            return nil
        }
        guard let workerId = value.workerId else {
            return nil
        }
        return "/2023-10-12/farms/\(farmId.urlPercentEncoding())/fleets/\(fleetId.urlPercentEncoding())/workers/\(workerId.urlPercentEncoding())/schedule"
    }
}

extension AssociateMemberToFarmInput {

    static func write(value: AssociateMemberToFarmInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identityStoreId"].write(value.identityStoreId)
        try writer["membershipLevel"].write(value.membershipLevel)
        try writer["principalType"].write(value.principalType)
    }
}

extension AssociateMemberToFleetInput {

    static func write(value: AssociateMemberToFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identityStoreId"].write(value.identityStoreId)
        try writer["membershipLevel"].write(value.membershipLevel)
        try writer["principalType"].write(value.principalType)
    }
}

extension AssociateMemberToJobInput {

    static func write(value: AssociateMemberToJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identityStoreId"].write(value.identityStoreId)
        try writer["membershipLevel"].write(value.membershipLevel)
        try writer["principalType"].write(value.principalType)
    }
}

extension AssociateMemberToQueueInput {

    static func write(value: AssociateMemberToQueueInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identityStoreId"].write(value.identityStoreId)
        try writer["membershipLevel"].write(value.membershipLevel)
        try writer["principalType"].write(value.principalType)
    }
}

extension BatchGetJobEntityInput {

    static func write(value: BatchGetJobEntityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifiers"].writeList(value.identifiers, memberWritingClosure: DeadlineClientTypes.JobEntityIdentifiersUnion.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CopyJobTemplateInput {

    static func write(value: CopyJobTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetS3Location"].write(value.targetS3Location, with: DeadlineClientTypes.S3Location.write(value:to:))
    }
}

extension CreateBudgetInput {

    static func write(value: CreateBudgetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeList(value.actions, memberWritingClosure: DeadlineClientTypes.BudgetActionToAdd.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["approximateDollarLimit"].write(value.approximateDollarLimit)
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["schedule"].write(value.schedule, with: DeadlineClientTypes.BudgetSchedule.write(value:to:))
        try writer["usageTrackingResource"].write(value.usageTrackingResource, with: DeadlineClientTypes.UsageTrackingResource.write(value:to:))
    }
}

extension CreateFarmInput {

    static func write(value: CreateFarmInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateFleetInput {

    static func write(value: CreateFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].write(value.configuration, with: DeadlineClientTypes.FleetConfiguration.write(value:to:))
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["maxWorkerCount"].write(value.maxWorkerCount)
        try writer["minWorkerCount"].write(value.minWorkerCount)
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateJobInput {

    static func write(value: CreateJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attachments"].write(value.attachments, with: DeadlineClientTypes.Attachments.write(value:to:))
        try writer["maxFailedTasksCount"].write(value.maxFailedTasksCount)
        try writer["maxRetriesPerTask"].write(value.maxRetriesPerTask)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: DeadlineClientTypes.JobParameter.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["priority"].write(value.priority)
        try writer["sourceJobId"].write(value.sourceJobId)
        try writer["storageProfileId"].write(value.storageProfileId)
        try writer["targetTaskRunStatus"].write(value.targetTaskRunStatus)
        try writer["template"].write(value.template)
        try writer["templateType"].write(value.templateType)
    }
}

extension CreateLicenseEndpointInput {

    static func write(value: CreateLicenseEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["vpcId"].write(value.vpcId)
    }
}

extension CreateMonitorInput {

    static func write(value: CreateMonitorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["displayName"].write(value.displayName)
        try writer["identityCenterInstanceArn"].write(value.identityCenterInstanceArn)
        try writer["roleArn"].write(value.roleArn)
        try writer["subdomain"].write(value.subdomain)
    }
}

extension CreateQueueInput {

    static func write(value: CreateQueueInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowedStorageProfileIds"].writeList(value.allowedStorageProfileIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["defaultBudgetAction"].write(value.defaultBudgetAction)
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["jobAttachmentSettings"].write(value.jobAttachmentSettings, with: DeadlineClientTypes.JobAttachmentSettings.write(value:to:))
        try writer["jobRunAsUser"].write(value.jobRunAsUser, with: DeadlineClientTypes.JobRunAsUser.write(value:to:))
        try writer["requiredFileSystemLocationNames"].writeList(value.requiredFileSystemLocationNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateQueueEnvironmentInput {

    static func write(value: CreateQueueEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["priority"].write(value.priority)
        try writer["template"].write(value.template)
        try writer["templateType"].write(value.templateType)
    }
}

extension CreateQueueFleetAssociationInput {

    static func write(value: CreateQueueFleetAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fleetId"].write(value.fleetId)
        try writer["queueId"].write(value.queueId)
    }
}

extension CreateStorageProfileInput {

    static func write(value: CreateStorageProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["displayName"].write(value.displayName)
        try writer["fileSystemLocations"].writeList(value.fileSystemLocations, memberWritingClosure: DeadlineClientTypes.FileSystemLocation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["osFamily"].write(value.osFamily)
    }
}

extension CreateWorkerInput {

    static func write(value: CreateWorkerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["hostProperties"].write(value.hostProperties, with: DeadlineClientTypes.HostPropertiesRequest.write(value:to:))
    }
}

extension SearchJobsInput {

    static func write(value: SearchJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterExpressions"].write(value.filterExpressions, with: DeadlineClientTypes.SearchGroupedFilterExpressions.write(value:to:))
        try writer["itemOffset"].write(value.itemOffset)
        try writer["pageSize"].write(value.pageSize)
        try writer["queueIds"].writeList(value.queueIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sortExpressions"].writeList(value.sortExpressions, memberWritingClosure: DeadlineClientTypes.SearchSortExpression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SearchStepsInput {

    static func write(value: SearchStepsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterExpressions"].write(value.filterExpressions, with: DeadlineClientTypes.SearchGroupedFilterExpressions.write(value:to:))
        try writer["itemOffset"].write(value.itemOffset)
        try writer["jobId"].write(value.jobId)
        try writer["pageSize"].write(value.pageSize)
        try writer["queueIds"].writeList(value.queueIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sortExpressions"].writeList(value.sortExpressions, memberWritingClosure: DeadlineClientTypes.SearchSortExpression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SearchTasksInput {

    static func write(value: SearchTasksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterExpressions"].write(value.filterExpressions, with: DeadlineClientTypes.SearchGroupedFilterExpressions.write(value:to:))
        try writer["itemOffset"].write(value.itemOffset)
        try writer["jobId"].write(value.jobId)
        try writer["pageSize"].write(value.pageSize)
        try writer["queueIds"].writeList(value.queueIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sortExpressions"].writeList(value.sortExpressions, memberWritingClosure: DeadlineClientTypes.SearchSortExpression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SearchWorkersInput {

    static func write(value: SearchWorkersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterExpressions"].write(value.filterExpressions, with: DeadlineClientTypes.SearchGroupedFilterExpressions.write(value:to:))
        try writer["fleetIds"].writeList(value.fleetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["itemOffset"].write(value.itemOffset)
        try writer["pageSize"].write(value.pageSize)
        try writer["sortExpressions"].writeList(value.sortExpressions, memberWritingClosure: DeadlineClientTypes.SearchSortExpression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartSessionsStatisticsAggregationInput {

    static func write(value: StartSessionsStatisticsAggregationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["groupBy"].writeList(value.groupBy, memberWritingClosure: SmithyReadWrite.WritingClosureBox<DeadlineClientTypes.UsageGroupByField>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["period"].write(value.period)
        try writer["resourceIds"].write(value.resourceIds, with: DeadlineClientTypes.SessionsStatisticsResources.write(value:to:))
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["statistics"].writeList(value.statistics, memberWritingClosure: SmithyReadWrite.WritingClosureBox<DeadlineClientTypes.UsageStatistic>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["timezone"].write(value.timezone)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateBudgetInput {

    static func write(value: UpdateBudgetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionsToAdd"].writeList(value.actionsToAdd, memberWritingClosure: DeadlineClientTypes.BudgetActionToAdd.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["actionsToRemove"].writeList(value.actionsToRemove, memberWritingClosure: DeadlineClientTypes.BudgetActionToRemove.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["approximateDollarLimit"].write(value.approximateDollarLimit)
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["schedule"].write(value.schedule, with: DeadlineClientTypes.BudgetSchedule.write(value:to:))
        try writer["status"].write(value.status)
    }
}

extension UpdateFarmInput {

    static func write(value: UpdateFarmInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
    }
}

extension UpdateFleetInput {

    static func write(value: UpdateFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].write(value.configuration, with: DeadlineClientTypes.FleetConfiguration.write(value:to:))
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["maxWorkerCount"].write(value.maxWorkerCount)
        try writer["minWorkerCount"].write(value.minWorkerCount)
        try writer["roleArn"].write(value.roleArn)
    }
}

extension UpdateJobInput {

    static func write(value: UpdateJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["lifecycleStatus"].write(value.lifecycleStatus)
        try writer["maxFailedTasksCount"].write(value.maxFailedTasksCount)
        try writer["maxRetriesPerTask"].write(value.maxRetriesPerTask)
        try writer["priority"].write(value.priority)
        try writer["targetTaskRunStatus"].write(value.targetTaskRunStatus)
    }
}

extension UpdateMonitorInput {

    static func write(value: UpdateMonitorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["displayName"].write(value.displayName)
        try writer["roleArn"].write(value.roleArn)
        try writer["subdomain"].write(value.subdomain)
    }
}

extension UpdateQueueInput {

    static func write(value: UpdateQueueInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowedStorageProfileIdsToAdd"].writeList(value.allowedStorageProfileIdsToAdd, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["allowedStorageProfileIdsToRemove"].writeList(value.allowedStorageProfileIdsToRemove, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["defaultBudgetAction"].write(value.defaultBudgetAction)
        try writer["description"].write(value.description)
        try writer["displayName"].write(value.displayName)
        try writer["jobAttachmentSettings"].write(value.jobAttachmentSettings, with: DeadlineClientTypes.JobAttachmentSettings.write(value:to:))
        try writer["jobRunAsUser"].write(value.jobRunAsUser, with: DeadlineClientTypes.JobRunAsUser.write(value:to:))
        try writer["requiredFileSystemLocationNamesToAdd"].writeList(value.requiredFileSystemLocationNamesToAdd, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["requiredFileSystemLocationNamesToRemove"].writeList(value.requiredFileSystemLocationNamesToRemove, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["roleArn"].write(value.roleArn)
    }
}

extension UpdateQueueEnvironmentInput {

    static func write(value: UpdateQueueEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["priority"].write(value.priority)
        try writer["template"].write(value.template)
        try writer["templateType"].write(value.templateType)
    }
}

extension UpdateQueueFleetAssociationInput {

    static func write(value: UpdateQueueFleetAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
    }
}

extension UpdateSessionInput {

    static func write(value: UpdateSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetLifecycleStatus"].write(value.targetLifecycleStatus)
    }
}

extension UpdateStepInput {

    static func write(value: UpdateStepInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetTaskRunStatus"].write(value.targetTaskRunStatus)
    }
}

extension UpdateStorageProfileInput {

    static func write(value: UpdateStorageProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["displayName"].write(value.displayName)
        try writer["fileSystemLocationsToAdd"].writeList(value.fileSystemLocationsToAdd, memberWritingClosure: DeadlineClientTypes.FileSystemLocation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["fileSystemLocationsToRemove"].writeList(value.fileSystemLocationsToRemove, memberWritingClosure: DeadlineClientTypes.FileSystemLocation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["osFamily"].write(value.osFamily)
    }
}

extension UpdateTaskInput {

    static func write(value: UpdateTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetRunStatus"].write(value.targetRunStatus)
    }
}

extension UpdateWorkerInput {

    static func write(value: UpdateWorkerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capabilities"].write(value.capabilities, with: DeadlineClientTypes.WorkerCapabilities.write(value:to:))
        try writer["hostProperties"].write(value.hostProperties, with: DeadlineClientTypes.HostPropertiesRequest.write(value:to:))
        try writer["status"].write(value.status)
    }
}

extension UpdateWorkerScheduleInput {

    static func write(value: UpdateWorkerScheduleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["updatedSessionActions"].writeMap(value.updatedSessionActions, valueWritingClosure: DeadlineClientTypes.UpdatedSessionActionInfo.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension AssociateMemberToFarmOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateMemberToFarmOutput {
        return AssociateMemberToFarmOutput()
    }
}

extension AssociateMemberToFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateMemberToFleetOutput {
        return AssociateMemberToFleetOutput()
    }
}

extension AssociateMemberToJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateMemberToJobOutput {
        return AssociateMemberToJobOutput()
    }
}

extension AssociateMemberToQueueOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateMemberToQueueOutput {
        return AssociateMemberToQueueOutput()
    }
}

extension AssumeFleetRoleForReadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssumeFleetRoleForReadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssumeFleetRoleForReadOutput()
        value.credentials = try reader["credentials"].readIfPresent(with: DeadlineClientTypes.AwsCredentials.read(from:))
        return value
    }
}

extension AssumeFleetRoleForWorkerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssumeFleetRoleForWorkerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssumeFleetRoleForWorkerOutput()
        value.credentials = try reader["credentials"].readIfPresent(with: DeadlineClientTypes.AwsCredentials.read(from:))
        return value
    }
}

extension AssumeQueueRoleForReadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssumeQueueRoleForReadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssumeQueueRoleForReadOutput()
        value.credentials = try reader["credentials"].readIfPresent(with: DeadlineClientTypes.AwsCredentials.read(from:))
        return value
    }
}

extension AssumeQueueRoleForUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssumeQueueRoleForUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssumeQueueRoleForUserOutput()
        value.credentials = try reader["credentials"].readIfPresent(with: DeadlineClientTypes.AwsCredentials.read(from:))
        return value
    }
}

extension AssumeQueueRoleForWorkerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssumeQueueRoleForWorkerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssumeQueueRoleForWorkerOutput()
        value.credentials = try reader["credentials"].readIfPresent(with: DeadlineClientTypes.AwsCredentials.read(from:))
        return value
    }
}

extension BatchGetJobEntityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetJobEntityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetJobEntityOutput()
        value.entities = try reader["entities"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.JobEntity.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.GetJobEntityError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CopyJobTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CopyJobTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CopyJobTemplateOutput()
        value.templateType = try reader["templateType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreateBudgetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBudgetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBudgetOutput()
        value.budgetId = try reader["budgetId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateFarmOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFarmOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFarmOutput()
        value.farmId = try reader["farmId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFleetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFleetOutput()
        value.fleetId = try reader["fleetId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateJobOutput()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateLicenseEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLicenseEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLicenseEndpointOutput()
        value.licenseEndpointId = try reader["licenseEndpointId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMonitorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMonitorOutput()
        value.identityCenterApplicationArn = try reader["identityCenterApplicationArn"].readIfPresent() ?? ""
        value.monitorId = try reader["monitorId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateQueueOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateQueueOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateQueueOutput()
        value.queueId = try reader["queueId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateQueueEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateQueueEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateQueueEnvironmentOutput()
        value.queueEnvironmentId = try reader["queueEnvironmentId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateQueueFleetAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateQueueFleetAssociationOutput {
        return CreateQueueFleetAssociationOutput()
    }
}

extension CreateStorageProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStorageProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStorageProfileOutput()
        value.storageProfileId = try reader["storageProfileId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateWorkerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkerOutput()
        value.workerId = try reader["workerId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteBudgetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBudgetOutput {
        return DeleteBudgetOutput()
    }
}

extension DeleteFarmOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFarmOutput {
        return DeleteFarmOutput()
    }
}

extension DeleteFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFleetOutput {
        return DeleteFleetOutput()
    }
}

extension DeleteLicenseEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLicenseEndpointOutput {
        return DeleteLicenseEndpointOutput()
    }
}

extension DeleteMeteredProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMeteredProductOutput {
        return DeleteMeteredProductOutput()
    }
}

extension DeleteMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMonitorOutput {
        return DeleteMonitorOutput()
    }
}

extension DeleteQueueOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteQueueOutput {
        return DeleteQueueOutput()
    }
}

extension DeleteQueueEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteQueueEnvironmentOutput {
        return DeleteQueueEnvironmentOutput()
    }
}

extension DeleteQueueFleetAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteQueueFleetAssociationOutput {
        return DeleteQueueFleetAssociationOutput()
    }
}

extension DeleteStorageProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStorageProfileOutput {
        return DeleteStorageProfileOutput()
    }
}

extension DeleteWorkerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkerOutput {
        return DeleteWorkerOutput()
    }
}

extension DisassociateMemberFromFarmOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateMemberFromFarmOutput {
        return DisassociateMemberFromFarmOutput()
    }
}

extension DisassociateMemberFromFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateMemberFromFleetOutput {
        return DisassociateMemberFromFleetOutput()
    }
}

extension DisassociateMemberFromJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateMemberFromJobOutput {
        return DisassociateMemberFromJobOutput()
    }
}

extension DisassociateMemberFromQueueOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateMemberFromQueueOutput {
        return DisassociateMemberFromQueueOutput()
    }
}

extension GetBudgetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBudgetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBudgetOutput()
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.ResponseBudgetAction.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.approximateDollarLimit = try reader["approximateDollarLimit"].readIfPresent() ?? 0.0
        value.budgetId = try reader["budgetId"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent() ?? ""
        value.queueStoppedAt = try reader["queueStoppedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.schedule = try reader["schedule"].readIfPresent(with: DeadlineClientTypes.BudgetSchedule.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.usageTrackingResource = try reader["usageTrackingResource"].readIfPresent(with: DeadlineClientTypes.UsageTrackingResource.read(from:))
        value.usages = try reader["usages"].readIfPresent(with: DeadlineClientTypes.ConsumedUsages.read(from:))
        return value
    }
}

extension GetFarmOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFarmOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFarmOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent() ?? ""
        value.farmId = try reader["farmId"].readIfPresent() ?? ""
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension GetFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFleetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFleetOutput()
        value.autoScalingStatus = try reader["autoScalingStatus"].readIfPresent()
        value.capabilities = try reader["capabilities"].readIfPresent(with: DeadlineClientTypes.FleetCapabilities.read(from:))
        value.configuration = try reader["configuration"].readIfPresent(with: DeadlineClientTypes.FleetConfiguration.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent() ?? ""
        value.farmId = try reader["farmId"].readIfPresent() ?? ""
        value.fleetId = try reader["fleetId"].readIfPresent() ?? ""
        value.maxWorkerCount = try reader["maxWorkerCount"].readIfPresent() ?? 0
        value.minWorkerCount = try reader["minWorkerCount"].readIfPresent() ?? 0
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.targetWorkerCount = try reader["targetWorkerCount"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.workerCount = try reader["workerCount"].readIfPresent() ?? 0
        return value
    }
}

extension GetJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJobOutput()
        value.attachments = try reader["attachments"].readIfPresent(with: DeadlineClientTypes.Attachments.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.lifecycleStatus = try reader["lifecycleStatus"].readIfPresent() ?? .sdkUnknown("")
        value.lifecycleStatusMessage = try reader["lifecycleStatusMessage"].readIfPresent() ?? ""
        value.maxFailedTasksCount = try reader["maxFailedTasksCount"].readIfPresent()
        value.maxRetriesPerTask = try reader["maxRetriesPerTask"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: DeadlineClientTypes.JobParameter.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.priority = try reader["priority"].readIfPresent() ?? 0
        value.sourceJobId = try reader["sourceJobId"].readIfPresent()
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.storageProfileId = try reader["storageProfileId"].readIfPresent()
        value.targetTaskRunStatus = try reader["targetTaskRunStatus"].readIfPresent()
        value.taskRunStatus = try reader["taskRunStatus"].readIfPresent()
        value.taskRunStatusCounts = try reader["taskRunStatusCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension GetLicenseEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLicenseEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLicenseEndpointOutput()
        value.dnsName = try reader["dnsName"].readIfPresent()
        value.licenseEndpointId = try reader["licenseEndpointId"].readIfPresent() ?? ""
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusMessage = try reader["statusMessage"].readIfPresent() ?? ""
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.vpcId = try reader["vpcId"].readIfPresent()
        return value
    }
}

extension GetMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMonitorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMonitorOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent() ?? ""
        value.identityCenterApplicationArn = try reader["identityCenterApplicationArn"].readIfPresent() ?? ""
        value.identityCenterInstanceArn = try reader["identityCenterInstanceArn"].readIfPresent() ?? ""
        value.monitorId = try reader["monitorId"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.subdomain = try reader["subdomain"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.url = try reader["url"].readIfPresent() ?? ""
        return value
    }
}

extension GetQueueOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQueueOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQueueOutput()
        value.allowedStorageProfileIds = try reader["allowedStorageProfileIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.blockedReason = try reader["blockedReason"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.defaultBudgetAction = try reader["defaultBudgetAction"].readIfPresent() ?? .sdkUnknown("")
        value.description = try reader["description"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent() ?? ""
        value.farmId = try reader["farmId"].readIfPresent() ?? ""
        value.jobAttachmentSettings = try reader["jobAttachmentSettings"].readIfPresent(with: DeadlineClientTypes.JobAttachmentSettings.read(from:))
        value.jobRunAsUser = try reader["jobRunAsUser"].readIfPresent(with: DeadlineClientTypes.JobRunAsUser.read(from:))
        value.queueId = try reader["queueId"].readIfPresent() ?? ""
        value.requiredFileSystemLocationNames = try reader["requiredFileSystemLocationNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension GetQueueEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQueueEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQueueEnvironmentOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.priority = try reader["priority"].readIfPresent() ?? 0
        value.queueEnvironmentId = try reader["queueEnvironmentId"].readIfPresent() ?? ""
        value.template = try reader["template"].readIfPresent() ?? ""
        value.templateType = try reader["templateType"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension GetQueueFleetAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetQueueFleetAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetQueueFleetAssociationOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.fleetId = try reader["fleetId"].readIfPresent() ?? ""
        value.queueId = try reader["queueId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension GetSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSessionOutput()
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.fleetId = try reader["fleetId"].readIfPresent() ?? ""
        value.hostProperties = try reader["hostProperties"].readIfPresent(with: DeadlineClientTypes.HostPropertiesResponse.read(from:))
        value.lifecycleStatus = try reader["lifecycleStatus"].readIfPresent() ?? .sdkUnknown("")
        value.log = try reader["log"].readIfPresent(with: DeadlineClientTypes.LogConfiguration.read(from:))
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.targetLifecycleStatus = try reader["targetLifecycleStatus"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.workerId = try reader["workerId"].readIfPresent() ?? ""
        value.workerLog = try reader["workerLog"].readIfPresent(with: DeadlineClientTypes.LogConfiguration.read(from:))
        return value
    }
}

extension GetSessionActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSessionActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSessionActionOutput()
        value.definition = try reader["definition"].readIfPresent(with: DeadlineClientTypes.SessionActionDefinition.read(from:))
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.processExitCode = try reader["processExitCode"].readIfPresent()
        value.progressMessage = try reader["progressMessage"].readIfPresent()
        value.progressPercent = try reader["progressPercent"].readIfPresent()
        value.sessionActionId = try reader["sessionActionId"].readIfPresent() ?? ""
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.workerUpdatedAt = try reader["workerUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension GetSessionsStatisticsAggregationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSessionsStatisticsAggregationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSessionsStatisticsAggregationOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.statistics = try reader["statistics"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.Statistics.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        return value
    }
}

extension GetStepOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStepOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStepOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.dependencyCounts = try reader["dependencyCounts"].readIfPresent(with: DeadlineClientTypes.DependencyCounts.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lifecycleStatus = try reader["lifecycleStatus"].readIfPresent() ?? .sdkUnknown("")
        value.lifecycleStatusMessage = try reader["lifecycleStatusMessage"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.parameterSpace = try reader["parameterSpace"].readIfPresent(with: DeadlineClientTypes.ParameterSpace.read(from:))
        value.requiredCapabilities = try reader["requiredCapabilities"].readIfPresent(with: DeadlineClientTypes.StepRequiredCapabilities.read(from:))
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.stepId = try reader["stepId"].readIfPresent() ?? ""
        value.targetTaskRunStatus = try reader["targetTaskRunStatus"].readIfPresent()
        value.taskRunStatus = try reader["taskRunStatus"].readIfPresent() ?? .sdkUnknown("")
        value.taskRunStatusCounts = try reader["taskRunStatusCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension GetStorageProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStorageProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStorageProfileOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent() ?? ""
        value.fileSystemLocations = try reader["fileSystemLocations"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.FileSystemLocation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.osFamily = try reader["osFamily"].readIfPresent() ?? .sdkUnknown("")
        value.storageProfileId = try reader["storageProfileId"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension GetStorageProfileForQueueOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStorageProfileForQueueOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStorageProfileForQueueOutput()
        value.displayName = try reader["displayName"].readIfPresent() ?? ""
        value.fileSystemLocations = try reader["fileSystemLocations"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.FileSystemLocation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.osFamily = try reader["osFamily"].readIfPresent() ?? .sdkUnknown("")
        value.storageProfileId = try reader["storageProfileId"].readIfPresent() ?? ""
        return value
    }
}

extension GetTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTaskOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.failureRetryCount = try reader["failureRetryCount"].readIfPresent()
        value.latestSessionActionId = try reader["latestSessionActionId"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: DeadlineClientTypes.TaskParameterValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.runStatus = try reader["runStatus"].readIfPresent() ?? .sdkUnknown("")
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.targetRunStatus = try reader["targetRunStatus"].readIfPresent()
        value.taskId = try reader["taskId"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension GetWorkerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkerOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.farmId = try reader["farmId"].readIfPresent() ?? ""
        value.fleetId = try reader["fleetId"].readIfPresent() ?? ""
        value.hostProperties = try reader["hostProperties"].readIfPresent(with: DeadlineClientTypes.HostPropertiesResponse.read(from:))
        value.log = try reader["log"].readIfPresent(with: DeadlineClientTypes.LogConfiguration.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.workerId = try reader["workerId"].readIfPresent() ?? ""
        return value
    }
}

extension ListAvailableMeteredProductsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAvailableMeteredProductsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAvailableMeteredProductsOutput()
        value.meteredProducts = try reader["meteredProducts"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.MeteredProductSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBudgetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBudgetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBudgetsOutput()
        value.budgets = try reader["budgets"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.BudgetSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFarmMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFarmMembersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFarmMembersOutput()
        value.members = try reader["members"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.FarmMember.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFarmsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFarmsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFarmsOutput()
        value.farms = try reader["farms"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.FarmSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFleetMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFleetMembersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFleetMembersOutput()
        value.members = try reader["members"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.FleetMember.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFleetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFleetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFleetsOutput()
        value.fleets = try reader["fleets"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.FleetSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListJobMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListJobMembersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListJobMembersOutput()
        value.members = try reader["members"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.JobMember.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListJobParameterDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListJobParameterDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListJobParameterDefinitionsOutput()
        value.jobParameterDefinitions = try reader["jobParameterDefinitions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDocument(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListJobsOutput()
        value.jobs = try reader["jobs"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.JobSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListLicenseEndpointsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLicenseEndpointsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLicenseEndpointsOutput()
        value.licenseEndpoints = try reader["licenseEndpoints"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.LicenseEndpointSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMeteredProductsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMeteredProductsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMeteredProductsOutput()
        value.meteredProducts = try reader["meteredProducts"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.MeteredProductSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMonitorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMonitorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMonitorsOutput()
        value.monitors = try reader["monitors"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.MonitorSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListQueueEnvironmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListQueueEnvironmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListQueueEnvironmentsOutput()
        value.environments = try reader["environments"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.QueueEnvironmentSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListQueueFleetAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListQueueFleetAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListQueueFleetAssociationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.queueFleetAssociations = try reader["queueFleetAssociations"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.QueueFleetAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListQueueMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListQueueMembersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListQueueMembersOutput()
        value.members = try reader["members"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.QueueMember.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListQueuesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListQueuesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListQueuesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.queues = try reader["queues"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.QueueSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListSessionActionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSessionActionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSessionActionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sessionActions = try reader["sessionActions"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.SessionActionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSessionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sessions = try reader["sessions"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.SessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListSessionsForWorkerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSessionsForWorkerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSessionsForWorkerOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sessions = try reader["sessions"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.WorkerSessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListStepConsumersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStepConsumersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStepConsumersOutput()
        value.consumers = try reader["consumers"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.StepConsumer.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListStepDependenciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStepDependenciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStepDependenciesOutput()
        value.dependencies = try reader["dependencies"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.StepDependency.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListStepsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStepsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStepsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.steps = try reader["steps"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.StepSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListStorageProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStorageProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStorageProfilesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.storageProfiles = try reader["storageProfiles"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.StorageProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListStorageProfilesForQueueOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStorageProfilesForQueueOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStorageProfilesForQueueOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.storageProfiles = try reader["storageProfiles"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.StorageProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTasksOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tasks = try reader["tasks"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.TaskSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListWorkersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkersOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.workers = try reader["workers"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.WorkerSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PutMeteredProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutMeteredProductOutput {
        return PutMeteredProductOutput()
    }
}

extension SearchJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchJobsOutput()
        value.jobs = try reader["jobs"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.JobSearchSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextItemOffset = try reader["nextItemOffset"].readIfPresent()
        value.totalResults = try reader["totalResults"].readIfPresent() ?? 0
        return value
    }
}

extension SearchStepsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchStepsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchStepsOutput()
        value.nextItemOffset = try reader["nextItemOffset"].readIfPresent()
        value.steps = try reader["steps"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.StepSearchSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.totalResults = try reader["totalResults"].readIfPresent() ?? 0
        return value
    }
}

extension SearchTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchTasksOutput()
        value.nextItemOffset = try reader["nextItemOffset"].readIfPresent()
        value.tasks = try reader["tasks"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.TaskSearchSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.totalResults = try reader["totalResults"].readIfPresent() ?? 0
        return value
    }
}

extension SearchWorkersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchWorkersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchWorkersOutput()
        value.nextItemOffset = try reader["nextItemOffset"].readIfPresent()
        value.totalResults = try reader["totalResults"].readIfPresent() ?? 0
        value.workers = try reader["workers"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.WorkerSearchSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension StartSessionsStatisticsAggregationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartSessionsStatisticsAggregationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartSessionsStatisticsAggregationOutput()
        value.aggregationId = try reader["aggregationId"].readIfPresent() ?? ""
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateBudgetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBudgetOutput {
        return UpdateBudgetOutput()
    }
}

extension UpdateFarmOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFarmOutput {
        return UpdateFarmOutput()
    }
}

extension UpdateFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFleetOutput {
        return UpdateFleetOutput()
    }
}

extension UpdateJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateJobOutput {
        return UpdateJobOutput()
    }
}

extension UpdateMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMonitorOutput {
        return UpdateMonitorOutput()
    }
}

extension UpdateQueueOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateQueueOutput {
        return UpdateQueueOutput()
    }
}

extension UpdateQueueEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateQueueEnvironmentOutput {
        return UpdateQueueEnvironmentOutput()
    }
}

extension UpdateQueueFleetAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateQueueFleetAssociationOutput {
        return UpdateQueueFleetAssociationOutput()
    }
}

extension UpdateSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSessionOutput {
        return UpdateSessionOutput()
    }
}

extension UpdateStepOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateStepOutput {
        return UpdateStepOutput()
    }
}

extension UpdateStorageProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateStorageProfileOutput {
        return UpdateStorageProfileOutput()
    }
}

extension UpdateTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTaskOutput {
        return UpdateTaskOutput()
    }
}

extension UpdateWorkerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorkerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateWorkerOutput()
        value.log = try reader["log"].readIfPresent(with: DeadlineClientTypes.LogConfiguration.read(from:))
        return value
    }
}

extension UpdateWorkerScheduleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorkerScheduleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateWorkerScheduleOutput()
        value.assignedSessions = try reader["assignedSessions"].readMapIfPresent(valueReadingClosure: DeadlineClientTypes.AssignedSession.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.cancelSessionActions = try reader["cancelSessionActions"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.desiredWorkerStatus = try reader["desiredWorkerStatus"].readIfPresent()
        value.updateIntervalSeconds = try reader["updateIntervalSeconds"].readIfPresent() ?? 0
        return value
    }
}

enum AssociateMemberToFarmOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateMemberToFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateMemberToJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateMemberToQueueOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssumeFleetRoleForReadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssumeFleetRoleForWorkerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssumeQueueRoleForReadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssumeQueueRoleForUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssumeQueueRoleForWorkerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetJobEntityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CopyJobTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBudgetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFarmOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLicenseEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateQueueOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateQueueEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateQueueFleetAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStorageProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBudgetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFarmOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLicenseEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMeteredProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteQueueOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteQueueEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteQueueFleetAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStorageProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateMemberFromFarmOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateMemberFromFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateMemberFromJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateMemberFromQueueOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBudgetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFarmOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLicenseEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQueueOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQueueEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetQueueFleetAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSessionActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSessionsStatisticsAggregationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStepOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStorageProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStorageProfileForQueueOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAvailableMeteredProductsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBudgetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFarmMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFarmsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFleetMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFleetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListJobMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListJobParameterDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLicenseEndpointsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMeteredProductsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMonitorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListQueueEnvironmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListQueueFleetAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListQueueMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListQueuesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSessionActionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSessionsForWorkerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStepConsumersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStepDependenciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStepsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStorageProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStorageProfilesForQueueOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutMeteredProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchStepsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchWorkersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartSessionsStatisticsAggregationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBudgetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFarmOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateQueueOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateQueueEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateQueueFleetAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateStepOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateStorageProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorkerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorkerScheduleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerErrorException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.context = try reader["context"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.context = try reader["context"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.context = try reader["context"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.context = try reader["context"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.context = try reader["context"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.context = try reader["context"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DeadlineClientTypes.AwsCredentials {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.AwsCredentials {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.AwsCredentials()
        value.accessKeyId = try reader["accessKeyId"].readIfPresent() ?? ""
        value.secretAccessKey = try reader["secretAccessKey"].readIfPresent() ?? ""
        value.sessionToken = try reader["sessionToken"].readIfPresent() ?? ""
        value.expiration = try reader["expiration"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension DeadlineClientTypes.JobEntity {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.JobEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "jobDetails":
                return .jobdetails(try reader["jobDetails"].read(with: DeadlineClientTypes.JobDetailsEntity.read(from:)))
            case "jobAttachmentDetails":
                return .jobattachmentdetails(try reader["jobAttachmentDetails"].read(with: DeadlineClientTypes.JobAttachmentDetailsEntity.read(from:)))
            case "stepDetails":
                return .stepdetails(try reader["stepDetails"].read(with: DeadlineClientTypes.StepDetailsEntity.read(from:)))
            case "environmentDetails":
                return .environmentdetails(try reader["environmentDetails"].read(with: DeadlineClientTypes.EnvironmentDetailsEntity.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DeadlineClientTypes.EnvironmentDetailsEntity {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.EnvironmentDetailsEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.EnvironmentDetailsEntity()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.schemaVersion = try reader["schemaVersion"].readIfPresent() ?? ""
        value.template = try reader["template"].readIfPresent() ?? [:]
        return value
    }
}

extension DeadlineClientTypes.StepDetailsEntity {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.StepDetailsEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.StepDetailsEntity()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.stepId = try reader["stepId"].readIfPresent() ?? ""
        value.schemaVersion = try reader["schemaVersion"].readIfPresent() ?? ""
        value.template = try reader["template"].readIfPresent() ?? [:]
        value.dependencies = try reader["dependencies"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DeadlineClientTypes.JobAttachmentDetailsEntity {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.JobAttachmentDetailsEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.JobAttachmentDetailsEntity()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.attachments = try reader["attachments"].readIfPresent(with: DeadlineClientTypes.Attachments.read(from:))
        return value
    }
}

extension DeadlineClientTypes.Attachments {

    static func write(value: DeadlineClientTypes.Attachments?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileSystem"].write(value.fileSystem)
        try writer["manifests"].writeList(value.manifests, memberWritingClosure: DeadlineClientTypes.ManifestProperties.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.Attachments {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.Attachments()
        value.manifests = try reader["manifests"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.ManifestProperties.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.fileSystem = try reader["fileSystem"].readIfPresent() ?? .copied
        return value
    }
}

extension DeadlineClientTypes.ManifestProperties {

    static func write(value: DeadlineClientTypes.ManifestProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileSystemLocationName"].write(value.fileSystemLocationName)
        try writer["inputManifestHash"].write(value.inputManifestHash)
        try writer["inputManifestPath"].write(value.inputManifestPath)
        try writer["outputRelativeDirectories"].writeList(value.outputRelativeDirectories, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["rootPath"].write(value.rootPath)
        try writer["rootPathFormat"].write(value.rootPathFormat)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.ManifestProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.ManifestProperties()
        value.fileSystemLocationName = try reader["fileSystemLocationName"].readIfPresent()
        value.rootPath = try reader["rootPath"].readIfPresent() ?? ""
        value.rootPathFormat = try reader["rootPathFormat"].readIfPresent() ?? .sdkUnknown("")
        value.outputRelativeDirectories = try reader["outputRelativeDirectories"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.inputManifestPath = try reader["inputManifestPath"].readIfPresent()
        value.inputManifestHash = try reader["inputManifestHash"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.JobDetailsEntity {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.JobDetailsEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.JobDetailsEntity()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.jobAttachmentSettings = try reader["jobAttachmentSettings"].readIfPresent(with: DeadlineClientTypes.JobAttachmentSettings.read(from:))
        value.jobRunAsUser = try reader["jobRunAsUser"].readIfPresent(with: DeadlineClientTypes.JobRunAsUser.read(from:))
        value.logGroupName = try reader["logGroupName"].readIfPresent() ?? ""
        value.queueRoleArn = try reader["queueRoleArn"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: DeadlineClientTypes.JobParameter.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.schemaVersion = try reader["schemaVersion"].readIfPresent() ?? ""
        value.pathMappingRules = try reader["pathMappingRules"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.PathMappingRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeadlineClientTypes.PathMappingRule {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.PathMappingRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.PathMappingRule()
        value.sourcePathFormat = try reader["sourcePathFormat"].readIfPresent() ?? .sdkUnknown("")
        value.sourcePath = try reader["sourcePath"].readIfPresent() ?? ""
        value.destinationPath = try reader["destinationPath"].readIfPresent() ?? ""
        return value
    }
}

extension DeadlineClientTypes.JobParameter {

    static func write(value: DeadlineClientTypes.JobParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .float(float):
                try writer["float"].write(float)
            case let .int(int):
                try writer["int"].write(int)
            case let .path(path):
                try writer["path"].write(path)
            case let .string(string):
                try writer["string"].write(string)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.JobParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "int":
                return .int(try reader["int"].read())
            case "float":
                return .float(try reader["float"].read())
            case "string":
                return .string(try reader["string"].read())
            case "path":
                return .path(try reader["path"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DeadlineClientTypes.JobRunAsUser {

    static func write(value: DeadlineClientTypes.JobRunAsUser?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["posix"].write(value.posix, with: DeadlineClientTypes.PosixUser.write(value:to:))
        try writer["runAs"].write(value.runAs)
        try writer["windows"].write(value.windows, with: DeadlineClientTypes.WindowsUser.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.JobRunAsUser {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.JobRunAsUser()
        value.posix = try reader["posix"].readIfPresent(with: DeadlineClientTypes.PosixUser.read(from:))
        value.windows = try reader["windows"].readIfPresent(with: DeadlineClientTypes.WindowsUser.read(from:))
        value.runAs = try reader["runAs"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeadlineClientTypes.WindowsUser {

    static func write(value: DeadlineClientTypes.WindowsUser?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["passwordArn"].write(value.passwordArn)
        try writer["user"].write(value.user)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.WindowsUser {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.WindowsUser()
        value.user = try reader["user"].readIfPresent() ?? ""
        value.passwordArn = try reader["passwordArn"].readIfPresent() ?? ""
        return value
    }
}

extension DeadlineClientTypes.PosixUser {

    static func write(value: DeadlineClientTypes.PosixUser?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["group"].write(value.group)
        try writer["user"].write(value.user)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.PosixUser {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.PosixUser()
        value.user = try reader["user"].readIfPresent() ?? ""
        value.group = try reader["group"].readIfPresent() ?? ""
        return value
    }
}

extension DeadlineClientTypes.JobAttachmentSettings {

    static func write(value: DeadlineClientTypes.JobAttachmentSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["rootPrefix"].write(value.rootPrefix)
        try writer["s3BucketName"].write(value.s3BucketName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.JobAttachmentSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.JobAttachmentSettings()
        value.s3BucketName = try reader["s3BucketName"].readIfPresent() ?? ""
        value.rootPrefix = try reader["rootPrefix"].readIfPresent() ?? ""
        return value
    }
}

extension DeadlineClientTypes.GetJobEntityError {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.GetJobEntityError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "jobDetails":
                return .jobdetails(try reader["jobDetails"].read(with: DeadlineClientTypes.JobDetailsError.read(from:)))
            case "jobAttachmentDetails":
                return .jobattachmentdetails(try reader["jobAttachmentDetails"].read(with: DeadlineClientTypes.JobAttachmentDetailsError.read(from:)))
            case "stepDetails":
                return .stepdetails(try reader["stepDetails"].read(with: DeadlineClientTypes.StepDetailsError.read(from:)))
            case "environmentDetails":
                return .environmentdetails(try reader["environmentDetails"].read(with: DeadlineClientTypes.EnvironmentDetailsError.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DeadlineClientTypes.EnvironmentDetailsError {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.EnvironmentDetailsError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.EnvironmentDetailsError()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent() ?? .sdkUnknown("")
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension DeadlineClientTypes.StepDetailsError {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.StepDetailsError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.StepDetailsError()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.stepId = try reader["stepId"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent() ?? .sdkUnknown("")
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension DeadlineClientTypes.JobAttachmentDetailsError {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.JobAttachmentDetailsError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.JobAttachmentDetailsError()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent() ?? .sdkUnknown("")
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension DeadlineClientTypes.JobDetailsError {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.JobDetailsError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.JobDetailsError()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent() ?? .sdkUnknown("")
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension DeadlineClientTypes.UsageTrackingResource {

    static func write(value: DeadlineClientTypes.UsageTrackingResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .queueid(queueid):
                try writer["queueId"].write(queueid)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.UsageTrackingResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "queueId":
                return .queueid(try reader["queueId"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DeadlineClientTypes.ConsumedUsages {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.ConsumedUsages {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.ConsumedUsages()
        value.approximateDollarUsage = try reader["approximateDollarUsage"].readIfPresent() ?? 0.0
        return value
    }
}

extension DeadlineClientTypes.ResponseBudgetAction {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.ResponseBudgetAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.ResponseBudgetAction()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.thresholdPercentage = try reader["thresholdPercentage"].readIfPresent() ?? 0.0
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.BudgetSchedule {

    static func write(value: DeadlineClientTypes.BudgetSchedule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .fixed(fixed):
                try writer["fixed"].write(fixed, with: DeadlineClientTypes.FixedBudgetSchedule.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.BudgetSchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "fixed":
                return .fixed(try reader["fixed"].read(with: DeadlineClientTypes.FixedBudgetSchedule.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DeadlineClientTypes.FixedBudgetSchedule {

    static func write(value: DeadlineClientTypes.FixedBudgetSchedule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.dateTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.FixedBudgetSchedule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.FixedBudgetSchedule()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension DeadlineClientTypes.FleetConfiguration {

    static func write(value: DeadlineClientTypes.FleetConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .customermanaged(customermanaged):
                try writer["customerManaged"].write(customermanaged, with: DeadlineClientTypes.CustomerManagedFleetConfiguration.write(value:to:))
            case let .servicemanagedec2(servicemanagedec2):
                try writer["serviceManagedEc2"].write(servicemanagedec2, with: DeadlineClientTypes.ServiceManagedEc2FleetConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.FleetConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "customerManaged":
                return .customermanaged(try reader["customerManaged"].read(with: DeadlineClientTypes.CustomerManagedFleetConfiguration.read(from:)))
            case "serviceManagedEc2":
                return .servicemanagedec2(try reader["serviceManagedEc2"].read(with: DeadlineClientTypes.ServiceManagedEc2FleetConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DeadlineClientTypes.ServiceManagedEc2FleetConfiguration {

    static func write(value: DeadlineClientTypes.ServiceManagedEc2FleetConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["instanceCapabilities"].write(value.instanceCapabilities, with: DeadlineClientTypes.ServiceManagedEc2InstanceCapabilities.write(value:to:))
        try writer["instanceMarketOptions"].write(value.instanceMarketOptions, with: DeadlineClientTypes.ServiceManagedEc2InstanceMarketOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.ServiceManagedEc2FleetConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.ServiceManagedEc2FleetConfiguration()
        value.instanceCapabilities = try reader["instanceCapabilities"].readIfPresent(with: DeadlineClientTypes.ServiceManagedEc2InstanceCapabilities.read(from:))
        value.instanceMarketOptions = try reader["instanceMarketOptions"].readIfPresent(with: DeadlineClientTypes.ServiceManagedEc2InstanceMarketOptions.read(from:))
        return value
    }
}

extension DeadlineClientTypes.ServiceManagedEc2InstanceMarketOptions {

    static func write(value: DeadlineClientTypes.ServiceManagedEc2InstanceMarketOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.ServiceManagedEc2InstanceMarketOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.ServiceManagedEc2InstanceMarketOptions()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeadlineClientTypes.ServiceManagedEc2InstanceCapabilities {

    static func write(value: DeadlineClientTypes.ServiceManagedEc2InstanceCapabilities?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowedInstanceTypes"].writeList(value.allowedInstanceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["cpuArchitectureType"].write(value.cpuArchitectureType)
        try writer["customAmounts"].writeList(value.customAmounts, memberWritingClosure: DeadlineClientTypes.FleetAmountCapability.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["customAttributes"].writeList(value.customAttributes, memberWritingClosure: DeadlineClientTypes.FleetAttributeCapability.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["excludedInstanceTypes"].writeList(value.excludedInstanceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["memoryMiB"].write(value.memoryMiB, with: DeadlineClientTypes.MemoryMiBRange.write(value:to:))
        try writer["osFamily"].write(value.osFamily)
        try writer["rootEbsVolume"].write(value.rootEbsVolume, with: DeadlineClientTypes.Ec2EbsVolume.write(value:to:))
        try writer["vCpuCount"].write(value.vCpuCount, with: DeadlineClientTypes.VCpuCountRange.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.ServiceManagedEc2InstanceCapabilities {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.ServiceManagedEc2InstanceCapabilities()
        value.vCpuCount = try reader["vCpuCount"].readIfPresent(with: DeadlineClientTypes.VCpuCountRange.read(from:))
        value.memoryMiB = try reader["memoryMiB"].readIfPresent(with: DeadlineClientTypes.MemoryMiBRange.read(from:))
        value.osFamily = try reader["osFamily"].readIfPresent() ?? .sdkUnknown("")
        value.cpuArchitectureType = try reader["cpuArchitectureType"].readIfPresent() ?? .sdkUnknown("")
        value.rootEbsVolume = try reader["rootEbsVolume"].readIfPresent(with: DeadlineClientTypes.Ec2EbsVolume.read(from:))
        value.allowedInstanceTypes = try reader["allowedInstanceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.excludedInstanceTypes = try reader["excludedInstanceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.customAmounts = try reader["customAmounts"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.FleetAmountCapability.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.customAttributes = try reader["customAttributes"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.FleetAttributeCapability.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeadlineClientTypes.FleetAttributeCapability {

    static func write(value: DeadlineClientTypes.FleetAttributeCapability?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.FleetAttributeCapability {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.FleetAttributeCapability()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DeadlineClientTypes.FleetAmountCapability {

    static func write(value: DeadlineClientTypes.FleetAmountCapability?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["max"].write(value.max)
        try writer["min"].write(value.min)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.FleetAmountCapability {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.FleetAmountCapability()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.min = try reader["min"].readIfPresent() ?? 0.0
        value.max = try reader["max"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.Ec2EbsVolume {

    static func write(value: DeadlineClientTypes.Ec2EbsVolume?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["iops"].write(value.iops)
        try writer["sizeGiB"].write(value.sizeGiB)
        try writer["throughputMiB"].write(value.throughputMiB)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.Ec2EbsVolume {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.Ec2EbsVolume()
        value.sizeGiB = try reader["sizeGiB"].readIfPresent() ?? 250
        value.iops = try reader["iops"].readIfPresent() ?? 3000
        value.throughputMiB = try reader["throughputMiB"].readIfPresent() ?? 125
        return value
    }
}

extension DeadlineClientTypes.MemoryMiBRange {

    static func write(value: DeadlineClientTypes.MemoryMiBRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["max"].write(value.max)
        try writer["min"].write(value.min)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.MemoryMiBRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.MemoryMiBRange()
        value.min = try reader["min"].readIfPresent() ?? 0
        value.max = try reader["max"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.VCpuCountRange {

    static func write(value: DeadlineClientTypes.VCpuCountRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["max"].write(value.max)
        try writer["min"].write(value.min)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.VCpuCountRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.VCpuCountRange()
        value.min = try reader["min"].readIfPresent() ?? 0
        value.max = try reader["max"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.CustomerManagedFleetConfiguration {

    static func write(value: DeadlineClientTypes.CustomerManagedFleetConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mode"].write(value.mode)
        try writer["storageProfileId"].write(value.storageProfileId)
        try writer["workerCapabilities"].write(value.workerCapabilities, with: DeadlineClientTypes.CustomerManagedWorkerCapabilities.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.CustomerManagedFleetConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.CustomerManagedFleetConfiguration()
        value.mode = try reader["mode"].readIfPresent() ?? .sdkUnknown("")
        value.workerCapabilities = try reader["workerCapabilities"].readIfPresent(with: DeadlineClientTypes.CustomerManagedWorkerCapabilities.read(from:))
        value.storageProfileId = try reader["storageProfileId"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.CustomerManagedWorkerCapabilities {

    static func write(value: DeadlineClientTypes.CustomerManagedWorkerCapabilities?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["acceleratorCount"].write(value.acceleratorCount, with: DeadlineClientTypes.AcceleratorCountRange.write(value:to:))
        try writer["acceleratorTotalMemoryMiB"].write(value.acceleratorTotalMemoryMiB, with: DeadlineClientTypes.AcceleratorTotalMemoryMiBRange.write(value:to:))
        try writer["acceleratorTypes"].writeList(value.acceleratorTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<DeadlineClientTypes.AcceleratorType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["cpuArchitectureType"].write(value.cpuArchitectureType)
        try writer["customAmounts"].writeList(value.customAmounts, memberWritingClosure: DeadlineClientTypes.FleetAmountCapability.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["customAttributes"].writeList(value.customAttributes, memberWritingClosure: DeadlineClientTypes.FleetAttributeCapability.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["memoryMiB"].write(value.memoryMiB, with: DeadlineClientTypes.MemoryMiBRange.write(value:to:))
        try writer["osFamily"].write(value.osFamily)
        try writer["vCpuCount"].write(value.vCpuCount, with: DeadlineClientTypes.VCpuCountRange.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.CustomerManagedWorkerCapabilities {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.CustomerManagedWorkerCapabilities()
        value.vCpuCount = try reader["vCpuCount"].readIfPresent(with: DeadlineClientTypes.VCpuCountRange.read(from:))
        value.memoryMiB = try reader["memoryMiB"].readIfPresent(with: DeadlineClientTypes.MemoryMiBRange.read(from:))
        value.acceleratorTypes = try reader["acceleratorTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<DeadlineClientTypes.AcceleratorType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.acceleratorCount = try reader["acceleratorCount"].readIfPresent(with: DeadlineClientTypes.AcceleratorCountRange.read(from:))
        value.acceleratorTotalMemoryMiB = try reader["acceleratorTotalMemoryMiB"].readIfPresent(with: DeadlineClientTypes.AcceleratorTotalMemoryMiBRange.read(from:))
        value.osFamily = try reader["osFamily"].readIfPresent() ?? .sdkUnknown("")
        value.cpuArchitectureType = try reader["cpuArchitectureType"].readIfPresent() ?? .sdkUnknown("")
        value.customAmounts = try reader["customAmounts"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.FleetAmountCapability.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.customAttributes = try reader["customAttributes"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.FleetAttributeCapability.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeadlineClientTypes.AcceleratorTotalMemoryMiBRange {

    static func write(value: DeadlineClientTypes.AcceleratorTotalMemoryMiBRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["max"].write(value.max)
        try writer["min"].write(value.min)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.AcceleratorTotalMemoryMiBRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.AcceleratorTotalMemoryMiBRange()
        value.min = try reader["min"].readIfPresent() ?? 0
        value.max = try reader["max"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.AcceleratorCountRange {

    static func write(value: DeadlineClientTypes.AcceleratorCountRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["max"].write(value.max)
        try writer["min"].write(value.min)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.AcceleratorCountRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.AcceleratorCountRange()
        value.min = try reader["min"].readIfPresent() ?? 0
        value.max = try reader["max"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.FleetCapabilities {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.FleetCapabilities {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.FleetCapabilities()
        value.amounts = try reader["amounts"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.FleetAmountCapability.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.attributes = try reader["attributes"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.FleetAttributeCapability.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeadlineClientTypes.LogConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.LogConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.LogConfiguration()
        value.logDriver = try reader["logDriver"].readIfPresent() ?? ""
        value.options = try reader["options"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.error = try reader["error"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.HostPropertiesResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.HostPropertiesResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.HostPropertiesResponse()
        value.ipAddresses = try reader["ipAddresses"].readIfPresent(with: DeadlineClientTypes.IpAddresses.read(from:))
        value.hostName = try reader["hostName"].readIfPresent()
        value.ec2InstanceArn = try reader["ec2InstanceArn"].readIfPresent()
        value.ec2InstanceType = try reader["ec2InstanceType"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.IpAddresses {

    static func write(value: DeadlineClientTypes.IpAddresses?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ipV4Addresses"].writeList(value.ipV4Addresses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ipV6Addresses"].writeList(value.ipV6Addresses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.IpAddresses {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.IpAddresses()
        value.ipV4Addresses = try reader["ipV4Addresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipV6Addresses = try reader["ipV6Addresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeadlineClientTypes.SessionActionDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.SessionActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "envEnter":
                return .enventer(try reader["envEnter"].read(with: DeadlineClientTypes.EnvironmentEnterSessionActionDefinition.read(from:)))
            case "envExit":
                return .envexit(try reader["envExit"].read(with: DeadlineClientTypes.EnvironmentExitSessionActionDefinition.read(from:)))
            case "taskRun":
                return .taskrun(try reader["taskRun"].read(with: DeadlineClientTypes.TaskRunSessionActionDefinition.read(from:)))
            case "syncInputJobAttachments":
                return .syncinputjobattachments(try reader["syncInputJobAttachments"].read(with: DeadlineClientTypes.SyncInputJobAttachmentsSessionActionDefinition.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DeadlineClientTypes.SyncInputJobAttachmentsSessionActionDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.SyncInputJobAttachmentsSessionActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.SyncInputJobAttachmentsSessionActionDefinition()
        value.stepId = try reader["stepId"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.TaskRunSessionActionDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.TaskRunSessionActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.TaskRunSessionActionDefinition()
        value.taskId = try reader["taskId"].readIfPresent() ?? ""
        value.stepId = try reader["stepId"].readIfPresent() ?? ""
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: DeadlineClientTypes.TaskParameterValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension DeadlineClientTypes.TaskParameterValue {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.TaskParameterValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "int":
                return .int(try reader["int"].read())
            case "float":
                return .float(try reader["float"].read())
            case "string":
                return .string(try reader["string"].read())
            case "path":
                return .path(try reader["path"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DeadlineClientTypes.EnvironmentExitSessionActionDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.EnvironmentExitSessionActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.EnvironmentExitSessionActionDefinition()
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        return value
    }
}

extension DeadlineClientTypes.EnvironmentEnterSessionActionDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.EnvironmentEnterSessionActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.EnvironmentEnterSessionActionDefinition()
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        return value
    }
}

extension DeadlineClientTypes.Statistics {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.Statistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.Statistics()
        value.queueId = try reader["queueId"].readIfPresent()
        value.fleetId = try reader["fleetId"].readIfPresent()
        value.jobId = try reader["jobId"].readIfPresent()
        value.jobName = try reader["jobName"].readIfPresent()
        value.userId = try reader["userId"].readIfPresent()
        value.usageType = try reader["usageType"].readIfPresent()
        value.licenseProduct = try reader["licenseProduct"].readIfPresent()
        value.instanceType = try reader["instanceType"].readIfPresent()
        value.count = try reader["count"].readIfPresent() ?? 0
        value.costInUsd = try reader["costInUsd"].readIfPresent(with: DeadlineClientTypes.Stats.read(from:))
        value.runtimeInSeconds = try reader["runtimeInSeconds"].readIfPresent(with: DeadlineClientTypes.Stats.read(from:))
        value.aggregationStartTime = try reader["aggregationStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.aggregationEndTime = try reader["aggregationEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension DeadlineClientTypes.Stats {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.Stats {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.Stats()
        value.min = try reader["min"].readIfPresent()
        value.max = try reader["max"].readIfPresent()
        value.avg = try reader["avg"].readIfPresent()
        value.sum = try reader["sum"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.DependencyCounts {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.DependencyCounts {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.DependencyCounts()
        value.dependenciesResolved = try reader["dependenciesResolved"].readIfPresent() ?? 0
        value.dependenciesUnresolved = try reader["dependenciesUnresolved"].readIfPresent() ?? 0
        value.consumersResolved = try reader["consumersResolved"].readIfPresent() ?? 0
        value.consumersUnresolved = try reader["consumersUnresolved"].readIfPresent() ?? 0
        return value
    }
}

extension DeadlineClientTypes.StepRequiredCapabilities {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.StepRequiredCapabilities {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.StepRequiredCapabilities()
        value.attributes = try reader["attributes"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.StepAttributeCapability.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.amounts = try reader["amounts"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.StepAmountCapability.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DeadlineClientTypes.StepAmountCapability {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.StepAmountCapability {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.StepAmountCapability()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.min = try reader["min"].readIfPresent()
        value.max = try reader["max"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.StepAttributeCapability {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.StepAttributeCapability {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.StepAttributeCapability()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.anyOf = try reader["anyOf"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allOf = try reader["allOf"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeadlineClientTypes.ParameterSpace {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.ParameterSpace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.ParameterSpace()
        value.parameters = try reader["parameters"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.StepParameter.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.combination = try reader["combination"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.StepParameter {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.StepParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.StepParameter()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeadlineClientTypes.FileSystemLocation {

    static func write(value: DeadlineClientTypes.FileSystemLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["path"].write(value.path)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.FileSystemLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.FileSystemLocation()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.path = try reader["path"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeadlineClientTypes.MeteredProductSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.MeteredProductSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.MeteredProductSummary()
        value.productId = try reader["productId"].readIfPresent() ?? ""
        value.family = try reader["family"].readIfPresent() ?? ""
        value.vendor = try reader["vendor"].readIfPresent() ?? ""
        value.port = try reader["port"].readIfPresent() ?? 0
        return value
    }
}

extension DeadlineClientTypes.BudgetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.BudgetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.BudgetSummary()
        value.budgetId = try reader["budgetId"].readIfPresent() ?? ""
        value.usageTrackingResource = try reader["usageTrackingResource"].readIfPresent(with: DeadlineClientTypes.UsageTrackingResource.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.displayName = try reader["displayName"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.approximateDollarLimit = try reader["approximateDollarLimit"].readIfPresent() ?? 0.0
        value.usages = try reader["usages"].readIfPresent(with: DeadlineClientTypes.ConsumedUsages.read(from:))
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension DeadlineClientTypes.FarmMember {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.FarmMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.FarmMember()
        value.farmId = try reader["farmId"].readIfPresent() ?? ""
        value.principalId = try reader["principalId"].readIfPresent() ?? ""
        value.principalType = try reader["principalType"].readIfPresent() ?? .sdkUnknown("")
        value.identityStoreId = try reader["identityStoreId"].readIfPresent() ?? ""
        value.membershipLevel = try reader["membershipLevel"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeadlineClientTypes.FarmSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.FarmSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.FarmSummary()
        value.farmId = try reader["farmId"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent() ?? ""
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.FleetMember {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.FleetMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.FleetMember()
        value.farmId = try reader["farmId"].readIfPresent() ?? ""
        value.fleetId = try reader["fleetId"].readIfPresent() ?? ""
        value.principalId = try reader["principalId"].readIfPresent() ?? ""
        value.principalType = try reader["principalType"].readIfPresent() ?? .sdkUnknown("")
        value.identityStoreId = try reader["identityStoreId"].readIfPresent() ?? ""
        value.membershipLevel = try reader["membershipLevel"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeadlineClientTypes.FleetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.FleetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.FleetSummary()
        value.fleetId = try reader["fleetId"].readIfPresent() ?? ""
        value.farmId = try reader["farmId"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.autoScalingStatus = try reader["autoScalingStatus"].readIfPresent()
        value.targetWorkerCount = try reader["targetWorkerCount"].readIfPresent()
        value.workerCount = try reader["workerCount"].readIfPresent() ?? 0
        value.minWorkerCount = try reader["minWorkerCount"].readIfPresent() ?? 0
        value.maxWorkerCount = try reader["maxWorkerCount"].readIfPresent() ?? 0
        value.configuration = try reader["configuration"].readIfPresent(with: DeadlineClientTypes.FleetConfiguration.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.JobMember {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.JobMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.JobMember()
        value.farmId = try reader["farmId"].readIfPresent() ?? ""
        value.queueId = try reader["queueId"].readIfPresent() ?? ""
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.principalId = try reader["principalId"].readIfPresent() ?? ""
        value.principalType = try reader["principalType"].readIfPresent() ?? .sdkUnknown("")
        value.identityStoreId = try reader["identityStoreId"].readIfPresent() ?? ""
        value.membershipLevel = try reader["membershipLevel"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeadlineClientTypes.JobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.JobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.JobSummary()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.lifecycleStatus = try reader["lifecycleStatus"].readIfPresent() ?? .sdkUnknown("")
        value.lifecycleStatusMessage = try reader["lifecycleStatusMessage"].readIfPresent() ?? ""
        value.priority = try reader["priority"].readIfPresent() ?? 0
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.taskRunStatus = try reader["taskRunStatus"].readIfPresent()
        value.targetTaskRunStatus = try reader["targetTaskRunStatus"].readIfPresent()
        value.taskRunStatusCounts = try reader["taskRunStatusCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.maxFailedTasksCount = try reader["maxFailedTasksCount"].readIfPresent()
        value.maxRetriesPerTask = try reader["maxRetriesPerTask"].readIfPresent()
        value.sourceJobId = try reader["sourceJobId"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.LicenseEndpointSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.LicenseEndpointSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.LicenseEndpointSummary()
        value.licenseEndpointId = try reader["licenseEndpointId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.MonitorSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.MonitorSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.MonitorSummary()
        value.monitorId = try reader["monitorId"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent() ?? ""
        value.subdomain = try reader["subdomain"].readIfPresent() ?? ""
        value.url = try reader["url"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.identityCenterInstanceArn = try reader["identityCenterInstanceArn"].readIfPresent() ?? ""
        value.identityCenterApplicationArn = try reader["identityCenterApplicationArn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.QueueEnvironmentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.QueueEnvironmentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.QueueEnvironmentSummary()
        value.queueEnvironmentId = try reader["queueEnvironmentId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.priority = try reader["priority"].readIfPresent() ?? 0
        return value
    }
}

extension DeadlineClientTypes.QueueFleetAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.QueueFleetAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.QueueFleetAssociationSummary()
        value.queueId = try reader["queueId"].readIfPresent() ?? ""
        value.fleetId = try reader["fleetId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.QueueMember {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.QueueMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.QueueMember()
        value.farmId = try reader["farmId"].readIfPresent() ?? ""
        value.queueId = try reader["queueId"].readIfPresent() ?? ""
        value.principalId = try reader["principalId"].readIfPresent() ?? ""
        value.principalType = try reader["principalType"].readIfPresent() ?? .sdkUnknown("")
        value.identityStoreId = try reader["identityStoreId"].readIfPresent() ?? ""
        value.membershipLevel = try reader["membershipLevel"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeadlineClientTypes.QueueSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.QueueSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.QueueSummary()
        value.farmId = try reader["farmId"].readIfPresent() ?? ""
        value.queueId = try reader["queueId"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.defaultBudgetAction = try reader["defaultBudgetAction"].readIfPresent() ?? .sdkUnknown("")
        value.blockedReason = try reader["blockedReason"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.SessionActionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.SessionActionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.SessionActionSummary()
        value.sessionActionId = try reader["sessionActionId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.workerUpdatedAt = try reader["workerUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.progressPercent = try reader["progressPercent"].readIfPresent()
        value.definition = try reader["definition"].readIfPresent(with: DeadlineClientTypes.SessionActionDefinitionSummary.read(from:))
        return value
    }
}

extension DeadlineClientTypes.SessionActionDefinitionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.SessionActionDefinitionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "envEnter":
                return .enventer(try reader["envEnter"].read(with: DeadlineClientTypes.EnvironmentEnterSessionActionDefinitionSummary.read(from:)))
            case "envExit":
                return .envexit(try reader["envExit"].read(with: DeadlineClientTypes.EnvironmentExitSessionActionDefinitionSummary.read(from:)))
            case "taskRun":
                return .taskrun(try reader["taskRun"].read(with: DeadlineClientTypes.TaskRunSessionActionDefinitionSummary.read(from:)))
            case "syncInputJobAttachments":
                return .syncinputjobattachments(try reader["syncInputJobAttachments"].read(with: DeadlineClientTypes.SyncInputJobAttachmentsSessionActionDefinitionSummary.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DeadlineClientTypes.SyncInputJobAttachmentsSessionActionDefinitionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.SyncInputJobAttachmentsSessionActionDefinitionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.SyncInputJobAttachmentsSessionActionDefinitionSummary()
        value.stepId = try reader["stepId"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.TaskRunSessionActionDefinitionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.TaskRunSessionActionDefinitionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.TaskRunSessionActionDefinitionSummary()
        value.taskId = try reader["taskId"].readIfPresent() ?? ""
        value.stepId = try reader["stepId"].readIfPresent() ?? ""
        return value
    }
}

extension DeadlineClientTypes.EnvironmentExitSessionActionDefinitionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.EnvironmentExitSessionActionDefinitionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.EnvironmentExitSessionActionDefinitionSummary()
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        return value
    }
}

extension DeadlineClientTypes.EnvironmentEnterSessionActionDefinitionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.EnvironmentEnterSessionActionDefinitionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.EnvironmentEnterSessionActionDefinitionSummary()
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        return value
    }
}

extension DeadlineClientTypes.SessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.SessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.SessionSummary()
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.fleetId = try reader["fleetId"].readIfPresent() ?? ""
        value.workerId = try reader["workerId"].readIfPresent() ?? ""
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lifecycleStatus = try reader["lifecycleStatus"].readIfPresent() ?? .sdkUnknown("")
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.targetLifecycleStatus = try reader["targetLifecycleStatus"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.WorkerSessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.WorkerSessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.WorkerSessionSummary()
        value.sessionId = try reader["sessionId"].readIfPresent() ?? ""
        value.queueId = try reader["queueId"].readIfPresent() ?? ""
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lifecycleStatus = try reader["lifecycleStatus"].readIfPresent() ?? .sdkUnknown("")
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.targetLifecycleStatus = try reader["targetLifecycleStatus"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.StepConsumer {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.StepConsumer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.StepConsumer()
        value.stepId = try reader["stepId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeadlineClientTypes.StepDependency {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.StepDependency {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.StepDependency()
        value.stepId = try reader["stepId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeadlineClientTypes.StepSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.StepSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.StepSummary()
        value.stepId = try reader["stepId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.lifecycleStatus = try reader["lifecycleStatus"].readIfPresent() ?? .sdkUnknown("")
        value.lifecycleStatusMessage = try reader["lifecycleStatusMessage"].readIfPresent()
        value.taskRunStatus = try reader["taskRunStatus"].readIfPresent() ?? .sdkUnknown("")
        value.taskRunStatusCounts = try reader["taskRunStatusCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.targetTaskRunStatus = try reader["targetTaskRunStatus"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.dependencyCounts = try reader["dependencyCounts"].readIfPresent(with: DeadlineClientTypes.DependencyCounts.read(from:))
        return value
    }
}

extension DeadlineClientTypes.StorageProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.StorageProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.StorageProfileSummary()
        value.storageProfileId = try reader["storageProfileId"].readIfPresent() ?? ""
        value.displayName = try reader["displayName"].readIfPresent() ?? ""
        value.osFamily = try reader["osFamily"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeadlineClientTypes.TaskSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.TaskSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.TaskSummary()
        value.taskId = try reader["taskId"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.runStatus = try reader["runStatus"].readIfPresent() ?? .sdkUnknown("")
        value.targetRunStatus = try reader["targetRunStatus"].readIfPresent()
        value.failureRetryCount = try reader["failureRetryCount"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: DeadlineClientTypes.TaskParameterValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.latestSessionActionId = try reader["latestSessionActionId"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.WorkerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.WorkerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.WorkerSummary()
        value.workerId = try reader["workerId"].readIfPresent() ?? ""
        value.farmId = try reader["farmId"].readIfPresent() ?? ""
        value.fleetId = try reader["fleetId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.hostProperties = try reader["hostProperties"].readIfPresent(with: DeadlineClientTypes.HostPropertiesResponse.read(from:))
        value.log = try reader["log"].readIfPresent(with: DeadlineClientTypes.LogConfiguration.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.JobSearchSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.JobSearchSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.JobSearchSummary()
        value.jobId = try reader["jobId"].readIfPresent()
        value.queueId = try reader["queueId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.lifecycleStatus = try reader["lifecycleStatus"].readIfPresent()
        value.lifecycleStatusMessage = try reader["lifecycleStatusMessage"].readIfPresent()
        value.taskRunStatus = try reader["taskRunStatus"].readIfPresent()
        value.targetTaskRunStatus = try reader["targetTaskRunStatus"].readIfPresent()
        value.taskRunStatusCounts = try reader["taskRunStatusCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.priority = try reader["priority"].readIfPresent()
        value.maxFailedTasksCount = try reader["maxFailedTasksCount"].readIfPresent()
        value.maxRetriesPerTask = try reader["maxRetriesPerTask"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.jobParameters = try reader["jobParameters"].readMapIfPresent(valueReadingClosure: DeadlineClientTypes.JobParameter.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.sourceJobId = try reader["sourceJobId"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.StepSearchSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.StepSearchSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.StepSearchSummary()
        value.stepId = try reader["stepId"].readIfPresent()
        value.jobId = try reader["jobId"].readIfPresent()
        value.queueId = try reader["queueId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.lifecycleStatus = try reader["lifecycleStatus"].readIfPresent()
        value.lifecycleStatusMessage = try reader["lifecycleStatusMessage"].readIfPresent()
        value.taskRunStatus = try reader["taskRunStatus"].readIfPresent()
        value.targetTaskRunStatus = try reader["targetTaskRunStatus"].readIfPresent()
        value.taskRunStatusCounts = try reader["taskRunStatusCounts"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.parameterSpace = try reader["parameterSpace"].readIfPresent(with: DeadlineClientTypes.ParameterSpace.read(from:))
        return value
    }
}

extension DeadlineClientTypes.TaskSearchSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.TaskSearchSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.TaskSearchSummary()
        value.taskId = try reader["taskId"].readIfPresent()
        value.stepId = try reader["stepId"].readIfPresent()
        value.jobId = try reader["jobId"].readIfPresent()
        value.queueId = try reader["queueId"].readIfPresent()
        value.runStatus = try reader["runStatus"].readIfPresent()
        value.targetRunStatus = try reader["targetRunStatus"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: DeadlineClientTypes.TaskParameterValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.failureRetryCount = try reader["failureRetryCount"].readIfPresent()
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endedAt = try reader["endedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension DeadlineClientTypes.WorkerSearchSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.WorkerSearchSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.WorkerSearchSummary()
        value.fleetId = try reader["fleetId"].readIfPresent()
        value.workerId = try reader["workerId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.hostProperties = try reader["hostProperties"].readIfPresent(with: DeadlineClientTypes.HostPropertiesResponse.read(from:))
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension DeadlineClientTypes.AssignedSession {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.AssignedSession {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.AssignedSession()
        value.queueId = try reader["queueId"].readIfPresent() ?? ""
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.sessionActions = try reader["sessionActions"].readListIfPresent(memberReadingClosure: DeadlineClientTypes.AssignedSessionAction.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.logConfiguration = try reader["logConfiguration"].readIfPresent(with: DeadlineClientTypes.LogConfiguration.read(from:))
        return value
    }
}

extension DeadlineClientTypes.AssignedSessionAction {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.AssignedSessionAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.AssignedSessionAction()
        value.sessionActionId = try reader["sessionActionId"].readIfPresent() ?? ""
        value.definition = try reader["definition"].readIfPresent(with: DeadlineClientTypes.AssignedSessionActionDefinition.read(from:))
        return value
    }
}

extension DeadlineClientTypes.AssignedSessionActionDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.AssignedSessionActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "envEnter":
                return .enventer(try reader["envEnter"].read(with: DeadlineClientTypes.AssignedEnvironmentEnterSessionActionDefinition.read(from:)))
            case "envExit":
                return .envexit(try reader["envExit"].read(with: DeadlineClientTypes.AssignedEnvironmentExitSessionActionDefinition.read(from:)))
            case "taskRun":
                return .taskrun(try reader["taskRun"].read(with: DeadlineClientTypes.AssignedTaskRunSessionActionDefinition.read(from:)))
            case "syncInputJobAttachments":
                return .syncinputjobattachments(try reader["syncInputJobAttachments"].read(with: DeadlineClientTypes.AssignedSyncInputJobAttachmentsSessionActionDefinition.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension DeadlineClientTypes.AssignedSyncInputJobAttachmentsSessionActionDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.AssignedSyncInputJobAttachmentsSessionActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.AssignedSyncInputJobAttachmentsSessionActionDefinition()
        value.stepId = try reader["stepId"].readIfPresent()
        return value
    }
}

extension DeadlineClientTypes.AssignedTaskRunSessionActionDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.AssignedTaskRunSessionActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.AssignedTaskRunSessionActionDefinition()
        value.taskId = try reader["taskId"].readIfPresent() ?? ""
        value.stepId = try reader["stepId"].readIfPresent() ?? ""
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: DeadlineClientTypes.TaskParameterValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension DeadlineClientTypes.AssignedEnvironmentExitSessionActionDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.AssignedEnvironmentExitSessionActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.AssignedEnvironmentExitSessionActionDefinition()
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        return value
    }
}

extension DeadlineClientTypes.AssignedEnvironmentEnterSessionActionDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.AssignedEnvironmentEnterSessionActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.AssignedEnvironmentEnterSessionActionDefinition()
        value.environmentId = try reader["environmentId"].readIfPresent() ?? ""
        return value
    }
}

extension DeadlineClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> DeadlineClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeadlineClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension DeadlineClientTypes.JobEntityIdentifiersUnion {

    static func write(value: DeadlineClientTypes.JobEntityIdentifiersUnion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .environmentdetails(environmentdetails):
                try writer["environmentDetails"].write(environmentdetails, with: DeadlineClientTypes.EnvironmentDetailsIdentifiers.write(value:to:))
            case let .jobattachmentdetails(jobattachmentdetails):
                try writer["jobAttachmentDetails"].write(jobattachmentdetails, with: DeadlineClientTypes.JobAttachmentDetailsIdentifiers.write(value:to:))
            case let .jobdetails(jobdetails):
                try writer["jobDetails"].write(jobdetails, with: DeadlineClientTypes.JobDetailsIdentifiers.write(value:to:))
            case let .stepdetails(stepdetails):
                try writer["stepDetails"].write(stepdetails, with: DeadlineClientTypes.StepDetailsIdentifiers.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension DeadlineClientTypes.EnvironmentDetailsIdentifiers {

    static func write(value: DeadlineClientTypes.EnvironmentDetailsIdentifiers?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["environmentId"].write(value.environmentId)
        try writer["jobId"].write(value.jobId)
    }
}

extension DeadlineClientTypes.StepDetailsIdentifiers {

    static func write(value: DeadlineClientTypes.StepDetailsIdentifiers?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jobId"].write(value.jobId)
        try writer["stepId"].write(value.stepId)
    }
}

extension DeadlineClientTypes.JobAttachmentDetailsIdentifiers {

    static func write(value: DeadlineClientTypes.JobAttachmentDetailsIdentifiers?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jobId"].write(value.jobId)
    }
}

extension DeadlineClientTypes.JobDetailsIdentifiers {

    static func write(value: DeadlineClientTypes.JobDetailsIdentifiers?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jobId"].write(value.jobId)
    }
}

extension DeadlineClientTypes.S3Location {

    static func write(value: DeadlineClientTypes.S3Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["key"].write(value.key)
    }
}

extension DeadlineClientTypes.BudgetActionToAdd {

    static func write(value: DeadlineClientTypes.BudgetActionToAdd?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["thresholdPercentage"].write(value.thresholdPercentage)
        try writer["type"].write(value.type)
    }
}

extension DeadlineClientTypes.HostPropertiesRequest {

    static func write(value: DeadlineClientTypes.HostPropertiesRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["hostName"].write(value.hostName)
        try writer["ipAddresses"].write(value.ipAddresses, with: DeadlineClientTypes.IpAddresses.write(value:to:))
    }
}

extension DeadlineClientTypes.SearchGroupedFilterExpressions {

    static func write(value: DeadlineClientTypes.SearchGroupedFilterExpressions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: DeadlineClientTypes.SearchFilterExpression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["operator"].write(value.`operator`)
    }
}

extension DeadlineClientTypes.SearchFilterExpression {

    static func write(value: DeadlineClientTypes.SearchFilterExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .datetimefilter(datetimefilter):
                try writer["dateTimeFilter"].write(datetimefilter, with: DeadlineClientTypes.DateTimeFilterExpression.write(value:to:))
            case let .groupfilter(groupfilter):
                try writer["groupFilter"].write(groupfilter, with: DeadlineClientTypes.SearchGroupedFilterExpressions.write(value:to:))
            case let .parameterfilter(parameterfilter):
                try writer["parameterFilter"].write(parameterfilter, with: DeadlineClientTypes.ParameterFilterExpression.write(value:to:))
            case let .searchtermfilter(searchtermfilter):
                try writer["searchTermFilter"].write(searchtermfilter, with: DeadlineClientTypes.SearchTermFilterExpression.write(value:to:))
            case let .stringfilter(stringfilter):
                try writer["stringFilter"].write(stringfilter, with: DeadlineClientTypes.StringFilterExpression.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension DeadlineClientTypes.StringFilterExpression {

    static func write(value: DeadlineClientTypes.StringFilterExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["operator"].write(value.`operator`)
        try writer["value"].write(value.value)
    }
}

extension DeadlineClientTypes.SearchTermFilterExpression {

    static func write(value: DeadlineClientTypes.SearchTermFilterExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["searchTerm"].write(value.searchTerm)
    }
}

extension DeadlineClientTypes.ParameterFilterExpression {

    static func write(value: DeadlineClientTypes.ParameterFilterExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["operator"].write(value.`operator`)
        try writer["value"].write(value.value)
    }
}

extension DeadlineClientTypes.DateTimeFilterExpression {

    static func write(value: DeadlineClientTypes.DateTimeFilterExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dateTime"].writeTimestamp(value.dateTime, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["name"].write(value.name)
        try writer["operator"].write(value.`operator`)
    }
}

extension DeadlineClientTypes.SearchSortExpression {

    static func write(value: DeadlineClientTypes.SearchSortExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .fieldsort(fieldsort):
                try writer["fieldSort"].write(fieldsort, with: DeadlineClientTypes.FieldSortExpression.write(value:to:))
            case let .parametersort(parametersort):
                try writer["parameterSort"].write(parametersort, with: DeadlineClientTypes.ParameterSortExpression.write(value:to:))
            case let .userjobsfirst(userjobsfirst):
                try writer["userJobsFirst"].write(userjobsfirst, with: DeadlineClientTypes.UserJobsFirst.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension DeadlineClientTypes.ParameterSortExpression {

    static func write(value: DeadlineClientTypes.ParameterSortExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension DeadlineClientTypes.FieldSortExpression {

    static func write(value: DeadlineClientTypes.FieldSortExpression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension DeadlineClientTypes.UserJobsFirst {

    static func write(value: DeadlineClientTypes.UserJobsFirst?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["userIdentityId"].write(value.userIdentityId)
    }
}

extension DeadlineClientTypes.SessionsStatisticsResources {

    static func write(value: DeadlineClientTypes.SessionsStatisticsResources?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .fleetids(fleetids):
                try writer["fleetIds"].writeList(fleetids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .queueids(queueids):
                try writer["queueIds"].writeList(queueids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension DeadlineClientTypes.BudgetActionToRemove {

    static func write(value: DeadlineClientTypes.BudgetActionToRemove?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["thresholdPercentage"].write(value.thresholdPercentage)
        try writer["type"].write(value.type)
    }
}

extension DeadlineClientTypes.WorkerCapabilities {

    static func write(value: DeadlineClientTypes.WorkerCapabilities?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["amounts"].writeList(value.amounts, memberWritingClosure: DeadlineClientTypes.WorkerAmountCapability.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["attributes"].writeList(value.attributes, memberWritingClosure: DeadlineClientTypes.WorkerAttributeCapability.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeadlineClientTypes.WorkerAttributeCapability {

    static func write(value: DeadlineClientTypes.WorkerAttributeCapability?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeadlineClientTypes.WorkerAmountCapability {

    static func write(value: DeadlineClientTypes.WorkerAmountCapability?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].write(value.value)
    }
}

extension DeadlineClientTypes.UpdatedSessionActionInfo {

    static func write(value: DeadlineClientTypes.UpdatedSessionActionInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["completedStatus"].write(value.completedStatus)
        try writer["endedAt"].writeTimestamp(value.endedAt, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["processExitCode"].write(value.processExitCode)
        try writer["progressMessage"].write(value.progressMessage)
        try writer["progressPercent"].write(value.progressPercent)
        try writer["startedAt"].writeTimestamp(value.startedAt, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["updatedAt"].writeTimestamp(value.updatedAt, format: SmithyTimestamps.TimestampFormat.dateTime)
    }
}

public enum DeadlineClientTypes {}
