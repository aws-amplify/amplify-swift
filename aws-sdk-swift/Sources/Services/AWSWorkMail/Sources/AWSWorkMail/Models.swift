//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

extension WorkMailClientTypes {

    public enum AccessControlRuleEffect: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessControlRuleEffect] {
            return [
                .allow,
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkMailClientTypes {
    /// A rule that controls access to an WorkMail organization.
    public struct AccessControlRule {
        /// Access protocol actions to include in the rule. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
        public var actions: [Swift.String]?
        /// The date that the rule was created.
        public var dateCreated: Foundation.Date?
        /// The date that the rule was modified.
        public var dateModified: Foundation.Date?
        /// The rule description.
        public var description: Swift.String?
        /// The rule effect.
        public var effect: WorkMailClientTypes.AccessControlRuleEffect?
        /// Impersonation role IDs to include in the rule.
        public var impersonationRoleIds: [Swift.String]?
        /// IPv4 CIDR ranges to include in the rule.
        public var ipRanges: [Swift.String]?
        /// The rule name.
        public var name: Swift.String?
        /// Access protocol actions to exclude from the rule. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
        public var notActions: [Swift.String]?
        /// Impersonation role IDs to exclude from the rule.
        public var notImpersonationRoleIds: [Swift.String]?
        /// IPv4 CIDR ranges to exclude from the rule.
        public var notIpRanges: [Swift.String]?
        /// User IDs to exclude from the rule.
        public var notUserIds: [Swift.String]?
        /// User IDs to include in the rule.
        public var userIds: [Swift.String]?

        public init(
            actions: [Swift.String]? = nil,
            dateCreated: Foundation.Date? = nil,
            dateModified: Foundation.Date? = nil,
            description: Swift.String? = nil,
            effect: WorkMailClientTypes.AccessControlRuleEffect? = nil,
            impersonationRoleIds: [Swift.String]? = nil,
            ipRanges: [Swift.String]? = nil,
            name: Swift.String? = nil,
            notActions: [Swift.String]? = nil,
            notImpersonationRoleIds: [Swift.String]? = nil,
            notIpRanges: [Swift.String]? = nil,
            notUserIds: [Swift.String]? = nil,
            userIds: [Swift.String]? = nil
        )
        {
            self.actions = actions
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.description = description
            self.effect = effect
            self.impersonationRoleIds = impersonationRoleIds
            self.ipRanges = ipRanges
            self.name = name
            self.notActions = notActions
            self.notImpersonationRoleIds = notImpersonationRoleIds
            self.notIpRanges = notIpRanges
            self.notUserIds = notUserIds
            self.userIds = userIds
        }
    }

}

extension WorkMailClientTypes {

    public enum AccessEffect: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessEffect] {
            return [
                .allow,
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The identifier supplied for the user, group, or resource does not exist in your organization.
public struct EntityNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You are performing an operation on a user, group, or resource that isn't in the expected state, such as trying to delete an active user.
public struct EntityStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// One or more of the input parameters don't match the service's restrictions.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An operation received a valid organization identifier that either doesn't belong or exist in the system.
public struct OrganizationNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OrganizationNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The organization must have a valid state to perform certain operations on the organization or its members.
public struct OrganizationStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OrganizationStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You can't perform a write operation against a read-only directory.
public struct UnsupportedOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedOperationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateDelegateToResourceInput {
    /// The member (user or group) to associate to the resource. The entity ID can accept UserId or GroupID, Username or Groupname, or email.
    ///
    /// * Entity: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: entity@domain.tld
    ///
    /// * Entity: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// The organization under which the resource exists.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The resource for which members (users or groups) are associated. The identifier can accept ResourceId, Resourcename, or email. The following identity formats are available:
    ///
    /// * Resource ID: r-0123456789a0123456789b0123456789
    ///
    /// * Email address: resource@domain.tld
    ///
    /// * Resource name: resource
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

public struct AssociateDelegateToResourceOutput {

    public init() { }
}

/// The directory service doesn't recognize the credentials supplied by WorkMail.
public struct DirectoryServiceAuthenticationFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryServiceAuthenticationFailedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The directory is unavailable. It might be located in another Region or deleted.
public struct DirectoryUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateMemberToGroupInput {
    /// The group to which the member (user or group) is associated. The identifier can accept GroupId, Groupname, or email. The following identity formats are available:
    ///
    /// * Group ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: group@domain.tld
    ///
    /// * Group name: group
    /// This member is required.
    public var groupId: Swift.String?
    /// The member (user or group) to associate to the group. The member ID can accept UserID or GroupId, Username or Groupname, or email.
    ///
    /// * Member: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: member@domain.tld
    ///
    /// * Member name: member
    /// This member is required.
    public var memberId: Swift.String?
    /// The organization under which the group exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.memberId = memberId
        self.organizationId = organizationId
    }
}

public struct AssociateMemberToGroupOutput {

    public init() { }
}

/// The resource cannot be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssumeImpersonationRoleInput {
    /// The impersonation role ID to assume.
    /// This member is required.
    public var impersonationRoleId: Swift.String?
    /// The WorkMail organization under which the impersonation role will be assumed.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        impersonationRoleId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.impersonationRoleId = impersonationRoleId
        self.organizationId = organizationId
    }
}

public struct AssumeImpersonationRoleOutput {
    /// The authentication token's validity, in seconds.
    public var expiresIn: Swift.Int?
    /// The authentication token for the impersonation role.
    public var token: Swift.String?

    public init(
        expiresIn: Swift.Int? = nil,
        token: Swift.String? = nil
    )
    {
        self.expiresIn = expiresIn
        self.token = token
    }
}

extension WorkMailClientTypes {
    /// Describes an EWS based availability provider when returned from the service. It does not contain the password of the endpoint.
    public struct RedactedEwsAvailabilityProvider {
        /// The endpoint of the remote EWS server.
        public var ewsEndpoint: Swift.String?
        /// The username used to authenticate the remote EWS server.
        public var ewsUsername: Swift.String?

        public init(
            ewsEndpoint: Swift.String? = nil,
            ewsUsername: Swift.String? = nil
        )
        {
            self.ewsEndpoint = ewsEndpoint
            self.ewsUsername = ewsUsername
        }
    }

}

extension WorkMailClientTypes {
    /// Describes a Lambda based availability provider.
    public struct LambdaAvailabilityProvider {
        /// The Amazon Resource Name (ARN) of the Lambda that acts as the availability provider.
        /// This member is required.
        public var lambdaArn: Swift.String?

        public init(
            lambdaArn: Swift.String? = nil
        )
        {
            self.lambdaArn = lambdaArn
        }
    }

}

extension WorkMailClientTypes {

    public enum AvailabilityProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ews
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [AvailabilityProviderType] {
            return [
                .ews,
                .lambda
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ews: return "EWS"
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkMailClientTypes {
    /// List all the AvailabilityConfiguration's for the given WorkMail organization.
    public struct AvailabilityConfiguration {
        /// The date and time at which the availability configuration was created.
        public var dateCreated: Foundation.Date?
        /// The date and time at which the availability configuration was last modified.
        public var dateModified: Foundation.Date?
        /// Displays the domain to which the provider applies.
        public var domainName: Swift.String?
        /// If ProviderType is EWS, then this field contains RedactedEwsAvailabilityProvider. Otherwise, it is not required.
        public var ewsProvider: WorkMailClientTypes.RedactedEwsAvailabilityProvider?
        /// If ProviderType is LAMBDA then this field contains LambdaAvailabilityProvider. Otherwise, it is not required.
        public var lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider?
        /// Displays the provider type that applies to this domain.
        public var providerType: WorkMailClientTypes.AvailabilityProviderType?

        public init(
            dateCreated: Foundation.Date? = nil,
            dateModified: Foundation.Date? = nil,
            domainName: Swift.String? = nil,
            ewsProvider: WorkMailClientTypes.RedactedEwsAvailabilityProvider? = nil,
            lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider? = nil,
            providerType: WorkMailClientTypes.AvailabilityProviderType? = nil
        )
        {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.domainName = domainName
            self.ewsProvider = ewsProvider
            self.lambdaProvider = lambdaProvider
            self.providerType = providerType
        }
    }

}

extension WorkMailClientTypes {
    /// At least one delegate must be associated to the resource to disable automatic replies from the resource.
    public struct BookingOptions {
        /// The resource's ability to automatically reply to requests. If disabled, delegates must be associated to the resource.
        public var autoAcceptRequests: Swift.Bool
        /// The resource's ability to automatically decline any conflicting requests.
        public var autoDeclineConflictingRequests: Swift.Bool
        /// The resource's ability to automatically decline any recurring requests.
        public var autoDeclineRecurringRequests: Swift.Bool

        public init(
            autoAcceptRequests: Swift.Bool = false,
            autoDeclineConflictingRequests: Swift.Bool = false,
            autoDeclineRecurringRequests: Swift.Bool = false
        )
        {
            self.autoAcceptRequests = autoAcceptRequests
            self.autoDeclineConflictingRequests = autoDeclineConflictingRequests
            self.autoDeclineRecurringRequests = autoDeclineRecurringRequests
        }
    }

}

public struct CancelMailboxExportJobInput {
    /// The idempotency token for the client request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The job ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        jobId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.jobId = jobId
        self.organizationId = organizationId
    }
}

public struct CancelMailboxExportJobOutput {

    public init() { }
}

/// The email address that you're trying to assign is already created for a different user, group, or resource.
public struct EmailAddressInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EmailAddressInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request exceeds the limit of the resource.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The domain specified is not found in your organization.
public struct MailDomainNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MailDomainNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// After a domain has been added to the organization, it must be verified. The domain is not yet verified.
public struct MailDomainStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MailDomainStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateAliasInput {
    /// The alias to add to the member set.
    /// This member is required.
    public var alias: Swift.String?
    /// The member (user or group) to which this alias is added.
    /// This member is required.
    public var entityId: Swift.String?
    /// The organization under which the member (user or group) exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

public struct CreateAliasOutput {

    public init() { }
}

/// The user, group, or resource name isn't unique in WorkMail.
public struct NameAvailabilityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NameAvailabilityException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension WorkMailClientTypes {
    /// Describes an EWS based availability provider. This is only used as input to the service.
    public struct EwsAvailabilityProvider {
        /// The endpoint of the remote EWS server.
        /// This member is required.
        public var ewsEndpoint: Swift.String?
        /// The password used to authenticate the remote EWS server.
        /// This member is required.
        public var ewsPassword: Swift.String?
        /// The username used to authenticate the remote EWS server.
        /// This member is required.
        public var ewsUsername: Swift.String?

        public init(
            ewsEndpoint: Swift.String? = nil,
            ewsPassword: Swift.String? = nil,
            ewsUsername: Swift.String? = nil
        )
        {
            self.ewsEndpoint = ewsEndpoint
            self.ewsPassword = ewsPassword
            self.ewsUsername = ewsUsername
        }
    }

}

extension WorkMailClientTypes.EwsAvailabilityProvider: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EwsAvailabilityProvider(ewsEndpoint: \(Swift.String(describing: ewsEndpoint)), ewsUsername: \(Swift.String(describing: ewsUsername)), ewsPassword: \"CONTENT_REDACTED\")"}
}

public struct CreateAvailabilityConfigurationInput {
    /// An idempotent token that ensures that an API request is executed only once.
    public var clientToken: Swift.String?
    /// The domain to which the provider applies.
    /// This member is required.
    public var domainName: Swift.String?
    /// Exchange Web Services (EWS) availability provider definition. The request must contain exactly one provider definition, either EwsProvider or LambdaProvider.
    public var ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider?
    /// Lambda availability provider definition. The request must contain exactly one provider definition, either EwsProvider or LambdaProvider.
    public var lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider?
    /// The WorkMail organization for which the AvailabilityConfiguration will be created.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        domainName: Swift.String? = nil,
        ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider? = nil,
        lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.domainName = domainName
        self.ewsProvider = ewsProvider
        self.lambdaProvider = lambdaProvider
        self.organizationId = organizationId
    }
}

public struct CreateAvailabilityConfigurationOutput {

    public init() { }
}

/// This user, group, or resource name is not allowed in WorkMail.
public struct ReservedNameException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReservedNameException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateGroupInput {
    /// If this parameter is enabled, the group will be hidden from the address book.
    public var hiddenFromGlobalAddressList: Swift.Bool?
    /// The name of the group.
    /// This member is required.
    public var name: Swift.String?
    /// The organization under which the group is to be created.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        hiddenFromGlobalAddressList: Swift.Bool? = false,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
        self.name = name
        self.organizationId = organizationId
    }
}

public struct CreateGroupOutput {
    /// The identifier of the group.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

extension WorkMailClientTypes {
    /// The rules for the given impersonation role.
    public struct ImpersonationRule {
        /// The rule description.
        public var description: Swift.String?
        /// The effect of the rule when it matches the input. Allowed effect values are ALLOW or DENY.
        /// This member is required.
        public var effect: WorkMailClientTypes.AccessEffect?
        /// The identifier of the rule.
        /// This member is required.
        public var impersonationRuleId: Swift.String?
        /// The rule name.
        public var name: Swift.String?
        /// A list of user IDs that don't match the rule.
        public var notTargetUsers: [Swift.String]?
        /// A list of user IDs that match the rule.
        public var targetUsers: [Swift.String]?

        public init(
            description: Swift.String? = nil,
            effect: WorkMailClientTypes.AccessEffect? = nil,
            impersonationRuleId: Swift.String? = nil,
            name: Swift.String? = nil,
            notTargetUsers: [Swift.String]? = nil,
            targetUsers: [Swift.String]? = nil
        )
        {
            self.description = description
            self.effect = effect
            self.impersonationRuleId = impersonationRuleId
            self.name = name
            self.notTargetUsers = notTargetUsers
            self.targetUsers = targetUsers
        }
    }

}

extension WorkMailClientTypes {

    public enum ImpersonationRoleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fullAccess
        case readOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [ImpersonationRoleType] {
            return [
                .fullAccess,
                .readOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fullAccess: return "FULL_ACCESS"
            case .readOnly: return "READ_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateImpersonationRoleInput {
    /// The idempotency token for the client request.
    public var clientToken: Swift.String?
    /// The description of the new impersonation role.
    public var description: Swift.String?
    /// The name of the new impersonation role.
    /// This member is required.
    public var name: Swift.String?
    /// The WorkMail organization to create the new impersonation role within.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The list of rules for the impersonation role.
    /// This member is required.
    public var rules: [WorkMailClientTypes.ImpersonationRule]?
    /// The impersonation role's type. The available impersonation role types are READ_ONLY or FULL_ACCESS.
    /// This member is required.
    public var type: WorkMailClientTypes.ImpersonationRoleType?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        rules: [WorkMailClientTypes.ImpersonationRule]? = nil,
        type: WorkMailClientTypes.ImpersonationRoleType? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.organizationId = organizationId
        self.rules = rules
        self.type = type
    }
}

public struct CreateImpersonationRoleOutput {
    /// The new impersonation role ID.
    public var impersonationRoleId: Swift.String?

    public init(
        impersonationRoleId: Swift.String? = nil
    )
    {
        self.impersonationRoleId = impersonationRoleId
    }
}

extension WorkMailClientTypes {

    public enum MobileDeviceAccessRuleEffect: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [MobileDeviceAccessRuleEffect] {
            return [
                .allow,
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateMobileDeviceAccessRuleInput {
    /// The idempotency token for the client request.
    public var clientToken: Swift.String?
    /// The rule description.
    public var description: Swift.String?
    /// Device models that the rule will match.
    public var deviceModels: [Swift.String]?
    /// Device operating systems that the rule will match.
    public var deviceOperatingSystems: [Swift.String]?
    /// Device types that the rule will match.
    public var deviceTypes: [Swift.String]?
    /// Device user agents that the rule will match.
    public var deviceUserAgents: [Swift.String]?
    /// The effect of the rule when it matches. Allowed values are ALLOW or DENY.
    /// This member is required.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// The rule name.
    /// This member is required.
    public var name: Swift.String?
    /// Device models that the rule will not match. All other device models will match.
    public var notDeviceModels: [Swift.String]?
    /// Device operating systems that the rule will not match. All other device operating systems will match.
    public var notDeviceOperatingSystems: [Swift.String]?
    /// Device types that the rule will not match. All other device types will match.
    public var notDeviceTypes: [Swift.String]?
    /// Device user agents that the rule will not match. All other device user agents will match.
    public var notDeviceUserAgents: [Swift.String]?
    /// The WorkMail organization under which the rule will be created.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        deviceModels: [Swift.String]? = nil,
        deviceOperatingSystems: [Swift.String]? = nil,
        deviceTypes: [Swift.String]? = nil,
        deviceUserAgents: [Swift.String]? = nil,
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        name: Swift.String? = nil,
        notDeviceModels: [Swift.String]? = nil,
        notDeviceOperatingSystems: [Swift.String]? = nil,
        notDeviceTypes: [Swift.String]? = nil,
        notDeviceUserAgents: [Swift.String]? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.deviceModels = deviceModels
        self.deviceOperatingSystems = deviceOperatingSystems
        self.deviceTypes = deviceTypes
        self.deviceUserAgents = deviceUserAgents
        self.effect = effect
        self.name = name
        self.notDeviceModels = notDeviceModels
        self.notDeviceOperatingSystems = notDeviceOperatingSystems
        self.notDeviceTypes = notDeviceTypes
        self.notDeviceUserAgents = notDeviceUserAgents
        self.organizationId = organizationId
    }
}

public struct CreateMobileDeviceAccessRuleOutput {
    /// The identifier for the newly created mobile device access rule.
    public var mobileDeviceAccessRuleId: Swift.String?

    public init(
        mobileDeviceAccessRuleId: Swift.String? = nil
    )
    {
        self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
    }
}

/// The directory is already in use by another WorkMail organization in the same account and Region.
public struct DirectoryInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectoryInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension WorkMailClientTypes {
    /// The domain to associate with an WorkMail organization. When you configure a domain hosted in Amazon Route 53 (Route 53), all recommended DNS records are added to the organization when you create it. For more information, see [Adding a domain](https://docs.aws.amazon.com/workmail/latest/adminguide/add_domain.html) in the WorkMail Administrator Guide.
    public struct Domain {
        /// The fully qualified domain name.
        /// This member is required.
        public var domainName: Swift.String?
        /// The hosted zone ID for a domain hosted in Route 53. Required when configuring a domain hosted in Route 53.
        public var hostedZoneId: Swift.String?

        public init(
            domainName: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.hostedZoneId = hostedZoneId
        }
    }

}

public struct CreateOrganizationInput {
    /// The organization alias.
    /// This member is required.
    public var alias: Swift.String?
    /// The idempotency token associated with the request.
    public var clientToken: Swift.String?
    /// The AWS Directory Service directory ID.
    public var directoryId: Swift.String?
    /// The email domains to associate with the organization.
    public var domains: [WorkMailClientTypes.Domain]?
    /// When true, allows organization interoperability between WorkMail and Microsoft Exchange. If true, you must include a AD Connector directory ID in the request.
    public var enableInteroperability: Swift.Bool?
    /// The Amazon Resource Name (ARN) of a customer managed key from AWS KMS.
    public var kmsKeyArn: Swift.String?

    public init(
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        domains: [WorkMailClientTypes.Domain]? = nil,
        enableInteroperability: Swift.Bool? = false,
        kmsKeyArn: Swift.String? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.directoryId = directoryId
        self.domains = domains
        self.enableInteroperability = enableInteroperability
        self.kmsKeyArn = kmsKeyArn
    }
}

public struct CreateOrganizationOutput {
    /// The organization ID.
    public var organizationId: Swift.String?

    public init(
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

extension WorkMailClientTypes {

    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equipment
        case room
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .equipment,
                .room
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equipment: return "EQUIPMENT"
            case .room: return "ROOM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateResourceInput {
    /// Resource description.
    public var description: Swift.String?
    /// If this parameter is enabled, the resource will be hidden from the address book.
    public var hiddenFromGlobalAddressList: Swift.Bool?
    /// The name of the new resource.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier associated with the organization for which the resource is created.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The type of the new resource. The available types are equipment and room.
    /// This member is required.
    public var type: WorkMailClientTypes.ResourceType?

    public init(
        description: Swift.String? = nil,
        hiddenFromGlobalAddressList: Swift.Bool? = false,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        type: WorkMailClientTypes.ResourceType? = nil
    )
    {
        self.description = description
        self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
        self.name = name
        self.organizationId = organizationId
        self.type = type
    }
}

public struct CreateResourceOutput {
    /// The identifier of the new resource.
    public var resourceId: Swift.String?

    public init(
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

/// The supplied password doesn't match the minimum security constraints, such as length or use of special characters.
public struct InvalidPasswordException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPasswordException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension WorkMailClientTypes {

    public enum UserRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case remoteUser
        case resource
        case systemUser
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [UserRole] {
            return [
                .remoteUser,
                .resource,
                .systemUser,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .remoteUser: return "REMOTE_USER"
            case .resource: return "RESOURCE"
            case .systemUser: return "SYSTEM_USER"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateUserInput {
    /// The display name for the new user.
    /// This member is required.
    public var displayName: Swift.String?
    /// The first name of the new user.
    public var firstName: Swift.String?
    /// If this parameter is enabled, the user will be hidden from the address book.
    public var hiddenFromGlobalAddressList: Swift.Bool?
    /// The last name of the new user.
    public var lastName: Swift.String?
    /// The name for the new user. WorkMail directory user names have a maximum length of 64. All others have a maximum length of 20.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the organization for which the user is created.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The password for the new user.
    public var password: Swift.String?
    /// The role of the new user. You cannot pass SYSTEM_USER or RESOURCE role in a single request. When a user role is not selected, the default role of USER is selected.
    public var role: WorkMailClientTypes.UserRole?

    public init(
        displayName: Swift.String? = nil,
        firstName: Swift.String? = nil,
        hiddenFromGlobalAddressList: Swift.Bool? = false,
        lastName: Swift.String? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        password: Swift.String? = nil,
        role: WorkMailClientTypes.UserRole? = nil
    )
    {
        self.displayName = displayName
        self.firstName = firstName
        self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
        self.lastName = lastName
        self.name = name
        self.organizationId = organizationId
        self.password = password
        self.role = role
    }
}

extension CreateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserInput(hiddenFromGlobalAddressList: \(Swift.String(describing: hiddenFromGlobalAddressList)), name: \(Swift.String(describing: name)), organizationId: \(Swift.String(describing: organizationId)), role: \(Swift.String(describing: role)), displayName: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", password: \"CONTENT_REDACTED\")"}
}

public struct CreateUserOutput {
    /// The identifier for the new user.
    public var userId: Swift.String?

    public init(
        userId: Swift.String? = nil
    )
    {
        self.userId = userId
    }
}

extension WorkMailClientTypes {

    public enum MemberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case group
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberType] {
            return [
                .group,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkMailClientTypes {
    /// The name of the attribute, which is one of the values defined in the UserAttribute enumeration.
    public struct Delegate {
        /// The identifier for the user or group associated as the resource's delegate.
        /// This member is required.
        public var id: Swift.String?
        /// The type of the delegate: user or group.
        /// This member is required.
        public var type: WorkMailClientTypes.MemberType?

        public init(
            id: Swift.String? = nil,
            type: WorkMailClientTypes.MemberType? = nil
        )
        {
            self.id = id
            self.type = type
        }
    }

}

public struct DeleteAccessControlRuleInput {
    /// The name of the access control rule.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier for the organization.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.name = name
        self.organizationId = organizationId
    }
}

public struct DeleteAccessControlRuleOutput {

    public init() { }
}

public struct DeleteAliasInput {
    /// The aliases to be removed from the user's set of aliases. Duplicate entries in the list are collapsed into single entries (the list is transformed into a set).
    /// This member is required.
    public var alias: Swift.String?
    /// The identifier for the member (user or group) from which to have the aliases removed.
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier for the organization under which the user exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

public struct DeleteAliasOutput {

    public init() { }
}

public struct DeleteAvailabilityConfigurationInput {
    /// The domain for which the AvailabilityConfiguration will be deleted.
    /// This member is required.
    public var domainName: Swift.String?
    /// The WorkMail organization for which the AvailabilityConfiguration will be deleted.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.organizationId = organizationId
    }
}

public struct DeleteAvailabilityConfigurationOutput {

    public init() { }
}

public struct DeleteEmailMonitoringConfigurationInput {
    /// The ID of the organization from which the email monitoring configuration is deleted.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

public struct DeleteEmailMonitoringConfigurationOutput {

    public init() { }
}

public struct DeleteGroupInput {
    /// The identifier of the group to be deleted. The identifier can be the GroupId, or Groupname. The following identity formats are available:
    ///
    /// * Group ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Group name: group
    /// This member is required.
    public var groupId: Swift.String?
    /// The organization that contains the group.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.organizationId = organizationId
    }
}

public struct DeleteGroupOutput {

    public init() { }
}

public struct DeleteImpersonationRoleInput {
    /// The ID of the impersonation role to delete.
    /// This member is required.
    public var impersonationRoleId: Swift.String?
    /// The WorkMail organization from which to delete the impersonation role.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        impersonationRoleId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.impersonationRoleId = impersonationRoleId
        self.organizationId = organizationId
    }
}

public struct DeleteImpersonationRoleOutput {

    public init() { }
}

public struct DeleteMailboxPermissionsInput {
    /// The identifier of the entity that owns the mailbox. The identifier can be UserId or Group Id, Username or Groupname, or email.
    ///
    /// * Entity ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: entity@domain.tld
    ///
    /// * Entity name: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier of the entity for which to delete granted permissions. The identifier can be UserId, ResourceID, or Group Id, Username or Groupname, or email.
    ///
    /// * Grantee ID: 12345678-1234-1234-1234-123456789012,r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: grantee@domain.tld
    ///
    /// * Grantee name: grantee
    /// This member is required.
    public var granteeId: Swift.String?
    /// The identifier of the organization under which the member (user or group) exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        granteeId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.granteeId = granteeId
        self.organizationId = organizationId
    }
}

public struct DeleteMailboxPermissionsOutput {

    public init() { }
}

public struct DeleteMobileDeviceAccessOverrideInput {
    /// The mobile device for which you delete the override. DeviceId is case insensitive.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The WorkMail organization for which the access override will be deleted.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The WorkMail user for which you want to delete the override. Accepts the following types of user identities:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var userId: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.organizationId = organizationId
        self.userId = userId
    }
}

public struct DeleteMobileDeviceAccessOverrideOutput {

    public init() { }
}

public struct DeleteMobileDeviceAccessRuleInput {
    /// The identifier of the rule to be deleted.
    /// This member is required.
    public var mobileDeviceAccessRuleId: Swift.String?
    /// The WorkMail organization under which the rule will be deleted.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        mobileDeviceAccessRuleId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
        self.organizationId = organizationId
    }
}

public struct DeleteMobileDeviceAccessRuleOutput {

    public init() { }
}

public struct DeleteOrganizationInput {
    /// The idempotency token associated with the request.
    public var clientToken: Swift.String?
    /// If true, deletes the AWS Directory Service directory associated with the organization.
    /// This member is required.
    public var deleteDirectory: Swift.Bool?
    /// Deletes a WorkMail organization even if the organization has enabled users.
    public var forceDelete: Swift.Bool?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        deleteDirectory: Swift.Bool? = false,
        forceDelete: Swift.Bool? = false,
        organizationId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.deleteDirectory = deleteDirectory
        self.forceDelete = forceDelete
        self.organizationId = organizationId
    }
}

public struct DeleteOrganizationOutput {
    /// The organization ID.
    public var organizationId: Swift.String?
    /// The state of the organization.
    public var state: Swift.String?

    public init(
        organizationId: Swift.String? = nil,
        state: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.state = state
    }
}

public struct DeleteResourceInput {
    /// The identifier associated with the organization from which the resource is deleted.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the resource to be deleted. The identifier can accept ResourceId, or Resourcename. The following identity formats are available:
    ///
    /// * Resource ID: r-0123456789a0123456789b0123456789
    ///
    /// * Resource name: resource
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

public struct DeleteResourceOutput {

    public init() { }
}

public struct DeleteRetentionPolicyInput {
    /// The retention policy ID.
    /// This member is required.
    public var id: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        id: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.id = id
        self.organizationId = organizationId
    }
}

public struct DeleteRetentionPolicyOutput {

    public init() { }
}

public struct DeleteUserInput {
    /// The organization that contains the user to be deleted.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the user to be deleted. The identifier can be the UserId or Username. The following identity formats are available:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * User name: user
    /// This member is required.
    public var userId: Swift.String?

    public init(
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.userId = userId
    }
}

public struct DeleteUserOutput {

    public init() { }
}

public struct DeregisterFromWorkMailInput {
    /// The identifier for the member to be updated. The identifier can be UserId, ResourceId, or Group Id, Username, Resourcename, or Groupname, or email.
    ///
    /// * Entity ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: entity@domain.tld
    ///
    /// * Entity name: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier for the organization under which the WorkMail entity exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

public struct DeregisterFromWorkMailOutput {

    public init() { }
}

/// You SES configuration has customizations that WorkMail cannot save. The error message lists the invalid setting. For examples of invalid settings, refer to [CreateReceiptRule](https://docs.aws.amazon.com/ses/latest/APIReference/API_CreateReceiptRule.html).
public struct InvalidCustomSesConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCustomSesConfigurationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The domain you're trying to change is in use by another user or organization in your account. See the error message for details.
public struct MailDomainInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MailDomainInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeregisterMailDomainInput {
    /// The domain to deregister in WorkMail and SES.
    /// This member is required.
    public var domainName: Swift.String?
    /// The WorkMail organization for which the domain will be deregistered.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.organizationId = organizationId
    }
}

public struct DeregisterMailDomainOutput {

    public init() { }
}

public struct DescribeEmailMonitoringConfigurationInput {
    /// The ID of the organization for which the email monitoring configuration is described.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

public struct DescribeEmailMonitoringConfigurationOutput {
    /// The Amazon Resource Name (ARN) of the CloudWatch Log group associated with the email monitoring configuration.
    public var logGroupArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM Role associated with the email monitoring configuration.
    public var roleArn: Swift.String?

    public init(
        logGroupArn: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.logGroupArn = logGroupArn
        self.roleArn = roleArn
    }
}

public struct DescribeEntityInput {
    /// The email under which the entity exists.
    /// This member is required.
    public var email: Swift.String?
    /// The identifier for the organization under which the entity exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        email: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.email = email
        self.organizationId = organizationId
    }
}

extension WorkMailClientTypes {

    public enum EntityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case group
        case resource
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityType] {
            return [
                .group,
                .resource,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .resource: return "RESOURCE"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeEntityOutput {
    /// The entity ID under which the entity exists.
    public var entityId: Swift.String?
    /// Username, GroupName, or ResourceName based on entity type.
    public var name: Swift.String?
    /// Entity type.
    public var type: WorkMailClientTypes.EntityType?

    public init(
        entityId: Swift.String? = nil,
        name: Swift.String? = nil,
        type: WorkMailClientTypes.EntityType? = nil
    )
    {
        self.entityId = entityId
        self.name = name
        self.type = type
    }
}

public struct DescribeGroupInput {
    /// The identifier for the group to be described. The identifier can accept GroupId, Groupname, or email. The following identity formats are available:
    ///
    /// * Group ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: group@domain.tld
    ///
    /// * Group name: group
    /// This member is required.
    public var groupId: Swift.String?
    /// The identifier for the organization under which the group exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.organizationId = organizationId
    }
}

extension WorkMailClientTypes {

    public enum EntityState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleted
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityState] {
            return [
                .deleted,
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeGroupOutput {
    /// The date and time when a user was deregistered from WorkMail, in UNIX epoch time format.
    public var disabledDate: Foundation.Date?
    /// The email of the described group.
    public var email: Swift.String?
    /// The date and time when a user was registered to WorkMail, in UNIX epoch time format.
    public var enabledDate: Foundation.Date?
    /// The identifier of the described group.
    public var groupId: Swift.String?
    /// If the value is set to true, the group is hidden from the address book.
    public var hiddenFromGlobalAddressList: Swift.Bool
    /// The name of the described group.
    public var name: Swift.String?
    /// The state of the user: enabled (registered to WorkMail) or disabled (deregistered or never registered to WorkMail).
    public var state: WorkMailClientTypes.EntityState?

    public init(
        disabledDate: Foundation.Date? = nil,
        email: Swift.String? = nil,
        enabledDate: Foundation.Date? = nil,
        groupId: Swift.String? = nil,
        hiddenFromGlobalAddressList: Swift.Bool = false,
        name: Swift.String? = nil,
        state: WorkMailClientTypes.EntityState? = nil
    )
    {
        self.disabledDate = disabledDate
        self.email = email
        self.enabledDate = enabledDate
        self.groupId = groupId
        self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
        self.name = name
        self.state = state
    }
}

public struct DescribeInboundDmarcSettingsInput {
    /// Lists the ID of the given organization.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

public struct DescribeInboundDmarcSettingsOutput {
    /// Lists the enforcement setting of the applied policy.
    public var enforced: Swift.Bool

    public init(
        enforced: Swift.Bool = false
    )
    {
        self.enforced = enforced
    }
}

public struct DescribeMailboxExportJobInput {
    /// The mailbox export job ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.organizationId = organizationId
    }
}

extension WorkMailClientTypes {

    public enum MailboxExportJobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [MailboxExportJobState] {
            return [
                .cancelled,
                .completed,
                .failed,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeMailboxExportJobOutput {
    /// The mailbox export job description.
    public var description: Swift.String?
    /// The mailbox export job end timestamp.
    public var endTime: Foundation.Date?
    /// The identifier of the user or resource associated with the mailbox.
    public var entityId: Swift.String?
    /// Error information for failed mailbox export jobs.
    public var errorInfo: Swift.String?
    /// The estimated progress of the mailbox export job, in percentage points.
    public var estimatedProgress: Swift.Int
    /// The Amazon Resource Name (ARN) of the symmetric AWS Key Management Service (AWS KMS) key that encrypts the exported mailbox content.
    public var kmsKeyArn: Swift.String?
    /// The ARN of the AWS Identity and Access Management (IAM) role that grants write permission to the Amazon Simple Storage Service (Amazon S3) bucket.
    public var roleArn: Swift.String?
    /// The name of the S3 bucket.
    public var s3BucketName: Swift.String?
    /// The path to the S3 bucket and file that the mailbox export job is exporting to.
    public var s3Path: Swift.String?
    /// The S3 bucket prefix.
    public var s3Prefix: Swift.String?
    /// The mailbox export job start timestamp.
    public var startTime: Foundation.Date?
    /// The state of the mailbox export job.
    public var state: WorkMailClientTypes.MailboxExportJobState?

    public init(
        description: Swift.String? = nil,
        endTime: Foundation.Date? = nil,
        entityId: Swift.String? = nil,
        errorInfo: Swift.String? = nil,
        estimatedProgress: Swift.Int = 0,
        kmsKeyArn: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3Path: Swift.String? = nil,
        s3Prefix: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        state: WorkMailClientTypes.MailboxExportJobState? = nil
    )
    {
        self.description = description
        self.endTime = endTime
        self.entityId = entityId
        self.errorInfo = errorInfo
        self.estimatedProgress = estimatedProgress
        self.kmsKeyArn = kmsKeyArn
        self.roleArn = roleArn
        self.s3BucketName = s3BucketName
        self.s3Path = s3Path
        self.s3Prefix = s3Prefix
        self.startTime = startTime
        self.state = state
    }
}

public struct DescribeOrganizationInput {
    /// The identifier for the organization to be described.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

public struct DescribeOrganizationOutput {
    /// The alias for an organization.
    public var alias: Swift.String?
    /// The Amazon Resource Name (ARN) of the organization.
    public var arn: Swift.String?
    /// The date at which the organization became usable in the WorkMail context, in UNIX epoch time format.
    public var completedDate: Foundation.Date?
    /// The default mail domain associated with the organization.
    public var defaultMailDomain: Swift.String?
    /// The identifier for the directory associated with an WorkMail organization.
    public var directoryId: Swift.String?
    /// The type of directory associated with the WorkMail organization.
    public var directoryType: Swift.String?
    /// (Optional) The error message indicating if unexpected behavior was encountered with regards to the organization.
    public var errorMessage: Swift.String?
    /// Indicates if interoperability is enabled for this organization.
    public var interoperabilityEnabled: Swift.Bool
    /// The user ID of the migration admin if migration is enabled for the organization.
    public var migrationAdmin: Swift.String?
    /// The identifier of an organization.
    public var organizationId: Swift.String?
    /// The state of an organization.
    public var state: Swift.String?

    public init(
        alias: Swift.String? = nil,
        arn: Swift.String? = nil,
        completedDate: Foundation.Date? = nil,
        defaultMailDomain: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        directoryType: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        interoperabilityEnabled: Swift.Bool = false,
        migrationAdmin: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        state: Swift.String? = nil
    )
    {
        self.alias = alias
        self.arn = arn
        self.completedDate = completedDate
        self.defaultMailDomain = defaultMailDomain
        self.directoryId = directoryId
        self.directoryType = directoryType
        self.errorMessage = errorMessage
        self.interoperabilityEnabled = interoperabilityEnabled
        self.migrationAdmin = migrationAdmin
        self.organizationId = organizationId
        self.state = state
    }
}

public struct DescribeResourceInput {
    /// The identifier associated with the organization for which the resource is described.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the resource to be described. The identifier can accept ResourceId, Resourcename, or email. The following identity formats are available:
    ///
    /// * Resource ID: r-0123456789a0123456789b0123456789
    ///
    /// * Email address: resource@domain.tld
    ///
    /// * Resource name: resource
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

public struct DescribeResourceOutput {
    /// The booking options for the described resource.
    public var bookingOptions: WorkMailClientTypes.BookingOptions?
    /// Description of the resource.
    public var description: Swift.String?
    /// The date and time when a resource was disabled from WorkMail, in UNIX epoch time format.
    public var disabledDate: Foundation.Date?
    /// The email of the described resource.
    public var email: Swift.String?
    /// The date and time when a resource was enabled for WorkMail, in UNIX epoch time format.
    public var enabledDate: Foundation.Date?
    /// If enabled, the resource is hidden from the global address list.
    public var hiddenFromGlobalAddressList: Swift.Bool
    /// The name of the described resource.
    public var name: Swift.String?
    /// The identifier of the described resource.
    public var resourceId: Swift.String?
    /// The state of the resource: enabled (registered to WorkMail), disabled (deregistered or never registered to WorkMail), or deleted.
    public var state: WorkMailClientTypes.EntityState?
    /// The type of the described resource.
    public var type: WorkMailClientTypes.ResourceType?

    public init(
        bookingOptions: WorkMailClientTypes.BookingOptions? = nil,
        description: Swift.String? = nil,
        disabledDate: Foundation.Date? = nil,
        email: Swift.String? = nil,
        enabledDate: Foundation.Date? = nil,
        hiddenFromGlobalAddressList: Swift.Bool = false,
        name: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        state: WorkMailClientTypes.EntityState? = nil,
        type: WorkMailClientTypes.ResourceType? = nil
    )
    {
        self.bookingOptions = bookingOptions
        self.description = description
        self.disabledDate = disabledDate
        self.email = email
        self.enabledDate = enabledDate
        self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
        self.name = name
        self.resourceId = resourceId
        self.state = state
        self.type = type
    }
}

public struct DescribeUserInput {
    /// The identifier for the organization under which the user exists.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier for the user to be described. The identifier can be the UserId, Username, or email. The following identity formats are available:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var userId: Swift.String?

    public init(
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.userId = userId
    }
}

public struct DescribeUserOutput {
    /// City where the user is located.
    public var city: Swift.String?
    /// Company of the user.
    public var company: Swift.String?
    /// Country where the user is located.
    public var country: Swift.String?
    /// Department of the user.
    public var department: Swift.String?
    /// The date and time at which the user was disabled for WorkMail usage, in UNIX epoch time format.
    public var disabledDate: Foundation.Date?
    /// The display name of the user.
    public var displayName: Swift.String?
    /// The email of the user.
    public var email: Swift.String?
    /// The date and time at which the user was enabled for WorkMailusage, in UNIX epoch time format.
    public var enabledDate: Foundation.Date?
    /// First name of the user.
    public var firstName: Swift.String?
    /// If enabled, the user is hidden from the global address list.
    public var hiddenFromGlobalAddressList: Swift.Bool
    /// Initials of the user.
    public var initials: Swift.String?
    /// Job title of the user.
    public var jobTitle: Swift.String?
    /// Last name of the user.
    public var lastName: Swift.String?
    /// The date when the mailbox was removed for the user.
    public var mailboxDeprovisionedDate: Foundation.Date?
    /// The date when the mailbox was created for the user.
    public var mailboxProvisionedDate: Foundation.Date?
    /// The name for the user.
    public var name: Swift.String?
    /// Office where the user is located.
    public var office: Swift.String?
    /// The state of a user: enabled (registered to WorkMail) or disabled (deregistered or never registered to WorkMail).
    public var state: WorkMailClientTypes.EntityState?
    /// Street where the user is located.
    public var street: Swift.String?
    /// User's contact number.
    public var telephone: Swift.String?
    /// The identifier for the described user.
    public var userId: Swift.String?
    /// In certain cases, other entities are modeled as users. If interoperability is enabled, resources are imported into WorkMail as users. Because different WorkMail organizations rely on different directory types, administrators can distinguish between an unregistered user (account is disabled and has a user role) and the directory administrators. The values are USER, RESOURCE, SYSTEM_USER, and REMOTE_USER.
    public var userRole: WorkMailClientTypes.UserRole?
    /// Zip code of the user.
    public var zipCode: Swift.String?

    public init(
        city: Swift.String? = nil,
        company: Swift.String? = nil,
        country: Swift.String? = nil,
        department: Swift.String? = nil,
        disabledDate: Foundation.Date? = nil,
        displayName: Swift.String? = nil,
        email: Swift.String? = nil,
        enabledDate: Foundation.Date? = nil,
        firstName: Swift.String? = nil,
        hiddenFromGlobalAddressList: Swift.Bool = false,
        initials: Swift.String? = nil,
        jobTitle: Swift.String? = nil,
        lastName: Swift.String? = nil,
        mailboxDeprovisionedDate: Foundation.Date? = nil,
        mailboxProvisionedDate: Foundation.Date? = nil,
        name: Swift.String? = nil,
        office: Swift.String? = nil,
        state: WorkMailClientTypes.EntityState? = nil,
        street: Swift.String? = nil,
        telephone: Swift.String? = nil,
        userId: Swift.String? = nil,
        userRole: WorkMailClientTypes.UserRole? = nil,
        zipCode: Swift.String? = nil
    )
    {
        self.city = city
        self.company = company
        self.country = country
        self.department = department
        self.disabledDate = disabledDate
        self.displayName = displayName
        self.email = email
        self.enabledDate = enabledDate
        self.firstName = firstName
        self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
        self.initials = initials
        self.jobTitle = jobTitle
        self.lastName = lastName
        self.mailboxDeprovisionedDate = mailboxDeprovisionedDate
        self.mailboxProvisionedDate = mailboxProvisionedDate
        self.name = name
        self.office = office
        self.state = state
        self.street = street
        self.telephone = telephone
        self.userId = userId
        self.userRole = userRole
        self.zipCode = zipCode
    }
}

extension DescribeUserOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserOutput(disabledDate: \(Swift.String(describing: disabledDate)), email: \(Swift.String(describing: email)), enabledDate: \(Swift.String(describing: enabledDate)), hiddenFromGlobalAddressList: \(Swift.String(describing: hiddenFromGlobalAddressList)), mailboxDeprovisionedDate: \(Swift.String(describing: mailboxDeprovisionedDate)), mailboxProvisionedDate: \(Swift.String(describing: mailboxProvisionedDate)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)), userId: \(Swift.String(describing: userId)), userRole: \(Swift.String(describing: userRole)), city: \"CONTENT_REDACTED\", company: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", department: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", initials: \"CONTENT_REDACTED\", jobTitle: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", office: \"CONTENT_REDACTED\", street: \"CONTENT_REDACTED\", telephone: \"CONTENT_REDACTED\", zipCode: \"CONTENT_REDACTED\")"}
}

public struct DisassociateDelegateFromResourceInput {
    /// The identifier for the member (user, group) to be removed from the resource's delegates. The entity ID can accept UserId or GroupID, Username or Groupname, or email.
    ///
    /// * Entity: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: entity@domain.tld
    ///
    /// * Entity: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier for the organization under which the resource exists.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the resource from which delegates' set members are removed. The identifier can accept ResourceId, Resourcename, or email. The following identity formats are available:
    ///
    /// * Resource ID: r-0123456789a0123456789b0123456789
    ///
    /// * Email address: resource@domain.tld
    ///
    /// * Resource name: resource
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

public struct DisassociateDelegateFromResourceOutput {

    public init() { }
}

public struct DisassociateMemberFromGroupInput {
    /// The identifier for the group from which members are removed. The identifier can accept GroupId, Groupname, or email. The following identity formats are available:
    ///
    /// * Group ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: group@domain.tld
    ///
    /// * Group name: group
    /// This member is required.
    public var groupId: Swift.String?
    /// The identifier for the member to be removed from the group. The member ID can accept UserID or GroupId, Username or Groupname, or email.
    ///
    /// * Member ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: member@domain.tld
    ///
    /// * Member name: member
    /// This member is required.
    public var memberId: Swift.String?
    /// The identifier for the organization under which the group exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.memberId = memberId
        self.organizationId = organizationId
    }
}

public struct DisassociateMemberFromGroupOutput {

    public init() { }
}

extension WorkMailClientTypes {
    /// A DNS record uploaded to your DNS provider.
    public struct DnsRecord {
        /// The DNS hostname.- For example, domain.example.com.
        public var hostname: Swift.String?
        /// The RFC 1035 record type. Possible values: CNAME, A, MX.
        public var type: Swift.String?
        /// The value returned by the DNS for a query to that hostname and record type.
        public var value: Swift.String?

        public init(
            hostname: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.hostname = hostname
            self.type = type
            self.value = value
        }
    }

}

extension WorkMailClientTypes {

    public enum DnsRecordVerificationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case pending
        case verified
        case sdkUnknown(Swift.String)

        public static var allCases: [DnsRecordVerificationStatus] {
            return [
                .failed,
                .pending,
                .verified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .verified: return "VERIFIED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The user, group, or resource that you're trying to register is already registered.
public struct EntityAlreadyRegisteredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityAlreadyRegisteredException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension WorkMailClientTypes {

    public enum RetentionAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case delete
        case `none`
        case permanentlyDelete
        case sdkUnknown(Swift.String)

        public static var allCases: [RetentionAction] {
            return [
                .delete,
                .none,
                .permanentlyDelete
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .none: return "NONE"
            case .permanentlyDelete: return "PERMANENTLY_DELETE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkMailClientTypes {

    public enum FolderName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deletedItems
        case drafts
        case inbox
        case junkEmail
        case sentItems
        case sdkUnknown(Swift.String)

        public static var allCases: [FolderName] {
            return [
                .deletedItems,
                .drafts,
                .inbox,
                .junkEmail,
                .sentItems
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deletedItems: return "DELETED_ITEMS"
            case .drafts: return "DRAFTS"
            case .inbox: return "INBOX"
            case .junkEmail: return "JUNK_EMAIL"
            case .sentItems: return "SENT_ITEMS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkMailClientTypes {
    /// The configuration applied to an organization's folders by its retention policy.
    public struct FolderConfiguration {
        /// The action to take on the folder contents at the end of the folder configuration period.
        /// This member is required.
        public var action: WorkMailClientTypes.RetentionAction?
        /// The folder name.
        /// This member is required.
        public var name: WorkMailClientTypes.FolderName?
        /// The number of days for which the folder-configuration action applies.
        public var period: Swift.Int?

        public init(
            action: WorkMailClientTypes.RetentionAction? = nil,
            name: WorkMailClientTypes.FolderName? = nil,
            period: Swift.Int? = nil
        )
        {
            self.action = action
            self.name = name
            self.period = period
        }
    }

}

public struct GetAccessControlEffectInput {
    /// The access protocol action. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
    /// This member is required.
    public var action: Swift.String?
    /// The impersonation role ID.
    public var impersonationRoleId: Swift.String?
    /// The IPv4 address.
    /// This member is required.
    public var ipAddress: Swift.String?
    /// The identifier for the organization.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The user ID.
    public var userId: Swift.String?

    public init(
        action: Swift.String? = nil,
        impersonationRoleId: Swift.String? = nil,
        ipAddress: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.action = action
        self.impersonationRoleId = impersonationRoleId
        self.ipAddress = ipAddress
        self.organizationId = organizationId
        self.userId = userId
    }
}

public struct GetAccessControlEffectOutput {
    /// The rule effect.
    public var effect: WorkMailClientTypes.AccessControlRuleEffect?
    /// The rules that match the given parameters, resulting in an effect.
    public var matchedRules: [Swift.String]?

    public init(
        effect: WorkMailClientTypes.AccessControlRuleEffect? = nil,
        matchedRules: [Swift.String]? = nil
    )
    {
        self.effect = effect
        self.matchedRules = matchedRules
    }
}

public struct GetDefaultRetentionPolicyInput {
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

public struct GetDefaultRetentionPolicyOutput {
    /// The retention policy description.
    public var description: Swift.String?
    /// The retention policy folder configurations.
    public var folderConfigurations: [WorkMailClientTypes.FolderConfiguration]?
    /// The retention policy ID.
    public var id: Swift.String?
    /// The retention policy name.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        folderConfigurations: [WorkMailClientTypes.FolderConfiguration]? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.folderConfigurations = folderConfigurations
        self.id = id
        self.name = name
    }
}

public struct GetImpersonationRoleInput {
    /// The impersonation role ID to retrieve.
    /// This member is required.
    public var impersonationRoleId: Swift.String?
    /// The WorkMail organization from which to retrieve the impersonation role.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        impersonationRoleId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.impersonationRoleId = impersonationRoleId
        self.organizationId = organizationId
    }
}

public struct GetImpersonationRoleOutput {
    /// The date when the impersonation role was created.
    public var dateCreated: Foundation.Date?
    /// The date when the impersonation role was last modified.
    public var dateModified: Foundation.Date?
    /// The impersonation role description.
    public var description: Swift.String?
    /// The impersonation role ID.
    public var impersonationRoleId: Swift.String?
    /// The impersonation role name.
    public var name: Swift.String?
    /// The list of rules for the given impersonation role.
    public var rules: [WorkMailClientTypes.ImpersonationRule]?
    /// The impersonation role type.
    public var type: WorkMailClientTypes.ImpersonationRoleType?

    public init(
        dateCreated: Foundation.Date? = nil,
        dateModified: Foundation.Date? = nil,
        description: Swift.String? = nil,
        impersonationRoleId: Swift.String? = nil,
        name: Swift.String? = nil,
        rules: [WorkMailClientTypes.ImpersonationRule]? = nil,
        type: WorkMailClientTypes.ImpersonationRoleType? = nil
    )
    {
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.description = description
        self.impersonationRoleId = impersonationRoleId
        self.name = name
        self.rules = rules
        self.type = type
    }
}

public struct GetImpersonationRoleEffectInput {
    /// The impersonation role ID to test.
    /// This member is required.
    public var impersonationRoleId: Swift.String?
    /// The WorkMail organization where the impersonation role is defined.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The WorkMail organization user chosen to test the impersonation role. The following identity formats are available:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var targetUser: Swift.String?

    public init(
        impersonationRoleId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        targetUser: Swift.String? = nil
    )
    {
        self.impersonationRoleId = impersonationRoleId
        self.organizationId = organizationId
        self.targetUser = targetUser
    }
}

extension WorkMailClientTypes {
    /// The impersonation rule that matched the input.
    public struct ImpersonationMatchedRule {
        /// The ID of the rule that matched the input
        public var impersonationRuleId: Swift.String?
        /// The name of the rule that matched the input.
        public var name: Swift.String?

        public init(
            impersonationRuleId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.impersonationRuleId = impersonationRuleId
            self.name = name
        }
    }

}

public struct GetImpersonationRoleEffectOutput {
    /// Effect of the impersonation role on the target user based on its rules. Available effects are ALLOW or DENY.
    public var effect: WorkMailClientTypes.AccessEffect?
    /// A list of the rules that match the input and produce the configured effect.
    public var matchedRules: [WorkMailClientTypes.ImpersonationMatchedRule]?
    /// The impersonation role type.
    public var type: WorkMailClientTypes.ImpersonationRoleType?

    public init(
        effect: WorkMailClientTypes.AccessEffect? = nil,
        matchedRules: [WorkMailClientTypes.ImpersonationMatchedRule]? = nil,
        type: WorkMailClientTypes.ImpersonationRoleType? = nil
    )
    {
        self.effect = effect
        self.matchedRules = matchedRules
        self.type = type
    }
}

public struct GetMailboxDetailsInput {
    /// The identifier for the organization that contains the user whose mailbox details are being requested.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier for the user whose mailbox details are being requested. The identifier can be the UserId, Username, or email. The following identity formats are available:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var userId: Swift.String?

    public init(
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.userId = userId
    }
}

public struct GetMailboxDetailsOutput {
    /// The maximum allowed mailbox size, in MB, for the specified user.
    public var mailboxQuota: Swift.Int?
    /// The current mailbox size, in MB, for the specified user.
    public var mailboxSize: Swift.Double

    public init(
        mailboxQuota: Swift.Int? = nil,
        mailboxSize: Swift.Double = 0.0
    )
    {
        self.mailboxQuota = mailboxQuota
        self.mailboxSize = mailboxSize
    }
}

public struct GetMailDomainInput {
    /// The domain from which you want to retrieve details.
    /// This member is required.
    public var domainName: Swift.String?
    /// The WorkMail organization for which the domain is retrieved.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.organizationId = organizationId
    }
}

public struct GetMailDomainOutput {
    /// Indicates the status of a DKIM verification.
    public var dkimVerificationStatus: WorkMailClientTypes.DnsRecordVerificationStatus?
    /// Specifies whether the domain is the default domain for your organization.
    public var isDefault: Swift.Bool
    /// Specifies whether the domain is a test domain provided by WorkMail, or a custom domain.
    public var isTestDomain: Swift.Bool
    /// Indicates the status of the domain ownership verification.
    public var ownershipVerificationStatus: WorkMailClientTypes.DnsRecordVerificationStatus?
    /// A list of the DNS records that WorkMail recommends adding in your DNS provider for the best user experience. The records configure your domain with DMARC, SPF, DKIM, and direct incoming email traffic to SES. See admin guide for more details.
    public var records: [WorkMailClientTypes.DnsRecord]?

    public init(
        dkimVerificationStatus: WorkMailClientTypes.DnsRecordVerificationStatus? = nil,
        isDefault: Swift.Bool = false,
        isTestDomain: Swift.Bool = false,
        ownershipVerificationStatus: WorkMailClientTypes.DnsRecordVerificationStatus? = nil,
        records: [WorkMailClientTypes.DnsRecord]? = nil
    )
    {
        self.dkimVerificationStatus = dkimVerificationStatus
        self.isDefault = isDefault
        self.isTestDomain = isTestDomain
        self.ownershipVerificationStatus = ownershipVerificationStatus
        self.records = records
    }
}

public struct GetMobileDeviceAccessEffectInput {
    /// Device model the simulated user will report.
    public var deviceModel: Swift.String?
    /// Device operating system the simulated user will report.
    public var deviceOperatingSystem: Swift.String?
    /// Device type the simulated user will report.
    public var deviceType: Swift.String?
    /// Device user agent the simulated user will report.
    public var deviceUserAgent: Swift.String?
    /// The WorkMail organization to simulate the access effect for.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        deviceModel: Swift.String? = nil,
        deviceOperatingSystem: Swift.String? = nil,
        deviceType: Swift.String? = nil,
        deviceUserAgent: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.deviceModel = deviceModel
        self.deviceOperatingSystem = deviceOperatingSystem
        self.deviceType = deviceType
        self.deviceUserAgent = deviceUserAgent
        self.organizationId = organizationId
    }
}

extension WorkMailClientTypes {
    /// The rule that a simulated user matches.
    public struct MobileDeviceAccessMatchedRule {
        /// Identifier of the rule that a simulated user matches.
        public var mobileDeviceAccessRuleId: Swift.String?
        /// Name of a rule that a simulated user matches.
        public var name: Swift.String?

        public init(
            mobileDeviceAccessRuleId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
            self.name = name
        }
    }

}

public struct GetMobileDeviceAccessEffectOutput {
    /// The effect of the simulated access, ALLOW or DENY, after evaluating mobile device access rules in the WorkMail organization for the simulated user parameters.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// A list of the rules which matched the simulated user input and produced the effect.
    public var matchedRules: [WorkMailClientTypes.MobileDeviceAccessMatchedRule]?

    public init(
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        matchedRules: [WorkMailClientTypes.MobileDeviceAccessMatchedRule]? = nil
    )
    {
        self.effect = effect
        self.matchedRules = matchedRules
    }
}

public struct GetMobileDeviceAccessOverrideInput {
    /// The mobile device to which the override applies. DeviceId is case insensitive.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The WorkMail organization to which you want to apply the override.
    /// This member is required.
    public var organizationId: Swift.String?
    /// Identifies the WorkMail user for the override. Accepts the following types of user identities:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var userId: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.organizationId = organizationId
        self.userId = userId
    }
}

public struct GetMobileDeviceAccessOverrideOutput {
    /// The date the override was first created.
    public var dateCreated: Foundation.Date?
    /// The date the description was last modified.
    public var dateModified: Foundation.Date?
    /// A description of the override.
    public var description: Swift.String?
    /// The device to which the access override applies.
    public var deviceId: Swift.String?
    /// The effect of the override, ALLOW or DENY.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// The WorkMail user to which the access override applies.
    public var userId: Swift.String?

    public init(
        dateCreated: Foundation.Date? = nil,
        dateModified: Foundation.Date? = nil,
        description: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        userId: Swift.String? = nil
    )
    {
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.description = description
        self.deviceId = deviceId
        self.effect = effect
        self.userId = userId
    }
}

extension WorkMailClientTypes {
    /// The representation of an WorkMail group.
    public struct Group {
        /// The date indicating when the group was disabled from WorkMail use.
        public var disabledDate: Foundation.Date?
        /// The email of the group.
        public var email: Swift.String?
        /// The date indicating when the group was enabled for WorkMail use.
        public var enabledDate: Foundation.Date?
        /// The identifier of the group.
        public var id: Swift.String?
        /// The name of the group.
        public var name: Swift.String?
        /// The state of the group, which can be ENABLED, DISABLED, or DELETED.
        public var state: WorkMailClientTypes.EntityState?

        public init(
            disabledDate: Foundation.Date? = nil,
            email: Swift.String? = nil,
            enabledDate: Foundation.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil
        )
        {
            self.disabledDate = disabledDate
            self.email = email
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
        }
    }

}

extension WorkMailClientTypes {
    /// The identifier that contains the Group ID and name of a group.
    public struct GroupIdentifier {
        /// Group ID that matched the group.
        public var groupId: Swift.String?
        /// Group name that matched the group.
        public var groupName: Swift.String?

        public init(
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
        }
    }

}

extension WorkMailClientTypes {
    /// An impersonation role for the given WorkMail organization.
    public struct ImpersonationRole {
        /// The date when the impersonation role was created.
        public var dateCreated: Foundation.Date?
        /// The date when the impersonation role was last modified.
        public var dateModified: Foundation.Date?
        /// The identifier of the impersonation role.
        public var impersonationRoleId: Swift.String?
        /// The impersonation role name.
        public var name: Swift.String?
        /// The impersonation role type.
        public var type: WorkMailClientTypes.ImpersonationRoleType?

        public init(
            dateCreated: Foundation.Date? = nil,
            dateModified: Foundation.Date? = nil,
            impersonationRoleId: Swift.String? = nil,
            name: Swift.String? = nil,
            type: WorkMailClientTypes.ImpersonationRoleType? = nil
        )
        {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.impersonationRoleId = impersonationRoleId
            self.name = name
            self.type = type
        }
    }

}

/// The configuration for a resource isn't valid. A resource must either be able to auto-respond to requests or have at least one delegate associated that can do so on its behalf.
public struct InvalidConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidConfigurationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension WorkMailClientTypes {
    /// The details of a mailbox export job, including the user or resource ID associated with the mailbox and the S3 bucket that the mailbox contents are exported to.
    public struct MailboxExportJob {
        /// The mailbox export job description.
        public var description: Swift.String?
        /// The mailbox export job end timestamp.
        public var endTime: Foundation.Date?
        /// The identifier of the user or resource associated with the mailbox.
        public var entityId: Swift.String?
        /// The estimated progress of the mailbox export job, in percentage points.
        public var estimatedProgress: Swift.Int
        /// The identifier of the mailbox export job.
        public var jobId: Swift.String?
        /// The name of the S3 bucket.
        public var s3BucketName: Swift.String?
        /// The path to the S3 bucket and file that the mailbox export job exports to.
        public var s3Path: Swift.String?
        /// The mailbox export job start timestamp.
        public var startTime: Foundation.Date?
        /// The state of the mailbox export job.
        public var state: WorkMailClientTypes.MailboxExportJobState?

        public init(
            description: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            entityId: Swift.String? = nil,
            estimatedProgress: Swift.Int = 0,
            jobId: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            s3Path: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            state: WorkMailClientTypes.MailboxExportJobState? = nil
        )
        {
            self.description = description
            self.endTime = endTime
            self.entityId = entityId
            self.estimatedProgress = estimatedProgress
            self.jobId = jobId
            self.s3BucketName = s3BucketName
            self.s3Path = s3Path
            self.startTime = startTime
            self.state = state
        }
    }

}

public struct ListAccessControlRulesInput {
    /// The identifier for the organization.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

public struct ListAccessControlRulesOutput {
    /// The access control rules.
    public var rules: [WorkMailClientTypes.AccessControlRule]?

    public init(
        rules: [WorkMailClientTypes.AccessControlRule]? = nil
    )
    {
        self.rules = rules
    }
}

public struct ListAliasesInput {
    /// The identifier for the entity for which to list the aliases.
    /// This member is required.
    public var entityId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the entity exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

public struct ListAliasesOutput {
    /// The entity's paginated aliases.
    public var aliases: [Swift.String]?
    /// The token to use to retrieve the next page of results. The value is "null" when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        aliases: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aliases = aliases
        self.nextToken = nextToken
    }
}

public struct ListAvailabilityConfigurationsInput {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not require a token.
    public var nextToken: Swift.String?
    /// The WorkMail organization for which the AvailabilityConfiguration's will be listed.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

public struct ListAvailabilityConfigurationsOutput {
    /// The list of AvailabilityConfiguration's that exist for the specified WorkMail organization.
    public var availabilityConfigurations: [WorkMailClientTypes.AvailabilityConfiguration]?
    /// The token to use to retrieve the next page of results. The value is null when there are no further results to return.
    public var nextToken: Swift.String?

    public init(
        availabilityConfigurations: [WorkMailClientTypes.AvailabilityConfiguration]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.availabilityConfigurations = availabilityConfigurations
        self.nextToken = nextToken
    }
}

public struct ListGroupMembersInput {
    /// The identifier for the group to which the members (users or groups) are associated. The identifier can accept GroupId, Groupname, or email. The following identity formats are available:
    ///
    /// * Group ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: group@domain.tld
    ///
    /// * Group name: group
    /// This member is required.
    public var groupId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the group exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

extension WorkMailClientTypes {
    /// The representation of a user or group.
    public struct Member {
        /// The date indicating when the member was disabled from WorkMail use.
        public var disabledDate: Foundation.Date?
        /// The date indicating when the member was enabled for WorkMail use.
        public var enabledDate: Foundation.Date?
        /// The identifier of the member.
        public var id: Swift.String?
        /// The name of the member.
        public var name: Swift.String?
        /// The state of the member, which can be ENABLED, DISABLED, or DELETED.
        public var state: WorkMailClientTypes.EntityState?
        /// A member can be a user or group.
        public var type: WorkMailClientTypes.MemberType?

        public init(
            disabledDate: Foundation.Date? = nil,
            enabledDate: Foundation.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil,
            type: WorkMailClientTypes.MemberType? = nil
        )
        {
            self.disabledDate = disabledDate
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
            self.type = type
        }
    }

}

public struct ListGroupMembersOutput {
    /// The members associated to the group.
    public var members: [WorkMailClientTypes.Member]?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?

    public init(
        members: [WorkMailClientTypes.Member]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

extension WorkMailClientTypes {
    /// Filtering options for ListGroups operation. This is only used as input to Operation.
    public struct ListGroupsFilters {
        /// Filters only groups with the provided name prefix.
        public var namePrefix: Swift.String?
        /// Filters only groups with the provided primary email prefix.
        public var primaryEmailPrefix: Swift.String?
        /// Filters only groups with the provided state.
        public var state: WorkMailClientTypes.EntityState?

        public init(
            namePrefix: Swift.String? = nil,
            primaryEmailPrefix: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil
        )
        {
            self.namePrefix = namePrefix
            self.primaryEmailPrefix = primaryEmailPrefix
            self.state = state
        }
    }

}

public struct ListGroupsInput {
    /// Limit the search results based on the filter criteria. Only one filter per request is supported.
    public var filters: WorkMailClientTypes.ListGroupsFilters?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the groups exist.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        filters: WorkMailClientTypes.ListGroupsFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

public struct ListGroupsOutput {
    /// The overview of groups for an organization.
    public var groups: [WorkMailClientTypes.Group]?
    /// The token to use to retrieve the next page of results. The value is "null" when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        groups: [WorkMailClientTypes.Group]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

extension WorkMailClientTypes {
    /// Filtering options for ListGroupsForEntity operation. This is only used as input to Operation.
    public struct ListGroupsForEntityFilters {
        /// Filters only group names that start with the provided name prefix.
        public var groupNamePrefix: Swift.String?

        public init(
            groupNamePrefix: Swift.String? = nil
        )
        {
            self.groupNamePrefix = groupNamePrefix
        }
    }

}

public struct ListGroupsForEntityInput {
    /// The identifier for the entity. The entity ID can accept UserId or GroupID, Username or Groupname, or email.
    ///
    /// * Entity ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: entity@domain.tld
    ///
    /// * Entity name: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// Limit the search results based on the filter criteria.
    public var filters: WorkMailClientTypes.ListGroupsForEntityFilters?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the entity exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        filters: WorkMailClientTypes.ListGroupsForEntityFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

public struct ListGroupsForEntityOutput {
    /// The overview of groups in an organization.
    public var groups: [WorkMailClientTypes.GroupIdentifier]?
    /// The token to use to retrieve the next page of results. This value is `null` when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        groups: [WorkMailClientTypes.GroupIdentifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

public struct ListImpersonationRolesInput {
    /// The maximum number of results returned in a single call.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results. The first call doesn't require a token.
    public var nextToken: Swift.String?
    /// The WorkMail organization to which the listed impersonation roles belong.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

public struct ListImpersonationRolesOutput {
    /// The token to retrieve the next page of results. The value is null when there are no results to return.
    public var nextToken: Swift.String?
    /// The list of impersonation roles under the given WorkMail organization.
    public var roles: [WorkMailClientTypes.ImpersonationRole]?

    public init(
        nextToken: Swift.String? = nil,
        roles: [WorkMailClientTypes.ImpersonationRole]? = nil
    )
    {
        self.nextToken = nextToken
        self.roles = roles
    }
}

public struct ListMailboxExportJobsInput {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

public struct ListMailboxExportJobsOutput {
    /// The mailbox export job details.
    public var jobs: [WorkMailClientTypes.MailboxExportJob]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        jobs: [WorkMailClientTypes.MailboxExportJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

public struct ListMailboxPermissionsInput {
    /// The identifier of the user, or resource for which to list mailbox permissions. The entity ID can accept UserId or ResourceId, Username or Resourcename, or email.
    ///
    /// * Entity ID: 12345678-1234-1234-1234-123456789012, or r-0123456789a0123456789b0123456789
    ///
    /// * Email address: entity@domain.tld
    ///
    /// * Entity name: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier of the organization under which the user, group, or resource exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

extension WorkMailClientTypes {

    public enum PermissionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fullAccess
        case sendAs
        case sendOnBehalf
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionType] {
            return [
                .fullAccess,
                .sendAs,
                .sendOnBehalf
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fullAccess: return "FULL_ACCESS"
            case .sendAs: return "SEND_AS"
            case .sendOnBehalf: return "SEND_ON_BEHALF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkMailClientTypes {
    /// Permission granted to a user, group, or resource to access a certain aspect of another user, group, or resource mailbox.
    public struct Permission {
        /// The identifier of the user, group, or resource to which the permissions are granted.
        /// This member is required.
        public var granteeId: Swift.String?
        /// The type of user, group, or resource referred to in GranteeId.
        /// This member is required.
        public var granteeType: WorkMailClientTypes.MemberType?
        /// The permissions granted to the grantee. SEND_AS allows the grantee to send email as the owner of the mailbox (the grantee is not mentioned on these emails). SEND_ON_BEHALF allows the grantee to send email on behalf of the owner of the mailbox (the grantee is not mentioned as the physical sender of these emails). FULL_ACCESS allows the grantee full access to the mailbox, irrespective of other folder-level permissions set on the mailbox.
        /// This member is required.
        public var permissionValues: [WorkMailClientTypes.PermissionType]?

        public init(
            granteeId: Swift.String? = nil,
            granteeType: WorkMailClientTypes.MemberType? = nil,
            permissionValues: [WorkMailClientTypes.PermissionType]? = nil
        )
        {
            self.granteeId = granteeId
            self.granteeType = granteeType
            self.permissionValues = permissionValues
        }
    }

}

public struct ListMailboxPermissionsOutput {
    /// The token to use to retrieve the next page of results. The value is "null" when there are no more results to return.
    public var nextToken: Swift.String?
    /// One page of the user, group, or resource mailbox permissions.
    public var permissions: [WorkMailClientTypes.Permission]?

    public init(
        nextToken: Swift.String? = nil,
        permissions: [WorkMailClientTypes.Permission]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

public struct ListMailDomainsInput {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not require a token.
    public var nextToken: Swift.String?
    /// The WorkMail organization for which to list domains.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

extension WorkMailClientTypes {
    /// The data for a given domain.
    public struct MailDomainSummary {
        /// Whether the domain is default or not.
        public var defaultDomain: Swift.Bool
        /// The domain name.
        public var domainName: Swift.String?

        public init(
            defaultDomain: Swift.Bool = false,
            domainName: Swift.String? = nil
        )
        {
            self.defaultDomain = defaultDomain
            self.domainName = domainName
        }
    }

}

public struct ListMailDomainsOutput {
    /// The list of mail domain summaries, specifying domains that exist in the specified WorkMail organization, along with the information about whether the domain is or isn't the default.
    public var mailDomains: [WorkMailClientTypes.MailDomainSummary]?
    /// The token to use to retrieve the next page of results. The value becomes null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        mailDomains: [WorkMailClientTypes.MailDomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mailDomains = mailDomains
        self.nextToken = nextToken
    }
}

public struct ListMobileDeviceAccessOverridesInput {
    /// The mobile device to which the access override applies.
    public var deviceId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not require a token.
    public var nextToken: Swift.String?
    /// The WorkMail organization under which to list mobile device access overrides.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The WorkMail user under which you list the mobile device access overrides. Accepts the following types of user identities:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    public var userId: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
        self.userId = userId
    }
}

extension WorkMailClientTypes {
    /// The override object.
    public struct MobileDeviceAccessOverride {
        /// The date the override was first created.
        public var dateCreated: Foundation.Date?
        /// The date the override was last modified.
        public var dateModified: Foundation.Date?
        /// A description of the override.
        public var description: Swift.String?
        /// The device to which the override applies.
        public var deviceId: Swift.String?
        /// The effect of the override, ALLOW or DENY.
        public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
        /// The WorkMail user to which the access override applies.
        public var userId: Swift.String?

        public init(
            dateCreated: Foundation.Date? = nil,
            dateModified: Foundation.Date? = nil,
            description: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
            userId: Swift.String? = nil
        )
        {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.description = description
            self.deviceId = deviceId
            self.effect = effect
            self.userId = userId
        }
    }

}

public struct ListMobileDeviceAccessOverridesOutput {
    /// The token to use to retrieve the next page of results. The value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of mobile device access overrides that exist for the specified WorkMail organization and user.
    public var overrides: [WorkMailClientTypes.MobileDeviceAccessOverride]?

    public init(
        nextToken: Swift.String? = nil,
        overrides: [WorkMailClientTypes.MobileDeviceAccessOverride]? = nil
    )
    {
        self.nextToken = nextToken
        self.overrides = overrides
    }
}

public struct ListMobileDeviceAccessRulesInput {
    /// The WorkMail organization for which to list the rules.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

extension WorkMailClientTypes {
    /// A rule that controls access to mobile devices for an WorkMail group.
    public struct MobileDeviceAccessRule {
        /// The date and time at which an access rule was created.
        public var dateCreated: Foundation.Date?
        /// The date and time at which an access rule was modified.
        public var dateModified: Foundation.Date?
        /// The description of a mobile access rule.
        public var description: Swift.String?
        /// Device models that a rule will match.
        public var deviceModels: [Swift.String]?
        /// Device operating systems that a rule will match.
        public var deviceOperatingSystems: [Swift.String]?
        /// Device types that a rule will match.
        public var deviceTypes: [Swift.String]?
        /// Device user agents that a rule will match.
        public var deviceUserAgents: [Swift.String]?
        /// The effect of the rule when it matches. Allowed values are ALLOW or DENY.
        public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
        /// The ID assigned to a mobile access rule.
        public var mobileDeviceAccessRuleId: Swift.String?
        /// The name of a mobile access rule.
        public var name: Swift.String?
        /// Device models that a rule will not match. All other device models will match.
        public var notDeviceModels: [Swift.String]?
        /// Device operating systems that a rule will not match. All other device types will match.
        public var notDeviceOperatingSystems: [Swift.String]?
        /// Device types that a rule will not match. All other device types will match.
        public var notDeviceTypes: [Swift.String]?
        /// Device user agents that a rule will not match. All other device user agents will match.
        public var notDeviceUserAgents: [Swift.String]?

        public init(
            dateCreated: Foundation.Date? = nil,
            dateModified: Foundation.Date? = nil,
            description: Swift.String? = nil,
            deviceModels: [Swift.String]? = nil,
            deviceOperatingSystems: [Swift.String]? = nil,
            deviceTypes: [Swift.String]? = nil,
            deviceUserAgents: [Swift.String]? = nil,
            effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
            mobileDeviceAccessRuleId: Swift.String? = nil,
            name: Swift.String? = nil,
            notDeviceModels: [Swift.String]? = nil,
            notDeviceOperatingSystems: [Swift.String]? = nil,
            notDeviceTypes: [Swift.String]? = nil,
            notDeviceUserAgents: [Swift.String]? = nil
        )
        {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.description = description
            self.deviceModels = deviceModels
            self.deviceOperatingSystems = deviceOperatingSystems
            self.deviceTypes = deviceTypes
            self.deviceUserAgents = deviceUserAgents
            self.effect = effect
            self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
            self.name = name
            self.notDeviceModels = notDeviceModels
            self.notDeviceOperatingSystems = notDeviceOperatingSystems
            self.notDeviceTypes = notDeviceTypes
            self.notDeviceUserAgents = notDeviceUserAgents
        }
    }

}

public struct ListMobileDeviceAccessRulesOutput {
    /// The list of mobile device access rules that exist under the specified WorkMail organization.
    public var rules: [WorkMailClientTypes.MobileDeviceAccessRule]?

    public init(
        rules: [WorkMailClientTypes.MobileDeviceAccessRule]? = nil
    )
    {
        self.rules = rules
    }
}

public struct ListOrganizationsInput {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension WorkMailClientTypes {
    /// The representation of an organization.
    public struct OrganizationSummary {
        /// The alias associated with the organization.
        public var alias: Swift.String?
        /// The default email domain associated with the organization.
        public var defaultMailDomain: Swift.String?
        /// The error message associated with the organization. It is only present if unexpected behavior has occurred with regards to the organization. It provides insight or solutions regarding unexpected behavior.
        public var errorMessage: Swift.String?
        /// The identifier associated with the organization.
        public var organizationId: Swift.String?
        /// The state associated with the organization.
        public var state: Swift.String?

        public init(
            alias: Swift.String? = nil,
            defaultMailDomain: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            organizationId: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.alias = alias
            self.defaultMailDomain = defaultMailDomain
            self.errorMessage = errorMessage
            self.organizationId = organizationId
            self.state = state
        }
    }

}

public struct ListOrganizationsOutput {
    /// The token to use to retrieve the next page of results. The value is "null" when there are no more results to return.
    public var nextToken: Swift.String?
    /// The overview of owned organizations presented as a list of organization summaries.
    public var organizationSummaries: [WorkMailClientTypes.OrganizationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        organizationSummaries: [WorkMailClientTypes.OrganizationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationSummaries = organizationSummaries
    }
}

public struct ListResourceDelegatesInput {
    /// The number of maximum results in a page.
    public var maxResults: Swift.Int?
    /// The token used to paginate through the delegates associated with a resource.
    public var nextToken: Swift.String?
    /// The identifier for the organization that contains the resource for which delegates are listed.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier for the resource whose delegates are listed. The identifier can accept ResourceId, Resourcename, or email. The following identity formats are available:
    ///
    /// * Resource ID: r-0123456789a0123456789b0123456789
    ///
    /// * Email address: resource@domain.tld
    ///
    /// * Resource name: resource
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

public struct ListResourceDelegatesOutput {
    /// One page of the resource's delegates.
    public var delegates: [WorkMailClientTypes.Delegate]?
    /// The token used to paginate through the delegates associated with a resource. While results are still available, it has an associated value. When the last page is reached, the token is empty.
    public var nextToken: Swift.String?

    public init(
        delegates: [WorkMailClientTypes.Delegate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.delegates = delegates
        self.nextToken = nextToken
    }
}

extension WorkMailClientTypes {
    /// Filtering options for ListResources operation. This is only used as input to Operation.
    public struct ListResourcesFilters {
        /// Filters only resource that start with the entered name prefix .
        public var namePrefix: Swift.String?
        /// Filters only resource with the provided primary email prefix.
        public var primaryEmailPrefix: Swift.String?
        /// Filters only resource with the provided state.
        public var state: WorkMailClientTypes.EntityState?

        public init(
            namePrefix: Swift.String? = nil,
            primaryEmailPrefix: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil
        )
        {
            self.namePrefix = namePrefix
            self.primaryEmailPrefix = primaryEmailPrefix
            self.state = state
        }
    }

}

public struct ListResourcesInput {
    /// Limit the resource search results based on the filter criteria. You can only use one filter per request.
    public var filters: WorkMailClientTypes.ListResourcesFilters?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the resources exist.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        filters: WorkMailClientTypes.ListResourcesFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

extension WorkMailClientTypes {
    /// The representation of a resource.
    public struct Resource {
        /// Resource description.
        public var description: Swift.String?
        /// The date indicating when the resource was disabled from WorkMail use.
        public var disabledDate: Foundation.Date?
        /// The email of the resource.
        public var email: Swift.String?
        /// The date indicating when the resource was enabled for WorkMail use.
        public var enabledDate: Foundation.Date?
        /// The identifier of the resource.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?
        /// The state of the resource, which can be ENABLED, DISABLED, or DELETED.
        public var state: WorkMailClientTypes.EntityState?
        /// The type of the resource: equipment or room.
        public var type: WorkMailClientTypes.ResourceType?

        public init(
            description: Swift.String? = nil,
            disabledDate: Foundation.Date? = nil,
            email: Swift.String? = nil,
            enabledDate: Foundation.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil,
            type: WorkMailClientTypes.ResourceType? = nil
        )
        {
            self.description = description
            self.disabledDate = disabledDate
            self.email = email
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
            self.type = type
        }
    }

}

public struct ListResourcesOutput {
    /// The token used to paginate through all the organization's resources. While results are still available, it has an associated value. When the last page is reached, the token is empty.
    public var nextToken: Swift.String?
    /// One page of the organization's resource representation.
    public var resources: [WorkMailClientTypes.Resource]?

    public init(
        nextToken: Swift.String? = nil,
        resources: [WorkMailClientTypes.Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

public struct ListTagsForResourceInput {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

extension WorkMailClientTypes {
    /// Describes a tag applied to a resource.
    public struct Tag {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct ListTagsForResourceOutput {
    /// A list of tag key-value pairs.
    public var tags: [WorkMailClientTypes.Tag]?

    public init(
        tags: [WorkMailClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

extension WorkMailClientTypes {
    /// Filtering options for ListUsers operation. This is only used as input to Operation.
    public struct ListUsersFilters {
        /// Filters only users with the provided display name prefix.
        public var displayNamePrefix: Swift.String?
        /// Filters only users with the provided email prefix.
        public var primaryEmailPrefix: Swift.String?
        /// Filters only users with the provided state.
        public var state: WorkMailClientTypes.EntityState?
        /// Filters only users with the provided username prefix.
        public var usernamePrefix: Swift.String?

        public init(
            displayNamePrefix: Swift.String? = nil,
            primaryEmailPrefix: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil,
            usernamePrefix: Swift.String? = nil
        )
        {
            self.displayNamePrefix = displayNamePrefix
            self.primaryEmailPrefix = primaryEmailPrefix
            self.state = state
            self.usernamePrefix = usernamePrefix
        }
    }

}

extension WorkMailClientTypes.ListUsersFilters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUsersFilters(primaryEmailPrefix: \(Swift.String(describing: primaryEmailPrefix)), state: \(Swift.String(describing: state)), usernamePrefix: \(Swift.String(describing: usernamePrefix)), displayNamePrefix: \"CONTENT_REDACTED\")"}
}

public struct ListUsersInput {
    /// Limit the user search results based on the filter criteria. You can only use one filter per request.
    public var filters: WorkMailClientTypes.ListUsersFilters?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the users exist.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        filters: WorkMailClientTypes.ListUsersFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

extension WorkMailClientTypes {
    /// The representation of an WorkMail user.
    public struct User {
        /// The date indicating when the user was disabled from WorkMail use.
        public var disabledDate: Foundation.Date?
        /// The display name of the user.
        public var displayName: Swift.String?
        /// The email of the user.
        public var email: Swift.String?
        /// The date indicating when the user was enabled for WorkMail use.
        public var enabledDate: Foundation.Date?
        /// The identifier of the user.
        public var id: Swift.String?
        /// The name of the user.
        public var name: Swift.String?
        /// The state of the user, which can be ENABLED, DISABLED, or DELETED.
        public var state: WorkMailClientTypes.EntityState?
        /// The role of the user.
        public var userRole: WorkMailClientTypes.UserRole?

        public init(
            disabledDate: Foundation.Date? = nil,
            displayName: Swift.String? = nil,
            email: Swift.String? = nil,
            enabledDate: Foundation.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil,
            userRole: WorkMailClientTypes.UserRole? = nil
        )
        {
            self.disabledDate = disabledDate
            self.displayName = displayName
            self.email = email
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
            self.userRole = userRole
        }
    }

}

public struct ListUsersOutput {
    /// The token to use to retrieve the next page of results. This value is `null` when there are no more results to return.
    public var nextToken: Swift.String?
    /// The overview of users for an organization.
    public var users: [WorkMailClientTypes.User]?

    public init(
        nextToken: Swift.String? = nil,
        users: [WorkMailClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

public struct PutAccessControlRuleInput {
    /// Access protocol actions to include in the rule. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
    public var actions: [Swift.String]?
    /// The rule description.
    /// This member is required.
    public var description: Swift.String?
    /// The rule effect.
    /// This member is required.
    public var effect: WorkMailClientTypes.AccessControlRuleEffect?
    /// Impersonation role IDs to include in the rule.
    public var impersonationRoleIds: [Swift.String]?
    /// IPv4 CIDR ranges to include in the rule.
    public var ipRanges: [Swift.String]?
    /// The rule name.
    /// This member is required.
    public var name: Swift.String?
    /// Access protocol actions to exclude from the rule. Valid values include ActiveSync, AutoDiscover, EWS, IMAP, SMTP, WindowsOutlook, and WebMail.
    public var notActions: [Swift.String]?
    /// Impersonation role IDs to exclude from the rule.
    public var notImpersonationRoleIds: [Swift.String]?
    /// IPv4 CIDR ranges to exclude from the rule.
    public var notIpRanges: [Swift.String]?
    /// User IDs to exclude from the rule.
    public var notUserIds: [Swift.String]?
    /// The identifier of the organization.
    /// This member is required.
    public var organizationId: Swift.String?
    /// User IDs to include in the rule.
    public var userIds: [Swift.String]?

    public init(
        actions: [Swift.String]? = nil,
        description: Swift.String? = nil,
        effect: WorkMailClientTypes.AccessControlRuleEffect? = nil,
        impersonationRoleIds: [Swift.String]? = nil,
        ipRanges: [Swift.String]? = nil,
        name: Swift.String? = nil,
        notActions: [Swift.String]? = nil,
        notImpersonationRoleIds: [Swift.String]? = nil,
        notIpRanges: [Swift.String]? = nil,
        notUserIds: [Swift.String]? = nil,
        organizationId: Swift.String? = nil,
        userIds: [Swift.String]? = nil
    )
    {
        self.actions = actions
        self.description = description
        self.effect = effect
        self.impersonationRoleIds = impersonationRoleIds
        self.ipRanges = ipRanges
        self.name = name
        self.notActions = notActions
        self.notImpersonationRoleIds = notImpersonationRoleIds
        self.notIpRanges = notIpRanges
        self.notUserIds = notUserIds
        self.organizationId = organizationId
        self.userIds = userIds
    }
}

public struct PutAccessControlRuleOutput {

    public init() { }
}

public struct PutEmailMonitoringConfigurationInput {
    /// The Amazon Resource Name (ARN) of the CloudWatch Log group associated with the email monitoring configuration.
    /// This member is required.
    public var logGroupArn: Swift.String?
    /// The ID of the organization for which the email monitoring configuration is set.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM Role associated with the email monitoring configuration.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        logGroupArn: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.logGroupArn = logGroupArn
        self.organizationId = organizationId
        self.roleArn = roleArn
    }
}

public struct PutEmailMonitoringConfigurationOutput {

    public init() { }
}

public struct PutInboundDmarcSettingsInput {
    /// Enforces or suspends a policy after it's applied.
    /// This member is required.
    public var enforced: Swift.Bool?
    /// The ID of the organization that you are applying the DMARC policy to.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        enforced: Swift.Bool? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.enforced = enforced
        self.organizationId = organizationId
    }
}

public struct PutInboundDmarcSettingsOutput {

    public init() { }
}

public struct PutMailboxPermissionsInput {
    /// The identifier of the user or resource for which to update mailbox permissions. The identifier can be UserId, ResourceID, or Group Id, Username, Resourcename, or Groupname, or email.
    ///
    /// * Entity ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: entity@domain.tld
    ///
    /// * Entity name: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier of the user, group, or resource to which to grant the permissions. The identifier can be UserId, ResourceID, or Group Id, Username, Resourcename, or Groupname, or email.
    ///
    /// * Grantee ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: grantee@domain.tld
    ///
    /// * Grantee name: grantee
    /// This member is required.
    public var granteeId: Swift.String?
    /// The identifier of the organization under which the user, group, or resource exists.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The permissions granted to the grantee. SEND_AS allows the grantee to send email as the owner of the mailbox (the grantee is not mentioned on these emails). SEND_ON_BEHALF allows the grantee to send email on behalf of the owner of the mailbox (the grantee is not mentioned as the physical sender of these emails). FULL_ACCESS allows the grantee full access to the mailbox, irrespective of other folder-level permissions set on the mailbox.
    /// This member is required.
    public var permissionValues: [WorkMailClientTypes.PermissionType]?

    public init(
        entityId: Swift.String? = nil,
        granteeId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        permissionValues: [WorkMailClientTypes.PermissionType]? = nil
    )
    {
        self.entityId = entityId
        self.granteeId = granteeId
        self.organizationId = organizationId
        self.permissionValues = permissionValues
    }
}

public struct PutMailboxPermissionsOutput {

    public init() { }
}

public struct PutMobileDeviceAccessOverrideInput {
    /// A description of the override.
    public var description: Swift.String?
    /// The mobile device for which you create the override. DeviceId is case insensitive.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The effect of the override, ALLOW or DENY.
    /// This member is required.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// Identifies the WorkMail organization for which you create the override.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The WorkMail user for which you create the override. Accepts the following types of user identities:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var userId: Swift.String?

    public init(
        description: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.description = description
        self.deviceId = deviceId
        self.effect = effect
        self.organizationId = organizationId
        self.userId = userId
    }
}

public struct PutMobileDeviceAccessOverrideOutput {

    public init() { }
}

public struct PutRetentionPolicyInput {
    /// The retention policy description.
    public var description: Swift.String?
    /// The retention policy folder configurations.
    /// This member is required.
    public var folderConfigurations: [WorkMailClientTypes.FolderConfiguration]?
    /// The retention policy ID.
    public var id: Swift.String?
    /// The retention policy name.
    /// This member is required.
    public var name: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        description: Swift.String? = nil,
        folderConfigurations: [WorkMailClientTypes.FolderConfiguration]? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.description = description
        self.folderConfigurations = folderConfigurations
        self.id = id
        self.name = name
        self.organizationId = organizationId
    }
}

extension PutRetentionPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRetentionPolicyInput(folderConfigurations: \(Swift.String(describing: folderConfigurations)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), organizationId: \(Swift.String(describing: organizationId)), description: \"CONTENT_REDACTED\")"}
}

public struct PutRetentionPolicyOutput {

    public init() { }
}

public struct RegisterMailDomainInput {
    /// Idempotency token used when retrying requests.
    public var clientToken: Swift.String?
    /// The name of the mail domain to create in WorkMail and SES.
    /// This member is required.
    public var domainName: Swift.String?
    /// The WorkMail organization under which you're creating the domain.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        domainName: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.domainName = domainName
        self.organizationId = organizationId
    }
}

public struct RegisterMailDomainOutput {

    public init() { }
}

public struct RegisterToWorkMailInput {
    /// The email for the user, group, or resource to be updated.
    /// This member is required.
    public var email: Swift.String?
    /// The identifier for the user, group, or resource to be updated. The identifier can accept UserId, ResourceId, or GroupId, or Username, Resourcename, or Groupname. The following identity formats are available:
    ///
    /// * Entity ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Entity name: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier for the organization under which the user, group, or resource exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        email: Swift.String? = nil,
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.email = email
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

public struct RegisterToWorkMailOutput {

    public init() { }
}

public struct ResetPasswordInput {
    /// The identifier of the organization that contains the user for which the password is reset.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The new password for the user.
    /// This member is required.
    public var password: Swift.String?
    /// The identifier of the user for whom the password is reset.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        organizationId: Swift.String? = nil,
        password: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.password = password
        self.userId = userId
    }
}

extension ResetPasswordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetPasswordInput(organizationId: \(Swift.String(describing: organizationId)), userId: \(Swift.String(describing: userId)), password: \"CONTENT_REDACTED\")"}
}

public struct ResetPasswordOutput {

    public init() { }
}

public struct StartMailboxExportJobInput {
    /// The idempotency token for the client request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The mailbox export job description.
    public var description: Swift.String?
    /// The identifier of the user or resource associated with the mailbox. The identifier can accept UserId or ResourceId, Username or Resourcename, or email. The following identity formats are available:
    ///
    /// * Entity ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789 , or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: entity@domain.tld
    ///
    /// * Entity name: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// The Amazon Resource Name (ARN) of the symmetric AWS Key Management Service (AWS KMS) key that encrypts the exported mailbox content.
    /// This member is required.
    public var kmsKeyArn: Swift.String?
    /// The identifier associated with the organization.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The ARN of the AWS Identity and Access Management (IAM) role that grants write permission to the S3 bucket.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The name of the S3 bucket.
    /// This member is required.
    public var s3BucketName: Swift.String?
    /// The S3 bucket prefix.
    /// This member is required.
    public var s3Prefix: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        entityId: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3Prefix: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.entityId = entityId
        self.kmsKeyArn = kmsKeyArn
        self.organizationId = organizationId
        self.roleArn = roleArn
        self.s3BucketName = s3BucketName
        self.s3Prefix = s3Prefix
    }
}

public struct StartMailboxExportJobOutput {
    /// The job ID.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

/// The resource can have up to 50 user-applied tags.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct TagResourceInput {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    public var tags: [WorkMailClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [WorkMailClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct TestAvailabilityConfigurationInput {
    /// The domain to which the provider applies. If this field is provided, a stored availability provider associated to this domain name will be tested.
    public var domainName: Swift.String?
    /// Describes an EWS based availability provider. This is only used as input to the service.
    public var ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider?
    /// Describes a Lambda based availability provider.
    public var lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider?
    /// The WorkMail organization where the availability provider will be tested.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider? = nil,
        lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.ewsProvider = ewsProvider
        self.lambdaProvider = lambdaProvider
        self.organizationId = organizationId
    }
}

public struct TestAvailabilityConfigurationOutput {
    /// String containing the reason for a failed test if TestPassed is false.
    public var failureReason: Swift.String?
    /// Boolean indicating whether the test passed or failed.
    public var testPassed: Swift.Bool

    public init(
        failureReason: Swift.String? = nil,
        testPassed: Swift.Bool = false
    )
    {
        self.failureReason = failureReason
        self.testPassed = testPassed
    }
}

public struct UntagResourceInput {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateAvailabilityConfigurationInput {
    /// The domain to which the provider applies the availability configuration.
    /// This member is required.
    public var domainName: Swift.String?
    /// The EWS availability provider definition. The request must contain exactly one provider definition, either EwsProvider or LambdaProvider. The previously stored provider will be overridden by the one provided.
    public var ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider?
    /// The Lambda availability provider definition. The request must contain exactly one provider definition, either EwsProvider or LambdaProvider. The previously stored provider will be overridden by the one provided.
    public var lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider?
    /// The WorkMail organization for which the AvailabilityConfiguration will be updated.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        ewsProvider: WorkMailClientTypes.EwsAvailabilityProvider? = nil,
        lambdaProvider: WorkMailClientTypes.LambdaAvailabilityProvider? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.ewsProvider = ewsProvider
        self.lambdaProvider = lambdaProvider
        self.organizationId = organizationId
    }
}

public struct UpdateAvailabilityConfigurationOutput {

    public init() { }
}

public struct UpdateDefaultMailDomainInput {
    /// The domain name that will become the default domain.
    /// This member is required.
    public var domainName: Swift.String?
    /// The WorkMail organization for which to list domains.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.organizationId = organizationId
    }
}

public struct UpdateDefaultMailDomainOutput {

    public init() { }
}

public struct UpdateGroupInput {
    /// The identifier for the group to be updated. The identifier can accept GroupId, Groupname, or email. The following identity formats are available:
    ///
    /// * Group ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: group@domain.tld
    ///
    /// * Group name: group
    /// This member is required.
    public var groupId: Swift.String?
    /// If enabled, the group is hidden from the global address list.
    public var hiddenFromGlobalAddressList: Swift.Bool?
    /// The identifier for the organization under which the group exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        hiddenFromGlobalAddressList: Swift.Bool? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
        self.organizationId = organizationId
    }
}

public struct UpdateGroupOutput {

    public init() { }
}

public struct UpdateImpersonationRoleInput {
    /// The updated impersonation role description.
    public var description: Swift.String?
    /// The ID of the impersonation role to update.
    /// This member is required.
    public var impersonationRoleId: Swift.String?
    /// The updated impersonation role name.
    /// This member is required.
    public var name: Swift.String?
    /// The WorkMail organization that contains the impersonation role to update.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The updated list of rules.
    /// This member is required.
    public var rules: [WorkMailClientTypes.ImpersonationRule]?
    /// The updated impersonation role type.
    /// This member is required.
    public var type: WorkMailClientTypes.ImpersonationRoleType?

    public init(
        description: Swift.String? = nil,
        impersonationRoleId: Swift.String? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        rules: [WorkMailClientTypes.ImpersonationRule]? = nil,
        type: WorkMailClientTypes.ImpersonationRoleType? = nil
    )
    {
        self.description = description
        self.impersonationRoleId = impersonationRoleId
        self.name = name
        self.organizationId = organizationId
        self.rules = rules
        self.type = type
    }
}

public struct UpdateImpersonationRoleOutput {

    public init() { }
}

public struct UpdateMailboxQuotaInput {
    /// The updated mailbox quota, in MB, for the specified user.
    /// This member is required.
    public var mailboxQuota: Swift.Int?
    /// The identifier for the organization that contains the user for whom to update the mailbox quota.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifer for the user for whom to update the mailbox quota. The identifier can be the UserId, Username, or email. The following identity formats are available:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var userId: Swift.String?

    public init(
        mailboxQuota: Swift.Int? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.mailboxQuota = mailboxQuota
        self.organizationId = organizationId
        self.userId = userId
    }
}

public struct UpdateMailboxQuotaOutput {

    public init() { }
}

public struct UpdateMobileDeviceAccessRuleInput {
    /// The updated rule description.
    public var description: Swift.String?
    /// Device models that the updated rule will match.
    public var deviceModels: [Swift.String]?
    /// Device operating systems that the updated rule will match.
    public var deviceOperatingSystems: [Swift.String]?
    /// Device types that the updated rule will match.
    public var deviceTypes: [Swift.String]?
    /// User agents that the updated rule will match.
    public var deviceUserAgents: [Swift.String]?
    /// The effect of the rule when it matches. Allowed values are ALLOW or DENY.
    /// This member is required.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// The identifier of the rule to be updated.
    /// This member is required.
    public var mobileDeviceAccessRuleId: Swift.String?
    /// The updated rule name.
    /// This member is required.
    public var name: Swift.String?
    /// Device models that the updated rule will not match. All other device models will match.
    public var notDeviceModels: [Swift.String]?
    /// Device operating systems that the updated rule will not match. All other device operating systems will match.
    public var notDeviceOperatingSystems: [Swift.String]?
    /// Device types that the updated rule will not match. All other device types will match.
    public var notDeviceTypes: [Swift.String]?
    /// User agents that the updated rule will not match. All other user agents will match.
    public var notDeviceUserAgents: [Swift.String]?
    /// The WorkMail organization under which the rule will be updated.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        description: Swift.String? = nil,
        deviceModels: [Swift.String]? = nil,
        deviceOperatingSystems: [Swift.String]? = nil,
        deviceTypes: [Swift.String]? = nil,
        deviceUserAgents: [Swift.String]? = nil,
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        mobileDeviceAccessRuleId: Swift.String? = nil,
        name: Swift.String? = nil,
        notDeviceModels: [Swift.String]? = nil,
        notDeviceOperatingSystems: [Swift.String]? = nil,
        notDeviceTypes: [Swift.String]? = nil,
        notDeviceUserAgents: [Swift.String]? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.description = description
        self.deviceModels = deviceModels
        self.deviceOperatingSystems = deviceOperatingSystems
        self.deviceTypes = deviceTypes
        self.deviceUserAgents = deviceUserAgents
        self.effect = effect
        self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
        self.name = name
        self.notDeviceModels = notDeviceModels
        self.notDeviceOperatingSystems = notDeviceOperatingSystems
        self.notDeviceTypes = notDeviceTypes
        self.notDeviceUserAgents = notDeviceUserAgents
        self.organizationId = organizationId
    }
}

public struct UpdateMobileDeviceAccessRuleOutput {

    public init() { }
}

public struct UpdatePrimaryEmailAddressInput {
    /// The value of the email to be updated as primary.
    /// This member is required.
    public var email: Swift.String?
    /// The user, group, or resource to update. The identifier can accept UseriD, ResourceId, or GroupId, Username, Resourcename, or Groupname, or email. The following identity formats are available:
    ///
    /// * Entity ID: 12345678-1234-1234-1234-123456789012, r-0123456789a0123456789b0123456789, or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: entity@domain.tld
    ///
    /// * Entity name: entity
    /// This member is required.
    public var entityId: Swift.String?
    /// The organization that contains the user, group, or resource to update.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        email: Swift.String? = nil,
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.email = email
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

public struct UpdatePrimaryEmailAddressOutput {

    public init() { }
}

public struct UpdateResourceInput {
    /// The resource's booking options to be updated.
    public var bookingOptions: WorkMailClientTypes.BookingOptions?
    /// Updates the resource description.
    public var description: Swift.String?
    /// If enabled, the resource is hidden from the global address list.
    public var hiddenFromGlobalAddressList: Swift.Bool?
    /// The name of the resource to be updated.
    public var name: Swift.String?
    /// The identifier associated with the organization for which the resource is updated.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the resource to be updated. The identifier can accept ResourceId, Resourcename, or email. The following identity formats are available:
    ///
    /// * Resource ID: r-0123456789a0123456789b0123456789
    ///
    /// * Email address: resource@domain.tld
    ///
    /// * Resource name: resource
    /// This member is required.
    public var resourceId: Swift.String?
    /// Updates the resource type.
    public var type: WorkMailClientTypes.ResourceType?

    public init(
        bookingOptions: WorkMailClientTypes.BookingOptions? = nil,
        description: Swift.String? = nil,
        hiddenFromGlobalAddressList: Swift.Bool? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        type: WorkMailClientTypes.ResourceType? = nil
    )
    {
        self.bookingOptions = bookingOptions
        self.description = description
        self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
        self.name = name
        self.organizationId = organizationId
        self.resourceId = resourceId
        self.type = type
    }
}

public struct UpdateResourceOutput {

    public init() { }
}

public struct UpdateUserInput {
    /// Updates the user's city.
    public var city: Swift.String?
    /// Updates the user's company.
    public var company: Swift.String?
    /// Updates the user's country.
    public var country: Swift.String?
    /// Updates the user's department.
    public var department: Swift.String?
    /// Updates the display name of the user.
    public var displayName: Swift.String?
    /// Updates the user's first name.
    public var firstName: Swift.String?
    /// If enabled, the user is hidden from the global address list.
    public var hiddenFromGlobalAddressList: Swift.Bool?
    /// Updates the user's initials.
    public var initials: Swift.String?
    /// Updates the user's job title.
    public var jobTitle: Swift.String?
    /// Updates the user's last name.
    public var lastName: Swift.String?
    /// Updates the user's office.
    public var office: Swift.String?
    /// The identifier for the organization under which the user exists.
    /// This member is required.
    public var organizationId: Swift.String?
    /// Updates the user role. You cannot pass SYSTEM_USER or RESOURCE.
    public var role: WorkMailClientTypes.UserRole?
    /// Updates the user's street address.
    public var street: Swift.String?
    /// Updates the user's contact details.
    public var telephone: Swift.String?
    /// The identifier for the user to be updated. The identifier can be the UserId, Username, or email. The following identity formats are available:
    ///
    /// * User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    /// * Email address: user@domain.tld
    ///
    /// * User name: user
    /// This member is required.
    public var userId: Swift.String?
    /// Updates the user's zipcode.
    public var zipCode: Swift.String?

    public init(
        city: Swift.String? = nil,
        company: Swift.String? = nil,
        country: Swift.String? = nil,
        department: Swift.String? = nil,
        displayName: Swift.String? = nil,
        firstName: Swift.String? = nil,
        hiddenFromGlobalAddressList: Swift.Bool? = nil,
        initials: Swift.String? = nil,
        jobTitle: Swift.String? = nil,
        lastName: Swift.String? = nil,
        office: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        role: WorkMailClientTypes.UserRole? = nil,
        street: Swift.String? = nil,
        telephone: Swift.String? = nil,
        userId: Swift.String? = nil,
        zipCode: Swift.String? = nil
    )
    {
        self.city = city
        self.company = company
        self.country = country
        self.department = department
        self.displayName = displayName
        self.firstName = firstName
        self.hiddenFromGlobalAddressList = hiddenFromGlobalAddressList
        self.initials = initials
        self.jobTitle = jobTitle
        self.lastName = lastName
        self.office = office
        self.organizationId = organizationId
        self.role = role
        self.street = street
        self.telephone = telephone
        self.userId = userId
        self.zipCode = zipCode
    }
}

extension UpdateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserInput(hiddenFromGlobalAddressList: \(Swift.String(describing: hiddenFromGlobalAddressList)), organizationId: \(Swift.String(describing: organizationId)), role: \(Swift.String(describing: role)), userId: \(Swift.String(describing: userId)), city: \"CONTENT_REDACTED\", company: \"CONTENT_REDACTED\", country: \"CONTENT_REDACTED\", department: \"CONTENT_REDACTED\", displayName: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", initials: \"CONTENT_REDACTED\", jobTitle: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", office: \"CONTENT_REDACTED\", street: \"CONTENT_REDACTED\", telephone: \"CONTENT_REDACTED\", zipCode: \"CONTENT_REDACTED\")"}
}

public struct UpdateUserOutput {

    public init() { }
}

extension AssociateDelegateToResourceInput {

    static func urlPathProvider(_ value: AssociateDelegateToResourceInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateMemberToGroupInput {

    static func urlPathProvider(_ value: AssociateMemberToGroupInput) -> Swift.String? {
        return "/"
    }
}

extension AssumeImpersonationRoleInput {

    static func urlPathProvider(_ value: AssumeImpersonationRoleInput) -> Swift.String? {
        return "/"
    }
}

extension CancelMailboxExportJobInput {

    static func urlPathProvider(_ value: CancelMailboxExportJobInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAliasInput {

    static func urlPathProvider(_ value: CreateAliasInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAvailabilityConfigurationInput {

    static func urlPathProvider(_ value: CreateAvailabilityConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateGroupInput {

    static func urlPathProvider(_ value: CreateGroupInput) -> Swift.String? {
        return "/"
    }
}

extension CreateImpersonationRoleInput {

    static func urlPathProvider(_ value: CreateImpersonationRoleInput) -> Swift.String? {
        return "/"
    }
}

extension CreateMobileDeviceAccessRuleInput {

    static func urlPathProvider(_ value: CreateMobileDeviceAccessRuleInput) -> Swift.String? {
        return "/"
    }
}

extension CreateOrganizationInput {

    static func urlPathProvider(_ value: CreateOrganizationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateResourceInput {

    static func urlPathProvider(_ value: CreateResourceInput) -> Swift.String? {
        return "/"
    }
}

extension CreateUserInput {

    static func urlPathProvider(_ value: CreateUserInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAccessControlRuleInput {

    static func urlPathProvider(_ value: DeleteAccessControlRuleInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAliasInput {

    static func urlPathProvider(_ value: DeleteAliasInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAvailabilityConfigurationInput {

    static func urlPathProvider(_ value: DeleteAvailabilityConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteEmailMonitoringConfigurationInput {

    static func urlPathProvider(_ value: DeleteEmailMonitoringConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteGroupInput {

    static func urlPathProvider(_ value: DeleteGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteImpersonationRoleInput {

    static func urlPathProvider(_ value: DeleteImpersonationRoleInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteMailboxPermissionsInput {

    static func urlPathProvider(_ value: DeleteMailboxPermissionsInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteMobileDeviceAccessOverrideInput {

    static func urlPathProvider(_ value: DeleteMobileDeviceAccessOverrideInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteMobileDeviceAccessRuleInput {

    static func urlPathProvider(_ value: DeleteMobileDeviceAccessRuleInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteOrganizationInput {

    static func urlPathProvider(_ value: DeleteOrganizationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteResourceInput {

    static func urlPathProvider(_ value: DeleteResourceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRetentionPolicyInput {

    static func urlPathProvider(_ value: DeleteRetentionPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteUserInput {

    static func urlPathProvider(_ value: DeleteUserInput) -> Swift.String? {
        return "/"
    }
}

extension DeregisterFromWorkMailInput {

    static func urlPathProvider(_ value: DeregisterFromWorkMailInput) -> Swift.String? {
        return "/"
    }
}

extension DeregisterMailDomainInput {

    static func urlPathProvider(_ value: DeregisterMailDomainInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEmailMonitoringConfigurationInput {

    static func urlPathProvider(_ value: DescribeEmailMonitoringConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEntityInput {

    static func urlPathProvider(_ value: DescribeEntityInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeGroupInput {

    static func urlPathProvider(_ value: DescribeGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeInboundDmarcSettingsInput {

    static func urlPathProvider(_ value: DescribeInboundDmarcSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeMailboxExportJobInput {

    static func urlPathProvider(_ value: DescribeMailboxExportJobInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeOrganizationInput {

    static func urlPathProvider(_ value: DescribeOrganizationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeResourceInput {

    static func urlPathProvider(_ value: DescribeResourceInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeUserInput {

    static func urlPathProvider(_ value: DescribeUserInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateDelegateFromResourceInput {

    static func urlPathProvider(_ value: DisassociateDelegateFromResourceInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateMemberFromGroupInput {

    static func urlPathProvider(_ value: DisassociateMemberFromGroupInput) -> Swift.String? {
        return "/"
    }
}

extension GetAccessControlEffectInput {

    static func urlPathProvider(_ value: GetAccessControlEffectInput) -> Swift.String? {
        return "/"
    }
}

extension GetDefaultRetentionPolicyInput {

    static func urlPathProvider(_ value: GetDefaultRetentionPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetImpersonationRoleInput {

    static func urlPathProvider(_ value: GetImpersonationRoleInput) -> Swift.String? {
        return "/"
    }
}

extension GetImpersonationRoleEffectInput {

    static func urlPathProvider(_ value: GetImpersonationRoleEffectInput) -> Swift.String? {
        return "/"
    }
}

extension GetMailboxDetailsInput {

    static func urlPathProvider(_ value: GetMailboxDetailsInput) -> Swift.String? {
        return "/"
    }
}

extension GetMailDomainInput {

    static func urlPathProvider(_ value: GetMailDomainInput) -> Swift.String? {
        return "/"
    }
}

extension GetMobileDeviceAccessEffectInput {

    static func urlPathProvider(_ value: GetMobileDeviceAccessEffectInput) -> Swift.String? {
        return "/"
    }
}

extension GetMobileDeviceAccessOverrideInput {

    static func urlPathProvider(_ value: GetMobileDeviceAccessOverrideInput) -> Swift.String? {
        return "/"
    }
}

extension ListAccessControlRulesInput {

    static func urlPathProvider(_ value: ListAccessControlRulesInput) -> Swift.String? {
        return "/"
    }
}

extension ListAliasesInput {

    static func urlPathProvider(_ value: ListAliasesInput) -> Swift.String? {
        return "/"
    }
}

extension ListAvailabilityConfigurationsInput {

    static func urlPathProvider(_ value: ListAvailabilityConfigurationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListGroupMembersInput {

    static func urlPathProvider(_ value: ListGroupMembersInput) -> Swift.String? {
        return "/"
    }
}

extension ListGroupsInput {

    static func urlPathProvider(_ value: ListGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension ListGroupsForEntityInput {

    static func urlPathProvider(_ value: ListGroupsForEntityInput) -> Swift.String? {
        return "/"
    }
}

extension ListImpersonationRolesInput {

    static func urlPathProvider(_ value: ListImpersonationRolesInput) -> Swift.String? {
        return "/"
    }
}

extension ListMailboxExportJobsInput {

    static func urlPathProvider(_ value: ListMailboxExportJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListMailboxPermissionsInput {

    static func urlPathProvider(_ value: ListMailboxPermissionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListMailDomainsInput {

    static func urlPathProvider(_ value: ListMailDomainsInput) -> Swift.String? {
        return "/"
    }
}

extension ListMobileDeviceAccessOverridesInput {

    static func urlPathProvider(_ value: ListMobileDeviceAccessOverridesInput) -> Swift.String? {
        return "/"
    }
}

extension ListMobileDeviceAccessRulesInput {

    static func urlPathProvider(_ value: ListMobileDeviceAccessRulesInput) -> Swift.String? {
        return "/"
    }
}

extension ListOrganizationsInput {

    static func urlPathProvider(_ value: ListOrganizationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListResourceDelegatesInput {

    static func urlPathProvider(_ value: ListResourceDelegatesInput) -> Swift.String? {
        return "/"
    }
}

extension ListResourcesInput {

    static func urlPathProvider(_ value: ListResourcesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListUsersInput {

    static func urlPathProvider(_ value: ListUsersInput) -> Swift.String? {
        return "/"
    }
}

extension PutAccessControlRuleInput {

    static func urlPathProvider(_ value: PutAccessControlRuleInput) -> Swift.String? {
        return "/"
    }
}

extension PutEmailMonitoringConfigurationInput {

    static func urlPathProvider(_ value: PutEmailMonitoringConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension PutInboundDmarcSettingsInput {

    static func urlPathProvider(_ value: PutInboundDmarcSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension PutMailboxPermissionsInput {

    static func urlPathProvider(_ value: PutMailboxPermissionsInput) -> Swift.String? {
        return "/"
    }
}

extension PutMobileDeviceAccessOverrideInput {

    static func urlPathProvider(_ value: PutMobileDeviceAccessOverrideInput) -> Swift.String? {
        return "/"
    }
}

extension PutRetentionPolicyInput {

    static func urlPathProvider(_ value: PutRetentionPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterMailDomainInput {

    static func urlPathProvider(_ value: RegisterMailDomainInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterToWorkMailInput {

    static func urlPathProvider(_ value: RegisterToWorkMailInput) -> Swift.String? {
        return "/"
    }
}

extension ResetPasswordInput {

    static func urlPathProvider(_ value: ResetPasswordInput) -> Swift.String? {
        return "/"
    }
}

extension StartMailboxExportJobInput {

    static func urlPathProvider(_ value: StartMailboxExportJobInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TestAvailabilityConfigurationInput {

    static func urlPathProvider(_ value: TestAvailabilityConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAvailabilityConfigurationInput {

    static func urlPathProvider(_ value: UpdateAvailabilityConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDefaultMailDomainInput {

    static func urlPathProvider(_ value: UpdateDefaultMailDomainInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateGroupInput {

    static func urlPathProvider(_ value: UpdateGroupInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateImpersonationRoleInput {

    static func urlPathProvider(_ value: UpdateImpersonationRoleInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateMailboxQuotaInput {

    static func urlPathProvider(_ value: UpdateMailboxQuotaInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateMobileDeviceAccessRuleInput {

    static func urlPathProvider(_ value: UpdateMobileDeviceAccessRuleInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePrimaryEmailAddressInput {

    static func urlPathProvider(_ value: UpdatePrimaryEmailAddressInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateResourceInput {

    static func urlPathProvider(_ value: UpdateResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateUserInput {

    static func urlPathProvider(_ value: UpdateUserInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateDelegateToResourceInput {

    static func write(value: AssociateDelegateToResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EntityId"].write(value.entityId)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension AssociateMemberToGroupInput {

    static func write(value: AssociateMemberToGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupId"].write(value.groupId)
        try writer["MemberId"].write(value.memberId)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension AssumeImpersonationRoleInput {

    static func write(value: AssumeImpersonationRoleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ImpersonationRoleId"].write(value.impersonationRoleId)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension CancelMailboxExportJobInput {

    static func write(value: CancelMailboxExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["JobId"].write(value.jobId)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension CreateAliasInput {

    static func write(value: CreateAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Alias"].write(value.alias)
        try writer["EntityId"].write(value.entityId)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension CreateAvailabilityConfigurationInput {

    static func write(value: CreateAvailabilityConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DomainName"].write(value.domainName)
        try writer["EwsProvider"].write(value.ewsProvider, with: WorkMailClientTypes.EwsAvailabilityProvider.write(value:to:))
        try writer["LambdaProvider"].write(value.lambdaProvider, with: WorkMailClientTypes.LambdaAvailabilityProvider.write(value:to:))
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension CreateGroupInput {

    static func write(value: CreateGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HiddenFromGlobalAddressList"].write(value.hiddenFromGlobalAddressList)
        try writer["Name"].write(value.name)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension CreateImpersonationRoleInput {

    static func write(value: CreateImpersonationRoleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["Rules"].writeList(value.rules, memberWritingClosure: WorkMailClientTypes.ImpersonationRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
    }
}

extension CreateMobileDeviceAccessRuleInput {

    static func write(value: CreateMobileDeviceAccessRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["DeviceModels"].writeList(value.deviceModels, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DeviceOperatingSystems"].writeList(value.deviceOperatingSystems, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DeviceTypes"].writeList(value.deviceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DeviceUserAgents"].writeList(value.deviceUserAgents, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Effect"].write(value.effect)
        try writer["Name"].write(value.name)
        try writer["NotDeviceModels"].writeList(value.notDeviceModels, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NotDeviceOperatingSystems"].writeList(value.notDeviceOperatingSystems, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NotDeviceTypes"].writeList(value.notDeviceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NotDeviceUserAgents"].writeList(value.notDeviceUserAgents, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension CreateOrganizationInput {

    static func write(value: CreateOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Alias"].write(value.alias)
        try writer["ClientToken"].write(value.clientToken)
        try writer["DirectoryId"].write(value.directoryId)
        try writer["Domains"].writeList(value.domains, memberWritingClosure: WorkMailClientTypes.Domain.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EnableInteroperability"].write(value.enableInteroperability)
        try writer["KmsKeyArn"].write(value.kmsKeyArn)
    }
}

extension CreateResourceInput {

    static func write(value: CreateResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["HiddenFromGlobalAddressList"].write(value.hiddenFromGlobalAddressList)
        try writer["Name"].write(value.name)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["Type"].write(value.type)
    }
}

extension CreateUserInput {

    static func write(value: CreateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayName"].write(value.displayName)
        try writer["FirstName"].write(value.firstName)
        try writer["HiddenFromGlobalAddressList"].write(value.hiddenFromGlobalAddressList)
        try writer["LastName"].write(value.lastName)
        try writer["Name"].write(value.name)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["Password"].write(value.password)
        try writer["Role"].write(value.role)
    }
}

extension DeleteAccessControlRuleInput {

    static func write(value: DeleteAccessControlRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension DeleteAliasInput {

    static func write(value: DeleteAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Alias"].write(value.alias)
        try writer["EntityId"].write(value.entityId)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension DeleteAvailabilityConfigurationInput {

    static func write(value: DeleteAvailabilityConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension DeleteEmailMonitoringConfigurationInput {

    static func write(value: DeleteEmailMonitoringConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension DeleteGroupInput {

    static func write(value: DeleteGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupId"].write(value.groupId)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension DeleteImpersonationRoleInput {

    static func write(value: DeleteImpersonationRoleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ImpersonationRoleId"].write(value.impersonationRoleId)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension DeleteMailboxPermissionsInput {

    static func write(value: DeleteMailboxPermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EntityId"].write(value.entityId)
        try writer["GranteeId"].write(value.granteeId)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension DeleteMobileDeviceAccessOverrideInput {

    static func write(value: DeleteMobileDeviceAccessOverrideInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceId"].write(value.deviceId)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["UserId"].write(value.userId)
    }
}

extension DeleteMobileDeviceAccessRuleInput {

    static func write(value: DeleteMobileDeviceAccessRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MobileDeviceAccessRuleId"].write(value.mobileDeviceAccessRuleId)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension DeleteOrganizationInput {

    static func write(value: DeleteOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DeleteDirectory"].write(value.deleteDirectory)
        try writer["ForceDelete"].write(value.forceDelete)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension DeleteResourceInput {

    static func write(value: DeleteResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationId"].write(value.organizationId)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension DeleteRetentionPolicyInput {

    static func write(value: DeleteRetentionPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension DeleteUserInput {

    static func write(value: DeleteUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationId"].write(value.organizationId)
        try writer["UserId"].write(value.userId)
    }
}

extension DeregisterFromWorkMailInput {

    static func write(value: DeregisterFromWorkMailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EntityId"].write(value.entityId)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension DeregisterMailDomainInput {

    static func write(value: DeregisterMailDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension DescribeEmailMonitoringConfigurationInput {

    static func write(value: DescribeEmailMonitoringConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension DescribeEntityInput {

    static func write(value: DescribeEntityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Email"].write(value.email)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension DescribeGroupInput {

    static func write(value: DescribeGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupId"].write(value.groupId)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension DescribeInboundDmarcSettingsInput {

    static func write(value: DescribeInboundDmarcSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension DescribeMailboxExportJobInput {

    static func write(value: DescribeMailboxExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["JobId"].write(value.jobId)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension DescribeOrganizationInput {

    static func write(value: DescribeOrganizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension DescribeResourceInput {

    static func write(value: DescribeResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationId"].write(value.organizationId)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension DescribeUserInput {

    static func write(value: DescribeUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationId"].write(value.organizationId)
        try writer["UserId"].write(value.userId)
    }
}

extension DisassociateDelegateFromResourceInput {

    static func write(value: DisassociateDelegateFromResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EntityId"].write(value.entityId)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension DisassociateMemberFromGroupInput {

    static func write(value: DisassociateMemberFromGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupId"].write(value.groupId)
        try writer["MemberId"].write(value.memberId)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension GetAccessControlEffectInput {

    static func write(value: GetAccessControlEffectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["ImpersonationRoleId"].write(value.impersonationRoleId)
        try writer["IpAddress"].write(value.ipAddress)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["UserId"].write(value.userId)
    }
}

extension GetDefaultRetentionPolicyInput {

    static func write(value: GetDefaultRetentionPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension GetImpersonationRoleInput {

    static func write(value: GetImpersonationRoleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ImpersonationRoleId"].write(value.impersonationRoleId)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension GetImpersonationRoleEffectInput {

    static func write(value: GetImpersonationRoleEffectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ImpersonationRoleId"].write(value.impersonationRoleId)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["TargetUser"].write(value.targetUser)
    }
}

extension GetMailboxDetailsInput {

    static func write(value: GetMailboxDetailsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationId"].write(value.organizationId)
        try writer["UserId"].write(value.userId)
    }
}

extension GetMailDomainInput {

    static func write(value: GetMailDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension GetMobileDeviceAccessEffectInput {

    static func write(value: GetMobileDeviceAccessEffectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceModel"].write(value.deviceModel)
        try writer["DeviceOperatingSystem"].write(value.deviceOperatingSystem)
        try writer["DeviceType"].write(value.deviceType)
        try writer["DeviceUserAgent"].write(value.deviceUserAgent)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension GetMobileDeviceAccessOverrideInput {

    static func write(value: GetMobileDeviceAccessOverrideInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceId"].write(value.deviceId)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["UserId"].write(value.userId)
    }
}

extension ListAccessControlRulesInput {

    static func write(value: ListAccessControlRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension ListAliasesInput {

    static func write(value: ListAliasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EntityId"].write(value.entityId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension ListAvailabilityConfigurationsInput {

    static func write(value: ListAvailabilityConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension ListGroupMembersInput {

    static func write(value: ListGroupMembersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupId"].write(value.groupId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension ListGroupsInput {

    static func write(value: ListGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: WorkMailClientTypes.ListGroupsFilters.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension ListGroupsForEntityInput {

    static func write(value: ListGroupsForEntityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EntityId"].write(value.entityId)
        try writer["Filters"].write(value.filters, with: WorkMailClientTypes.ListGroupsForEntityFilters.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension ListImpersonationRolesInput {

    static func write(value: ListImpersonationRolesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension ListMailboxExportJobsInput {

    static func write(value: ListMailboxExportJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension ListMailboxPermissionsInput {

    static func write(value: ListMailboxPermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EntityId"].write(value.entityId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension ListMailDomainsInput {

    static func write(value: ListMailDomainsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension ListMobileDeviceAccessOverridesInput {

    static func write(value: ListMobileDeviceAccessOverridesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceId"].write(value.deviceId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["UserId"].write(value.userId)
    }
}

extension ListMobileDeviceAccessRulesInput {

    static func write(value: ListMobileDeviceAccessRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension ListOrganizationsInput {

    static func write(value: ListOrganizationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListResourceDelegatesInput {

    static func write(value: ListResourceDelegatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension ListResourcesInput {

    static func write(value: ListResourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: WorkMailClientTypes.ListResourcesFilters.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension ListUsersInput {

    static func write(value: ListUsersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: WorkMailClientTypes.ListUsersFilters.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension PutAccessControlRuleInput {

    static func write(value: PutAccessControlRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Actions"].writeList(value.actions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["Effect"].write(value.effect)
        try writer["ImpersonationRoleIds"].writeList(value.impersonationRoleIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IpRanges"].writeList(value.ipRanges, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["NotActions"].writeList(value.notActions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NotImpersonationRoleIds"].writeList(value.notImpersonationRoleIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NotIpRanges"].writeList(value.notIpRanges, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NotUserIds"].writeList(value.notUserIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["UserIds"].writeList(value.userIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutEmailMonitoringConfigurationInput {

    static func write(value: PutEmailMonitoringConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LogGroupArn"].write(value.logGroupArn)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["RoleArn"].write(value.roleArn)
    }
}

extension PutInboundDmarcSettingsInput {

    static func write(value: PutInboundDmarcSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enforced"].write(value.enforced)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension PutMailboxPermissionsInput {

    static func write(value: PutMailboxPermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EntityId"].write(value.entityId)
        try writer["GranteeId"].write(value.granteeId)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["PermissionValues"].writeList(value.permissionValues, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkMailClientTypes.PermissionType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutMobileDeviceAccessOverrideInput {

    static func write(value: PutMobileDeviceAccessOverrideInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["DeviceId"].write(value.deviceId)
        try writer["Effect"].write(value.effect)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["UserId"].write(value.userId)
    }
}

extension PutRetentionPolicyInput {

    static func write(value: PutRetentionPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["FolderConfigurations"].writeList(value.folderConfigurations, memberWritingClosure: WorkMailClientTypes.FolderConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Id"].write(value.id)
        try writer["Name"].write(value.name)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension RegisterMailDomainInput {

    static func write(value: RegisterMailDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DomainName"].write(value.domainName)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension RegisterToWorkMailInput {

    static func write(value: RegisterToWorkMailInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Email"].write(value.email)
        try writer["EntityId"].write(value.entityId)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension ResetPasswordInput {

    static func write(value: ResetPasswordInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OrganizationId"].write(value.organizationId)
        try writer["Password"].write(value.password)
        try writer["UserId"].write(value.userId)
    }
}

extension StartMailboxExportJobInput {

    static func write(value: StartMailboxExportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["EntityId"].write(value.entityId)
        try writer["KmsKeyArn"].write(value.kmsKeyArn)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["RoleArn"].write(value.roleArn)
        try writer["S3BucketName"].write(value.s3BucketName)
        try writer["S3Prefix"].write(value.s3Prefix)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: WorkMailClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TestAvailabilityConfigurationInput {

    static func write(value: TestAvailabilityConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["EwsProvider"].write(value.ewsProvider, with: WorkMailClientTypes.EwsAvailabilityProvider.write(value:to:))
        try writer["LambdaProvider"].write(value.lambdaProvider, with: WorkMailClientTypes.LambdaAvailabilityProvider.write(value:to:))
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAvailabilityConfigurationInput {

    static func write(value: UpdateAvailabilityConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["EwsProvider"].write(value.ewsProvider, with: WorkMailClientTypes.EwsAvailabilityProvider.write(value:to:))
        try writer["LambdaProvider"].write(value.lambdaProvider, with: WorkMailClientTypes.LambdaAvailabilityProvider.write(value:to:))
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension UpdateDefaultMailDomainInput {

    static func write(value: UpdateDefaultMailDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension UpdateGroupInput {

    static func write(value: UpdateGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupId"].write(value.groupId)
        try writer["HiddenFromGlobalAddressList"].write(value.hiddenFromGlobalAddressList)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension UpdateImpersonationRoleInput {

    static func write(value: UpdateImpersonationRoleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["ImpersonationRoleId"].write(value.impersonationRoleId)
        try writer["Name"].write(value.name)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["Rules"].writeList(value.rules, memberWritingClosure: WorkMailClientTypes.ImpersonationRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
    }
}

extension UpdateMailboxQuotaInput {

    static func write(value: UpdateMailboxQuotaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MailboxQuota"].write(value.mailboxQuota)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["UserId"].write(value.userId)
    }
}

extension UpdateMobileDeviceAccessRuleInput {

    static func write(value: UpdateMobileDeviceAccessRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["DeviceModels"].writeList(value.deviceModels, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DeviceOperatingSystems"].writeList(value.deviceOperatingSystems, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DeviceTypes"].writeList(value.deviceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["DeviceUserAgents"].writeList(value.deviceUserAgents, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Effect"].write(value.effect)
        try writer["MobileDeviceAccessRuleId"].write(value.mobileDeviceAccessRuleId)
        try writer["Name"].write(value.name)
        try writer["NotDeviceModels"].writeList(value.notDeviceModels, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NotDeviceOperatingSystems"].writeList(value.notDeviceOperatingSystems, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NotDeviceTypes"].writeList(value.notDeviceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NotDeviceUserAgents"].writeList(value.notDeviceUserAgents, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension UpdatePrimaryEmailAddressInput {

    static func write(value: UpdatePrimaryEmailAddressInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Email"].write(value.email)
        try writer["EntityId"].write(value.entityId)
        try writer["OrganizationId"].write(value.organizationId)
    }
}

extension UpdateResourceInput {

    static func write(value: UpdateResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BookingOptions"].write(value.bookingOptions, with: WorkMailClientTypes.BookingOptions.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["HiddenFromGlobalAddressList"].write(value.hiddenFromGlobalAddressList)
        try writer["Name"].write(value.name)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["ResourceId"].write(value.resourceId)
        try writer["Type"].write(value.type)
    }
}

extension UpdateUserInput {

    static func write(value: UpdateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["City"].write(value.city)
        try writer["Company"].write(value.company)
        try writer["Country"].write(value.country)
        try writer["Department"].write(value.department)
        try writer["DisplayName"].write(value.displayName)
        try writer["FirstName"].write(value.firstName)
        try writer["HiddenFromGlobalAddressList"].write(value.hiddenFromGlobalAddressList)
        try writer["Initials"].write(value.initials)
        try writer["JobTitle"].write(value.jobTitle)
        try writer["LastName"].write(value.lastName)
        try writer["Office"].write(value.office)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["Role"].write(value.role)
        try writer["Street"].write(value.street)
        try writer["Telephone"].write(value.telephone)
        try writer["UserId"].write(value.userId)
        try writer["ZipCode"].write(value.zipCode)
    }
}

extension AssociateDelegateToResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateDelegateToResourceOutput {
        return AssociateDelegateToResourceOutput()
    }
}

extension AssociateMemberToGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateMemberToGroupOutput {
        return AssociateMemberToGroupOutput()
    }
}

extension AssumeImpersonationRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssumeImpersonationRoleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssumeImpersonationRoleOutput()
        value.expiresIn = try reader["ExpiresIn"].readIfPresent()
        value.token = try reader["Token"].readIfPresent()
        return value
    }
}

extension CancelMailboxExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelMailboxExportJobOutput {
        return CancelMailboxExportJobOutput()
    }
}

extension CreateAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAliasOutput {
        return CreateAliasOutput()
    }
}

extension CreateAvailabilityConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAvailabilityConfigurationOutput {
        return CreateAvailabilityConfigurationOutput()
    }
}

extension CreateGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGroupOutput()
        value.groupId = try reader["GroupId"].readIfPresent()
        return value
    }
}

extension CreateImpersonationRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateImpersonationRoleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateImpersonationRoleOutput()
        value.impersonationRoleId = try reader["ImpersonationRoleId"].readIfPresent()
        return value
    }
}

extension CreateMobileDeviceAccessRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMobileDeviceAccessRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMobileDeviceAccessRuleOutput()
        value.mobileDeviceAccessRuleId = try reader["MobileDeviceAccessRuleId"].readIfPresent()
        return value
    }
}

extension CreateOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOrganizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOrganizationOutput()
        value.organizationId = try reader["OrganizationId"].readIfPresent()
        return value
    }
}

extension CreateResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateResourceOutput()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        return value
    }
}

extension CreateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUserOutput()
        value.userId = try reader["UserId"].readIfPresent()
        return value
    }
}

extension DeleteAccessControlRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccessControlRuleOutput {
        return DeleteAccessControlRuleOutput()
    }
}

extension DeleteAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAliasOutput {
        return DeleteAliasOutput()
    }
}

extension DeleteAvailabilityConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAvailabilityConfigurationOutput {
        return DeleteAvailabilityConfigurationOutput()
    }
}

extension DeleteEmailMonitoringConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEmailMonitoringConfigurationOutput {
        return DeleteEmailMonitoringConfigurationOutput()
    }
}

extension DeleteGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGroupOutput {
        return DeleteGroupOutput()
    }
}

extension DeleteImpersonationRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteImpersonationRoleOutput {
        return DeleteImpersonationRoleOutput()
    }
}

extension DeleteMailboxPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMailboxPermissionsOutput {
        return DeleteMailboxPermissionsOutput()
    }
}

extension DeleteMobileDeviceAccessOverrideOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMobileDeviceAccessOverrideOutput {
        return DeleteMobileDeviceAccessOverrideOutput()
    }
}

extension DeleteMobileDeviceAccessRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMobileDeviceAccessRuleOutput {
        return DeleteMobileDeviceAccessRuleOutput()
    }
}

extension DeleteOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOrganizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteOrganizationOutput()
        value.organizationId = try reader["OrganizationId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension DeleteResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourceOutput {
        return DeleteResourceOutput()
    }
}

extension DeleteRetentionPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRetentionPolicyOutput {
        return DeleteRetentionPolicyOutput()
    }
}

extension DeleteUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUserOutput {
        return DeleteUserOutput()
    }
}

extension DeregisterFromWorkMailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterFromWorkMailOutput {
        return DeregisterFromWorkMailOutput()
    }
}

extension DeregisterMailDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterMailDomainOutput {
        return DeregisterMailDomainOutput()
    }
}

extension DescribeEmailMonitoringConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEmailMonitoringConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEmailMonitoringConfigurationOutput()
        value.logGroupArn = try reader["LogGroupArn"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

extension DescribeEntityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEntityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEntityOutput()
        value.entityId = try reader["EntityId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension DescribeGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeGroupOutput()
        value.disabledDate = try reader["DisabledDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.email = try reader["Email"].readIfPresent()
        value.enabledDate = try reader["EnabledDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.groupId = try reader["GroupId"].readIfPresent()
        value.hiddenFromGlobalAddressList = try reader["HiddenFromGlobalAddressList"].readIfPresent() ?? false
        value.name = try reader["Name"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension DescribeInboundDmarcSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInboundDmarcSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInboundDmarcSettingsOutput()
        value.enforced = try reader["Enforced"].readIfPresent() ?? false
        return value
    }
}

extension DescribeMailboxExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMailboxExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMailboxExportJobOutput()
        value.description = try reader["Description"].readIfPresent()
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.entityId = try reader["EntityId"].readIfPresent()
        value.errorInfo = try reader["ErrorInfo"].readIfPresent()
        value.estimatedProgress = try reader["EstimatedProgress"].readIfPresent() ?? 0
        value.kmsKeyArn = try reader["KmsKeyArn"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent()
        value.s3Path = try reader["S3Path"].readIfPresent()
        value.s3Prefix = try reader["S3Prefix"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension DescribeOrganizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeOrganizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeOrganizationOutput()
        value.arn = try reader["ARN"].readIfPresent()
        value.alias = try reader["Alias"].readIfPresent()
        value.completedDate = try reader["CompletedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaultMailDomain = try reader["DefaultMailDomain"].readIfPresent()
        value.directoryId = try reader["DirectoryId"].readIfPresent()
        value.directoryType = try reader["DirectoryType"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.interoperabilityEnabled = try reader["InteroperabilityEnabled"].readIfPresent() ?? false
        value.migrationAdmin = try reader["MigrationAdmin"].readIfPresent()
        value.organizationId = try reader["OrganizationId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension DescribeResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeResourceOutput()
        value.bookingOptions = try reader["BookingOptions"].readIfPresent(with: WorkMailClientTypes.BookingOptions.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.disabledDate = try reader["DisabledDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.email = try reader["Email"].readIfPresent()
        value.enabledDate = try reader["EnabledDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.hiddenFromGlobalAddressList = try reader["HiddenFromGlobalAddressList"].readIfPresent() ?? false
        value.name = try reader["Name"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension DescribeUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeUserOutput()
        value.city = try reader["City"].readIfPresent()
        value.company = try reader["Company"].readIfPresent()
        value.country = try reader["Country"].readIfPresent()
        value.department = try reader["Department"].readIfPresent()
        value.disabledDate = try reader["DisabledDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.email = try reader["Email"].readIfPresent()
        value.enabledDate = try reader["EnabledDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.firstName = try reader["FirstName"].readIfPresent()
        value.hiddenFromGlobalAddressList = try reader["HiddenFromGlobalAddressList"].readIfPresent() ?? false
        value.initials = try reader["Initials"].readIfPresent()
        value.jobTitle = try reader["JobTitle"].readIfPresent()
        value.lastName = try reader["LastName"].readIfPresent()
        value.mailboxDeprovisionedDate = try reader["MailboxDeprovisionedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.mailboxProvisionedDate = try reader["MailboxProvisionedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["Name"].readIfPresent()
        value.office = try reader["Office"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.street = try reader["Street"].readIfPresent()
        value.telephone = try reader["Telephone"].readIfPresent()
        value.userId = try reader["UserId"].readIfPresent()
        value.userRole = try reader["UserRole"].readIfPresent()
        value.zipCode = try reader["ZipCode"].readIfPresent()
        return value
    }
}

extension DisassociateDelegateFromResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateDelegateFromResourceOutput {
        return DisassociateDelegateFromResourceOutput()
    }
}

extension DisassociateMemberFromGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateMemberFromGroupOutput {
        return DisassociateMemberFromGroupOutput()
    }
}

extension GetAccessControlEffectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccessControlEffectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccessControlEffectOutput()
        value.effect = try reader["Effect"].readIfPresent()
        value.matchedRules = try reader["MatchedRules"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetDefaultRetentionPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDefaultRetentionPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDefaultRetentionPolicyOutput()
        value.description = try reader["Description"].readIfPresent()
        value.folderConfigurations = try reader["FolderConfigurations"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.FolderConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension GetImpersonationRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImpersonationRoleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetImpersonationRoleOutput()
        value.dateCreated = try reader["DateCreated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dateModified = try reader["DateModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.impersonationRoleId = try reader["ImpersonationRoleId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.ImpersonationRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension GetImpersonationRoleEffectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImpersonationRoleEffectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetImpersonationRoleEffectOutput()
        value.effect = try reader["Effect"].readIfPresent()
        value.matchedRules = try reader["MatchedRules"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.ImpersonationMatchedRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension GetMailboxDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMailboxDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMailboxDetailsOutput()
        value.mailboxQuota = try reader["MailboxQuota"].readIfPresent()
        value.mailboxSize = try reader["MailboxSize"].readIfPresent() ?? 0
        return value
    }
}

extension GetMailDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMailDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMailDomainOutput()
        value.dkimVerificationStatus = try reader["DkimVerificationStatus"].readIfPresent()
        value.isDefault = try reader["IsDefault"].readIfPresent() ?? false
        value.isTestDomain = try reader["IsTestDomain"].readIfPresent() ?? false
        value.ownershipVerificationStatus = try reader["OwnershipVerificationStatus"].readIfPresent()
        value.records = try reader["Records"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.DnsRecord.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetMobileDeviceAccessEffectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMobileDeviceAccessEffectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMobileDeviceAccessEffectOutput()
        value.effect = try reader["Effect"].readIfPresent()
        value.matchedRules = try reader["MatchedRules"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.MobileDeviceAccessMatchedRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetMobileDeviceAccessOverrideOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMobileDeviceAccessOverrideOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMobileDeviceAccessOverrideOutput()
        value.dateCreated = try reader["DateCreated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dateModified = try reader["DateModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.effect = try reader["Effect"].readIfPresent()
        value.userId = try reader["UserId"].readIfPresent()
        return value
    }
}

extension ListAccessControlRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccessControlRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccessControlRulesOutput()
        value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.AccessControlRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListAliasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAliasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAliasesOutput()
        value.aliases = try reader["Aliases"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAvailabilityConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAvailabilityConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAvailabilityConfigurationsOutput()
        value.availabilityConfigurations = try reader["AvailabilityConfigurations"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.AvailabilityConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListGroupMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGroupMembersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGroupMembersOutput()
        value.members = try reader["Members"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.Member.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGroupsOutput()
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.Group.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListGroupsForEntityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGroupsForEntityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGroupsForEntityOutput()
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.GroupIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListImpersonationRolesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImpersonationRolesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImpersonationRolesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.roles = try reader["Roles"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.ImpersonationRole.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListMailboxExportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMailboxExportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMailboxExportJobsOutput()
        value.jobs = try reader["Jobs"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.MailboxExportJob.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListMailboxPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMailboxPermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMailboxPermissionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.permissions = try reader["Permissions"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.Permission.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListMailDomainsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMailDomainsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMailDomainsOutput()
        value.mailDomains = try reader["MailDomains"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.MailDomainSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListMobileDeviceAccessOverridesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMobileDeviceAccessOverridesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMobileDeviceAccessOverridesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.overrides = try reader["Overrides"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.MobileDeviceAccessOverride.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListMobileDeviceAccessRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMobileDeviceAccessRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMobileDeviceAccessRulesOutput()
        value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.MobileDeviceAccessRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListOrganizationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOrganizationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOrganizationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.organizationSummaries = try reader["OrganizationSummaries"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.OrganizationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListResourceDelegatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourceDelegatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourceDelegatesOutput()
        value.delegates = try reader["Delegates"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.Delegate.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourcesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resources = try reader["Resources"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListUsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUsersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.users = try reader["Users"].readListIfPresent(memberReadingClosure: WorkMailClientTypes.User.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutAccessControlRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutAccessControlRuleOutput {
        return PutAccessControlRuleOutput()
    }
}

extension PutEmailMonitoringConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutEmailMonitoringConfigurationOutput {
        return PutEmailMonitoringConfigurationOutput()
    }
}

extension PutInboundDmarcSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutInboundDmarcSettingsOutput {
        return PutInboundDmarcSettingsOutput()
    }
}

extension PutMailboxPermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutMailboxPermissionsOutput {
        return PutMailboxPermissionsOutput()
    }
}

extension PutMobileDeviceAccessOverrideOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutMobileDeviceAccessOverrideOutput {
        return PutMobileDeviceAccessOverrideOutput()
    }
}

extension PutRetentionPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRetentionPolicyOutput {
        return PutRetentionPolicyOutput()
    }
}

extension RegisterMailDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterMailDomainOutput {
        return RegisterMailDomainOutput()
    }
}

extension RegisterToWorkMailOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterToWorkMailOutput {
        return RegisterToWorkMailOutput()
    }
}

extension ResetPasswordOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResetPasswordOutput {
        return ResetPasswordOutput()
    }
}

extension StartMailboxExportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartMailboxExportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartMailboxExportJobOutput()
        value.jobId = try reader["JobId"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension TestAvailabilityConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestAvailabilityConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TestAvailabilityConfigurationOutput()
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.testPassed = try reader["TestPassed"].readIfPresent() ?? false
        return value
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAvailabilityConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAvailabilityConfigurationOutput {
        return UpdateAvailabilityConfigurationOutput()
    }
}

extension UpdateDefaultMailDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDefaultMailDomainOutput {
        return UpdateDefaultMailDomainOutput()
    }
}

extension UpdateGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGroupOutput {
        return UpdateGroupOutput()
    }
}

extension UpdateImpersonationRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateImpersonationRoleOutput {
        return UpdateImpersonationRoleOutput()
    }
}

extension UpdateMailboxQuotaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMailboxQuotaOutput {
        return UpdateMailboxQuotaOutput()
    }
}

extension UpdateMobileDeviceAccessRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMobileDeviceAccessRuleOutput {
        return UpdateMobileDeviceAccessRuleOutput()
    }
}

extension UpdatePrimaryEmailAddressOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePrimaryEmailAddressOutput {
        return UpdatePrimaryEmailAddressOutput()
    }
}

extension UpdateResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateResourceOutput {
        return UpdateResourceOutput()
    }
}

extension UpdateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserOutput {
        return UpdateUserOutput()
    }
}

enum AssociateDelegateToResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateMemberToGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectoryServiceAuthenticationFailedException": return try DirectoryServiceAuthenticationFailedException.makeError(baseError: baseError)
            case "DirectoryUnavailableException": return try DirectoryUnavailableException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssumeImpersonationRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelMailboxExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EmailAddressInUseException": return try EmailAddressInUseException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "MailDomainNotFoundException": return try MailDomainNotFoundException.makeError(baseError: baseError)
            case "MailDomainStateException": return try MailDomainStateException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAvailabilityConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NameAvailabilityException": return try NameAvailabilityException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectoryServiceAuthenticationFailedException": return try DirectoryServiceAuthenticationFailedException.makeError(baseError: baseError)
            case "DirectoryUnavailableException": return try DirectoryUnavailableException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NameAvailabilityException": return try NameAvailabilityException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "ReservedNameException": return try ReservedNameException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateImpersonationRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMobileDeviceAccessRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectoryInUseException": return try DirectoryInUseException.makeError(baseError: baseError)
            case "DirectoryUnavailableException": return try DirectoryUnavailableException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NameAvailabilityException": return try NameAvailabilityException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectoryServiceAuthenticationFailedException": return try DirectoryServiceAuthenticationFailedException.makeError(baseError: baseError)
            case "DirectoryUnavailableException": return try DirectoryUnavailableException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NameAvailabilityException": return try NameAvailabilityException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "ReservedNameException": return try ReservedNameException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectoryServiceAuthenticationFailedException": return try DirectoryServiceAuthenticationFailedException.makeError(baseError: baseError)
            case "DirectoryUnavailableException": return try DirectoryUnavailableException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidPasswordException": return try InvalidPasswordException.makeError(baseError: baseError)
            case "NameAvailabilityException": return try NameAvailabilityException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "ReservedNameException": return try ReservedNameException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccessControlRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAvailabilityConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEmailMonitoringConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectoryServiceAuthenticationFailedException": return try DirectoryServiceAuthenticationFailedException.makeError(baseError: baseError)
            case "DirectoryUnavailableException": return try DirectoryUnavailableException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteImpersonationRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMailboxPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMobileDeviceAccessOverrideOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMobileDeviceAccessRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRetentionPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectoryServiceAuthenticationFailedException": return try DirectoryServiceAuthenticationFailedException.makeError(baseError: baseError)
            case "DirectoryUnavailableException": return try DirectoryUnavailableException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterFromWorkMailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterMailDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidCustomSesConfigurationException": return try InvalidCustomSesConfigurationException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MailDomainInUseException": return try MailDomainInUseException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEmailMonitoringConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEntityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInboundDmarcSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMailboxExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeOrganizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateDelegateFromResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateMemberFromGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectoryServiceAuthenticationFailedException": return try DirectoryServiceAuthenticationFailedException.makeError(baseError: baseError)
            case "DirectoryUnavailableException": return try DirectoryUnavailableException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccessControlEffectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDefaultRetentionPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImpersonationRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImpersonationRoleEffectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMailboxDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMailDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MailDomainNotFoundException": return try MailDomainNotFoundException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMobileDeviceAccessEffectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMobileDeviceAccessOverrideOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccessControlRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAliasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAvailabilityConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGroupMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGroupsForEntityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImpersonationRolesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMailboxExportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMailboxPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMailDomainsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMobileDeviceAccessOverridesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMobileDeviceAccessRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOrganizationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourceDelegatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutAccessControlRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutEmailMonitoringConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutInboundDmarcSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutMailboxPermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutMobileDeviceAccessOverrideOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRetentionPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterMailDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "MailDomainInUseException": return try MailDomainInUseException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterToWorkMailOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectoryServiceAuthenticationFailedException": return try DirectoryServiceAuthenticationFailedException.makeError(baseError: baseError)
            case "DirectoryUnavailableException": return try DirectoryUnavailableException.makeError(baseError: baseError)
            case "EmailAddressInUseException": return try EmailAddressInUseException.makeError(baseError: baseError)
            case "EntityAlreadyRegisteredException": return try EntityAlreadyRegisteredException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MailDomainNotFoundException": return try MailDomainNotFoundException.makeError(baseError: baseError)
            case "MailDomainStateException": return try MailDomainStateException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResetPasswordOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectoryServiceAuthenticationFailedException": return try DirectoryServiceAuthenticationFailedException.makeError(baseError: baseError)
            case "DirectoryUnavailableException": return try DirectoryUnavailableException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidPasswordException": return try InvalidPasswordException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartMailboxExportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestAvailabilityConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAvailabilityConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDefaultMailDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MailDomainNotFoundException": return try MailDomainNotFoundException.makeError(baseError: baseError)
            case "MailDomainStateException": return try MailDomainStateException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateImpersonationRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMailboxQuotaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMobileDeviceAccessRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePrimaryEmailAddressOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectoryServiceAuthenticationFailedException": return try DirectoryServiceAuthenticationFailedException.makeError(baseError: baseError)
            case "DirectoryUnavailableException": return try DirectoryUnavailableException.makeError(baseError: baseError)
            case "EmailAddressInUseException": return try EmailAddressInUseException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MailDomainNotFoundException": return try MailDomainNotFoundException.makeError(baseError: baseError)
            case "MailDomainStateException": return try MailDomainStateException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectoryUnavailableException": return try DirectoryUnavailableException.makeError(baseError: baseError)
            case "EmailAddressInUseException": return try EmailAddressInUseException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidConfigurationException": return try InvalidConfigurationException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "MailDomainNotFoundException": return try MailDomainNotFoundException.makeError(baseError: baseError)
            case "MailDomainStateException": return try MailDomainStateException.makeError(baseError: baseError)
            case "NameAvailabilityException": return try NameAvailabilityException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectoryServiceAuthenticationFailedException": return try DirectoryServiceAuthenticationFailedException.makeError(baseError: baseError)
            case "DirectoryUnavailableException": return try DirectoryUnavailableException.makeError(baseError: baseError)
            case "EntityNotFoundException": return try EntityNotFoundException.makeError(baseError: baseError)
            case "EntityStateException": return try EntityStateException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OrganizationNotFoundException": return try OrganizationNotFoundException.makeError(baseError: baseError)
            case "OrganizationStateException": return try OrganizationStateException.makeError(baseError: baseError)
            case "UnsupportedOperationException": return try UnsupportedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension EntityStateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EntityStateException {
        let reader = baseError.errorBodyReader
        var value = EntityStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParameterException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedOperationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnsupportedOperationException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedOperationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OrganizationNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OrganizationNotFoundException {
        let reader = baseError.errorBodyReader
        var value = OrganizationNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EntityNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EntityNotFoundException {
        let reader = baseError.errorBodyReader
        var value = EntityNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OrganizationStateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OrganizationStateException {
        let reader = baseError.errorBodyReader
        var value = OrganizationStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DirectoryUnavailableException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DirectoryUnavailableException {
        let reader = baseError.errorBodyReader
        var value = DirectoryUnavailableException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DirectoryServiceAuthenticationFailedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DirectoryServiceAuthenticationFailedException {
        let reader = baseError.errorBodyReader
        var value = DirectoryServiceAuthenticationFailedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EmailAddressInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EmailAddressInUseException {
        let reader = baseError.errorBodyReader
        var value = EmailAddressInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MailDomainNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MailDomainNotFoundException {
        let reader = baseError.errorBodyReader
        var value = MailDomainNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MailDomainStateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MailDomainStateException {
        let reader = baseError.errorBodyReader
        var value = MailDomainStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NameAvailabilityException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NameAvailabilityException {
        let reader = baseError.errorBodyReader
        var value = NameAvailabilityException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReservedNameException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ReservedNameException {
        let reader = baseError.errorBodyReader
        var value = ReservedNameException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DirectoryInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DirectoryInUseException {
        let reader = baseError.errorBodyReader
        var value = DirectoryInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPasswordException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidPasswordException {
        let reader = baseError.errorBodyReader
        var value = InvalidPasswordException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidCustomSesConfigurationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidCustomSesConfigurationException {
        let reader = baseError.errorBodyReader
        var value = InvalidCustomSesConfigurationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MailDomainInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MailDomainInUseException {
        let reader = baseError.errorBodyReader
        var value = MailDomainInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EntityAlreadyRegisteredException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> EntityAlreadyRegisteredException {
        let reader = baseError.errorBodyReader
        var value = EntityAlreadyRegisteredException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidConfigurationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidConfigurationException {
        let reader = baseError.errorBodyReader
        var value = InvalidConfigurationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension WorkMailClientTypes.BookingOptions {

    static func write(value: WorkMailClientTypes.BookingOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoAcceptRequests"].write(value.autoAcceptRequests)
        try writer["AutoDeclineConflictingRequests"].write(value.autoDeclineConflictingRequests)
        try writer["AutoDeclineRecurringRequests"].write(value.autoDeclineRecurringRequests)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.BookingOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.BookingOptions()
        value.autoAcceptRequests = try reader["AutoAcceptRequests"].readIfPresent() ?? false
        value.autoDeclineRecurringRequests = try reader["AutoDeclineRecurringRequests"].readIfPresent() ?? false
        value.autoDeclineConflictingRequests = try reader["AutoDeclineConflictingRequests"].readIfPresent() ?? false
        return value
    }
}

extension WorkMailClientTypes.FolderConfiguration {

    static func write(value: WorkMailClientTypes.FolderConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action)
        try writer["Name"].write(value.name)
        try writer["Period"].write(value.period)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.FolderConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.FolderConfiguration()
        value.name = try reader["Name"].readIfPresent() ?? .sdkUnknown("")
        value.action = try reader["Action"].readIfPresent() ?? .sdkUnknown("")
        value.period = try reader["Period"].readIfPresent()
        return value
    }
}

extension WorkMailClientTypes.ImpersonationRule {

    static func write(value: WorkMailClientTypes.ImpersonationRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Effect"].write(value.effect)
        try writer["ImpersonationRuleId"].write(value.impersonationRuleId)
        try writer["Name"].write(value.name)
        try writer["NotTargetUsers"].writeList(value.notTargetUsers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetUsers"].writeList(value.targetUsers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.ImpersonationRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.ImpersonationRule()
        value.impersonationRuleId = try reader["ImpersonationRuleId"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.effect = try reader["Effect"].readIfPresent() ?? .sdkUnknown("")
        value.targetUsers = try reader["TargetUsers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.notTargetUsers = try reader["NotTargetUsers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WorkMailClientTypes.ImpersonationMatchedRule {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.ImpersonationMatchedRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.ImpersonationMatchedRule()
        value.impersonationRuleId = try reader["ImpersonationRuleId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension WorkMailClientTypes.DnsRecord {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.DnsRecord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.DnsRecord()
        value.type = try reader["Type"].readIfPresent()
        value.hostname = try reader["Hostname"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension WorkMailClientTypes.MobileDeviceAccessMatchedRule {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.MobileDeviceAccessMatchedRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.MobileDeviceAccessMatchedRule()
        value.mobileDeviceAccessRuleId = try reader["MobileDeviceAccessRuleId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension WorkMailClientTypes.AccessControlRule {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.AccessControlRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.AccessControlRule()
        value.name = try reader["Name"].readIfPresent()
        value.effect = try reader["Effect"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.ipRanges = try reader["IpRanges"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.notIpRanges = try reader["NotIpRanges"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.notActions = try reader["NotActions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.userIds = try reader["UserIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.notUserIds = try reader["NotUserIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.dateCreated = try reader["DateCreated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dateModified = try reader["DateModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.impersonationRoleIds = try reader["ImpersonationRoleIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.notImpersonationRoleIds = try reader["NotImpersonationRoleIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WorkMailClientTypes.AvailabilityConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.AvailabilityConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.AvailabilityConfiguration()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.providerType = try reader["ProviderType"].readIfPresent()
        value.ewsProvider = try reader["EwsProvider"].readIfPresent(with: WorkMailClientTypes.RedactedEwsAvailabilityProvider.read(from:))
        value.lambdaProvider = try reader["LambdaProvider"].readIfPresent(with: WorkMailClientTypes.LambdaAvailabilityProvider.read(from:))
        value.dateCreated = try reader["DateCreated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dateModified = try reader["DateModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WorkMailClientTypes.LambdaAvailabilityProvider {

    static func write(value: WorkMailClientTypes.LambdaAvailabilityProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LambdaArn"].write(value.lambdaArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.LambdaAvailabilityProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.LambdaAvailabilityProvider()
        value.lambdaArn = try reader["LambdaArn"].readIfPresent() ?? ""
        return value
    }
}

extension WorkMailClientTypes.RedactedEwsAvailabilityProvider {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.RedactedEwsAvailabilityProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.RedactedEwsAvailabilityProvider()
        value.ewsEndpoint = try reader["EwsEndpoint"].readIfPresent()
        value.ewsUsername = try reader["EwsUsername"].readIfPresent()
        return value
    }
}

extension WorkMailClientTypes.Member {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.Member {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.Member()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.enabledDate = try reader["EnabledDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.disabledDate = try reader["DisabledDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WorkMailClientTypes.Group {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.Group {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.Group()
        value.id = try reader["Id"].readIfPresent()
        value.email = try reader["Email"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.enabledDate = try reader["EnabledDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.disabledDate = try reader["DisabledDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WorkMailClientTypes.GroupIdentifier {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.GroupIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.GroupIdentifier()
        value.groupId = try reader["GroupId"].readIfPresent()
        value.groupName = try reader["GroupName"].readIfPresent()
        return value
    }
}

extension WorkMailClientTypes.ImpersonationRole {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.ImpersonationRole {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.ImpersonationRole()
        value.impersonationRoleId = try reader["ImpersonationRoleId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.dateCreated = try reader["DateCreated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dateModified = try reader["DateModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WorkMailClientTypes.MailboxExportJob {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.MailboxExportJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.MailboxExportJob()
        value.jobId = try reader["JobId"].readIfPresent()
        value.entityId = try reader["EntityId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.s3BucketName = try reader["S3BucketName"].readIfPresent()
        value.s3Path = try reader["S3Path"].readIfPresent()
        value.estimatedProgress = try reader["EstimatedProgress"].readIfPresent() ?? 0
        value.state = try reader["State"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WorkMailClientTypes.Permission {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.Permission {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.Permission()
        value.granteeId = try reader["GranteeId"].readIfPresent() ?? ""
        value.granteeType = try reader["GranteeType"].readIfPresent() ?? .sdkUnknown("")
        value.permissionValues = try reader["PermissionValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<WorkMailClientTypes.PermissionType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension WorkMailClientTypes.MailDomainSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.MailDomainSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.MailDomainSummary()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.defaultDomain = try reader["DefaultDomain"].readIfPresent() ?? false
        return value
    }
}

extension WorkMailClientTypes.MobileDeviceAccessOverride {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.MobileDeviceAccessOverride {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.MobileDeviceAccessOverride()
        value.userId = try reader["UserId"].readIfPresent()
        value.deviceId = try reader["DeviceId"].readIfPresent()
        value.effect = try reader["Effect"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.dateCreated = try reader["DateCreated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dateModified = try reader["DateModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WorkMailClientTypes.MobileDeviceAccessRule {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.MobileDeviceAccessRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.MobileDeviceAccessRule()
        value.mobileDeviceAccessRuleId = try reader["MobileDeviceAccessRuleId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.effect = try reader["Effect"].readIfPresent()
        value.deviceTypes = try reader["DeviceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.notDeviceTypes = try reader["NotDeviceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.deviceModels = try reader["DeviceModels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.notDeviceModels = try reader["NotDeviceModels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.deviceOperatingSystems = try reader["DeviceOperatingSystems"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.notDeviceOperatingSystems = try reader["NotDeviceOperatingSystems"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.deviceUserAgents = try reader["DeviceUserAgents"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.notDeviceUserAgents = try reader["NotDeviceUserAgents"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.dateCreated = try reader["DateCreated"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dateModified = try reader["DateModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WorkMailClientTypes.OrganizationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.OrganizationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.OrganizationSummary()
        value.organizationId = try reader["OrganizationId"].readIfPresent()
        value.alias = try reader["Alias"].readIfPresent()
        value.defaultMailDomain = try reader["DefaultMailDomain"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension WorkMailClientTypes.Delegate {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.Delegate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.Delegate()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension WorkMailClientTypes.Resource {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.Resource()
        value.id = try reader["Id"].readIfPresent()
        value.email = try reader["Email"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.enabledDate = try reader["EnabledDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.disabledDate = try reader["DisabledDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension WorkMailClientTypes.Tag {

    static func write(value: WorkMailClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension WorkMailClientTypes.User {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkMailClientTypes.User {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkMailClientTypes.User()
        value.id = try reader["Id"].readIfPresent()
        value.email = try reader["Email"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.userRole = try reader["UserRole"].readIfPresent()
        value.enabledDate = try reader["EnabledDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.disabledDate = try reader["DisabledDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension WorkMailClientTypes.EwsAvailabilityProvider {

    static func write(value: WorkMailClientTypes.EwsAvailabilityProvider?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EwsEndpoint"].write(value.ewsEndpoint)
        try writer["EwsPassword"].write(value.ewsPassword)
        try writer["EwsUsername"].write(value.ewsUsername)
    }
}

extension WorkMailClientTypes.Domain {

    static func write(value: WorkMailClientTypes.Domain?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["HostedZoneId"].write(value.hostedZoneId)
    }
}

extension WorkMailClientTypes.ListGroupsFilters {

    static func write(value: WorkMailClientTypes.ListGroupsFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NamePrefix"].write(value.namePrefix)
        try writer["PrimaryEmailPrefix"].write(value.primaryEmailPrefix)
        try writer["State"].write(value.state)
    }
}

extension WorkMailClientTypes.ListGroupsForEntityFilters {

    static func write(value: WorkMailClientTypes.ListGroupsForEntityFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupNamePrefix"].write(value.groupNamePrefix)
    }
}

extension WorkMailClientTypes.ListResourcesFilters {

    static func write(value: WorkMailClientTypes.ListResourcesFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NamePrefix"].write(value.namePrefix)
        try writer["PrimaryEmailPrefix"].write(value.primaryEmailPrefix)
        try writer["State"].write(value.state)
    }
}

extension WorkMailClientTypes.ListUsersFilters {

    static func write(value: WorkMailClientTypes.ListUsersFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DisplayNamePrefix"].write(value.displayNamePrefix)
        try writer["PrimaryEmailPrefix"].write(value.primaryEmailPrefix)
        try writer["State"].write(value.state)
        try writer["UsernamePrefix"].write(value.usernamePrefix)
    }
}

public enum WorkMailClientTypes {}
