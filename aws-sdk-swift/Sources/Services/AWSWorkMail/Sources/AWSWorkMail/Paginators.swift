//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension WorkMailClient {
    /// Paginate over `[ListAliasesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAliasesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAliasesOutput`
    public func listAliasesPaginated(input: ListAliasesInput) -> ClientRuntime.PaginatorSequence<ListAliasesInput, ListAliasesOutput> {
        return ClientRuntime.PaginatorSequence<ListAliasesInput, ListAliasesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAliases(input:))
    }
}

extension ListAliasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAliasesInput {
        return ListAliasesInput(
            entityId: self.entityId,
            maxResults: self.maxResults,
            nextToken: token,
            organizationId: self.organizationId
        )}
}
extension WorkMailClient {
    /// Paginate over `[ListAvailabilityConfigurationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAvailabilityConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAvailabilityConfigurationsOutput`
    public func listAvailabilityConfigurationsPaginated(input: ListAvailabilityConfigurationsInput) -> ClientRuntime.PaginatorSequence<ListAvailabilityConfigurationsInput, ListAvailabilityConfigurationsOutput> {
        return ClientRuntime.PaginatorSequence<ListAvailabilityConfigurationsInput, ListAvailabilityConfigurationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAvailabilityConfigurations(input:))
    }
}

extension ListAvailabilityConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAvailabilityConfigurationsInput {
        return ListAvailabilityConfigurationsInput(
            maxResults: self.maxResults,
            nextToken: token,
            organizationId: self.organizationId
        )}
}

extension PaginatorSequence where OperationStackInput == ListAvailabilityConfigurationsInput, OperationStackOutput == ListAvailabilityConfigurationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAvailabilityConfigurationsPaginated`
    /// to access the nested member `[WorkMailClientTypes.AvailabilityConfiguration]`
    /// - Returns: `[WorkMailClientTypes.AvailabilityConfiguration]`
    public func availabilityConfigurations() async throws -> [WorkMailClientTypes.AvailabilityConfiguration] {
        return try await self.asyncCompactMap { item in item.availabilityConfigurations }
    }
}
extension WorkMailClient {
    /// Paginate over `[ListGroupMembersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListGroupMembersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListGroupMembersOutput`
    public func listGroupMembersPaginated(input: ListGroupMembersInput) -> ClientRuntime.PaginatorSequence<ListGroupMembersInput, ListGroupMembersOutput> {
        return ClientRuntime.PaginatorSequence<ListGroupMembersInput, ListGroupMembersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listGroupMembers(input:))
    }
}

extension ListGroupMembersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGroupMembersInput {
        return ListGroupMembersInput(
            groupId: self.groupId,
            maxResults: self.maxResults,
            nextToken: token,
            organizationId: self.organizationId
        )}
}
extension WorkMailClient {
    /// Paginate over `[ListGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListGroupsOutput`
    public func listGroupsPaginated(input: ListGroupsInput) -> ClientRuntime.PaginatorSequence<ListGroupsInput, ListGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListGroupsInput, ListGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listGroups(input:))
    }
}

extension ListGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGroupsInput {
        return ListGroupsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            organizationId: self.organizationId
        )}
}
extension WorkMailClient {
    /// Paginate over `[ListGroupsForEntityOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListGroupsForEntityInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListGroupsForEntityOutput`
    public func listGroupsForEntityPaginated(input: ListGroupsForEntityInput) -> ClientRuntime.PaginatorSequence<ListGroupsForEntityInput, ListGroupsForEntityOutput> {
        return ClientRuntime.PaginatorSequence<ListGroupsForEntityInput, ListGroupsForEntityOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listGroupsForEntity(input:))
    }
}

extension ListGroupsForEntityInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGroupsForEntityInput {
        return ListGroupsForEntityInput(
            entityId: self.entityId,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            organizationId: self.organizationId
        )}
}
extension WorkMailClient {
    /// Paginate over `[ListImpersonationRolesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImpersonationRolesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImpersonationRolesOutput`
    public func listImpersonationRolesPaginated(input: ListImpersonationRolesInput) -> ClientRuntime.PaginatorSequence<ListImpersonationRolesInput, ListImpersonationRolesOutput> {
        return ClientRuntime.PaginatorSequence<ListImpersonationRolesInput, ListImpersonationRolesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listImpersonationRoles(input:))
    }
}

extension ListImpersonationRolesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImpersonationRolesInput {
        return ListImpersonationRolesInput(
            maxResults: self.maxResults,
            nextToken: token,
            organizationId: self.organizationId
        )}
}
extension WorkMailClient {
    /// Paginate over `[ListMailboxExportJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMailboxExportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMailboxExportJobsOutput`
    public func listMailboxExportJobsPaginated(input: ListMailboxExportJobsInput) -> ClientRuntime.PaginatorSequence<ListMailboxExportJobsInput, ListMailboxExportJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListMailboxExportJobsInput, ListMailboxExportJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMailboxExportJobs(input:))
    }
}

extension ListMailboxExportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMailboxExportJobsInput {
        return ListMailboxExportJobsInput(
            maxResults: self.maxResults,
            nextToken: token,
            organizationId: self.organizationId
        )}
}
extension WorkMailClient {
    /// Paginate over `[ListMailboxPermissionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMailboxPermissionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMailboxPermissionsOutput`
    public func listMailboxPermissionsPaginated(input: ListMailboxPermissionsInput) -> ClientRuntime.PaginatorSequence<ListMailboxPermissionsInput, ListMailboxPermissionsOutput> {
        return ClientRuntime.PaginatorSequence<ListMailboxPermissionsInput, ListMailboxPermissionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMailboxPermissions(input:))
    }
}

extension ListMailboxPermissionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMailboxPermissionsInput {
        return ListMailboxPermissionsInput(
            entityId: self.entityId,
            maxResults: self.maxResults,
            nextToken: token,
            organizationId: self.organizationId
        )}
}
extension WorkMailClient {
    /// Paginate over `[ListMailDomainsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMailDomainsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMailDomainsOutput`
    public func listMailDomainsPaginated(input: ListMailDomainsInput) -> ClientRuntime.PaginatorSequence<ListMailDomainsInput, ListMailDomainsOutput> {
        return ClientRuntime.PaginatorSequence<ListMailDomainsInput, ListMailDomainsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMailDomains(input:))
    }
}

extension ListMailDomainsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMailDomainsInput {
        return ListMailDomainsInput(
            maxResults: self.maxResults,
            nextToken: token,
            organizationId: self.organizationId
        )}
}
extension WorkMailClient {
    /// Paginate over `[ListMobileDeviceAccessOverridesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMobileDeviceAccessOverridesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMobileDeviceAccessOverridesOutput`
    public func listMobileDeviceAccessOverridesPaginated(input: ListMobileDeviceAccessOverridesInput) -> ClientRuntime.PaginatorSequence<ListMobileDeviceAccessOverridesInput, ListMobileDeviceAccessOverridesOutput> {
        return ClientRuntime.PaginatorSequence<ListMobileDeviceAccessOverridesInput, ListMobileDeviceAccessOverridesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMobileDeviceAccessOverrides(input:))
    }
}

extension ListMobileDeviceAccessOverridesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMobileDeviceAccessOverridesInput {
        return ListMobileDeviceAccessOverridesInput(
            deviceId: self.deviceId,
            maxResults: self.maxResults,
            nextToken: token,
            organizationId: self.organizationId,
            userId: self.userId
        )}
}
extension WorkMailClient {
    /// Paginate over `[ListOrganizationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOrganizationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOrganizationsOutput`
    public func listOrganizationsPaginated(input: ListOrganizationsInput) -> ClientRuntime.PaginatorSequence<ListOrganizationsInput, ListOrganizationsOutput> {
        return ClientRuntime.PaginatorSequence<ListOrganizationsInput, ListOrganizationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listOrganizations(input:))
    }
}

extension ListOrganizationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOrganizationsInput {
        return ListOrganizationsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension WorkMailClient {
    /// Paginate over `[ListResourceDelegatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResourceDelegatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResourceDelegatesOutput`
    public func listResourceDelegatesPaginated(input: ListResourceDelegatesInput) -> ClientRuntime.PaginatorSequence<ListResourceDelegatesInput, ListResourceDelegatesOutput> {
        return ClientRuntime.PaginatorSequence<ListResourceDelegatesInput, ListResourceDelegatesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listResourceDelegates(input:))
    }
}

extension ListResourceDelegatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResourceDelegatesInput {
        return ListResourceDelegatesInput(
            maxResults: self.maxResults,
            nextToken: token,
            organizationId: self.organizationId,
            resourceId: self.resourceId
        )}
}
extension WorkMailClient {
    /// Paginate over `[ListResourcesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListResourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListResourcesOutput`
    public func listResourcesPaginated(input: ListResourcesInput) -> ClientRuntime.PaginatorSequence<ListResourcesInput, ListResourcesOutput> {
        return ClientRuntime.PaginatorSequence<ListResourcesInput, ListResourcesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listResources(input:))
    }
}

extension ListResourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResourcesInput {
        return ListResourcesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            organizationId: self.organizationId
        )}
}
extension WorkMailClient {
    /// Paginate over `[ListUsersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUsersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUsersOutput`
    public func listUsersPaginated(input: ListUsersInput) -> ClientRuntime.PaginatorSequence<ListUsersInput, ListUsersOutput> {
        return ClientRuntime.PaginatorSequence<ListUsersInput, ListUsersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listUsers(input:))
    }
}

extension ListUsersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUsersInput {
        return ListUsersInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            organizationId: self.organizationId
        )}
}
