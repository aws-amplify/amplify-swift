//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension AppRunnerClient {
    /// Paginate over `[DescribeCustomDomainsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeCustomDomainsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeCustomDomainsOutput`
    public func describeCustomDomainsPaginated(input: DescribeCustomDomainsInput) -> ClientRuntime.PaginatorSequence<DescribeCustomDomainsInput, DescribeCustomDomainsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeCustomDomainsInput, DescribeCustomDomainsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeCustomDomains(input:))
    }
}

extension DescribeCustomDomainsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeCustomDomainsInput {
        return DescribeCustomDomainsInput(
            maxResults: self.maxResults,
            nextToken: token,
            serviceArn: self.serviceArn
        )}
}
extension AppRunnerClient {
    /// Paginate over `[ListAutoScalingConfigurationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAutoScalingConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAutoScalingConfigurationsOutput`
    public func listAutoScalingConfigurationsPaginated(input: ListAutoScalingConfigurationsInput) -> ClientRuntime.PaginatorSequence<ListAutoScalingConfigurationsInput, ListAutoScalingConfigurationsOutput> {
        return ClientRuntime.PaginatorSequence<ListAutoScalingConfigurationsInput, ListAutoScalingConfigurationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAutoScalingConfigurations(input:))
    }
}

extension ListAutoScalingConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAutoScalingConfigurationsInput {
        return ListAutoScalingConfigurationsInput(
            autoScalingConfigurationName: self.autoScalingConfigurationName,
            latestOnly: self.latestOnly,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension AppRunnerClient {
    /// Paginate over `[ListConnectionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListConnectionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListConnectionsOutput`
    public func listConnectionsPaginated(input: ListConnectionsInput) -> ClientRuntime.PaginatorSequence<ListConnectionsInput, ListConnectionsOutput> {
        return ClientRuntime.PaginatorSequence<ListConnectionsInput, ListConnectionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listConnections(input:))
    }
}

extension ListConnectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListConnectionsInput {
        return ListConnectionsInput(
            connectionName: self.connectionName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension AppRunnerClient {
    /// Paginate over `[ListObservabilityConfigurationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListObservabilityConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListObservabilityConfigurationsOutput`
    public func listObservabilityConfigurationsPaginated(input: ListObservabilityConfigurationsInput) -> ClientRuntime.PaginatorSequence<ListObservabilityConfigurationsInput, ListObservabilityConfigurationsOutput> {
        return ClientRuntime.PaginatorSequence<ListObservabilityConfigurationsInput, ListObservabilityConfigurationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listObservabilityConfigurations(input:))
    }
}

extension ListObservabilityConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListObservabilityConfigurationsInput {
        return ListObservabilityConfigurationsInput(
            latestOnly: self.latestOnly,
            maxResults: self.maxResults,
            nextToken: token,
            observabilityConfigurationName: self.observabilityConfigurationName
        )}
}
extension AppRunnerClient {
    /// Paginate over `[ListOperationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOperationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOperationsOutput`
    public func listOperationsPaginated(input: ListOperationsInput) -> ClientRuntime.PaginatorSequence<ListOperationsInput, ListOperationsOutput> {
        return ClientRuntime.PaginatorSequence<ListOperationsInput, ListOperationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listOperations(input:))
    }
}

extension ListOperationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOperationsInput {
        return ListOperationsInput(
            maxResults: self.maxResults,
            nextToken: token,
            serviceArn: self.serviceArn
        )}
}
extension AppRunnerClient {
    /// Paginate over `[ListServicesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListServicesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListServicesOutput`
    public func listServicesPaginated(input: ListServicesInput) -> ClientRuntime.PaginatorSequence<ListServicesInput, ListServicesOutput> {
        return ClientRuntime.PaginatorSequence<ListServicesInput, ListServicesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listServices(input:))
    }
}

extension ListServicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListServicesInput {
        return ListServicesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension AppRunnerClient {
    /// Paginate over `[ListServicesForAutoScalingConfigurationOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListServicesForAutoScalingConfigurationInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListServicesForAutoScalingConfigurationOutput`
    public func listServicesForAutoScalingConfigurationPaginated(input: ListServicesForAutoScalingConfigurationInput) -> ClientRuntime.PaginatorSequence<ListServicesForAutoScalingConfigurationInput, ListServicesForAutoScalingConfigurationOutput> {
        return ClientRuntime.PaginatorSequence<ListServicesForAutoScalingConfigurationInput, ListServicesForAutoScalingConfigurationOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listServicesForAutoScalingConfiguration(input:))
    }
}

extension ListServicesForAutoScalingConfigurationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListServicesForAutoScalingConfigurationInput {
        return ListServicesForAutoScalingConfigurationInput(
            autoScalingConfigurationArn: self.autoScalingConfigurationArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension AppRunnerClient {
    /// Paginate over `[ListVpcConnectorsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListVpcConnectorsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListVpcConnectorsOutput`
    public func listVpcConnectorsPaginated(input: ListVpcConnectorsInput) -> ClientRuntime.PaginatorSequence<ListVpcConnectorsInput, ListVpcConnectorsOutput> {
        return ClientRuntime.PaginatorSequence<ListVpcConnectorsInput, ListVpcConnectorsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listVpcConnectors(input:))
    }
}

extension ListVpcConnectorsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListVpcConnectorsInput {
        return ListVpcConnectorsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension AppRunnerClient {
    /// Paginate over `[ListVpcIngressConnectionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListVpcIngressConnectionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListVpcIngressConnectionsOutput`
    public func listVpcIngressConnectionsPaginated(input: ListVpcIngressConnectionsInput) -> ClientRuntime.PaginatorSequence<ListVpcIngressConnectionsInput, ListVpcIngressConnectionsOutput> {
        return ClientRuntime.PaginatorSequence<ListVpcIngressConnectionsInput, ListVpcIngressConnectionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listVpcIngressConnections(input:))
    }
}

extension ListVpcIngressConnectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListVpcIngressConnectionsInput {
        return ListVpcIngressConnectionsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
