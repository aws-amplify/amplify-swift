//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// An unexpected service exception occurred.
public struct InternalServiceErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceError" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// One or more input parameters aren't valid. Refer to the API action's document page, correct the input parameters, and try the action again.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequest" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You can't perform this action when the resource is in its current state.
public struct InvalidStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidState" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateCustomDomainInput: Swift.Sendable {
    /// A custom domain endpoint to associate. Specify a root domain (for example, example.com), a subdomain (for example, login.example.com or admin.login.example.com), or a wildcard (for example, *.example.com).
    /// This member is required.
    public var domainName: Swift.String?
    /// Set to true to associate the subdomain www.DomainName  with the App Runner service in addition to the base domain. Default: true
    public var enableWWWSubdomain: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to associate a custom domain name with.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        enableWWWSubdomain: Swift.Bool? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.enableWWWSubdomain = enableWWWSubdomain
        self.serviceArn = serviceArn
    }
}

extension AppRunnerClientTypes {

    public enum CertificateValidationRecordStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case pendingValidation
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateValidationRecordStatus] {
            return [
                .failed,
                .pendingValidation,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pendingValidation: return "PENDING_VALIDATION"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes a certificate CNAME record to add to your DNS. For more information, see [AssociateCustomDomain](https://docs.aws.amazon.com/apprunner/latest/api/API_AssociateCustomDomain.html).
    public struct CertificateValidationRecord: Swift.Sendable {
        /// The certificate CNAME record name.
        public var name: Swift.String?
        /// The current state of the certificate CNAME record validation. It should change to SUCCESS after App Runner completes validation with your DNS.
        public var status: AppRunnerClientTypes.CertificateValidationRecordStatus?
        /// The record type, always CNAME.
        public var type: Swift.String?
        /// The certificate CNAME record value.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            status: AppRunnerClientTypes.CertificateValidationRecordStatus? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.status = status
            self.type = type
            self.value = value
        }
    }
}

extension AppRunnerClientTypes {

    public enum CustomDomainAssociationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case bindingCertificate
        case createFailed
        case creating
        case deleteFailed
        case deleting
        case pendingCertificateDnsValidation
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomDomainAssociationStatus] {
            return [
                .active,
                .bindingCertificate,
                .createFailed,
                .creating,
                .deleteFailed,
                .deleting,
                .pendingCertificateDnsValidation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .bindingCertificate: return "BINDING_CERTIFICATE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .pendingCertificateDnsValidation: return "PENDING_CERTIFICATE_DNS_VALIDATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes a custom domain that's associated with an App Runner service.
    public struct CustomDomain: Swift.Sendable {
        /// A list of certificate CNAME records that's used for this domain name.
        public var certificateValidationRecords: [AppRunnerClientTypes.CertificateValidationRecord]?
        /// An associated custom domain endpoint. It can be a root domain (for example, example.com), a subdomain (for example, login.example.com or admin.login.example.com), or a wildcard (for example, *.example.com).
        /// This member is required.
        public var domainName: Swift.String?
        /// When true, the subdomain www.DomainName  is associated with the App Runner service in addition to the base domain.
        /// This member is required.
        public var enableWWWSubdomain: Swift.Bool?
        /// The current state of the domain name association.
        /// This member is required.
        public var status: AppRunnerClientTypes.CustomDomainAssociationStatus?

        public init(
            certificateValidationRecords: [AppRunnerClientTypes.CertificateValidationRecord]? = nil,
            domainName: Swift.String? = nil,
            enableWWWSubdomain: Swift.Bool? = nil,
            status: AppRunnerClientTypes.CustomDomainAssociationStatus? = nil
        )
        {
            self.certificateValidationRecords = certificateValidationRecords
            self.domainName = domainName
            self.enableWWWSubdomain = enableWWWSubdomain
            self.status = status
        }
    }
}

extension AppRunnerClientTypes {

    /// DNS Target record for a custom domain of this Amazon VPC.
    public struct VpcDNSTarget: Swift.Sendable {
        /// The domain name of your target DNS that is associated with the Amazon VPC.
        public var domainName: Swift.String?
        /// The ID of the Amazon VPC that is associated with the custom domain name of the target DNS.
        public var vpcId: Swift.String?
        /// The Amazon Resource Name (ARN) of the VPC Ingress Connection that is associated with your service.
        public var vpcIngressConnectionArn: Swift.String?

        public init(
            domainName: Swift.String? = nil,
            vpcId: Swift.String? = nil,
            vpcIngressConnectionArn: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.vpcId = vpcId
            self.vpcIngressConnectionArn = vpcIngressConnectionArn
        }
    }
}

public struct AssociateCustomDomainOutput: Swift.Sendable {
    /// A description of the domain name that's being associated.
    /// This member is required.
    public var customDomain: AppRunnerClientTypes.CustomDomain?
    /// The App Runner subdomain of the App Runner service. The custom domain name is mapped to this target name.
    /// This member is required.
    public var dnsTarget: Swift.String?
    /// The Amazon Resource Name (ARN) of the App Runner service with which a custom domain name is associated.
    /// This member is required.
    public var serviceArn: Swift.String?
    /// DNS Target records for the custom domains of this Amazon VPC.
    /// This member is required.
    public var vpcDNSTargets: [AppRunnerClientTypes.VpcDNSTarget]?

    public init(
        customDomain: AppRunnerClientTypes.CustomDomain? = nil,
        dnsTarget: Swift.String? = nil,
        serviceArn: Swift.String? = nil,
        vpcDNSTargets: [AppRunnerClientTypes.VpcDNSTarget]? = nil
    )
    {
        self.customDomain = customDomain
        self.dnsTarget = dnsTarget
        self.serviceArn = serviceArn
        self.vpcDNSTargets = vpcDNSTargets
    }
}

/// App Runner can't create this resource. You've reached your account quota for this resource type. For App Runner per-resource quotas, see [App Runner endpoints and quotas](https://docs.aws.amazon.com/general/latest/gr/apprunner.html) in the Amazon Web Services General Reference.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension AppRunnerClientTypes {

    /// Describes a tag that is applied to an App Runner resource. A tag is a metadata item consisting of a key-value pair.
    public struct Tag: Swift.Sendable {
        /// The key of the tag.
        public var key: Swift.String?
        /// The value of the tag.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateAutoScalingConfigurationInput: Swift.Sendable {
    /// A name for the auto scaling configuration. When you use it for the first time in an Amazon Web Services Region, App Runner creates revision number 1 of this name. When you use the same name in subsequent calls, App Runner creates incremental revisions of the configuration. Prior to the release of [Auto scale configuration enhancements](https://docs.aws.amazon.com/apprunner/latest/relnotes/release-2023-09-22-auto-scale-config.html), the name DefaultConfiguration was reserved. This restriction is no longer in place. You can now manage DefaultConfiguration the same way you manage your custom auto scaling configurations. This means you can do the following with the DefaultConfiguration that App Runner provides:
    ///
    /// * Create new revisions of the DefaultConfiguration.
    ///
    /// * Delete the revisions of the DefaultConfiguration.
    ///
    /// * Delete the auto scaling configuration for which the App Runner DefaultConfiguration was created.
    ///
    /// * If you delete the auto scaling configuration you can create another custom auto scaling configuration with the same DefaultConfiguration name. The original DefaultConfiguration resource provided by App Runner remains in your account unless you make changes to it.
    /// This member is required.
    public var autoScalingConfigurationName: Swift.String?
    /// The maximum number of concurrent requests that you want an instance to process. If the number of concurrent requests exceeds this limit, App Runner scales up your service. Default: 100
    public var maxConcurrency: Swift.Int?
    /// The maximum number of instances that your service scales up to. At most MaxSize instances actively serve traffic for your service. Default: 25
    public var maxSize: Swift.Int?
    /// The minimum number of instances that App Runner provisions for your service. The service always has at least MinSize provisioned instances. Some of them actively serve traffic. The rest of them (provisioned and inactive instances) are a cost-effective compute capacity reserve and are ready to be quickly activated. You pay for memory usage of all the provisioned instances. You pay for CPU usage of only the active subset. App Runner temporarily doubles the number of provisioned instances during deployments, to maintain the same capacity for both old and new code. Default: 1
    public var minSize: Swift.Int?
    /// A list of metadata items that you can associate with your auto scaling configuration resource. A tag is a key-value pair.
    public var tags: [AppRunnerClientTypes.Tag]?

    public init(
        autoScalingConfigurationName: Swift.String? = nil,
        maxConcurrency: Swift.Int? = nil,
        maxSize: Swift.Int? = nil,
        minSize: Swift.Int? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.autoScalingConfigurationName = autoScalingConfigurationName
        self.maxConcurrency = maxConcurrency
        self.maxSize = maxSize
        self.minSize = minSize
        self.tags = tags
    }
}

extension AppRunnerClientTypes {

    public enum AutoScalingConfigurationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoScalingConfigurationStatus] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes an App Runner automatic scaling configuration resource. A higher MinSize increases the spread of your App Runner service over more Availability Zones in the Amazon Web Services Region. The tradeoff is a higher minimal cost. A lower MaxSize controls your cost. The tradeoff is lower responsiveness during peak demand. Multiple revisions of a configuration might have the same AutoScalingConfigurationName and different AutoScalingConfigurationRevision values.
    public struct AutoScalingConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of this auto scaling configuration.
        public var autoScalingConfigurationArn: Swift.String?
        /// The customer-provided auto scaling configuration name. It can be used in multiple revisions of a configuration.
        public var autoScalingConfigurationName: Swift.String?
        /// The revision of this auto scaling configuration. It's unique among all the active configurations ("Status": "ACTIVE") that share the same AutoScalingConfigurationName.
        public var autoScalingConfigurationRevision: Swift.Int?
        /// The time when the auto scaling configuration was created. It's in Unix time stamp format.
        public var createdAt: Foundation.Date?
        /// The time when the auto scaling configuration was deleted. It's in Unix time stamp format.
        public var deletedAt: Foundation.Date?
        /// Indicates if this auto scaling configuration has an App Runner service associated with it. A value of true indicates one or more services are associated. A value of false indicates no services are associated.
        public var hasAssociatedService: Swift.Bool?
        /// Indicates if this auto scaling configuration should be used as the default for a new App Runner service that does not have an auto scaling configuration ARN specified during creation. Each account can have only one default AutoScalingConfiguration per region. The default AutoScalingConfiguration can be any revision under the same AutoScalingConfigurationName.
        public var isDefault: Swift.Bool?
        /// It's set to true for the configuration with the highest Revision among all configurations that share the same AutoScalingConfigurationName. It's set to false otherwise.
        public var latest: Swift.Bool?
        /// The maximum number of concurrent requests that an instance processes. If the number of concurrent requests exceeds this limit, App Runner scales the service up.
        public var maxConcurrency: Swift.Int?
        /// The maximum number of instances that a service scales up to. At most MaxSize instances actively serve traffic for your service.
        public var maxSize: Swift.Int?
        /// The minimum number of instances that App Runner provisions for a service. The service always has at least MinSize provisioned instances. Some of them actively serve traffic. The rest of them (provisioned and inactive instances) are a cost-effective compute capacity reserve and are ready to be quickly activated. You pay for memory usage of all the provisioned instances. You pay for CPU usage of only the active subset. App Runner temporarily doubles the number of provisioned instances during deployments, to maintain the same capacity for both old and new code.
        public var minSize: Swift.Int?
        /// The current state of the auto scaling configuration. If the status of a configuration revision is INACTIVE, it was deleted and can't be used. Inactive configuration revisions are permanently removed some time after they are deleted.
        public var status: AppRunnerClientTypes.AutoScalingConfigurationStatus?

        public init(
            autoScalingConfigurationArn: Swift.String? = nil,
            autoScalingConfigurationName: Swift.String? = nil,
            autoScalingConfigurationRevision: Swift.Int? = nil,
            createdAt: Foundation.Date? = nil,
            deletedAt: Foundation.Date? = nil,
            hasAssociatedService: Swift.Bool? = nil,
            isDefault: Swift.Bool? = nil,
            latest: Swift.Bool? = nil,
            maxConcurrency: Swift.Int? = nil,
            maxSize: Swift.Int? = nil,
            minSize: Swift.Int? = nil,
            status: AppRunnerClientTypes.AutoScalingConfigurationStatus? = nil
        )
        {
            self.autoScalingConfigurationArn = autoScalingConfigurationArn
            self.autoScalingConfigurationName = autoScalingConfigurationName
            self.autoScalingConfigurationRevision = autoScalingConfigurationRevision
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.hasAssociatedService = hasAssociatedService
            self.isDefault = isDefault
            self.latest = latest
            self.maxConcurrency = maxConcurrency
            self.maxSize = maxSize
            self.minSize = minSize
            self.status = status
        }
    }
}

public struct CreateAutoScalingConfigurationOutput: Swift.Sendable {
    /// A description of the App Runner auto scaling configuration that's created by this request.
    /// This member is required.
    public var autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?

    public init(
        autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
    }
}

extension AppRunnerClientTypes {

    public enum ProviderType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bitbucket
        case github
        case sdkUnknown(Swift.String)

        public static var allCases: [ProviderType] {
            return [
                .bitbucket,
                .github
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bitbucket: return "BITBUCKET"
            case .github: return "GITHUB"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateConnectionInput: Swift.Sendable {
    /// A name for the new connection. It must be unique across all App Runner connections for the Amazon Web Services account in the Amazon Web Services Region.
    /// This member is required.
    public var connectionName: Swift.String?
    /// The source repository provider.
    /// This member is required.
    public var providerType: AppRunnerClientTypes.ProviderType?
    /// A list of metadata items that you can associate with your connection resource. A tag is a key-value pair.
    public var tags: [AppRunnerClientTypes.Tag]?

    public init(
        connectionName: Swift.String? = nil,
        providerType: AppRunnerClientTypes.ProviderType? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.connectionName = connectionName
        self.providerType = providerType
        self.tags = tags
    }
}

extension AppRunnerClientTypes {

    public enum ConnectionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleted
        case error
        case pendingHandshake
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .available,
                .deleted,
                .error,
                .pendingHandshake
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .error: return "ERROR"
            case .pendingHandshake: return "PENDING_HANDSHAKE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes an App Runner connection resource.
    public struct Connection: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of this connection.
        public var connectionArn: Swift.String?
        /// The customer-provided connection name.
        public var connectionName: Swift.String?
        /// The App Runner connection creation time, expressed as a Unix time stamp.
        public var createdAt: Foundation.Date?
        /// The source repository provider.
        public var providerType: AppRunnerClientTypes.ProviderType?
        /// The current state of the App Runner connection. When the state is AVAILABLE, you can use the connection to create an App Runner service.
        public var status: AppRunnerClientTypes.ConnectionStatus?

        public init(
            connectionArn: Swift.String? = nil,
            connectionName: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            providerType: AppRunnerClientTypes.ProviderType? = nil,
            status: AppRunnerClientTypes.ConnectionStatus? = nil
        )
        {
            self.connectionArn = connectionArn
            self.connectionName = connectionName
            self.createdAt = createdAt
            self.providerType = providerType
            self.status = status
        }
    }
}

public struct CreateConnectionOutput: Swift.Sendable {
    /// A description of the App Runner connection that's created by this request.
    /// This member is required.
    public var connection: AppRunnerClientTypes.Connection?

    public init(
        connection: AppRunnerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

extension AppRunnerClientTypes {

    public enum TracingVendor: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsxray
        case sdkUnknown(Swift.String)

        public static var allCases: [TracingVendor] {
            return [
                .awsxray
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsxray: return "AWSXRAY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes the configuration of the tracing feature within an App Runner observability configuration.
    public struct TraceConfiguration: Swift.Sendable {
        /// The implementation provider chosen for tracing App Runner services.
        /// This member is required.
        public var vendor: AppRunnerClientTypes.TracingVendor?

        public init(
            vendor: AppRunnerClientTypes.TracingVendor? = nil
        )
        {
            self.vendor = vendor
        }
    }
}

public struct CreateObservabilityConfigurationInput: Swift.Sendable {
    /// A name for the observability configuration. When you use it for the first time in an Amazon Web Services Region, App Runner creates revision number 1 of this name. When you use the same name in subsequent calls, App Runner creates incremental revisions of the configuration. The name DefaultConfiguration is reserved. You can't use it to create a new observability configuration, and you can't create a revision of it. When you want to use your own observability configuration for your App Runner service, create a configuration with a different name, and then provide it when you create or update your service.
    /// This member is required.
    public var observabilityConfigurationName: Swift.String?
    /// A list of metadata items that you can associate with your observability configuration resource. A tag is a key-value pair.
    public var tags: [AppRunnerClientTypes.Tag]?
    /// The configuration of the tracing feature within this observability configuration. If you don't specify it, App Runner doesn't enable tracing.
    public var traceConfiguration: AppRunnerClientTypes.TraceConfiguration?

    public init(
        observabilityConfigurationName: Swift.String? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil,
        traceConfiguration: AppRunnerClientTypes.TraceConfiguration? = nil
    )
    {
        self.observabilityConfigurationName = observabilityConfigurationName
        self.tags = tags
        self.traceConfiguration = traceConfiguration
    }
}

extension AppRunnerClientTypes {

    public enum ObservabilityConfigurationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [ObservabilityConfigurationStatus] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes an App Runner observability configuration resource. Multiple revisions of a configuration have the same ObservabilityConfigurationName and different ObservabilityConfigurationRevision values. The resource is designed to configure multiple features (currently one feature, tracing). This type contains optional members that describe the configuration of these features (currently one member, TraceConfiguration). If a feature member isn't specified, the feature isn't enabled.
    public struct ObservabilityConfiguration: Swift.Sendable {
        /// The time when the observability configuration was created. It's in Unix time stamp format.
        public var createdAt: Foundation.Date?
        /// The time when the observability configuration was deleted. It's in Unix time stamp format.
        public var deletedAt: Foundation.Date?
        /// It's set to true for the configuration with the highest Revision among all configurations that share the same ObservabilityConfigurationName. It's set to false otherwise.
        public var latest: Swift.Bool
        /// The Amazon Resource Name (ARN) of this observability configuration.
        public var observabilityConfigurationArn: Swift.String?
        /// The customer-provided observability configuration name. It can be used in multiple revisions of a configuration.
        public var observabilityConfigurationName: Swift.String?
        /// The revision of this observability configuration. It's unique among all the active configurations ("Status": "ACTIVE") that share the same ObservabilityConfigurationName.
        public var observabilityConfigurationRevision: Swift.Int
        /// The current state of the observability configuration. If the status of a configuration revision is INACTIVE, it was deleted and can't be used. Inactive configuration revisions are permanently removed some time after they are deleted.
        public var status: AppRunnerClientTypes.ObservabilityConfigurationStatus?
        /// The configuration of the tracing feature within this observability configuration. If not specified, tracing isn't enabled.
        public var traceConfiguration: AppRunnerClientTypes.TraceConfiguration?

        public init(
            createdAt: Foundation.Date? = nil,
            deletedAt: Foundation.Date? = nil,
            latest: Swift.Bool = false,
            observabilityConfigurationArn: Swift.String? = nil,
            observabilityConfigurationName: Swift.String? = nil,
            observabilityConfigurationRevision: Swift.Int = 0,
            status: AppRunnerClientTypes.ObservabilityConfigurationStatus? = nil,
            traceConfiguration: AppRunnerClientTypes.TraceConfiguration? = nil
        )
        {
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.latest = latest
            self.observabilityConfigurationArn = observabilityConfigurationArn
            self.observabilityConfigurationName = observabilityConfigurationName
            self.observabilityConfigurationRevision = observabilityConfigurationRevision
            self.status = status
            self.traceConfiguration = traceConfiguration
        }
    }
}

public struct CreateObservabilityConfigurationOutput: Swift.Sendable {
    /// A description of the App Runner observability configuration that's created by this request.
    /// This member is required.
    public var observabilityConfiguration: AppRunnerClientTypes.ObservabilityConfiguration?

    public init(
        observabilityConfiguration: AppRunnerClientTypes.ObservabilityConfiguration? = nil
    )
    {
        self.observabilityConfiguration = observabilityConfiguration
    }
}

extension AppRunnerClientTypes {

    /// Describes a custom encryption key that App Runner uses to encrypt copies of the source repository and service logs.
    public struct EncryptionConfiguration: Swift.Sendable {
        /// The ARN of the KMS key that's used for encryption.
        /// This member is required.
        public var kmsKey: Swift.String?

        public init(
            kmsKey: Swift.String? = nil
        )
        {
            self.kmsKey = kmsKey
        }
    }
}

extension AppRunnerClientTypes {

    public enum HealthCheckProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case http
        case tcp
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthCheckProtocol] {
            return [
                .http,
                .tcp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .tcp: return "TCP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes the settings for the health check that App Runner performs to monitor the health of a service.
    public struct HealthCheckConfiguration: Swift.Sendable {
        /// The number of consecutive checks that must succeed before App Runner decides that the service is healthy. Default: 1
        public var healthyThreshold: Swift.Int?
        /// The time interval, in seconds, between health checks. Default: 5
        public var interval: Swift.Int?
        /// The URL that health check requests are sent to. Path is only applicable when you set Protocol to HTTP. Default: "/"
        public var path: Swift.String?
        /// The IP protocol that App Runner uses to perform health checks for your service. If you set Protocol to HTTP, App Runner sends health check requests to the HTTP path specified by Path. Default: TCP
        public var `protocol`: AppRunnerClientTypes.HealthCheckProtocol?
        /// The time, in seconds, to wait for a health check response before deciding it failed. Default: 2
        public var timeout: Swift.Int?
        /// The number of consecutive checks that must fail before App Runner decides that the service is unhealthy. Default: 5
        public var unhealthyThreshold: Swift.Int?

        public init(
            healthyThreshold: Swift.Int? = nil,
            interval: Swift.Int? = nil,
            path: Swift.String? = nil,
            `protocol`: AppRunnerClientTypes.HealthCheckProtocol? = nil,
            timeout: Swift.Int? = nil,
            unhealthyThreshold: Swift.Int? = nil
        )
        {
            self.healthyThreshold = healthyThreshold
            self.interval = interval
            self.path = path
            self.`protocol` = `protocol`
            self.timeout = timeout
            self.unhealthyThreshold = unhealthyThreshold
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes the runtime configuration of an App Runner service instance (scaling unit).
    public struct InstanceConfiguration: Swift.Sendable {
        /// The number of CPU units reserved for each instance of your App Runner service. Default: 1 vCPU
        public var cpu: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role that provides permissions to your App Runner service. These are permissions that your code needs when it calls any Amazon Web Services APIs.
        public var instanceRoleArn: Swift.String?
        /// The amount of memory, in MB or GB, reserved for each instance of your App Runner service. Default: 2 GB
        public var memory: Swift.String?

        public init(
            cpu: Swift.String? = nil,
            instanceRoleArn: Swift.String? = nil,
            memory: Swift.String? = nil
        )
        {
            self.cpu = cpu
            self.instanceRoleArn = instanceRoleArn
            self.memory = memory
        }
    }
}

extension AppRunnerClientTypes {

    public enum EgressType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case vpc
        case sdkUnknown(Swift.String)

        public static var allCases: [EgressType] {
            return [
                .default,
                .vpc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .vpc: return "VPC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes configuration settings related to outbound network traffic of an App Runner service.
    public struct EgressConfiguration: Swift.Sendable {
        /// The type of egress configuration. Set to DEFAULT for access to resources hosted on public networks. Set to VPC to associate your service to a custom VPC specified by VpcConnectorArn.
        public var egressType: AppRunnerClientTypes.EgressType?
        /// The Amazon Resource Name (ARN) of the App Runner VPC connector that you want to associate with your App Runner service. Only valid when EgressType = VPC.
        public var vpcConnectorArn: Swift.String?

        public init(
            egressType: AppRunnerClientTypes.EgressType? = nil,
            vpcConnectorArn: Swift.String? = nil
        )
        {
            self.egressType = egressType
            self.vpcConnectorArn = vpcConnectorArn
        }
    }
}

extension AppRunnerClientTypes {

    /// Network configuration settings for inbound network traffic.
    public struct IngressConfiguration: Swift.Sendable {
        /// Specifies whether your App Runner service is publicly accessible. To make the service publicly accessible set it to True. To make the service privately accessible, from only within an Amazon VPC set it to False.
        public var isPubliclyAccessible: Swift.Bool

        public init(
            isPubliclyAccessible: Swift.Bool = false
        )
        {
            self.isPubliclyAccessible = isPubliclyAccessible
        }
    }
}

extension AppRunnerClientTypes {

    public enum IpAddressType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dualStack
        case ipv4
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressType] {
            return [
                .dualStack,
                .ipv4
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dualStack: return "DUAL_STACK"
            case .ipv4: return "IPV4"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes configuration settings related to network traffic of an App Runner service. Consists of embedded objects for each configurable network feature.
    public struct NetworkConfiguration: Swift.Sendable {
        /// Network configuration settings for outbound message traffic.
        public var egressConfiguration: AppRunnerClientTypes.EgressConfiguration?
        /// Network configuration settings for inbound message traffic.
        public var ingressConfiguration: AppRunnerClientTypes.IngressConfiguration?
        /// App Runner provides you with the option to choose between Internet Protocol version 4 (IPv4) and dual stack (IPv4 and IPv6) for your incoming public network configuration. This is an optional parameter. If you do not specify an IpAddressType, it defaults to select IPv4. Currently, App Runner supports dual stack for only Public endpoint. Only IPv4 is supported for Private endpoint. If you update a service that's using dual-stack Public endpoint to a Private endpoint, your App Runner service will default to support only IPv4 for Private endpoint and fail to receive traffic originating from IPv6 endpoint.
        public var ipAddressType: AppRunnerClientTypes.IpAddressType?

        public init(
            egressConfiguration: AppRunnerClientTypes.EgressConfiguration? = nil,
            ingressConfiguration: AppRunnerClientTypes.IngressConfiguration? = nil,
            ipAddressType: AppRunnerClientTypes.IpAddressType? = nil
        )
        {
            self.egressConfiguration = egressConfiguration
            self.ingressConfiguration = ingressConfiguration
            self.ipAddressType = ipAddressType
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes the observability configuration of an App Runner service. These are additional observability features, like tracing, that you choose to enable. They're configured in a separate resource that you associate with your service.
    public struct ServiceObservabilityConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the observability configuration that is associated with the service. Specified only when ObservabilityEnabled is true. Specify an ARN with a name and a revision number to associate that revision. For example: arn:aws:apprunner:us-east-1:123456789012:observabilityconfiguration/xray-tracing/3 Specify just the name to associate the latest revision. For example: arn:aws:apprunner:us-east-1:123456789012:observabilityconfiguration/xray-tracing
        public var observabilityConfigurationArn: Swift.String?
        /// When true, an observability configuration resource is associated with the service, and an ObservabilityConfigurationArn is specified.
        /// This member is required.
        public var observabilityEnabled: Swift.Bool

        public init(
            observabilityConfigurationArn: Swift.String? = nil,
            observabilityEnabled: Swift.Bool = false
        )
        {
            self.observabilityConfigurationArn = observabilityConfigurationArn
            self.observabilityEnabled = observabilityEnabled
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes resources needed to authenticate access to some source repositories. The specific resource depends on the repository provider.
    public struct AuthenticationConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the IAM role that grants the App Runner service access to a source repository. It's required for ECR image repositories (but not for ECR Public repositories).
        public var accessRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the App Runner connection that enables the App Runner service to connect to a source repository. It's required for GitHub code repositories.
        public var connectionArn: Swift.String?

        public init(
            accessRoleArn: Swift.String? = nil,
            connectionArn: Swift.String? = nil
        )
        {
            self.accessRoleArn = accessRoleArn
            self.connectionArn = connectionArn
        }
    }
}

extension AppRunnerClientTypes {

    public enum Runtime: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case corretto11
        case corretto8
        case dotnet6
        case go1
        case nodejs12
        case nodejs14
        case nodejs16
        case nodejs18
        case php81
        case python3
        case python311
        case ruby31
        case sdkUnknown(Swift.String)

        public static var allCases: [Runtime] {
            return [
                .corretto11,
                .corretto8,
                .dotnet6,
                .go1,
                .nodejs12,
                .nodejs14,
                .nodejs16,
                .nodejs18,
                .php81,
                .python3,
                .python311,
                .ruby31
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .corretto11: return "CORRETTO_11"
            case .corretto8: return "CORRETTO_8"
            case .dotnet6: return "DOTNET_6"
            case .go1: return "GO_1"
            case .nodejs12: return "NODEJS_12"
            case .nodejs14: return "NODEJS_14"
            case .nodejs16: return "NODEJS_16"
            case .nodejs18: return "NODEJS_18"
            case .php81: return "PHP_81"
            case .python3: return "PYTHON_3"
            case .python311: return "PYTHON_311"
            case .ruby31: return "RUBY_31"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes the basic configuration needed for building and running an App Runner service. This type doesn't support the full set of possible configuration options. Fur full configuration capabilities, use a apprunner.yaml file in the source code repository.
    public struct CodeConfigurationValues: Swift.Sendable {
        /// The command App Runner runs to build your application.
        public var buildCommand: Swift.String?
        /// The port that your application listens to in the container. Default: 8080
        public var port: Swift.String?
        /// A runtime environment type for building and running an App Runner service. It represents a programming language runtime.
        /// This member is required.
        public var runtime: AppRunnerClientTypes.Runtime?
        /// An array of key-value pairs representing the secrets and parameters that get referenced to your service as an environment variable. The supported values are either the full Amazon Resource Name (ARN) of the Secrets Manager secret or the full ARN of the parameter in the Amazon Web Services Systems Manager Parameter Store.
        ///
        /// * If the Amazon Web Services Systems Manager Parameter Store parameter exists in the same Amazon Web Services Region as the service that you're launching, you can use either the full ARN or name of the secret. If the parameter exists in a different Region, then the full ARN must be specified.
        ///
        /// * Currently, cross account referencing of Amazon Web Services Systems Manager Parameter Store parameter is not supported.
        public var runtimeEnvironmentSecrets: [Swift.String: Swift.String]?
        /// The environment variables that are available to your running App Runner service. An array of key-value pairs.
        public var runtimeEnvironmentVariables: [Swift.String: Swift.String]?
        /// The command App Runner runs to start your application.
        public var startCommand: Swift.String?

        public init(
            buildCommand: Swift.String? = nil,
            port: Swift.String? = nil,
            runtime: AppRunnerClientTypes.Runtime? = nil,
            runtimeEnvironmentSecrets: [Swift.String: Swift.String]? = nil,
            runtimeEnvironmentVariables: [Swift.String: Swift.String]? = nil,
            startCommand: Swift.String? = nil
        )
        {
            self.buildCommand = buildCommand
            self.port = port
            self.runtime = runtime
            self.runtimeEnvironmentSecrets = runtimeEnvironmentSecrets
            self.runtimeEnvironmentVariables = runtimeEnvironmentVariables
            self.startCommand = startCommand
        }
    }
}

extension AppRunnerClientTypes.CodeConfigurationValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeConfigurationValues(port: \(Swift.String(describing: port)), runtime: \(Swift.String(describing: runtime)), buildCommand: \"CONTENT_REDACTED\", runtimeEnvironmentSecrets: \"CONTENT_REDACTED\", runtimeEnvironmentVariables: \"CONTENT_REDACTED\", startCommand: \"CONTENT_REDACTED\")"}
}

extension AppRunnerClientTypes {

    public enum ConfigurationSource: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case api
        case repository
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationSource] {
            return [
                .api,
                .repository
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .api: return "API"
            case .repository: return "REPOSITORY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes the configuration that App Runner uses to build and run an App Runner service from a source code repository.
    public struct CodeConfiguration: Swift.Sendable {
        /// The basic configuration for building and running the App Runner service. Use it to quickly launch an App Runner service without providing a apprunner.yaml file in the source code repository (or ignoring the file if it exists).
        public var codeConfigurationValues: AppRunnerClientTypes.CodeConfigurationValues?
        /// The source of the App Runner configuration. Values are interpreted as follows:
        ///
        /// * REPOSITORY  App Runner reads configuration values from the apprunner.yaml file in the source code repository and ignores CodeConfigurationValues.
        ///
        /// * API  App Runner uses configuration values provided in CodeConfigurationValues and ignores the apprunner.yaml file in the source code repository.
        /// This member is required.
        public var configurationSource: AppRunnerClientTypes.ConfigurationSource?

        public init(
            codeConfigurationValues: AppRunnerClientTypes.CodeConfigurationValues? = nil,
            configurationSource: AppRunnerClientTypes.ConfigurationSource? = nil
        )
        {
            self.codeConfigurationValues = codeConfigurationValues
            self.configurationSource = configurationSource
        }
    }
}

extension AppRunnerClientTypes {

    public enum SourceCodeVersionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case branch
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceCodeVersionType] {
            return [
                .branch
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .branch: return "BRANCH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppRunnerClientTypes {

    /// Identifies a version of code that App Runner refers to within a source code repository.
    public struct SourceCodeVersion: Swift.Sendable {
        /// The type of version identifier. For a git-based repository, branches represent versions.
        /// This member is required.
        public var type: AppRunnerClientTypes.SourceCodeVersionType?
        /// A source code version. For a git-based repository, a branch name maps to a specific version. App Runner uses the most recent commit to the branch.
        /// This member is required.
        public var value: Swift.String?

        public init(
            type: AppRunnerClientTypes.SourceCodeVersionType? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes a source code repository.
    public struct CodeRepository: Swift.Sendable {
        /// Configuration for building and running the service from a source code repository. CodeConfiguration is required only for CreateService request.
        public var codeConfiguration: AppRunnerClientTypes.CodeConfiguration?
        /// The location of the repository that contains the source code.
        /// This member is required.
        public var repositoryUrl: Swift.String?
        /// The version that should be used within the source code repository.
        /// This member is required.
        public var sourceCodeVersion: AppRunnerClientTypes.SourceCodeVersion?
        /// The path of the directory that stores source code and configuration files. The build and start commands also execute from here. The path is absolute from root and, if not specified, defaults to the repository root.
        public var sourceDirectory: Swift.String?

        public init(
            codeConfiguration: AppRunnerClientTypes.CodeConfiguration? = nil,
            repositoryUrl: Swift.String? = nil,
            sourceCodeVersion: AppRunnerClientTypes.SourceCodeVersion? = nil,
            sourceDirectory: Swift.String? = nil
        )
        {
            self.codeConfiguration = codeConfiguration
            self.repositoryUrl = repositoryUrl
            self.sourceCodeVersion = sourceCodeVersion
            self.sourceDirectory = sourceDirectory
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes the configuration that App Runner uses to run an App Runner service using an image pulled from a source image repository.
    public struct ImageConfiguration: Swift.Sendable {
        /// The port that your application listens to in the container. Default: 8080
        public var port: Swift.String?
        /// An array of key-value pairs representing the secrets and parameters that get referenced to your service as an environment variable. The supported values are either the full Amazon Resource Name (ARN) of the Secrets Manager secret or the full ARN of the parameter in the Amazon Web Services Systems Manager Parameter Store.
        ///
        /// * If the Amazon Web Services Systems Manager Parameter Store parameter exists in the same Amazon Web Services Region as the service that you're launching, you can use either the full ARN or name of the secret. If the parameter exists in a different Region, then the full ARN must be specified.
        ///
        /// * Currently, cross account referencing of Amazon Web Services Systems Manager Parameter Store parameter is not supported.
        public var runtimeEnvironmentSecrets: [Swift.String: Swift.String]?
        /// Environment variables that are available to your running App Runner service. An array of key-value pairs.
        public var runtimeEnvironmentVariables: [Swift.String: Swift.String]?
        /// An optional command that App Runner runs to start the application in the source image. If specified, this command overrides the Docker images default start command.
        public var startCommand: Swift.String?

        public init(
            port: Swift.String? = nil,
            runtimeEnvironmentSecrets: [Swift.String: Swift.String]? = nil,
            runtimeEnvironmentVariables: [Swift.String: Swift.String]? = nil,
            startCommand: Swift.String? = nil
        )
        {
            self.port = port
            self.runtimeEnvironmentSecrets = runtimeEnvironmentSecrets
            self.runtimeEnvironmentVariables = runtimeEnvironmentVariables
            self.startCommand = startCommand
        }
    }
}

extension AppRunnerClientTypes.ImageConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageConfiguration(port: \(Swift.String(describing: port)), runtimeEnvironmentSecrets: \"CONTENT_REDACTED\", runtimeEnvironmentVariables: \"CONTENT_REDACTED\", startCommand: \"CONTENT_REDACTED\")"}
}

extension AppRunnerClientTypes {

    public enum ImageRepositoryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ecr
        case ecrPublic
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageRepositoryType] {
            return [
                .ecr,
                .ecrPublic
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ecr: return "ECR"
            case .ecrPublic: return "ECR_PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes a source image repository.
    public struct ImageRepository: Swift.Sendable {
        /// Configuration for running the identified image.
        public var imageConfiguration: AppRunnerClientTypes.ImageConfiguration?
        /// The identifier of an image. For an image in Amazon Elastic Container Registry (Amazon ECR), this is an image name. For the image name format, see [Pulling an image](https://docs.aws.amazon.com/AmazonECR/latest/userguide/docker-pull-ecr-image.html) in the Amazon ECR User Guide.
        /// This member is required.
        public var imageIdentifier: Swift.String?
        /// The type of the image repository. This reflects the repository provider and whether the repository is private or public.
        /// This member is required.
        public var imageRepositoryType: AppRunnerClientTypes.ImageRepositoryType?

        public init(
            imageConfiguration: AppRunnerClientTypes.ImageConfiguration? = nil,
            imageIdentifier: Swift.String? = nil,
            imageRepositoryType: AppRunnerClientTypes.ImageRepositoryType? = nil
        )
        {
            self.imageConfiguration = imageConfiguration
            self.imageIdentifier = imageIdentifier
            self.imageRepositoryType = imageRepositoryType
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes the source deployed to an App Runner service. It can be a code or an image repository.
    public struct SourceConfiguration: Swift.Sendable {
        /// Describes the resources that are needed to authenticate access to some source repositories.
        public var authenticationConfiguration: AppRunnerClientTypes.AuthenticationConfiguration?
        /// If true, continuous integration from the source repository is enabled for the App Runner service. Each repository change (including any source code commit or new image version) starts a deployment. Default: App Runner sets to false for a source image that uses an ECR Public repository or an ECR repository that's in an Amazon Web Services account other than the one that the service is in. App Runner sets to true in all other cases (which currently include a source code repository or a source image using a same-account ECR repository).
        public var autoDeploymentsEnabled: Swift.Bool?
        /// The description of a source code repository. You must provide either this member or ImageRepository (but not both).
        public var codeRepository: AppRunnerClientTypes.CodeRepository?
        /// The description of a source image repository. You must provide either this member or CodeRepository (but not both).
        public var imageRepository: AppRunnerClientTypes.ImageRepository?

        public init(
            authenticationConfiguration: AppRunnerClientTypes.AuthenticationConfiguration? = nil,
            autoDeploymentsEnabled: Swift.Bool? = nil,
            codeRepository: AppRunnerClientTypes.CodeRepository? = nil,
            imageRepository: AppRunnerClientTypes.ImageRepository? = nil
        )
        {
            self.authenticationConfiguration = authenticationConfiguration
            self.autoDeploymentsEnabled = autoDeploymentsEnabled
            self.codeRepository = codeRepository
            self.imageRepository = imageRepository
        }
    }
}

public struct CreateServiceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of an App Runner automatic scaling configuration resource that you want to associate with your service. If not provided, App Runner associates the latest revision of a default auto scaling configuration. Specify an ARN with a name and a revision number to associate that revision. For example: arn:aws:apprunner:us-east-1:123456789012:autoscalingconfiguration/high-availability/3 Specify just the name to associate the latest revision. For example: arn:aws:apprunner:us-east-1:123456789012:autoscalingconfiguration/high-availability
    public var autoScalingConfigurationArn: Swift.String?
    /// An optional custom encryption key that App Runner uses to encrypt the copy of your source repository that it maintains and your service logs. By default, App Runner uses an Amazon Web Services managed key.
    public var encryptionConfiguration: AppRunnerClientTypes.EncryptionConfiguration?
    /// The settings for the health check that App Runner performs to monitor the health of the App Runner service.
    public var healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration?
    /// The runtime configuration of instances (scaling units) of your service.
    public var instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration?
    /// Configuration settings related to network traffic of the web application that the App Runner service runs.
    public var networkConfiguration: AppRunnerClientTypes.NetworkConfiguration?
    /// The observability configuration of your service.
    public var observabilityConfiguration: AppRunnerClientTypes.ServiceObservabilityConfiguration?
    /// A name for the App Runner service. It must be unique across all the running App Runner services in your Amazon Web Services account in the Amazon Web Services Region.
    /// This member is required.
    public var serviceName: Swift.String?
    /// The source to deploy to the App Runner service. It can be a code or an image repository.
    /// This member is required.
    public var sourceConfiguration: AppRunnerClientTypes.SourceConfiguration?
    /// An optional list of metadata items that you can associate with the App Runner service resource. A tag is a key-value pair.
    public var tags: [AppRunnerClientTypes.Tag]?

    public init(
        autoScalingConfigurationArn: Swift.String? = nil,
        encryptionConfiguration: AppRunnerClientTypes.EncryptionConfiguration? = nil,
        healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration? = nil,
        instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration? = nil,
        networkConfiguration: AppRunnerClientTypes.NetworkConfiguration? = nil,
        observabilityConfiguration: AppRunnerClientTypes.ServiceObservabilityConfiguration? = nil,
        serviceName: Swift.String? = nil,
        sourceConfiguration: AppRunnerClientTypes.SourceConfiguration? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
        self.encryptionConfiguration = encryptionConfiguration
        self.healthCheckConfiguration = healthCheckConfiguration
        self.instanceConfiguration = instanceConfiguration
        self.networkConfiguration = networkConfiguration
        self.observabilityConfiguration = observabilityConfiguration
        self.serviceName = serviceName
        self.sourceConfiguration = sourceConfiguration
        self.tags = tags
    }
}

extension AppRunnerClientTypes {

    /// Provides summary information about an App Runner automatic scaling configuration resource. This type contains limited information about an auto scaling configuration. It includes only identification information, without configuration details. It's returned by the [ListAutoScalingConfigurations] action. Complete configuration information is returned by the [CreateAutoScalingConfiguration], [DescribeAutoScalingConfiguration], and [DeleteAutoScalingConfiguration] actions using the [AutoScalingConfiguration] type.
    public struct AutoScalingConfigurationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of this auto scaling configuration.
        public var autoScalingConfigurationArn: Swift.String?
        /// The customer-provided auto scaling configuration name. It can be used in multiple revisions of a configuration.
        public var autoScalingConfigurationName: Swift.String?
        /// The revision of this auto scaling configuration. It's unique among all the active configurations ("Status": "ACTIVE") with the same AutoScalingConfigurationName.
        public var autoScalingConfigurationRevision: Swift.Int
        /// The time when the auto scaling configuration was created. It's in Unix time stamp format.
        public var createdAt: Foundation.Date?
        /// Indicates if this auto scaling configuration has an App Runner service associated with it. A value of true indicates one or more services are associated. A value of false indicates no services are associated.
        public var hasAssociatedService: Swift.Bool?
        /// Indicates if this auto scaling configuration should be used as the default for a new App Runner service that does not have an auto scaling configuration ARN specified during creation. Each account can have only one default AutoScalingConfiguration per region. The default AutoScalingConfiguration can be any revision under the same AutoScalingConfigurationName.
        public var isDefault: Swift.Bool?
        /// The current state of the auto scaling configuration. If the status of a configuration revision is INACTIVE, it was deleted and can't be used. Inactive configuration revisions are permanently removed some time after they are deleted.
        public var status: AppRunnerClientTypes.AutoScalingConfigurationStatus?

        public init(
            autoScalingConfigurationArn: Swift.String? = nil,
            autoScalingConfigurationName: Swift.String? = nil,
            autoScalingConfigurationRevision: Swift.Int = 0,
            createdAt: Foundation.Date? = nil,
            hasAssociatedService: Swift.Bool? = nil,
            isDefault: Swift.Bool? = nil,
            status: AppRunnerClientTypes.AutoScalingConfigurationStatus? = nil
        )
        {
            self.autoScalingConfigurationArn = autoScalingConfigurationArn
            self.autoScalingConfigurationName = autoScalingConfigurationName
            self.autoScalingConfigurationRevision = autoScalingConfigurationRevision
            self.createdAt = createdAt
            self.hasAssociatedService = hasAssociatedService
            self.isDefault = isDefault
            self.status = status
        }
    }
}

extension AppRunnerClientTypes {

    public enum ServiceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createFailed
        case deleted
        case deleteFailed
        case operationInProgress
        case paused
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceStatus] {
            return [
                .createFailed,
                .deleted,
                .deleteFailed,
                .operationInProgress,
                .paused,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .operationInProgress: return "OPERATION_IN_PROGRESS"
            case .paused: return "PAUSED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes an App Runner service. It can describe a service in any state, including deleted services. This type contains the full information about a service, including configuration details. It's returned by the [CreateService](https://docs.aws.amazon.com/apprunner/latest/api/API_CreateService.html), [DescribeService](https://docs.aws.amazon.com/apprunner/latest/api/API_DescribeService.html), and [DeleteService](https://docs.aws.amazon.com/apprunner/latest/api/API_DeleteService.html) actions. A subset of this information is returned by the [ListServices](https://docs.aws.amazon.com/apprunner/latest/api/API_ListServices.html) action using the [ServiceSummary](https://docs.aws.amazon.com/apprunner/latest/api/API_ServiceSummary.html) type.
    public struct Service: Swift.Sendable {
        /// Summary information for the App Runner automatic scaling configuration resource that's associated with this service.
        /// This member is required.
        public var autoScalingConfigurationSummary: AppRunnerClientTypes.AutoScalingConfigurationSummary?
        /// The time when the App Runner service was created. It's in the Unix time stamp format.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The time when the App Runner service was deleted. It's in the Unix time stamp format.
        public var deletedAt: Foundation.Date?
        /// The encryption key that App Runner uses to encrypt the service logs and the copy of the source repository that App Runner maintains for the service. It can be either a customer-provided encryption key or an Amazon Web Services managed key.
        public var encryptionConfiguration: AppRunnerClientTypes.EncryptionConfiguration?
        /// The settings for the health check that App Runner performs to monitor the health of this service.
        public var healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration?
        /// The runtime configuration of instances (scaling units) of this service.
        /// This member is required.
        public var instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration?
        /// Configuration settings related to network traffic of the web application that this service runs.
        /// This member is required.
        public var networkConfiguration: AppRunnerClientTypes.NetworkConfiguration?
        /// The observability configuration of this service.
        public var observabilityConfiguration: AppRunnerClientTypes.ServiceObservabilityConfiguration?
        /// The Amazon Resource Name (ARN) of this service.
        /// This member is required.
        public var serviceArn: Swift.String?
        /// An ID that App Runner generated for this service. It's unique within the Amazon Web Services Region.
        /// This member is required.
        public var serviceId: Swift.String?
        /// The customer-provided service name.
        /// This member is required.
        public var serviceName: Swift.String?
        /// A subdomain URL that App Runner generated for this service. You can use this URL to access your service web application.
        public var serviceUrl: Swift.String?
        /// The source deployed to the App Runner service. It can be a code or an image repository.
        /// This member is required.
        public var sourceConfiguration: AppRunnerClientTypes.SourceConfiguration?
        /// The current state of the App Runner service. These particular values mean the following.
        ///
        /// * CREATE_FAILED  The service failed to create. The failed service isn't usable, and still counts towards your service quota. To troubleshoot this failure, read the failure events and logs, change any parameters that need to be fixed, and rebuild your service using UpdateService.
        ///
        /// * DELETE_FAILED  The service failed to delete and can't be successfully recovered. Retry the service deletion call to ensure that all related resources are removed.
        /// This member is required.
        public var status: AppRunnerClientTypes.ServiceStatus?
        /// The time when the App Runner service was last updated at. It's in the Unix time stamp format.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            autoScalingConfigurationSummary: AppRunnerClientTypes.AutoScalingConfigurationSummary? = nil,
            createdAt: Foundation.Date? = nil,
            deletedAt: Foundation.Date? = nil,
            encryptionConfiguration: AppRunnerClientTypes.EncryptionConfiguration? = nil,
            healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration? = nil,
            instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration? = nil,
            networkConfiguration: AppRunnerClientTypes.NetworkConfiguration? = nil,
            observabilityConfiguration: AppRunnerClientTypes.ServiceObservabilityConfiguration? = nil,
            serviceArn: Swift.String? = nil,
            serviceId: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceUrl: Swift.String? = nil,
            sourceConfiguration: AppRunnerClientTypes.SourceConfiguration? = nil,
            status: AppRunnerClientTypes.ServiceStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.autoScalingConfigurationSummary = autoScalingConfigurationSummary
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.encryptionConfiguration = encryptionConfiguration
            self.healthCheckConfiguration = healthCheckConfiguration
            self.instanceConfiguration = instanceConfiguration
            self.networkConfiguration = networkConfiguration
            self.observabilityConfiguration = observabilityConfiguration
            self.serviceArn = serviceArn
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceUrl = serviceUrl
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct CreateServiceOutput: Swift.Sendable {
    /// The unique ID of the asynchronous operation that this request started. You can use it combined with the [ListOperations](https://docs.aws.amazon.com/apprunner/latest/api/API_ListOperations.html) call to track the operation's progress.
    /// This member is required.
    public var operationId: Swift.String?
    /// A description of the App Runner service that's created by this request.
    /// This member is required.
    public var service: AppRunnerClientTypes.Service?

    public init(
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

public struct CreateVpcConnectorInput: Swift.Sendable {
    /// A list of IDs of security groups that App Runner should use for access to Amazon Web Services resources under the specified subnets. If not specified, App Runner uses the default security group of the Amazon VPC. The default security group allows all outbound traffic.
    public var securityGroups: [Swift.String]?
    /// A list of IDs of subnets that App Runner should use when it associates your service with a custom Amazon VPC. Specify IDs of subnets of a single Amazon VPC. App Runner determines the Amazon VPC from the subnets you specify. App Runner currently only provides support for IPv4.
    /// This member is required.
    public var subnets: [Swift.String]?
    /// A list of metadata items that you can associate with your VPC connector resource. A tag is a key-value pair.
    public var tags: [AppRunnerClientTypes.Tag]?
    /// A name for the VPC connector.
    /// This member is required.
    public var vpcConnectorName: Swift.String?

    public init(
        securityGroups: [Swift.String]? = nil,
        subnets: [Swift.String]? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil,
        vpcConnectorName: Swift.String? = nil
    )
    {
        self.securityGroups = securityGroups
        self.subnets = subnets
        self.tags = tags
        self.vpcConnectorName = vpcConnectorName
    }
}

extension AppRunnerClientTypes {

    public enum VpcConnectorStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcConnectorStatus] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppRunnerClientTypes {

    /// Describes an App Runner VPC connector resource. A VPC connector describes the Amazon Virtual Private Cloud (Amazon VPC) that an App Runner service is associated with, and the subnets and security group that are used. Multiple revisions of a connector might have the same Name and different Revision values. At this time, App Runner supports only one revision per name.
    public struct VpcConnector: Swift.Sendable {
        /// The time when the VPC connector was created. It's in Unix time stamp format.
        public var createdAt: Foundation.Date?
        /// The time when the VPC connector was deleted. It's in Unix time stamp format.
        public var deletedAt: Foundation.Date?
        /// A list of IDs of security groups that App Runner uses for access to Amazon Web Services resources under the specified subnets. If not specified, App Runner uses the default security group of the Amazon VPC. The default security group allows all outbound traffic.
        public var securityGroups: [Swift.String]?
        /// The current state of the VPC connector. If the status of a connector revision is INACTIVE, it was deleted and can't be used. Inactive connector revisions are permanently removed some time after they are deleted.
        public var status: AppRunnerClientTypes.VpcConnectorStatus?
        /// A list of IDs of subnets that App Runner uses for your service. All IDs are of subnets of a single Amazon VPC.
        public var subnets: [Swift.String]?
        /// The Amazon Resource Name (ARN) of this VPC connector.
        public var vpcConnectorArn: Swift.String?
        /// The customer-provided VPC connector name.
        public var vpcConnectorName: Swift.String?
        /// The revision of this VPC connector. It's unique among all the active connectors ("Status": "ACTIVE") that share the same Name. At this time, App Runner supports only one revision per name.
        public var vpcConnectorRevision: Swift.Int

        public init(
            createdAt: Foundation.Date? = nil,
            deletedAt: Foundation.Date? = nil,
            securityGroups: [Swift.String]? = nil,
            status: AppRunnerClientTypes.VpcConnectorStatus? = nil,
            subnets: [Swift.String]? = nil,
            vpcConnectorArn: Swift.String? = nil,
            vpcConnectorName: Swift.String? = nil,
            vpcConnectorRevision: Swift.Int = 0
        )
        {
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.securityGroups = securityGroups
            self.status = status
            self.subnets = subnets
            self.vpcConnectorArn = vpcConnectorArn
            self.vpcConnectorName = vpcConnectorName
            self.vpcConnectorRevision = vpcConnectorRevision
        }
    }
}

public struct CreateVpcConnectorOutput: Swift.Sendable {
    /// A description of the App Runner VPC connector that's created by this request.
    /// This member is required.
    public var vpcConnector: AppRunnerClientTypes.VpcConnector?

    public init(
        vpcConnector: AppRunnerClientTypes.VpcConnector? = nil
    )
    {
        self.vpcConnector = vpcConnector
    }
}

extension AppRunnerClientTypes {

    /// The configuration of your VPC and the associated VPC endpoint. The VPC endpoint is an Amazon Web Services PrivateLink resource that allows access to your App Runner services from within an Amazon VPC.
    public struct IngressVpcConfiguration: Swift.Sendable {
        /// The ID of the VPC endpoint that your App Runner service connects to.
        public var vpcEndpointId: Swift.String?
        /// The ID of the VPC that is used for the VPC endpoint.
        public var vpcId: Swift.String?

        public init(
            vpcEndpointId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }
    }
}

public struct CreateVpcIngressConnectionInput: Swift.Sendable {
    /// Specifications for the customers Amazon VPC and the related Amazon Web Services PrivateLink VPC endpoint that are used to create the VPC Ingress Connection resource.
    /// This member is required.
    public var ingressVpcConfiguration: AppRunnerClientTypes.IngressVpcConfiguration?
    /// The Amazon Resource Name (ARN) for this App Runner service that is used to create the VPC Ingress Connection resource.
    /// This member is required.
    public var serviceArn: Swift.String?
    /// An optional list of metadata items that you can associate with the VPC Ingress Connection resource. A tag is a key-value pair.
    public var tags: [AppRunnerClientTypes.Tag]?
    /// A name for the VPC Ingress Connection resource. It must be unique across all the active VPC Ingress Connections in your Amazon Web Services account in the Amazon Web Services Region.
    /// This member is required.
    public var vpcIngressConnectionName: Swift.String?

    public init(
        ingressVpcConfiguration: AppRunnerClientTypes.IngressVpcConfiguration? = nil,
        serviceArn: Swift.String? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil,
        vpcIngressConnectionName: Swift.String? = nil
    )
    {
        self.ingressVpcConfiguration = ingressVpcConfiguration
        self.serviceArn = serviceArn
        self.tags = tags
        self.vpcIngressConnectionName = vpcIngressConnectionName
    }
}

extension AppRunnerClientTypes {

    public enum VpcIngressConnectionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleted
        case failedCreation
        case failedDeletion
        case failedUpdate
        case pendingCreation
        case pendingDeletion
        case pendingUpdate
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcIngressConnectionStatus] {
            return [
                .available,
                .deleted,
                .failedCreation,
                .failedDeletion,
                .failedUpdate,
                .pendingCreation,
                .pendingDeletion,
                .pendingUpdate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .failedCreation: return "FAILED_CREATION"
            case .failedDeletion: return "FAILED_DELETION"
            case .failedUpdate: return "FAILED_UPDATE"
            case .pendingCreation: return "PENDING_CREATION"
            case .pendingDeletion: return "PENDING_DELETION"
            case .pendingUpdate: return "PENDING_UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppRunnerClientTypes {

    /// The App Runner resource that specifies an App Runner endpoint for incoming traffic. It establishes a connection between a VPC interface endpoint and a App Runner service, to make your App Runner service accessible from only within an Amazon VPC.
    public struct VpcIngressConnection: Swift.Sendable {
        /// The Account Id you use to create the VPC Ingress Connection resource.
        public var accountId: Swift.String?
        /// The time when the VPC Ingress Connection was created. It's in the Unix time stamp format.
        ///
        /// * Type: Timestamp
        ///
        /// * Required: Yes
        public var createdAt: Foundation.Date?
        /// The time when the App Runner service was deleted. It's in the Unix time stamp format.
        ///
        /// * Type: Timestamp
        ///
        /// * Required: No
        public var deletedAt: Foundation.Date?
        /// The domain name associated with the VPC Ingress Connection resource.
        public var domainName: Swift.String?
        /// Specifications for the customers VPC and related PrivateLink VPC endpoint that are used to associate with the VPC Ingress Connection resource.
        public var ingressVpcConfiguration: AppRunnerClientTypes.IngressVpcConfiguration?
        /// The Amazon Resource Name (ARN) of the service associated with the VPC Ingress Connection.
        public var serviceArn: Swift.String?
        /// The current status of the VPC Ingress Connection. The VPC Ingress Connection displays one of the following statuses: AVAILABLE, PENDING_CREATION, PENDING_UPDATE, PENDING_DELETION,FAILED_CREATION, FAILED_UPDATE, FAILED_DELETION, and DELETED..
        public var status: AppRunnerClientTypes.VpcIngressConnectionStatus?
        /// The Amazon Resource Name (ARN) of the VPC Ingress Connection.
        public var vpcIngressConnectionArn: Swift.String?
        /// The customer-provided VPC Ingress Connection name.
        public var vpcIngressConnectionName: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            deletedAt: Foundation.Date? = nil,
            domainName: Swift.String? = nil,
            ingressVpcConfiguration: AppRunnerClientTypes.IngressVpcConfiguration? = nil,
            serviceArn: Swift.String? = nil,
            status: AppRunnerClientTypes.VpcIngressConnectionStatus? = nil,
            vpcIngressConnectionArn: Swift.String? = nil,
            vpcIngressConnectionName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.domainName = domainName
            self.ingressVpcConfiguration = ingressVpcConfiguration
            self.serviceArn = serviceArn
            self.status = status
            self.vpcIngressConnectionArn = vpcIngressConnectionArn
            self.vpcIngressConnectionName = vpcIngressConnectionName
        }
    }
}

public struct CreateVpcIngressConnectionOutput: Swift.Sendable {
    /// A description of the App Runner VPC Ingress Connection resource that's created by this request.
    /// This member is required.
    public var vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection?

    public init(
        vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection? = nil
    )
    {
        self.vpcIngressConnection = vpcIngressConnection
    }
}

/// A resource doesn't exist for the specified Amazon Resource Name (ARN) in your Amazon Web Services account.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotfound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteAutoScalingConfigurationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the App Runner auto scaling configuration that you want to delete. The ARN can be a full auto scaling configuration ARN, or a partial ARN ending with either .../name  or .../name/revision . If a revision isn't specified, the latest active revision is deleted.
    /// This member is required.
    public var autoScalingConfigurationArn: Swift.String?
    /// Set to true to delete all of the revisions associated with the AutoScalingConfigurationArn parameter value. When DeleteAllRevisions is set to true, the only valid value for the Amazon Resource Name (ARN) is a partial ARN ending with: .../name.
    public var deleteAllRevisions: Swift.Bool?

    public init(
        autoScalingConfigurationArn: Swift.String? = nil,
        deleteAllRevisions: Swift.Bool? = false
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
        self.deleteAllRevisions = deleteAllRevisions
    }
}

public struct DeleteAutoScalingConfigurationOutput: Swift.Sendable {
    /// A description of the App Runner auto scaling configuration that this request just deleted.
    /// This member is required.
    public var autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?

    public init(
        autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
    }
}

public struct DeleteConnectionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the App Runner connection that you want to delete.
    /// This member is required.
    public var connectionArn: Swift.String?

    public init(
        connectionArn: Swift.String? = nil
    )
    {
        self.connectionArn = connectionArn
    }
}

public struct DeleteConnectionOutput: Swift.Sendable {
    /// A description of the App Runner connection that this request just deleted.
    public var connection: AppRunnerClientTypes.Connection?

    public init(
        connection: AppRunnerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

public struct DeleteObservabilityConfigurationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the App Runner observability configuration that you want to delete. The ARN can be a full observability configuration ARN, or a partial ARN ending with either .../name  or .../name/revision . If a revision isn't specified, the latest active revision is deleted.
    /// This member is required.
    public var observabilityConfigurationArn: Swift.String?

    public init(
        observabilityConfigurationArn: Swift.String? = nil
    )
    {
        self.observabilityConfigurationArn = observabilityConfigurationArn
    }
}

public struct DeleteObservabilityConfigurationOutput: Swift.Sendable {
    /// A description of the App Runner observability configuration that this request just deleted.
    /// This member is required.
    public var observabilityConfiguration: AppRunnerClientTypes.ObservabilityConfiguration?

    public init(
        observabilityConfiguration: AppRunnerClientTypes.ObservabilityConfiguration? = nil
    )
    {
        self.observabilityConfiguration = observabilityConfiguration
    }
}

public struct DeleteServiceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to delete.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init(
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

public struct DeleteServiceOutput: Swift.Sendable {
    /// The unique ID of the asynchronous operation that this request started. You can use it combined with the [ListOperations] call to track the operation's progress.
    /// This member is required.
    public var operationId: Swift.String?
    /// A description of the App Runner service that this request just deleted.
    /// This member is required.
    public var service: AppRunnerClientTypes.Service?

    public init(
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

public struct DeleteVpcConnectorInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the App Runner VPC connector that you want to delete. The ARN must be a full VPC connector ARN.
    /// This member is required.
    public var vpcConnectorArn: Swift.String?

    public init(
        vpcConnectorArn: Swift.String? = nil
    )
    {
        self.vpcConnectorArn = vpcConnectorArn
    }
}

public struct DeleteVpcConnectorOutput: Swift.Sendable {
    /// A description of the App Runner VPC connector that this request just deleted.
    /// This member is required.
    public var vpcConnector: AppRunnerClientTypes.VpcConnector?

    public init(
        vpcConnector: AppRunnerClientTypes.VpcConnector? = nil
    )
    {
        self.vpcConnector = vpcConnector
    }
}

public struct DeleteVpcIngressConnectionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the App Runner VPC Ingress Connection that you want to delete.
    /// This member is required.
    public var vpcIngressConnectionArn: Swift.String?

    public init(
        vpcIngressConnectionArn: Swift.String? = nil
    )
    {
        self.vpcIngressConnectionArn = vpcIngressConnectionArn
    }
}

public struct DeleteVpcIngressConnectionOutput: Swift.Sendable {
    /// A description of the App Runner VPC Ingress Connection that this request just deleted.
    /// This member is required.
    public var vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection?

    public init(
        vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection? = nil
    )
    {
        self.vpcIngressConnection = vpcIngressConnection
    }
}

public struct DescribeAutoScalingConfigurationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the App Runner auto scaling configuration that you want a description for. The ARN can be a full auto scaling configuration ARN, or a partial ARN ending with either .../name  or .../name/revision . If a revision isn't specified, the latest active revision is described.
    /// This member is required.
    public var autoScalingConfigurationArn: Swift.String?

    public init(
        autoScalingConfigurationArn: Swift.String? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
    }
}

public struct DescribeAutoScalingConfigurationOutput: Swift.Sendable {
    /// A full description of the App Runner auto scaling configuration that you specified in this request.
    /// This member is required.
    public var autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?

    public init(
        autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
    }
}

public struct DescribeCustomDomainsInput: Swift.Sendable {
    /// The maximum number of results that each response (result page) can include. It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones that are specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the App Runner service that you want associated custom domain names to be described for.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceArn = serviceArn
    }
}

public struct DescribeCustomDomainsOutput: Swift.Sendable {
    /// A list of descriptions of custom domain names that are associated with the service. In a paginated request, the request returns up to MaxResults records per call.
    /// This member is required.
    public var customDomains: [AppRunnerClientTypes.CustomDomain]?
    /// The App Runner subdomain of the App Runner service. The associated custom domain names are mapped to this target name.
    /// This member is required.
    public var dnsTarget: Swift.String?
    /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the App Runner service whose associated custom domain names you want to describe.
    /// This member is required.
    public var serviceArn: Swift.String?
    /// DNS Target records for the custom domains of this Amazon VPC.
    /// This member is required.
    public var vpcDNSTargets: [AppRunnerClientTypes.VpcDNSTarget]?

    public init(
        customDomains: [AppRunnerClientTypes.CustomDomain]? = nil,
        dnsTarget: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        serviceArn: Swift.String? = nil,
        vpcDNSTargets: [AppRunnerClientTypes.VpcDNSTarget]? = nil
    )
    {
        self.customDomains = customDomains
        self.dnsTarget = dnsTarget
        self.nextToken = nextToken
        self.serviceArn = serviceArn
        self.vpcDNSTargets = vpcDNSTargets
    }
}

public struct DescribeObservabilityConfigurationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the App Runner observability configuration that you want a description for. The ARN can be a full observability configuration ARN, or a partial ARN ending with either .../name  or .../name/revision . If a revision isn't specified, the latest active revision is described.
    /// This member is required.
    public var observabilityConfigurationArn: Swift.String?

    public init(
        observabilityConfigurationArn: Swift.String? = nil
    )
    {
        self.observabilityConfigurationArn = observabilityConfigurationArn
    }
}

public struct DescribeObservabilityConfigurationOutput: Swift.Sendable {
    /// A full description of the App Runner observability configuration that you specified in this request.
    /// This member is required.
    public var observabilityConfiguration: AppRunnerClientTypes.ObservabilityConfiguration?

    public init(
        observabilityConfiguration: AppRunnerClientTypes.ObservabilityConfiguration? = nil
    )
    {
        self.observabilityConfiguration = observabilityConfiguration
    }
}

public struct DescribeServiceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the App Runner service that you want a description for.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init(
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

public struct DescribeServiceOutput: Swift.Sendable {
    /// A full description of the App Runner service that you specified in this request.
    /// This member is required.
    public var service: AppRunnerClientTypes.Service?

    public init(
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

public struct DescribeVpcConnectorInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the App Runner VPC connector that you want a description for. The ARN must be a full VPC connector ARN.
    /// This member is required.
    public var vpcConnectorArn: Swift.String?

    public init(
        vpcConnectorArn: Swift.String? = nil
    )
    {
        self.vpcConnectorArn = vpcConnectorArn
    }
}

public struct DescribeVpcConnectorOutput: Swift.Sendable {
    /// A description of the App Runner VPC connector that you specified in this request.
    /// This member is required.
    public var vpcConnector: AppRunnerClientTypes.VpcConnector?

    public init(
        vpcConnector: AppRunnerClientTypes.VpcConnector? = nil
    )
    {
        self.vpcConnector = vpcConnector
    }
}

public struct DescribeVpcIngressConnectionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the App Runner VPC Ingress Connection that you want a description for.
    /// This member is required.
    public var vpcIngressConnectionArn: Swift.String?

    public init(
        vpcIngressConnectionArn: Swift.String? = nil
    )
    {
        self.vpcIngressConnectionArn = vpcIngressConnectionArn
    }
}

public struct DescribeVpcIngressConnectionOutput: Swift.Sendable {
    /// A description of the App Runner VPC Ingress Connection that you specified in this request.
    /// This member is required.
    public var vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection?

    public init(
        vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection? = nil
    )
    {
        self.vpcIngressConnection = vpcIngressConnection
    }
}

public struct DisassociateCustomDomainInput: Swift.Sendable {
    /// The domain name that you want to disassociate from the App Runner service.
    /// This member is required.
    public var domainName: Swift.String?
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to disassociate a custom domain name from.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init(
        domainName: Swift.String? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.serviceArn = serviceArn
    }
}

public struct DisassociateCustomDomainOutput: Swift.Sendable {
    /// A description of the domain name that's being disassociated.
    /// This member is required.
    public var customDomain: AppRunnerClientTypes.CustomDomain?
    /// The App Runner subdomain of the App Runner service. The disassociated custom domain name was mapped to this target name.
    /// This member is required.
    public var dnsTarget: Swift.String?
    /// The Amazon Resource Name (ARN) of the App Runner service that a custom domain name is disassociated from.
    /// This member is required.
    public var serviceArn: Swift.String?
    /// DNS Target records for the custom domains of this Amazon VPC.
    /// This member is required.
    public var vpcDNSTargets: [AppRunnerClientTypes.VpcDNSTarget]?

    public init(
        customDomain: AppRunnerClientTypes.CustomDomain? = nil,
        dnsTarget: Swift.String? = nil,
        serviceArn: Swift.String? = nil,
        vpcDNSTargets: [AppRunnerClientTypes.VpcDNSTarget]? = nil
    )
    {
        self.customDomain = customDomain
        self.dnsTarget = dnsTarget
        self.serviceArn = serviceArn
        self.vpcDNSTargets = vpcDNSTargets
    }
}

public struct ListAutoScalingConfigurationsInput: Swift.Sendable {
    /// The name of the App Runner auto scaling configuration that you want to list. If specified, App Runner lists revisions that share this name. If not specified, App Runner returns revisions of all active configurations.
    public var autoScalingConfigurationName: Swift.String?
    /// Set to true to list only the latest revision for each requested configuration name. Set to false to list all revisions for each requested configuration name. Default: true
    public var latestOnly: Swift.Bool?
    /// The maximum number of results to include in each response (result page). It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones that are specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?

    public init(
        autoScalingConfigurationName: Swift.String? = nil,
        latestOnly: Swift.Bool? = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.autoScalingConfigurationName = autoScalingConfigurationName
        self.latestOnly = latestOnly
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAutoScalingConfigurationsOutput: Swift.Sendable {
    /// A list of summary information records for auto scaling configurations. In a paginated request, the request returns up to MaxResults records for each call.
    /// This member is required.
    public var autoScalingConfigurationSummaryList: [AppRunnerClientTypes.AutoScalingConfigurationSummary]?
    /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
    public var nextToken: Swift.String?

    public init(
        autoScalingConfigurationSummaryList: [AppRunnerClientTypes.AutoScalingConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.autoScalingConfigurationSummaryList = autoScalingConfigurationSummaryList
        self.nextToken = nextToken
    }
}

public struct ListConnectionsInput: Swift.Sendable {
    /// If specified, only this connection is returned. If not specified, the result isn't filtered by name.
    public var connectionName: Swift.String?
    /// The maximum number of results to include in each response (result page). Used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. Used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?

    public init(
        connectionName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionName = connectionName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AppRunnerClientTypes {

    /// Provides summary information about an App Runner connection resource.
    public struct ConnectionSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of this connection.
        public var connectionArn: Swift.String?
        /// The customer-provided connection name.
        public var connectionName: Swift.String?
        /// The App Runner connection creation time, expressed as a Unix time stamp.
        public var createdAt: Foundation.Date?
        /// The source repository provider.
        public var providerType: AppRunnerClientTypes.ProviderType?
        /// The current state of the App Runner connection. When the state is AVAILABLE, you can use the connection to create an App Runner service.
        public var status: AppRunnerClientTypes.ConnectionStatus?

        public init(
            connectionArn: Swift.String? = nil,
            connectionName: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            providerType: AppRunnerClientTypes.ProviderType? = nil,
            status: AppRunnerClientTypes.ConnectionStatus? = nil
        )
        {
            self.connectionArn = connectionArn
            self.connectionName = connectionName
            self.createdAt = createdAt
            self.providerType = providerType
            self.status = status
        }
    }
}

public struct ListConnectionsOutput: Swift.Sendable {
    /// A list of summary information records for connections. In a paginated request, the request returns up to MaxResults records for each call.
    /// This member is required.
    public var connectionSummaryList: [AppRunnerClientTypes.ConnectionSummary]?
    /// The token that you can pass in a subsequent request to get the next result page. Returned in a paginated request.
    public var nextToken: Swift.String?

    public init(
        connectionSummaryList: [AppRunnerClientTypes.ConnectionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionSummaryList = connectionSummaryList
        self.nextToken = nextToken
    }
}

public struct ListObservabilityConfigurationsInput: Swift.Sendable {
    /// Set to true to list only the latest revision for each requested configuration name. Set to false to list all revisions for each requested configuration name. Default: true
    public var latestOnly: Swift.Bool?
    /// The maximum number of results to include in each response (result page). It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones that are specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?
    /// The name of the App Runner observability configuration that you want to list. If specified, App Runner lists revisions that share this name. If not specified, App Runner returns revisions of all active configurations.
    public var observabilityConfigurationName: Swift.String?

    public init(
        latestOnly: Swift.Bool? = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        observabilityConfigurationName: Swift.String? = nil
    )
    {
        self.latestOnly = latestOnly
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.observabilityConfigurationName = observabilityConfigurationName
    }
}

extension AppRunnerClientTypes {

    /// Provides summary information about an App Runner observability configuration resource. This type contains limited information about an observability configuration. It includes only identification information, without configuration details. It's returned by the [ListObservabilityConfigurations] action. Complete configuration information is returned by the [CreateObservabilityConfiguration], [DescribeObservabilityConfiguration], and [DeleteObservabilityConfiguration] actions using the [ObservabilityConfiguration] type.
    public struct ObservabilityConfigurationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of this observability configuration.
        public var observabilityConfigurationArn: Swift.String?
        /// The customer-provided observability configuration name. It can be used in multiple revisions of a configuration.
        public var observabilityConfigurationName: Swift.String?
        /// The revision of this observability configuration. It's unique among all the active configurations ("Status": "ACTIVE") that share the same ObservabilityConfigurationName.
        public var observabilityConfigurationRevision: Swift.Int

        public init(
            observabilityConfigurationArn: Swift.String? = nil,
            observabilityConfigurationName: Swift.String? = nil,
            observabilityConfigurationRevision: Swift.Int = 0
        )
        {
            self.observabilityConfigurationArn = observabilityConfigurationArn
            self.observabilityConfigurationName = observabilityConfigurationName
            self.observabilityConfigurationRevision = observabilityConfigurationRevision
        }
    }
}

public struct ListObservabilityConfigurationsOutput: Swift.Sendable {
    /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
    public var nextToken: Swift.String?
    /// A list of summary information records for observability configurations. In a paginated request, the request returns up to MaxResults records for each call.
    /// This member is required.
    public var observabilityConfigurationSummaryList: [AppRunnerClientTypes.ObservabilityConfigurationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        observabilityConfigurationSummaryList: [AppRunnerClientTypes.ObservabilityConfigurationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.observabilityConfigurationSummaryList = observabilityConfigurationSummaryList
    }
}

public struct ListOperationsInput: Swift.Sendable {
    /// The maximum number of results to include in each response (result page). It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the App Runner service that you want a list of operations for.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceArn = serviceArn
    }
}

extension AppRunnerClientTypes {

    public enum OperationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case pending
        case rollbackFailed
        case rollbackInProgress
        case rollbackSucceeded
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationStatus] {
            return [
                .failed,
                .inProgress,
                .pending,
                .rollbackFailed,
                .rollbackInProgress,
                .rollbackSucceeded,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .rollbackFailed: return "ROLLBACK_FAILED"
            case .rollbackInProgress: return "ROLLBACK_IN_PROGRESS"
            case .rollbackSucceeded: return "ROLLBACK_SUCCEEDED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppRunnerClientTypes {

    public enum OperationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createService
        case deleteService
        case pauseService
        case resumeService
        case startDeployment
        case updateService
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationType] {
            return [
                .createService,
                .deleteService,
                .pauseService,
                .resumeService,
                .startDeployment,
                .updateService
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createService: return "CREATE_SERVICE"
            case .deleteService: return "DELETE_SERVICE"
            case .pauseService: return "PAUSE_SERVICE"
            case .resumeService: return "RESUME_SERVICE"
            case .startDeployment: return "START_DEPLOYMENT"
            case .updateService: return "UPDATE_SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension AppRunnerClientTypes {

    /// Provides summary information for an operation that occurred on an App Runner service.
    public struct OperationSummary: Swift.Sendable {
        /// The time when the operation ended. It's in the Unix time stamp format.
        public var endedAt: Foundation.Date?
        /// A unique ID of this operation. It's unique in the scope of the App Runner service.
        public var id: Swift.String?
        /// The time when the operation started. It's in the Unix time stamp format.
        public var startedAt: Foundation.Date?
        /// The current state of the operation.
        public var status: AppRunnerClientTypes.OperationStatus?
        /// The Amazon Resource Name (ARN) of the resource that the operation acted on (for example, an App Runner service).
        public var targetArn: Swift.String?
        /// The type of operation. It indicates a specific action that occured.
        public var type: AppRunnerClientTypes.OperationType?
        /// The time when the operation was last updated. It's in the Unix time stamp format.
        public var updatedAt: Foundation.Date?

        public init(
            endedAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            startedAt: Foundation.Date? = nil,
            status: AppRunnerClientTypes.OperationStatus? = nil,
            targetArn: Swift.String? = nil,
            type: AppRunnerClientTypes.OperationType? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.endedAt = endedAt
            self.id = id
            self.startedAt = startedAt
            self.status = status
            self.targetArn = targetArn
            self.type = type
            self.updatedAt = updatedAt
        }
    }
}

public struct ListOperationsOutput: Swift.Sendable {
    /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
    public var nextToken: Swift.String?
    /// A list of operation summary information records. In a paginated request, the request returns up to MaxResults records for each call.
    public var operationSummaryList: [AppRunnerClientTypes.OperationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        operationSummaryList: [AppRunnerClientTypes.OperationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.operationSummaryList = operationSummaryList
    }
}

public struct ListServicesInput: Swift.Sendable {
    /// The maximum number of results to include in each response (result page). It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. Used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AppRunnerClientTypes {

    /// Provides summary information for an App Runner service. This type contains limited information about a service. It doesn't include configuration details. It's returned by the [ListServices](https://docs.aws.amazon.com/apprunner/latest/api/API_ListServices.html) action. Complete service information is returned by the [CreateService](https://docs.aws.amazon.com/apprunner/latest/api/API_CreateService.html), [DescribeService](https://docs.aws.amazon.com/apprunner/latest/api/API_DescribeService.html), and [DeleteService](https://docs.aws.amazon.com/apprunner/latest/api/API_DeleteService.html) actions using the [Service](https://docs.aws.amazon.com/apprunner/latest/api/API_Service.html) type.
    public struct ServiceSummary: Swift.Sendable {
        /// The time when the App Runner service was created. It's in the Unix time stamp format.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of this service.
        public var serviceArn: Swift.String?
        /// An ID that App Runner generated for this service. It's unique within the Amazon Web Services Region.
        public var serviceId: Swift.String?
        /// The customer-provided service name.
        public var serviceName: Swift.String?
        /// A subdomain URL that App Runner generated for this service. You can use this URL to access your service web application.
        public var serviceUrl: Swift.String?
        /// The current state of the App Runner service. These particular values mean the following.
        ///
        /// * CREATE_FAILED  The service failed to create. The failed service isn't usable, and still counts towards your service quota. To troubleshoot this failure, read the failure events and logs, change any parameters that need to be fixed, and rebuild your service using UpdateService.
        ///
        /// * DELETE_FAILED  The service failed to delete and can't be successfully recovered. Retry the service deletion call to ensure that all related resources are removed.
        public var status: AppRunnerClientTypes.ServiceStatus?
        /// The time when the App Runner service was last updated. It's in theUnix time stamp format.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            serviceArn: Swift.String? = nil,
            serviceId: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceUrl: Swift.String? = nil,
            status: AppRunnerClientTypes.ServiceStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.serviceArn = serviceArn
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceUrl = serviceUrl
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct ListServicesOutput: Swift.Sendable {
    /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
    public var nextToken: Swift.String?
    /// A list of service summary information records. In a paginated request, the request returns up to MaxResults records for each call.
    /// This member is required.
    public var serviceSummaryList: [AppRunnerClientTypes.ServiceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        serviceSummaryList: [AppRunnerClientTypes.ServiceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceSummaryList = serviceSummaryList
    }
}

public struct ListServicesForAutoScalingConfigurationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the App Runner auto scaling configuration that you want to list the services for. The ARN can be a full auto scaling configuration ARN, or a partial ARN ending with either .../name  or .../name/revision . If a revision isn't specified, the latest active revision is used.
    /// This member is required.
    public var autoScalingConfigurationArn: Swift.String?
    /// The maximum number of results to include in each response (result page). It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?

    public init(
        autoScalingConfigurationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListServicesForAutoScalingConfigurationOutput: Swift.Sendable {
    /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
    public var nextToken: Swift.String?
    /// A list of service ARN records. In a paginated request, the request returns up to MaxResults records for each call.
    /// This member is required.
    public var serviceArnList: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        serviceArnList: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceArnList = serviceArnList
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that a tag list is requested for. It must be the ARN of an App Runner resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A list of the tag key-value pairs that are associated with the resource.
    public var tags: [AppRunnerClientTypes.Tag]?

    public init(
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListVpcConnectorsInput: Swift.Sendable {
    /// The maximum number of results to include in each response (result page). It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones that are specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListVpcConnectorsOutput: Swift.Sendable {
    /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
    public var nextToken: Swift.String?
    /// A list of information records for VPC connectors. In a paginated request, the request returns up to MaxResults records for each call.
    /// This member is required.
    public var vpcConnectors: [AppRunnerClientTypes.VpcConnector]?

    public init(
        nextToken: Swift.String? = nil,
        vpcConnectors: [AppRunnerClientTypes.VpcConnector]? = nil
    )
    {
        self.nextToken = nextToken
        self.vpcConnectors = vpcConnectors
    }
}

extension AppRunnerClientTypes {

    /// Returns a list of VPC Ingress Connections based on the filter provided. It can return either ServiceArn or VpcEndpointId, or both.
    public struct ListVpcIngressConnectionsFilter: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of a service to filter by.
        public var serviceArn: Swift.String?
        /// The ID of a VPC Endpoint to filter by.
        public var vpcEndpointId: Swift.String?

        public init(
            serviceArn: Swift.String? = nil,
            vpcEndpointId: Swift.String? = nil
        )
        {
            self.serviceArn = serviceArn
            self.vpcEndpointId = vpcEndpointId
        }
    }
}

public struct ListVpcIngressConnectionsInput: Swift.Sendable {
    /// The VPC Ingress Connections to be listed based on either the Service Arn or Vpc Endpoint Id, or both.
    public var filter: AppRunnerClientTypes.ListVpcIngressConnectionsFilter?
    /// The maximum number of results to include in each response (result page). It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones that are specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?

    public init(
        filter: AppRunnerClientTypes.ListVpcIngressConnectionsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension AppRunnerClientTypes {

    /// Provides summary information about an VPC Ingress Connection, which includes its VPC Ingress Connection ARN and its associated Service ARN.
    public struct VpcIngressConnectionSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the service associated with the VPC Ingress Connection.
        public var serviceArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the VPC Ingress Connection.
        public var vpcIngressConnectionArn: Swift.String?

        public init(
            serviceArn: Swift.String? = nil,
            vpcIngressConnectionArn: Swift.String? = nil
        )
        {
            self.serviceArn = serviceArn
            self.vpcIngressConnectionArn = vpcIngressConnectionArn
        }
    }
}

public struct ListVpcIngressConnectionsOutput: Swift.Sendable {
    /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
    public var nextToken: Swift.String?
    /// A list of summary information records for VPC Ingress Connections. In a paginated request, the request returns up to MaxResults records for each call.
    /// This member is required.
    public var vpcIngressConnectionSummaryList: [AppRunnerClientTypes.VpcIngressConnectionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        vpcIngressConnectionSummaryList: [AppRunnerClientTypes.VpcIngressConnectionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.vpcIngressConnectionSummaryList = vpcIngressConnectionSummaryList
    }
}

public struct PauseServiceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to pause.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init(
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

public struct PauseServiceOutput: Swift.Sendable {
    /// The unique ID of the asynchronous operation that this request started. You can use it combined with the [ListOperations] call to track the operation's progress.
    public var operationId: Swift.String?
    /// A description of the App Runner service that this request just paused.
    /// This member is required.
    public var service: AppRunnerClientTypes.Service?

    public init(
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

public struct ResumeServiceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to resume.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init(
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

public struct ResumeServiceOutput: Swift.Sendable {
    /// The unique ID of the asynchronous operation that this request started. You can use it combined with the [ListOperations] call to track the operation's progress.
    public var operationId: Swift.String?
    /// A description of the App Runner service that this request just resumed.
    /// This member is required.
    public var service: AppRunnerClientTypes.Service?

    public init(
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

public struct StartDeploymentInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to manually deploy to.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init(
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

public struct StartDeploymentOutput: Swift.Sendable {
    /// The unique ID of the asynchronous operation that this request started. You can use it combined with the [ListOperations] call to track the operation's progress.
    /// This member is required.
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to update tags for. It must be the ARN of an App Runner resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag key-value pairs to add or update. If a key is new to the resource, the tag is added with the provided value. If a key is already associated with the resource, the value of the tag is updated.
    /// This member is required.
    public var tags: [AppRunnerClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from. It must be the ARN of an App Runner resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag keys that you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateDefaultAutoScalingConfigurationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the App Runner auto scaling configuration that you want to set as the default. The ARN can be a full auto scaling configuration ARN, or a partial ARN ending with either .../name  or .../name/revision . If a revision isn't specified, the latest active revision is set as the default.
    /// This member is required.
    public var autoScalingConfigurationArn: Swift.String?

    public init(
        autoScalingConfigurationArn: Swift.String? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
    }
}

public struct UpdateDefaultAutoScalingConfigurationOutput: Swift.Sendable {
    /// A description of the App Runner auto scaling configuration that was set as default.
    /// This member is required.
    public var autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?

    public init(
        autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
    }
}

public struct UpdateServiceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of an App Runner automatic scaling configuration resource that you want to associate with the App Runner service.
    public var autoScalingConfigurationArn: Swift.String?
    /// The settings for the health check that App Runner performs to monitor the health of the App Runner service.
    public var healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration?
    /// The runtime configuration to apply to instances (scaling units) of your service.
    public var instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration?
    /// Configuration settings related to network traffic of the web application that the App Runner service runs.
    public var networkConfiguration: AppRunnerClientTypes.NetworkConfiguration?
    /// The observability configuration of your service.
    public var observabilityConfiguration: AppRunnerClientTypes.ServiceObservabilityConfiguration?
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to update.
    /// This member is required.
    public var serviceArn: Swift.String?
    /// The source configuration to apply to the App Runner service. You can change the configuration of the code or image repository that the service uses. However, you can't switch from code to image or the other way around. This means that you must provide the same structure member of SourceConfiguration that you originally included when you created the service. Specifically, you can include either CodeRepository or ImageRepository. To update the source configuration, set the values to members of the structure that you include.
    public var sourceConfiguration: AppRunnerClientTypes.SourceConfiguration?

    public init(
        autoScalingConfigurationArn: Swift.String? = nil,
        healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration? = nil,
        instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration? = nil,
        networkConfiguration: AppRunnerClientTypes.NetworkConfiguration? = nil,
        observabilityConfiguration: AppRunnerClientTypes.ServiceObservabilityConfiguration? = nil,
        serviceArn: Swift.String? = nil,
        sourceConfiguration: AppRunnerClientTypes.SourceConfiguration? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
        self.healthCheckConfiguration = healthCheckConfiguration
        self.instanceConfiguration = instanceConfiguration
        self.networkConfiguration = networkConfiguration
        self.observabilityConfiguration = observabilityConfiguration
        self.serviceArn = serviceArn
        self.sourceConfiguration = sourceConfiguration
    }
}

public struct UpdateServiceOutput: Swift.Sendable {
    /// The unique ID of the asynchronous operation that this request started. You can use it combined with the [ListOperations] call to track the operation's progress.
    /// This member is required.
    public var operationId: Swift.String?
    /// A description of the App Runner service updated by this request. All configuration values in the returned Service structure reflect configuration changes that are being applied by this request.
    /// This member is required.
    public var service: AppRunnerClientTypes.Service?

    public init(
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

public struct UpdateVpcIngressConnectionInput: Swift.Sendable {
    /// Specifications for the customers Amazon VPC and the related Amazon Web Services PrivateLink VPC endpoint that are used to update the VPC Ingress Connection resource.
    /// This member is required.
    public var ingressVpcConfiguration: AppRunnerClientTypes.IngressVpcConfiguration?
    /// The Amazon Resource Name (Arn) for the App Runner VPC Ingress Connection resource that you want to update.
    /// This member is required.
    public var vpcIngressConnectionArn: Swift.String?

    public init(
        ingressVpcConfiguration: AppRunnerClientTypes.IngressVpcConfiguration? = nil,
        vpcIngressConnectionArn: Swift.String? = nil
    )
    {
        self.ingressVpcConfiguration = ingressVpcConfiguration
        self.vpcIngressConnectionArn = vpcIngressConnectionArn
    }
}

public struct UpdateVpcIngressConnectionOutput: Swift.Sendable {
    /// A description of the App Runner VPC Ingress Connection resource that's updated by this request.
    /// This member is required.
    public var vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection?

    public init(
        vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection? = nil
    )
    {
        self.vpcIngressConnection = vpcIngressConnection
    }
}

extension AssociateCustomDomainInput {

    static func urlPathProvider(_ value: AssociateCustomDomainInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAutoScalingConfigurationInput {

    static func urlPathProvider(_ value: CreateAutoScalingConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateConnectionInput {

    static func urlPathProvider(_ value: CreateConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateObservabilityConfigurationInput {

    static func urlPathProvider(_ value: CreateObservabilityConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateServiceInput {

    static func urlPathProvider(_ value: CreateServiceInput) -> Swift.String? {
        return "/"
    }
}

extension CreateVpcConnectorInput {

    static func urlPathProvider(_ value: CreateVpcConnectorInput) -> Swift.String? {
        return "/"
    }
}

extension CreateVpcIngressConnectionInput {

    static func urlPathProvider(_ value: CreateVpcIngressConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAutoScalingConfigurationInput {

    static func urlPathProvider(_ value: DeleteAutoScalingConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteConnectionInput {

    static func urlPathProvider(_ value: DeleteConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteObservabilityConfigurationInput {

    static func urlPathProvider(_ value: DeleteObservabilityConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteServiceInput {

    static func urlPathProvider(_ value: DeleteServiceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteVpcConnectorInput {

    static func urlPathProvider(_ value: DeleteVpcConnectorInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteVpcIngressConnectionInput {

    static func urlPathProvider(_ value: DeleteVpcIngressConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAutoScalingConfigurationInput {

    static func urlPathProvider(_ value: DescribeAutoScalingConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeCustomDomainsInput {

    static func urlPathProvider(_ value: DescribeCustomDomainsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeObservabilityConfigurationInput {

    static func urlPathProvider(_ value: DescribeObservabilityConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeServiceInput {

    static func urlPathProvider(_ value: DescribeServiceInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeVpcConnectorInput {

    static func urlPathProvider(_ value: DescribeVpcConnectorInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeVpcIngressConnectionInput {

    static func urlPathProvider(_ value: DescribeVpcIngressConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateCustomDomainInput {

    static func urlPathProvider(_ value: DisassociateCustomDomainInput) -> Swift.String? {
        return "/"
    }
}

extension ListAutoScalingConfigurationsInput {

    static func urlPathProvider(_ value: ListAutoScalingConfigurationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListConnectionsInput {

    static func urlPathProvider(_ value: ListConnectionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListObservabilityConfigurationsInput {

    static func urlPathProvider(_ value: ListObservabilityConfigurationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListOperationsInput {

    static func urlPathProvider(_ value: ListOperationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListServicesInput {

    static func urlPathProvider(_ value: ListServicesInput) -> Swift.String? {
        return "/"
    }
}

extension ListServicesForAutoScalingConfigurationInput {

    static func urlPathProvider(_ value: ListServicesForAutoScalingConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListVpcConnectorsInput {

    static func urlPathProvider(_ value: ListVpcConnectorsInput) -> Swift.String? {
        return "/"
    }
}

extension ListVpcIngressConnectionsInput {

    static func urlPathProvider(_ value: ListVpcIngressConnectionsInput) -> Swift.String? {
        return "/"
    }
}

extension PauseServiceInput {

    static func urlPathProvider(_ value: PauseServiceInput) -> Swift.String? {
        return "/"
    }
}

extension ResumeServiceInput {

    static func urlPathProvider(_ value: ResumeServiceInput) -> Swift.String? {
        return "/"
    }
}

extension StartDeploymentInput {

    static func urlPathProvider(_ value: StartDeploymentInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDefaultAutoScalingConfigurationInput {

    static func urlPathProvider(_ value: UpdateDefaultAutoScalingConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateServiceInput {

    static func urlPathProvider(_ value: UpdateServiceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateVpcIngressConnectionInput {

    static func urlPathProvider(_ value: UpdateVpcIngressConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateCustomDomainInput {

    static func write(value: AssociateCustomDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["EnableWWWSubdomain"].write(value.enableWWWSubdomain)
        try writer["ServiceArn"].write(value.serviceArn)
    }
}

extension CreateAutoScalingConfigurationInput {

    static func write(value: CreateAutoScalingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoScalingConfigurationName"].write(value.autoScalingConfigurationName)
        try writer["MaxConcurrency"].write(value.maxConcurrency)
        try writer["MaxSize"].write(value.maxSize)
        try writer["MinSize"].write(value.minSize)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AppRunnerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateConnectionInput {

    static func write(value: CreateConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionName"].write(value.connectionName)
        try writer["ProviderType"].write(value.providerType)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AppRunnerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateObservabilityConfigurationInput {

    static func write(value: CreateObservabilityConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObservabilityConfigurationName"].write(value.observabilityConfigurationName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AppRunnerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TraceConfiguration"].write(value.traceConfiguration, with: AppRunnerClientTypes.TraceConfiguration.write(value:to:))
    }
}

extension CreateServiceInput {

    static func write(value: CreateServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoScalingConfigurationArn"].write(value.autoScalingConfigurationArn)
        try writer["EncryptionConfiguration"].write(value.encryptionConfiguration, with: AppRunnerClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["HealthCheckConfiguration"].write(value.healthCheckConfiguration, with: AppRunnerClientTypes.HealthCheckConfiguration.write(value:to:))
        try writer["InstanceConfiguration"].write(value.instanceConfiguration, with: AppRunnerClientTypes.InstanceConfiguration.write(value:to:))
        try writer["NetworkConfiguration"].write(value.networkConfiguration, with: AppRunnerClientTypes.NetworkConfiguration.write(value:to:))
        try writer["ObservabilityConfiguration"].write(value.observabilityConfiguration, with: AppRunnerClientTypes.ServiceObservabilityConfiguration.write(value:to:))
        try writer["ServiceName"].write(value.serviceName)
        try writer["SourceConfiguration"].write(value.sourceConfiguration, with: AppRunnerClientTypes.SourceConfiguration.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AppRunnerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateVpcConnectorInput {

    static func write(value: CreateVpcConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SecurityGroups"].writeList(value.securityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subnets"].writeList(value.subnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AppRunnerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpcConnectorName"].write(value.vpcConnectorName)
    }
}

extension CreateVpcIngressConnectionInput {

    static func write(value: CreateVpcIngressConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IngressVpcConfiguration"].write(value.ingressVpcConfiguration, with: AppRunnerClientTypes.IngressVpcConfiguration.write(value:to:))
        try writer["ServiceArn"].write(value.serviceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AppRunnerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["VpcIngressConnectionName"].write(value.vpcIngressConnectionName)
    }
}

extension DeleteAutoScalingConfigurationInput {

    static func write(value: DeleteAutoScalingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoScalingConfigurationArn"].write(value.autoScalingConfigurationArn)
        try writer["DeleteAllRevisions"].write(value.deleteAllRevisions)
    }
}

extension DeleteConnectionInput {

    static func write(value: DeleteConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionArn"].write(value.connectionArn)
    }
}

extension DeleteObservabilityConfigurationInput {

    static func write(value: DeleteObservabilityConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObservabilityConfigurationArn"].write(value.observabilityConfigurationArn)
    }
}

extension DeleteServiceInput {

    static func write(value: DeleteServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServiceArn"].write(value.serviceArn)
    }
}

extension DeleteVpcConnectorInput {

    static func write(value: DeleteVpcConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VpcConnectorArn"].write(value.vpcConnectorArn)
    }
}

extension DeleteVpcIngressConnectionInput {

    static func write(value: DeleteVpcIngressConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VpcIngressConnectionArn"].write(value.vpcIngressConnectionArn)
    }
}

extension DescribeAutoScalingConfigurationInput {

    static func write(value: DescribeAutoScalingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoScalingConfigurationArn"].write(value.autoScalingConfigurationArn)
    }
}

extension DescribeCustomDomainsInput {

    static func write(value: DescribeCustomDomainsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServiceArn"].write(value.serviceArn)
    }
}

extension DescribeObservabilityConfigurationInput {

    static func write(value: DescribeObservabilityConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObservabilityConfigurationArn"].write(value.observabilityConfigurationArn)
    }
}

extension DescribeServiceInput {

    static func write(value: DescribeServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServiceArn"].write(value.serviceArn)
    }
}

extension DescribeVpcConnectorInput {

    static func write(value: DescribeVpcConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VpcConnectorArn"].write(value.vpcConnectorArn)
    }
}

extension DescribeVpcIngressConnectionInput {

    static func write(value: DescribeVpcIngressConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VpcIngressConnectionArn"].write(value.vpcIngressConnectionArn)
    }
}

extension DisassociateCustomDomainInput {

    static func write(value: DisassociateCustomDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainName"].write(value.domainName)
        try writer["ServiceArn"].write(value.serviceArn)
    }
}

extension ListAutoScalingConfigurationsInput {

    static func write(value: ListAutoScalingConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoScalingConfigurationName"].write(value.autoScalingConfigurationName)
        try writer["LatestOnly"].write(value.latestOnly)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListConnectionsInput {

    static func write(value: ListConnectionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionName"].write(value.connectionName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListObservabilityConfigurationsInput {

    static func write(value: ListObservabilityConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LatestOnly"].write(value.latestOnly)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ObservabilityConfigurationName"].write(value.observabilityConfigurationName)
    }
}

extension ListOperationsInput {

    static func write(value: ListOperationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServiceArn"].write(value.serviceArn)
    }
}

extension ListServicesInput {

    static func write(value: ListServicesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListServicesForAutoScalingConfigurationInput {

    static func write(value: ListServicesForAutoScalingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoScalingConfigurationArn"].write(value.autoScalingConfigurationArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension ListVpcConnectorsInput {

    static func write(value: ListVpcConnectorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListVpcIngressConnectionsInput {

    static func write(value: ListVpcIngressConnectionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: AppRunnerClientTypes.ListVpcIngressConnectionsFilter.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension PauseServiceInput {

    static func write(value: PauseServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServiceArn"].write(value.serviceArn)
    }
}

extension ResumeServiceInput {

    static func write(value: ResumeServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServiceArn"].write(value.serviceArn)
    }
}

extension StartDeploymentInput {

    static func write(value: StartDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServiceArn"].write(value.serviceArn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: AppRunnerClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDefaultAutoScalingConfigurationInput {

    static func write(value: UpdateDefaultAutoScalingConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoScalingConfigurationArn"].write(value.autoScalingConfigurationArn)
    }
}

extension UpdateServiceInput {

    static func write(value: UpdateServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoScalingConfigurationArn"].write(value.autoScalingConfigurationArn)
        try writer["HealthCheckConfiguration"].write(value.healthCheckConfiguration, with: AppRunnerClientTypes.HealthCheckConfiguration.write(value:to:))
        try writer["InstanceConfiguration"].write(value.instanceConfiguration, with: AppRunnerClientTypes.InstanceConfiguration.write(value:to:))
        try writer["NetworkConfiguration"].write(value.networkConfiguration, with: AppRunnerClientTypes.NetworkConfiguration.write(value:to:))
        try writer["ObservabilityConfiguration"].write(value.observabilityConfiguration, with: AppRunnerClientTypes.ServiceObservabilityConfiguration.write(value:to:))
        try writer["ServiceArn"].write(value.serviceArn)
        try writer["SourceConfiguration"].write(value.sourceConfiguration, with: AppRunnerClientTypes.SourceConfiguration.write(value:to:))
    }
}

extension UpdateVpcIngressConnectionInput {

    static func write(value: UpdateVpcIngressConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IngressVpcConfiguration"].write(value.ingressVpcConfiguration, with: AppRunnerClientTypes.IngressVpcConfiguration.write(value:to:))
        try writer["VpcIngressConnectionArn"].write(value.vpcIngressConnectionArn)
    }
}

extension AssociateCustomDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateCustomDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateCustomDomainOutput()
        value.customDomain = try reader["CustomDomain"].readIfPresent(with: AppRunnerClientTypes.CustomDomain.read(from:))
        value.dnsTarget = try reader["DNSTarget"].readIfPresent() ?? ""
        value.serviceArn = try reader["ServiceArn"].readIfPresent() ?? ""
        value.vpcDNSTargets = try reader["VpcDNSTargets"].readListIfPresent(memberReadingClosure: AppRunnerClientTypes.VpcDNSTarget.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CreateAutoScalingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAutoScalingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAutoScalingConfigurationOutput()
        value.autoScalingConfiguration = try reader["AutoScalingConfiguration"].readIfPresent(with: AppRunnerClientTypes.AutoScalingConfiguration.read(from:))
        return value
    }
}

extension CreateConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConnectionOutput()
        value.connection = try reader["Connection"].readIfPresent(with: AppRunnerClientTypes.Connection.read(from:))
        return value
    }
}

extension CreateObservabilityConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateObservabilityConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateObservabilityConfigurationOutput()
        value.observabilityConfiguration = try reader["ObservabilityConfiguration"].readIfPresent(with: AppRunnerClientTypes.ObservabilityConfiguration.read(from:))
        return value
    }
}

extension CreateServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServiceOutput()
        value.operationId = try reader["OperationId"].readIfPresent() ?? ""
        value.service = try reader["Service"].readIfPresent(with: AppRunnerClientTypes.Service.read(from:))
        return value
    }
}

extension CreateVpcConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVpcConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVpcConnectorOutput()
        value.vpcConnector = try reader["VpcConnector"].readIfPresent(with: AppRunnerClientTypes.VpcConnector.read(from:))
        return value
    }
}

extension CreateVpcIngressConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVpcIngressConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVpcIngressConnectionOutput()
        value.vpcIngressConnection = try reader["VpcIngressConnection"].readIfPresent(with: AppRunnerClientTypes.VpcIngressConnection.read(from:))
        return value
    }
}

extension DeleteAutoScalingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAutoScalingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAutoScalingConfigurationOutput()
        value.autoScalingConfiguration = try reader["AutoScalingConfiguration"].readIfPresent(with: AppRunnerClientTypes.AutoScalingConfiguration.read(from:))
        return value
    }
}

extension DeleteConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteConnectionOutput()
        value.connection = try reader["Connection"].readIfPresent(with: AppRunnerClientTypes.Connection.read(from:))
        return value
    }
}

extension DeleteObservabilityConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteObservabilityConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteObservabilityConfigurationOutput()
        value.observabilityConfiguration = try reader["ObservabilityConfiguration"].readIfPresent(with: AppRunnerClientTypes.ObservabilityConfiguration.read(from:))
        return value
    }
}

extension DeleteServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteServiceOutput()
        value.operationId = try reader["OperationId"].readIfPresent() ?? ""
        value.service = try reader["Service"].readIfPresent(with: AppRunnerClientTypes.Service.read(from:))
        return value
    }
}

extension DeleteVpcConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVpcConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteVpcConnectorOutput()
        value.vpcConnector = try reader["VpcConnector"].readIfPresent(with: AppRunnerClientTypes.VpcConnector.read(from:))
        return value
    }
}

extension DeleteVpcIngressConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVpcIngressConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteVpcIngressConnectionOutput()
        value.vpcIngressConnection = try reader["VpcIngressConnection"].readIfPresent(with: AppRunnerClientTypes.VpcIngressConnection.read(from:))
        return value
    }
}

extension DescribeAutoScalingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAutoScalingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAutoScalingConfigurationOutput()
        value.autoScalingConfiguration = try reader["AutoScalingConfiguration"].readIfPresent(with: AppRunnerClientTypes.AutoScalingConfiguration.read(from:))
        return value
    }
}

extension DescribeCustomDomainsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCustomDomainsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCustomDomainsOutput()
        value.customDomains = try reader["CustomDomains"].readListIfPresent(memberReadingClosure: AppRunnerClientTypes.CustomDomain.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.dnsTarget = try reader["DNSTarget"].readIfPresent() ?? ""
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.serviceArn = try reader["ServiceArn"].readIfPresent() ?? ""
        value.vpcDNSTargets = try reader["VpcDNSTargets"].readListIfPresent(memberReadingClosure: AppRunnerClientTypes.VpcDNSTarget.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DescribeObservabilityConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeObservabilityConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeObservabilityConfigurationOutput()
        value.observabilityConfiguration = try reader["ObservabilityConfiguration"].readIfPresent(with: AppRunnerClientTypes.ObservabilityConfiguration.read(from:))
        return value
    }
}

extension DescribeServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeServiceOutput()
        value.service = try reader["Service"].readIfPresent(with: AppRunnerClientTypes.Service.read(from:))
        return value
    }
}

extension DescribeVpcConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeVpcConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeVpcConnectorOutput()
        value.vpcConnector = try reader["VpcConnector"].readIfPresent(with: AppRunnerClientTypes.VpcConnector.read(from:))
        return value
    }
}

extension DescribeVpcIngressConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeVpcIngressConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeVpcIngressConnectionOutput()
        value.vpcIngressConnection = try reader["VpcIngressConnection"].readIfPresent(with: AppRunnerClientTypes.VpcIngressConnection.read(from:))
        return value
    }
}

extension DisassociateCustomDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateCustomDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateCustomDomainOutput()
        value.customDomain = try reader["CustomDomain"].readIfPresent(with: AppRunnerClientTypes.CustomDomain.read(from:))
        value.dnsTarget = try reader["DNSTarget"].readIfPresent() ?? ""
        value.serviceArn = try reader["ServiceArn"].readIfPresent() ?? ""
        value.vpcDNSTargets = try reader["VpcDNSTargets"].readListIfPresent(memberReadingClosure: AppRunnerClientTypes.VpcDNSTarget.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListAutoScalingConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAutoScalingConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAutoScalingConfigurationsOutput()
        value.autoScalingConfigurationSummaryList = try reader["AutoScalingConfigurationSummaryList"].readListIfPresent(memberReadingClosure: AppRunnerClientTypes.AutoScalingConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListConnectionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConnectionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConnectionsOutput()
        value.connectionSummaryList = try reader["ConnectionSummaryList"].readListIfPresent(memberReadingClosure: AppRunnerClientTypes.ConnectionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListObservabilityConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListObservabilityConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListObservabilityConfigurationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.observabilityConfigurationSummaryList = try reader["ObservabilityConfigurationSummaryList"].readListIfPresent(memberReadingClosure: AppRunnerClientTypes.ObservabilityConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListOperationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOperationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOperationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.operationSummaryList = try reader["OperationSummaryList"].readListIfPresent(memberReadingClosure: AppRunnerClientTypes.OperationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListServicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServicesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.serviceSummaryList = try reader["ServiceSummaryList"].readListIfPresent(memberReadingClosure: AppRunnerClientTypes.ServiceSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListServicesForAutoScalingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServicesForAutoScalingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServicesForAutoScalingConfigurationOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.serviceArnList = try reader["ServiceArnList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: AppRunnerClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListVpcConnectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVpcConnectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVpcConnectorsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.vpcConnectors = try reader["VpcConnectors"].readListIfPresent(memberReadingClosure: AppRunnerClientTypes.VpcConnector.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListVpcIngressConnectionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVpcIngressConnectionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVpcIngressConnectionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.vpcIngressConnectionSummaryList = try reader["VpcIngressConnectionSummaryList"].readListIfPresent(memberReadingClosure: AppRunnerClientTypes.VpcIngressConnectionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PauseServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PauseServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PauseServiceOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        value.service = try reader["Service"].readIfPresent(with: AppRunnerClientTypes.Service.read(from:))
        return value
    }
}

extension ResumeServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResumeServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ResumeServiceOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        value.service = try reader["Service"].readIfPresent(with: AppRunnerClientTypes.Service.read(from:))
        return value
    }
}

extension StartDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartDeploymentOutput()
        value.operationId = try reader["OperationId"].readIfPresent() ?? ""
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateDefaultAutoScalingConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDefaultAutoScalingConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDefaultAutoScalingConfigurationOutput()
        value.autoScalingConfiguration = try reader["AutoScalingConfiguration"].readIfPresent(with: AppRunnerClientTypes.AutoScalingConfiguration.read(from:))
        return value
    }
}

extension UpdateServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateServiceOutput()
        value.operationId = try reader["OperationId"].readIfPresent() ?? ""
        value.service = try reader["Service"].readIfPresent(with: AppRunnerClientTypes.Service.read(from:))
        return value
    }
}

extension UpdateVpcIngressConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVpcIngressConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVpcIngressConnectionOutput()
        value.vpcIngressConnection = try reader["VpcIngressConnection"].readIfPresent(with: AppRunnerClientTypes.VpcIngressConnection.read(from:))
        return value
    }
}

enum AssociateCustomDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidState": return try InvalidStateException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAutoScalingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceQuotaExceeded": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceQuotaExceeded": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateObservabilityConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceQuotaExceeded": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceQuotaExceeded": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVpcConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceQuotaExceeded": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVpcIngressConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidState": return try InvalidStateException.makeError(baseError: baseError)
            case "ServiceQuotaExceeded": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAutoScalingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteObservabilityConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidState": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVpcConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVpcIngressConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidState": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAutoScalingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCustomDomainsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeObservabilityConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeVpcConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeVpcIngressConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateCustomDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidState": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAutoScalingConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConnectionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListObservabilityConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOperationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServicesForAutoScalingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidState": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVpcConnectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVpcIngressConnectionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PauseServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidState": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResumeServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidState": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidState": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidState": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDefaultAutoScalingConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidState": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVpcIngressConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServiceError": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "InvalidRequest": return try InvalidRequestException.makeError(baseError: baseError)
            case "InvalidState": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotfound": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServiceErrorException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServiceErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServiceErrorException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidStateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidStateException {
        let reader = baseError.errorBodyReader
        var value = InvalidStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AppRunnerClientTypes.CustomDomain {

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.CustomDomain {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.CustomDomain()
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.enableWWWSubdomain = try reader["EnableWWWSubdomain"].readIfPresent() ?? false
        value.certificateValidationRecords = try reader["CertificateValidationRecords"].readListIfPresent(memberReadingClosure: AppRunnerClientTypes.CertificateValidationRecord.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppRunnerClientTypes.CertificateValidationRecord {

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.CertificateValidationRecord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.CertificateValidationRecord()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension AppRunnerClientTypes.VpcDNSTarget {

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.VpcDNSTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.VpcDNSTarget()
        value.vpcIngressConnectionArn = try reader["VpcIngressConnectionArn"].readIfPresent()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.domainName = try reader["DomainName"].readIfPresent()
        return value
    }
}

extension AppRunnerClientTypes.AutoScalingConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.AutoScalingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.AutoScalingConfiguration()
        value.autoScalingConfigurationArn = try reader["AutoScalingConfigurationArn"].readIfPresent()
        value.autoScalingConfigurationName = try reader["AutoScalingConfigurationName"].readIfPresent()
        value.autoScalingConfigurationRevision = try reader["AutoScalingConfigurationRevision"].readIfPresent()
        value.latest = try reader["Latest"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.maxConcurrency = try reader["MaxConcurrency"].readIfPresent()
        value.minSize = try reader["MinSize"].readIfPresent()
        value.maxSize = try reader["MaxSize"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletedAt = try reader["DeletedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.hasAssociatedService = try reader["HasAssociatedService"].readIfPresent()
        value.isDefault = try reader["IsDefault"].readIfPresent()
        return value
    }
}

extension AppRunnerClientTypes.Connection {

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.Connection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.Connection()
        value.connectionName = try reader["ConnectionName"].readIfPresent()
        value.connectionArn = try reader["ConnectionArn"].readIfPresent()
        value.providerType = try reader["ProviderType"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AppRunnerClientTypes.ObservabilityConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.ObservabilityConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.ObservabilityConfiguration()
        value.observabilityConfigurationArn = try reader["ObservabilityConfigurationArn"].readIfPresent()
        value.observabilityConfigurationName = try reader["ObservabilityConfigurationName"].readIfPresent()
        value.traceConfiguration = try reader["TraceConfiguration"].readIfPresent(with: AppRunnerClientTypes.TraceConfiguration.read(from:))
        value.observabilityConfigurationRevision = try reader["ObservabilityConfigurationRevision"].readIfPresent() ?? 0
        value.latest = try reader["Latest"].readIfPresent() ?? false
        value.status = try reader["Status"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletedAt = try reader["DeletedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AppRunnerClientTypes.TraceConfiguration {

    static func write(value: AppRunnerClientTypes.TraceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Vendor"].write(value.vendor)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.TraceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.TraceConfiguration()
        value.vendor = try reader["Vendor"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppRunnerClientTypes.Service {

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.Service {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.Service()
        value.serviceName = try reader["ServiceName"].readIfPresent() ?? ""
        value.serviceId = try reader["ServiceId"].readIfPresent() ?? ""
        value.serviceArn = try reader["ServiceArn"].readIfPresent() ?? ""
        value.serviceUrl = try reader["ServiceUrl"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.deletedAt = try reader["DeletedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.sourceConfiguration = try reader["SourceConfiguration"].readIfPresent(with: AppRunnerClientTypes.SourceConfiguration.read(from:))
        value.instanceConfiguration = try reader["InstanceConfiguration"].readIfPresent(with: AppRunnerClientTypes.InstanceConfiguration.read(from:))
        value.encryptionConfiguration = try reader["EncryptionConfiguration"].readIfPresent(with: AppRunnerClientTypes.EncryptionConfiguration.read(from:))
        value.healthCheckConfiguration = try reader["HealthCheckConfiguration"].readIfPresent(with: AppRunnerClientTypes.HealthCheckConfiguration.read(from:))
        value.autoScalingConfigurationSummary = try reader["AutoScalingConfigurationSummary"].readIfPresent(with: AppRunnerClientTypes.AutoScalingConfigurationSummary.read(from:))
        value.networkConfiguration = try reader["NetworkConfiguration"].readIfPresent(with: AppRunnerClientTypes.NetworkConfiguration.read(from:))
        value.observabilityConfiguration = try reader["ObservabilityConfiguration"].readIfPresent(with: AppRunnerClientTypes.ServiceObservabilityConfiguration.read(from:))
        return value
    }
}

extension AppRunnerClientTypes.ServiceObservabilityConfiguration {

    static func write(value: AppRunnerClientTypes.ServiceObservabilityConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ObservabilityConfigurationArn"].write(value.observabilityConfigurationArn)
        try writer["ObservabilityEnabled"].write(value.observabilityEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.ServiceObservabilityConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.ServiceObservabilityConfiguration()
        value.observabilityEnabled = try reader["ObservabilityEnabled"].readIfPresent() ?? false
        value.observabilityConfigurationArn = try reader["ObservabilityConfigurationArn"].readIfPresent()
        return value
    }
}

extension AppRunnerClientTypes.NetworkConfiguration {

    static func write(value: AppRunnerClientTypes.NetworkConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EgressConfiguration"].write(value.egressConfiguration, with: AppRunnerClientTypes.EgressConfiguration.write(value:to:))
        try writer["IngressConfiguration"].write(value.ingressConfiguration, with: AppRunnerClientTypes.IngressConfiguration.write(value:to:))
        try writer["IpAddressType"].write(value.ipAddressType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.NetworkConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.NetworkConfiguration()
        value.egressConfiguration = try reader["EgressConfiguration"].readIfPresent(with: AppRunnerClientTypes.EgressConfiguration.read(from:))
        value.ingressConfiguration = try reader["IngressConfiguration"].readIfPresent(with: AppRunnerClientTypes.IngressConfiguration.read(from:))
        value.ipAddressType = try reader["IpAddressType"].readIfPresent()
        return value
    }
}

extension AppRunnerClientTypes.IngressConfiguration {

    static func write(value: AppRunnerClientTypes.IngressConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IsPubliclyAccessible"].write(value.isPubliclyAccessible)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.IngressConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.IngressConfiguration()
        value.isPubliclyAccessible = try reader["IsPubliclyAccessible"].readIfPresent() ?? false
        return value
    }
}

extension AppRunnerClientTypes.EgressConfiguration {

    static func write(value: AppRunnerClientTypes.EgressConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EgressType"].write(value.egressType)
        try writer["VpcConnectorArn"].write(value.vpcConnectorArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.EgressConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.EgressConfiguration()
        value.egressType = try reader["EgressType"].readIfPresent()
        value.vpcConnectorArn = try reader["VpcConnectorArn"].readIfPresent()
        return value
    }
}

extension AppRunnerClientTypes.AutoScalingConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.AutoScalingConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.AutoScalingConfigurationSummary()
        value.autoScalingConfigurationArn = try reader["AutoScalingConfigurationArn"].readIfPresent()
        value.autoScalingConfigurationName = try reader["AutoScalingConfigurationName"].readIfPresent()
        value.autoScalingConfigurationRevision = try reader["AutoScalingConfigurationRevision"].readIfPresent() ?? 0
        value.status = try reader["Status"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.hasAssociatedService = try reader["HasAssociatedService"].readIfPresent()
        value.isDefault = try reader["IsDefault"].readIfPresent()
        return value
    }
}

extension AppRunnerClientTypes.HealthCheckConfiguration {

    static func write(value: AppRunnerClientTypes.HealthCheckConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HealthyThreshold"].write(value.healthyThreshold)
        try writer["Interval"].write(value.interval)
        try writer["Path"].write(value.path)
        try writer["Protocol"].write(value.`protocol`)
        try writer["Timeout"].write(value.timeout)
        try writer["UnhealthyThreshold"].write(value.unhealthyThreshold)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.HealthCheckConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.HealthCheckConfiguration()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.path = try reader["Path"].readIfPresent()
        value.interval = try reader["Interval"].readIfPresent()
        value.timeout = try reader["Timeout"].readIfPresent()
        value.healthyThreshold = try reader["HealthyThreshold"].readIfPresent()
        value.unhealthyThreshold = try reader["UnhealthyThreshold"].readIfPresent()
        return value
    }
}

extension AppRunnerClientTypes.EncryptionConfiguration {

    static func write(value: AppRunnerClientTypes.EncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KmsKey"].write(value.kmsKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.EncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.EncryptionConfiguration()
        value.kmsKey = try reader["KmsKey"].readIfPresent() ?? ""
        return value
    }
}

extension AppRunnerClientTypes.InstanceConfiguration {

    static func write(value: AppRunnerClientTypes.InstanceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Cpu"].write(value.cpu)
        try writer["InstanceRoleArn"].write(value.instanceRoleArn)
        try writer["Memory"].write(value.memory)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.InstanceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.InstanceConfiguration()
        value.cpu = try reader["Cpu"].readIfPresent()
        value.memory = try reader["Memory"].readIfPresent()
        value.instanceRoleArn = try reader["InstanceRoleArn"].readIfPresent()
        return value
    }
}

extension AppRunnerClientTypes.SourceConfiguration {

    static func write(value: AppRunnerClientTypes.SourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthenticationConfiguration"].write(value.authenticationConfiguration, with: AppRunnerClientTypes.AuthenticationConfiguration.write(value:to:))
        try writer["AutoDeploymentsEnabled"].write(value.autoDeploymentsEnabled)
        try writer["CodeRepository"].write(value.codeRepository, with: AppRunnerClientTypes.CodeRepository.write(value:to:))
        try writer["ImageRepository"].write(value.imageRepository, with: AppRunnerClientTypes.ImageRepository.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.SourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.SourceConfiguration()
        value.codeRepository = try reader["CodeRepository"].readIfPresent(with: AppRunnerClientTypes.CodeRepository.read(from:))
        value.imageRepository = try reader["ImageRepository"].readIfPresent(with: AppRunnerClientTypes.ImageRepository.read(from:))
        value.autoDeploymentsEnabled = try reader["AutoDeploymentsEnabled"].readIfPresent()
        value.authenticationConfiguration = try reader["AuthenticationConfiguration"].readIfPresent(with: AppRunnerClientTypes.AuthenticationConfiguration.read(from:))
        return value
    }
}

extension AppRunnerClientTypes.AuthenticationConfiguration {

    static func write(value: AppRunnerClientTypes.AuthenticationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessRoleArn"].write(value.accessRoleArn)
        try writer["ConnectionArn"].write(value.connectionArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.AuthenticationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.AuthenticationConfiguration()
        value.connectionArn = try reader["ConnectionArn"].readIfPresent()
        value.accessRoleArn = try reader["AccessRoleArn"].readIfPresent()
        return value
    }
}

extension AppRunnerClientTypes.ImageRepository {

    static func write(value: AppRunnerClientTypes.ImageRepository?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ImageConfiguration"].write(value.imageConfiguration, with: AppRunnerClientTypes.ImageConfiguration.write(value:to:))
        try writer["ImageIdentifier"].write(value.imageIdentifier)
        try writer["ImageRepositoryType"].write(value.imageRepositoryType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.ImageRepository {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.ImageRepository()
        value.imageIdentifier = try reader["ImageIdentifier"].readIfPresent() ?? ""
        value.imageConfiguration = try reader["ImageConfiguration"].readIfPresent(with: AppRunnerClientTypes.ImageConfiguration.read(from:))
        value.imageRepositoryType = try reader["ImageRepositoryType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension AppRunnerClientTypes.ImageConfiguration {

    static func write(value: AppRunnerClientTypes.ImageConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Port"].write(value.port)
        try writer["RuntimeEnvironmentSecrets"].writeMap(value.runtimeEnvironmentSecrets, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["RuntimeEnvironmentVariables"].writeMap(value.runtimeEnvironmentVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["StartCommand"].write(value.startCommand)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.ImageConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.ImageConfiguration()
        value.runtimeEnvironmentVariables = try reader["RuntimeEnvironmentVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.startCommand = try reader["StartCommand"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.runtimeEnvironmentSecrets = try reader["RuntimeEnvironmentSecrets"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AppRunnerClientTypes.CodeRepository {

    static func write(value: AppRunnerClientTypes.CodeRepository?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CodeConfiguration"].write(value.codeConfiguration, with: AppRunnerClientTypes.CodeConfiguration.write(value:to:))
        try writer["RepositoryUrl"].write(value.repositoryUrl)
        try writer["SourceCodeVersion"].write(value.sourceCodeVersion, with: AppRunnerClientTypes.SourceCodeVersion.write(value:to:))
        try writer["SourceDirectory"].write(value.sourceDirectory)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.CodeRepository {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.CodeRepository()
        value.repositoryUrl = try reader["RepositoryUrl"].readIfPresent() ?? ""
        value.sourceCodeVersion = try reader["SourceCodeVersion"].readIfPresent(with: AppRunnerClientTypes.SourceCodeVersion.read(from:))
        value.codeConfiguration = try reader["CodeConfiguration"].readIfPresent(with: AppRunnerClientTypes.CodeConfiguration.read(from:))
        value.sourceDirectory = try reader["SourceDirectory"].readIfPresent()
        return value
    }
}

extension AppRunnerClientTypes.CodeConfiguration {

    static func write(value: AppRunnerClientTypes.CodeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CodeConfigurationValues"].write(value.codeConfigurationValues, with: AppRunnerClientTypes.CodeConfigurationValues.write(value:to:))
        try writer["ConfigurationSource"].write(value.configurationSource)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.CodeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.CodeConfiguration()
        value.configurationSource = try reader["ConfigurationSource"].readIfPresent() ?? .sdkUnknown("")
        value.codeConfigurationValues = try reader["CodeConfigurationValues"].readIfPresent(with: AppRunnerClientTypes.CodeConfigurationValues.read(from:))
        return value
    }
}

extension AppRunnerClientTypes.CodeConfigurationValues {

    static func write(value: AppRunnerClientTypes.CodeConfigurationValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BuildCommand"].write(value.buildCommand)
        try writer["Port"].write(value.port)
        try writer["Runtime"].write(value.runtime)
        try writer["RuntimeEnvironmentSecrets"].writeMap(value.runtimeEnvironmentSecrets, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["RuntimeEnvironmentVariables"].writeMap(value.runtimeEnvironmentVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["StartCommand"].write(value.startCommand)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.CodeConfigurationValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.CodeConfigurationValues()
        value.runtime = try reader["Runtime"].readIfPresent() ?? .sdkUnknown("")
        value.buildCommand = try reader["BuildCommand"].readIfPresent()
        value.startCommand = try reader["StartCommand"].readIfPresent()
        value.port = try reader["Port"].readIfPresent()
        value.runtimeEnvironmentVariables = try reader["RuntimeEnvironmentVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.runtimeEnvironmentSecrets = try reader["RuntimeEnvironmentSecrets"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension AppRunnerClientTypes.SourceCodeVersion {

    static func write(value: AppRunnerClientTypes.SourceCodeVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.SourceCodeVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.SourceCodeVersion()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension AppRunnerClientTypes.VpcConnector {

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.VpcConnector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.VpcConnector()
        value.vpcConnectorName = try reader["VpcConnectorName"].readIfPresent()
        value.vpcConnectorArn = try reader["VpcConnectorArn"].readIfPresent()
        value.vpcConnectorRevision = try reader["VpcConnectorRevision"].readIfPresent() ?? 0
        value.subnets = try reader["Subnets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.securityGroups = try reader["SecurityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletedAt = try reader["DeletedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AppRunnerClientTypes.VpcIngressConnection {

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.VpcIngressConnection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.VpcIngressConnection()
        value.vpcIngressConnectionArn = try reader["VpcIngressConnectionArn"].readIfPresent()
        value.vpcIngressConnectionName = try reader["VpcIngressConnectionName"].readIfPresent()
        value.serviceArn = try reader["ServiceArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.domainName = try reader["DomainName"].readIfPresent()
        value.ingressVpcConfiguration = try reader["IngressVpcConfiguration"].readIfPresent(with: AppRunnerClientTypes.IngressVpcConfiguration.read(from:))
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletedAt = try reader["DeletedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AppRunnerClientTypes.IngressVpcConfiguration {

    static func write(value: AppRunnerClientTypes.IngressVpcConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VpcEndpointId"].write(value.vpcEndpointId)
        try writer["VpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.IngressVpcConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.IngressVpcConfiguration()
        value.vpcId = try reader["VpcId"].readIfPresent()
        value.vpcEndpointId = try reader["VpcEndpointId"].readIfPresent()
        return value
    }
}

extension AppRunnerClientTypes.ConnectionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.ConnectionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.ConnectionSummary()
        value.connectionName = try reader["ConnectionName"].readIfPresent()
        value.connectionArn = try reader["ConnectionArn"].readIfPresent()
        value.providerType = try reader["ProviderType"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AppRunnerClientTypes.ObservabilityConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.ObservabilityConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.ObservabilityConfigurationSummary()
        value.observabilityConfigurationArn = try reader["ObservabilityConfigurationArn"].readIfPresent()
        value.observabilityConfigurationName = try reader["ObservabilityConfigurationName"].readIfPresent()
        value.observabilityConfigurationRevision = try reader["ObservabilityConfigurationRevision"].readIfPresent() ?? 0
        return value
    }
}

extension AppRunnerClientTypes.OperationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.OperationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.OperationSummary()
        value.id = try reader["Id"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.targetArn = try reader["TargetArn"].readIfPresent()
        value.startedAt = try reader["StartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endedAt = try reader["EndedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension AppRunnerClientTypes.ServiceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.ServiceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.ServiceSummary()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        value.serviceId = try reader["ServiceId"].readIfPresent()
        value.serviceArn = try reader["ServiceArn"].readIfPresent()
        value.serviceUrl = try reader["ServiceUrl"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension AppRunnerClientTypes.Tag {

    static func write(value: AppRunnerClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension AppRunnerClientTypes.VpcIngressConnectionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> AppRunnerClientTypes.VpcIngressConnectionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = AppRunnerClientTypes.VpcIngressConnectionSummary()
        value.vpcIngressConnectionArn = try reader["VpcIngressConnectionArn"].readIfPresent()
        value.serviceArn = try reader["ServiceArn"].readIfPresent()
        return value
    }
}

extension AppRunnerClientTypes.ListVpcIngressConnectionsFilter {

    static func write(value: AppRunnerClientTypes.ListVpcIngressConnectionsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ServiceArn"].write(value.serviceArn)
        try writer["VpcEndpointId"].write(value.vpcEndpointId)
    }
}

public enum AppRunnerClientTypes {}
