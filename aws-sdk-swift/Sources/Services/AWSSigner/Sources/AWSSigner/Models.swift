//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct CancelSigningProfileOutput: Swift.Sendable {

    public init() { }
}

public struct RevokeSignatureOutput: Swift.Sendable {

    public init() { }
}

public struct RevokeSigningProfileOutput: Swift.Sendable {

    public init() { }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The resource encountered a conflicting state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// An internal error occurred.
public struct InternalServiceErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// A specified resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The client is making a request that exceeds service limits.
public struct ServiceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The allowed number of job-signing requests has been exceeded. This error supersedes the error ThrottlingException.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// You signing certificate could not be validated.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct AddProfilePermissionInput: Swift.Sendable {
    /// For cross-account signing. Grant a designated account permission to perform one or more of the following actions. Each action is associated with a specific API's operations. For more information about cross-account signing, see [Using cross-account signing with signing profiles](https://docs.aws.amazon.com/signer/latest/developerguide/signing-profile-cross-account.html) in the AWS Signer Developer Guide. You can designate the following actions to an account.
    ///
    /// * signer:StartSigningJob. This action isn't supported for container image workflows. For details, see [StartSigningJob].
    ///
    /// * signer:SignPayload. This action isn't supported for AWS Lambda workflows. For details, see [SignPayload]
    ///
    /// * signer:GetSigningProfile. For details, see [GetSigningProfile].
    ///
    /// * signer:RevokeSignature. For details, see [RevokeSignature].
    /// This member is required.
    public var action: Swift.String?
    /// The AWS principal receiving cross-account permissions. This may be an IAM role or another AWS account ID.
    /// This member is required.
    public var principal: Swift.String?
    /// The human-readable name of the signing profile.
    /// This member is required.
    public var profileName: Swift.String?
    /// The version of the signing profile.
    public var profileVersion: Swift.String?
    /// A unique identifier for the current profile revision.
    public var revisionId: Swift.String?
    /// A unique identifier for the cross-account permission statement.
    /// This member is required.
    public var statementId: Swift.String?

    public init(
        action: Swift.String? = nil,
        principal: Swift.String? = nil,
        profileName: Swift.String? = nil,
        profileVersion: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.action = action
        self.principal = principal
        self.profileName = profileName
        self.profileVersion = profileVersion
        self.revisionId = revisionId
        self.statementId = statementId
    }
}

public struct AddProfilePermissionOutput: Swift.Sendable {
    /// A unique identifier for the current profile revision.
    public var revisionId: Swift.String?

    public init(
        revisionId: Swift.String? = nil
    )
    {
        self.revisionId = revisionId
    }
}

/// The request contains invalid parameters for the ARN or tags. This exception also occurs when you call a tagging API on a cancelled signing profile.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct CancelSigningProfileInput: Swift.Sendable {
    /// The name of the signing profile to be canceled.
    /// This member is required.
    public var profileName: Swift.String?

    public init(
        profileName: Swift.String? = nil
    )
    {
        self.profileName = profileName
    }
}

extension SignerClientTypes {

    public enum Category: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsiot
        case sdkUnknown(Swift.String)

        public static var allCases: [Category] {
            return [
                .awsiot
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsiot: return "AWSIoT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeSigningJobInput: Swift.Sendable {
    /// The ID of the signing job on input.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

extension SignerClientTypes {

    public enum EncryptionAlgorithm: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ecdsa
        case rsa
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionAlgorithm] {
            return [
                .ecdsa,
                .rsa
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ecdsa: return "ECDSA"
            case .rsa: return "RSA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SignerClientTypes {

    public enum HashAlgorithm: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sha1
        case sha256
        case sdkUnknown(Swift.String)

        public static var allCases: [HashAlgorithm] {
            return [
                .sha1,
                .sha256
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sha1: return "SHA1"
            case .sha256: return "SHA256"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SignerClientTypes {

    /// A signing configuration that overrides the default encryption or hash algorithm of a signing job.
    public struct SigningConfigurationOverrides: Swift.Sendable {
        /// A specified override of the default encryption algorithm that is used in a code-signing job.
        public var encryptionAlgorithm: SignerClientTypes.EncryptionAlgorithm?
        /// A specified override of the default hash algorithm that is used in a code-signing job.
        public var hashAlgorithm: SignerClientTypes.HashAlgorithm?

        public init(
            encryptionAlgorithm: SignerClientTypes.EncryptionAlgorithm? = nil,
            hashAlgorithm: SignerClientTypes.HashAlgorithm? = nil
        )
        {
            self.encryptionAlgorithm = encryptionAlgorithm
            self.hashAlgorithm = hashAlgorithm
        }
    }
}

extension SignerClientTypes {

    public enum ImageFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case jsondetached
        case jsonembedded
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageFormat] {
            return [
                .json,
                .jsondetached,
                .jsonembedded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .jsondetached: return "JSONDetached"
            case .jsonembedded: return "JSONEmbedded"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SignerClientTypes {

    /// Any overrides that are applied to the signing configuration of a signing platform.
    public struct SigningPlatformOverrides: Swift.Sendable {
        /// A signing configuration that overrides the default encryption or hash algorithm of a signing job.
        public var signingConfiguration: SignerClientTypes.SigningConfigurationOverrides?
        /// A signed image is a JSON object. When overriding the default signing platform configuration, a customer can select either of two signing formats, JSONEmbedded or JSONDetached. (A third format value, JSON, is reserved for future use.) With JSONEmbedded, the signing image has the payload embedded in it. With JSONDetached, the payload is not be embedded in the signing image.
        public var signingImageFormat: SignerClientTypes.ImageFormat?

        public init(
            signingConfiguration: SignerClientTypes.SigningConfigurationOverrides? = nil,
            signingImageFormat: SignerClientTypes.ImageFormat? = nil
        )
        {
            self.signingConfiguration = signingConfiguration
            self.signingImageFormat = signingImageFormat
        }
    }
}

extension SignerClientTypes {

    /// Revocation information for a signing job.
    public struct SigningJobRevocationRecord: Swift.Sendable {
        /// A caller-supplied reason for revocation.
        public var reason: Swift.String?
        /// The time of revocation.
        public var revokedAt: Foundation.Date?
        /// The identity of the revoker.
        public var revokedBy: Swift.String?

        public init(
            reason: Swift.String? = nil,
            revokedAt: Foundation.Date? = nil,
            revokedBy: Swift.String? = nil
        )
        {
            self.reason = reason
            self.revokedAt = revokedAt
            self.revokedBy = revokedBy
        }
    }
}

extension SignerClientTypes {

    /// The Amazon S3 bucket name and key where Signer saved your signed code image.
    public struct S3SignedObject: Swift.Sendable {
        /// Name of the S3 bucket.
        public var bucketName: Swift.String?
        /// Key name that uniquely identifies a signed code image in your bucket.
        public var key: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.key = key
        }
    }
}

extension SignerClientTypes {

    /// Points to an S3SignedObject object that contains information about your signed code image.
    public struct SignedObject: Swift.Sendable {
        /// The S3SignedObject.
        public var s3: SignerClientTypes.S3SignedObject?

        public init(
            s3: SignerClientTypes.S3SignedObject? = nil
        )
        {
            self.s3 = s3
        }
    }
}

extension SignerClientTypes {

    /// The ACM certificate that is used to sign your code.
    public struct SigningMaterial: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the certificates that is used to sign your code.
        /// This member is required.
        public var certificateArn: Swift.String?

        public init(
            certificateArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
        }
    }
}

extension SignerClientTypes {

    /// Information about the Amazon S3 bucket where you saved your unsigned code.
    public struct S3Source: Swift.Sendable {
        /// Name of the S3 bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// Key name of the bucket object that contains your unsigned code.
        /// This member is required.
        public var key: Swift.String?
        /// Version of your source image in your version enabled S3 bucket.
        /// This member is required.
        public var version: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            key: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.key = key
            self.version = version
        }
    }
}

extension SignerClientTypes {

    /// An S3Source object that contains information about the S3 bucket where you saved your unsigned code.
    public struct Source: Swift.Sendable {
        /// The S3Source object.
        public var s3: SignerClientTypes.S3Source?

        public init(
            s3: SignerClientTypes.S3Source? = nil
        )
        {
            self.s3 = s3
        }
    }
}

extension SignerClientTypes {

    public enum SigningStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inprogress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [SigningStatus] {
            return [
                .failed,
                .inprogress,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .succeeded: return "Succeeded"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeSigningJobOutput: Swift.Sendable {
    /// Date and time that the signing job was completed.
    public var completedAt: Foundation.Date?
    /// Date and time that the signing job was created.
    public var createdAt: Foundation.Date?
    /// The ID of the signing job on output.
    public var jobId: Swift.String?
    /// The IAM entity that initiated the signing job.
    public var jobInvoker: Swift.String?
    /// The AWS account ID of the job owner.
    public var jobOwner: Swift.String?
    /// A list of any overrides that were applied to the signing operation.
    public var overrides: SignerClientTypes.SigningPlatformOverrides?
    /// A human-readable name for the signing platform associated with the signing job.
    public var platformDisplayName: Swift.String?
    /// The microcontroller platform to which your signed code image will be distributed.
    public var platformId: Swift.String?
    /// The name of the profile that initiated the signing operation.
    public var profileName: Swift.String?
    /// The version of the signing profile used to initiate the signing job.
    public var profileVersion: Swift.String?
    /// The IAM principal that requested the signing job.
    public var requestedBy: Swift.String?
    /// A revocation record if the signature generated by the signing job has been revoked. Contains a timestamp and the ID of the IAM entity that revoked the signature.
    public var revocationRecord: SignerClientTypes.SigningJobRevocationRecord?
    /// Thr expiration timestamp for the signature generated by the signing job.
    public var signatureExpiresAt: Foundation.Date?
    /// Name of the S3 bucket where the signed code image is saved by AWS Signer.
    public var signedObject: SignerClientTypes.SignedObject?
    /// The Amazon Resource Name (ARN) of your code signing certificate.
    public var signingMaterial: SignerClientTypes.SigningMaterial?
    /// Map of user-assigned key-value pairs used during signing. These values contain any information that you specified for use in your signing job.
    public var signingParameters: [Swift.String: Swift.String]?
    /// The object that contains the name of your S3 bucket or your raw code.
    public var source: SignerClientTypes.Source?
    /// Status of the signing job.
    public var status: SignerClientTypes.SigningStatus?
    /// String value that contains the status reason.
    public var statusReason: Swift.String?

    public init(
        completedAt: Foundation.Date? = nil,
        createdAt: Foundation.Date? = nil,
        jobId: Swift.String? = nil,
        jobInvoker: Swift.String? = nil,
        jobOwner: Swift.String? = nil,
        overrides: SignerClientTypes.SigningPlatformOverrides? = nil,
        platformDisplayName: Swift.String? = nil,
        platformId: Swift.String? = nil,
        profileName: Swift.String? = nil,
        profileVersion: Swift.String? = nil,
        requestedBy: Swift.String? = nil,
        revocationRecord: SignerClientTypes.SigningJobRevocationRecord? = nil,
        signatureExpiresAt: Foundation.Date? = nil,
        signedObject: SignerClientTypes.SignedObject? = nil,
        signingMaterial: SignerClientTypes.SigningMaterial? = nil,
        signingParameters: [Swift.String: Swift.String]? = nil,
        source: SignerClientTypes.Source? = nil,
        status: SignerClientTypes.SigningStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.completedAt = completedAt
        self.createdAt = createdAt
        self.jobId = jobId
        self.jobInvoker = jobInvoker
        self.jobOwner = jobOwner
        self.overrides = overrides
        self.platformDisplayName = platformDisplayName
        self.platformId = platformId
        self.profileName = profileName
        self.profileVersion = profileVersion
        self.requestedBy = requestedBy
        self.revocationRecord = revocationRecord
        self.signatureExpiresAt = signatureExpiresAt
        self.signedObject = signedObject
        self.signingMaterial = signingMaterial
        self.signingParameters = signingParameters
        self.source = source
        self.status = status
        self.statusReason = statusReason
    }
}

extension SignerClientTypes {

    /// The name and prefix of the Amazon S3 bucket where AWS Signer saves your signed objects.
    public struct S3Destination: Swift.Sendable {
        /// Name of the S3 bucket.
        public var bucketName: Swift.String?
        /// An S3 prefix that you can use to limit responses to those that begin with the specified prefix.
        public var `prefix`: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.`prefix` = `prefix`
        }
    }
}

extension SignerClientTypes {

    /// Points to an S3Destination object that contains information about your S3 bucket.
    public struct Destination: Swift.Sendable {
        /// The S3Destination object.
        public var s3: SignerClientTypes.S3Destination?

        public init(
            s3: SignerClientTypes.S3Destination? = nil
        )
        {
            self.s3 = s3
        }
    }
}

extension SignerClientTypes {

    /// The encryption algorithm options that are available to a code-signing job.
    public struct EncryptionAlgorithmOptions: Swift.Sendable {
        /// The set of accepted encryption algorithms that are allowed in a code-signing job.
        /// This member is required.
        public var allowedValues: [SignerClientTypes.EncryptionAlgorithm]?
        /// The default encryption algorithm that is used by a code-signing job.
        /// This member is required.
        public var defaultValue: SignerClientTypes.EncryptionAlgorithm?

        public init(
            allowedValues: [SignerClientTypes.EncryptionAlgorithm]? = nil,
            defaultValue: SignerClientTypes.EncryptionAlgorithm? = nil
        )
        {
            self.allowedValues = allowedValues
            self.defaultValue = defaultValue
        }
    }
}

public struct GetRevocationStatusInput: Swift.Sendable {
    /// A list of composite signed hashes that identify certificates. A certificate identifier consists of a subject certificate TBS hash (signed by the parent CA) combined with a parent CA TBS hash (signed by the parent CAâ€™s CA). Root certificates are defined as their own CA. The following example shows how to calculate a hash for this parameter using OpenSSL commands: openssl asn1parse -in childCert.pem -strparse 4 -out childCert.tbs
    ///     openssl sha384 < childCert.tbs -binary > childCertTbsHash
    ///
    ///
    ///     openssl asn1parse -in parentCert.pem -strparse 4 -out parentCert.tbs
    ///
    ///
    ///     openssl sha384 < parentCert.tbs -binary > parentCertTbsHash xxd -p childCertTbsHash > certificateHash.hex xxd -p parentCertTbsHash >> certificateHash.hex
    ///
    ///
    ///     cat certificateHash.hex | tr -d '\n'
    /// This member is required.
    public var certificateHashes: [Swift.String]?
    /// The ARN of a signing job.
    /// This member is required.
    public var jobArn: Swift.String?
    /// The ID of a signing platform.
    /// This member is required.
    public var platformId: Swift.String?
    /// The version of a signing profile.
    /// This member is required.
    public var profileVersionArn: Swift.String?
    /// The timestamp of the signature that validates the profile or job.
    /// This member is required.
    public var signatureTimestamp: Foundation.Date?

    public init(
        certificateHashes: [Swift.String]? = nil,
        jobArn: Swift.String? = nil,
        platformId: Swift.String? = nil,
        profileVersionArn: Swift.String? = nil,
        signatureTimestamp: Foundation.Date? = nil
    )
    {
        self.certificateHashes = certificateHashes
        self.jobArn = jobArn
        self.platformId = platformId
        self.profileVersionArn = profileVersionArn
        self.signatureTimestamp = signatureTimestamp
    }
}

public struct GetRevocationStatusOutput: Swift.Sendable {
    /// A list of revoked entities (including zero or more of the signing profile ARN, signing job ARN, and certificate hashes) supplied as input to the API.
    public var revokedEntities: [Swift.String]?

    public init(
        revokedEntities: [Swift.String]? = nil
    )
    {
        self.revokedEntities = revokedEntities
    }
}

public struct GetSigningPlatformInput: Swift.Sendable {
    /// The ID of the target signing platform.
    /// This member is required.
    public var platformId: Swift.String?

    public init(
        platformId: Swift.String? = nil
    )
    {
        self.platformId = platformId
    }
}

extension SignerClientTypes {

    /// The hash algorithms that are available to a code-signing job.
    public struct HashAlgorithmOptions: Swift.Sendable {
        /// The set of accepted hash algorithms allowed in a code-signing job.
        /// This member is required.
        public var allowedValues: [SignerClientTypes.HashAlgorithm]?
        /// The default hash algorithm that is used in a code-signing job.
        /// This member is required.
        public var defaultValue: SignerClientTypes.HashAlgorithm?

        public init(
            allowedValues: [SignerClientTypes.HashAlgorithm]? = nil,
            defaultValue: SignerClientTypes.HashAlgorithm? = nil
        )
        {
            self.allowedValues = allowedValues
            self.defaultValue = defaultValue
        }
    }
}

extension SignerClientTypes {

    /// The configuration of a signing operation.
    public struct SigningConfiguration: Swift.Sendable {
        /// The encryption algorithm options that are available for a code-signing job.
        /// This member is required.
        public var encryptionAlgorithmOptions: SignerClientTypes.EncryptionAlgorithmOptions?
        /// The hash algorithm options that are available for a code-signing job.
        /// This member is required.
        public var hashAlgorithmOptions: SignerClientTypes.HashAlgorithmOptions?

        public init(
            encryptionAlgorithmOptions: SignerClientTypes.EncryptionAlgorithmOptions? = nil,
            hashAlgorithmOptions: SignerClientTypes.HashAlgorithmOptions? = nil
        )
        {
            self.encryptionAlgorithmOptions = encryptionAlgorithmOptions
            self.hashAlgorithmOptions = hashAlgorithmOptions
        }
    }
}

extension SignerClientTypes {

    /// The image format of a AWS Signer platform or profile.
    public struct SigningImageFormat: Swift.Sendable {
        /// The default format of a signing image.
        /// This member is required.
        public var defaultFormat: SignerClientTypes.ImageFormat?
        /// The supported formats of a signing image.
        /// This member is required.
        public var supportedFormats: [SignerClientTypes.ImageFormat]?

        public init(
            defaultFormat: SignerClientTypes.ImageFormat? = nil,
            supportedFormats: [SignerClientTypes.ImageFormat]? = nil
        )
        {
            self.defaultFormat = defaultFormat
            self.supportedFormats = supportedFormats
        }
    }
}

public struct GetSigningPlatformOutput: Swift.Sendable {
    /// The category type of the target signing platform.
    public var category: SignerClientTypes.Category?
    /// The display name of the target signing platform.
    public var displayName: Swift.String?
    /// The maximum size (in MB) of the payload that can be signed by the target platform.
    public var maxSizeInMB: Swift.Int
    /// A list of partner entities that use the target signing platform.
    public var partner: Swift.String?
    /// The ID of the target signing platform.
    public var platformId: Swift.String?
    /// A flag indicating whether signatures generated for the signing platform can be revoked.
    public var revocationSupported: Swift.Bool
    /// A list of configurations applied to the target platform at signing.
    public var signingConfiguration: SignerClientTypes.SigningConfiguration?
    /// The format of the target platform's signing image.
    public var signingImageFormat: SignerClientTypes.SigningImageFormat?
    /// The validation template that is used by the target signing platform.
    public var target: Swift.String?

    public init(
        category: SignerClientTypes.Category? = nil,
        displayName: Swift.String? = nil,
        maxSizeInMB: Swift.Int = 0,
        partner: Swift.String? = nil,
        platformId: Swift.String? = nil,
        revocationSupported: Swift.Bool = false,
        signingConfiguration: SignerClientTypes.SigningConfiguration? = nil,
        signingImageFormat: SignerClientTypes.SigningImageFormat? = nil,
        target: Swift.String? = nil
    )
    {
        self.category = category
        self.displayName = displayName
        self.maxSizeInMB = maxSizeInMB
        self.partner = partner
        self.platformId = platformId
        self.revocationSupported = revocationSupported
        self.signingConfiguration = signingConfiguration
        self.signingImageFormat = signingImageFormat
        self.target = target
    }
}

public struct GetSigningProfileInput: Swift.Sendable {
    /// The name of the target signing profile.
    /// This member is required.
    public var profileName: Swift.String?
    /// The AWS account ID of the profile owner.
    public var profileOwner: Swift.String?

    public init(
        profileName: Swift.String? = nil,
        profileOwner: Swift.String? = nil
    )
    {
        self.profileName = profileName
        self.profileOwner = profileOwner
    }
}

extension SignerClientTypes {

    /// Revocation information for a signing profile.
    public struct SigningProfileRevocationRecord: Swift.Sendable {
        /// The time when revocation becomes effective.
        public var revocationEffectiveFrom: Foundation.Date?
        /// The time when the signing profile was revoked.
        public var revokedAt: Foundation.Date?
        /// The identity of the revoker.
        public var revokedBy: Swift.String?

        public init(
            revocationEffectiveFrom: Foundation.Date? = nil,
            revokedAt: Foundation.Date? = nil,
            revokedBy: Swift.String? = nil
        )
        {
            self.revocationEffectiveFrom = revocationEffectiveFrom
            self.revokedAt = revokedAt
            self.revokedBy = revokedBy
        }
    }
}

extension SignerClientTypes {

    public enum ValidityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case days
        case months
        case years
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidityType] {
            return [
                .days,
                .months,
                .years
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .days: return "DAYS"
            case .months: return "MONTHS"
            case .years: return "YEARS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SignerClientTypes {

    /// The validity period for a signing job.
    public struct SignatureValidityPeriod: Swift.Sendable {
        /// The time unit for signature validity.
        public var type: SignerClientTypes.ValidityType?
        /// The numerical value of the time unit for signature validity.
        public var value: Swift.Int

        public init(
            type: SignerClientTypes.ValidityType? = nil,
            value: Swift.Int = 0
        )
        {
            self.type = type
            self.value = value
        }
    }
}

extension SignerClientTypes {

    public enum SigningProfileStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case canceled
        case revoked
        case sdkUnknown(Swift.String)

        public static var allCases: [SigningProfileStatus] {
            return [
                .active,
                .canceled,
                .revoked
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .canceled: return "Canceled"
            case .revoked: return "Revoked"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSigningProfileOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the signing profile.
    public var arn: Swift.String?
    /// A list of overrides applied by the target signing profile for signing operations.
    public var overrides: SignerClientTypes.SigningPlatformOverrides?
    /// A human-readable name for the signing platform associated with the signing profile.
    public var platformDisplayName: Swift.String?
    /// The ID of the platform that is used by the target signing profile.
    public var platformId: Swift.String?
    /// The name of the target signing profile.
    public var profileName: Swift.String?
    /// The current version of the signing profile.
    public var profileVersion: Swift.String?
    /// The signing profile ARN, including the profile version.
    public var profileVersionArn: Swift.String?
    /// Revocation information for a signing profile.
    public var revocationRecord: SignerClientTypes.SigningProfileRevocationRecord?
    /// The validity period for a signing job.
    public var signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod?
    /// The ARN of the certificate that the target profile uses for signing operations.
    public var signingMaterial: SignerClientTypes.SigningMaterial?
    /// A map of key-value pairs for signing operations that is attached to the target signing profile.
    public var signingParameters: [Swift.String: Swift.String]?
    /// The status of the target signing profile.
    public var status: SignerClientTypes.SigningProfileStatus?
    /// Reason for the status of the target signing profile.
    public var statusReason: Swift.String?
    /// A list of tags associated with the signing profile.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        overrides: SignerClientTypes.SigningPlatformOverrides? = nil,
        platformDisplayName: Swift.String? = nil,
        platformId: Swift.String? = nil,
        profileName: Swift.String? = nil,
        profileVersion: Swift.String? = nil,
        profileVersionArn: Swift.String? = nil,
        revocationRecord: SignerClientTypes.SigningProfileRevocationRecord? = nil,
        signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod? = nil,
        signingMaterial: SignerClientTypes.SigningMaterial? = nil,
        signingParameters: [Swift.String: Swift.String]? = nil,
        status: SignerClientTypes.SigningProfileStatus? = nil,
        statusReason: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.overrides = overrides
        self.platformDisplayName = platformDisplayName
        self.platformId = platformId
        self.profileName = profileName
        self.profileVersion = profileVersion
        self.profileVersionArn = profileVersionArn
        self.revocationRecord = revocationRecord
        self.signatureValidityPeriod = signatureValidityPeriod
        self.signingMaterial = signingMaterial
        self.signingParameters = signingParameters
        self.status = status
        self.statusReason = statusReason
        self.tags = tags
    }
}

public struct ListProfilePermissionsInput: Swift.Sendable {
    /// String for specifying the next set of paginated results.
    public var nextToken: Swift.String?
    /// Name of the signing profile containing the cross-account permissions.
    /// This member is required.
    public var profileName: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        profileName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.profileName = profileName
    }
}

extension SignerClientTypes {

    /// A cross-account permission for a signing profile.
    public struct Permission: Swift.Sendable {
        /// An AWS Signer action permitted as part of cross-account permissions.
        public var action: Swift.String?
        /// The AWS principal that has been granted a cross-account permission.
        public var principal: Swift.String?
        /// The signing profile version that a permission applies to.
        public var profileVersion: Swift.String?
        /// A unique identifier for a cross-account permission statement.
        public var statementId: Swift.String?

        public init(
            action: Swift.String? = nil,
            principal: Swift.String? = nil,
            profileVersion: Swift.String? = nil,
            statementId: Swift.String? = nil
        )
        {
            self.action = action
            self.principal = principal
            self.profileVersion = profileVersion
            self.statementId = statementId
        }
    }
}

public struct ListProfilePermissionsOutput: Swift.Sendable {
    /// String for specifying the next set of paginated results.
    public var nextToken: Swift.String?
    /// List of permissions associated with the Signing Profile.
    public var permissions: [SignerClientTypes.Permission]?
    /// Total size of the policy associated with the Signing Profile in bytes.
    public var policySizeBytes: Swift.Int
    /// The identifier for the current revision of profile permissions.
    public var revisionId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        permissions: [SignerClientTypes.Permission]? = nil,
        policySizeBytes: Swift.Int = 0,
        revisionId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
        self.policySizeBytes = policySizeBytes
        self.revisionId = revisionId
    }
}

public struct ListSigningJobsInput: Swift.Sendable {
    /// Filters results to return only signing jobs with revoked signatures.
    public var isRevoked: Swift.Bool?
    /// Filters results to return only signing jobs initiated by a specified IAM entity.
    public var jobInvoker: Swift.String?
    /// Specifies the maximum number of items to return in the response. Use this parameter when paginating results. If additional items exist beyond the number you specify, the nextToken element is set in the response. Use the nextToken value in a subsequent request to retrieve additional items.
    public var maxResults: Swift.Int?
    /// String for specifying the next set of paginated results to return. After you receive a response with truncated results, use this parameter in a subsequent request. Set it to the value of nextToken from the response that you just received.
    public var nextToken: Swift.String?
    /// The ID of microcontroller platform that you specified for the distribution of your code image.
    public var platformId: Swift.String?
    /// The IAM principal that requested the signing job.
    public var requestedBy: Swift.String?
    /// Filters results to return only signing jobs with signatures expiring after a specified timestamp.
    public var signatureExpiresAfter: Foundation.Date?
    /// Filters results to return only signing jobs with signatures expiring before a specified timestamp.
    public var signatureExpiresBefore: Foundation.Date?
    /// A status value with which to filter your results.
    public var status: SignerClientTypes.SigningStatus?

    public init(
        isRevoked: Swift.Bool? = false,
        jobInvoker: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        platformId: Swift.String? = nil,
        requestedBy: Swift.String? = nil,
        signatureExpiresAfter: Foundation.Date? = nil,
        signatureExpiresBefore: Foundation.Date? = nil,
        status: SignerClientTypes.SigningStatus? = nil
    )
    {
        self.isRevoked = isRevoked
        self.jobInvoker = jobInvoker
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.platformId = platformId
        self.requestedBy = requestedBy
        self.signatureExpiresAfter = signatureExpiresAfter
        self.signatureExpiresBefore = signatureExpiresBefore
        self.status = status
    }
}

extension SignerClientTypes {

    /// Contains information about a signing job.
    public struct SigningJob: Swift.Sendable {
        /// The date and time that the signing job was created.
        public var createdAt: Foundation.Date?
        /// Indicates whether the signing job is revoked.
        public var isRevoked: Swift.Bool
        /// The ID of the signing job.
        public var jobId: Swift.String?
        /// The AWS account ID of the job invoker.
        public var jobInvoker: Swift.String?
        /// The AWS account ID of the job owner.
        public var jobOwner: Swift.String?
        /// The name of a signing platform.
        public var platformDisplayName: Swift.String?
        /// The unique identifier for a signing platform.
        public var platformId: Swift.String?
        /// The name of the signing profile that created a signing job.
        public var profileName: Swift.String?
        /// The version of the signing profile that created a signing job.
        public var profileVersion: Swift.String?
        /// The time when the signature of a signing job expires.
        public var signatureExpiresAt: Foundation.Date?
        /// A SignedObject structure that contains information about a signing job's signed code image.
        public var signedObject: SignerClientTypes.SignedObject?
        /// A SigningMaterial object that contains the Amazon Resource Name (ARN) of the certificate used for the signing job.
        public var signingMaterial: SignerClientTypes.SigningMaterial?
        /// A Source that contains information about a signing job's code image source.
        public var source: SignerClientTypes.Source?
        /// The status of the signing job.
        public var status: SignerClientTypes.SigningStatus?

        public init(
            createdAt: Foundation.Date? = nil,
            isRevoked: Swift.Bool = false,
            jobId: Swift.String? = nil,
            jobInvoker: Swift.String? = nil,
            jobOwner: Swift.String? = nil,
            platformDisplayName: Swift.String? = nil,
            platformId: Swift.String? = nil,
            profileName: Swift.String? = nil,
            profileVersion: Swift.String? = nil,
            signatureExpiresAt: Foundation.Date? = nil,
            signedObject: SignerClientTypes.SignedObject? = nil,
            signingMaterial: SignerClientTypes.SigningMaterial? = nil,
            source: SignerClientTypes.Source? = nil,
            status: SignerClientTypes.SigningStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.isRevoked = isRevoked
            self.jobId = jobId
            self.jobInvoker = jobInvoker
            self.jobOwner = jobOwner
            self.platformDisplayName = platformDisplayName
            self.platformId = platformId
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.signatureExpiresAt = signatureExpiresAt
            self.signedObject = signedObject
            self.signingMaterial = signingMaterial
            self.source = source
            self.status = status
        }
    }
}

public struct ListSigningJobsOutput: Swift.Sendable {
    /// A list of your signing jobs.
    public var jobs: [SignerClientTypes.SigningJob]?
    /// String for specifying the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        jobs: [SignerClientTypes.SigningJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

public struct ListSigningPlatformsInput: Swift.Sendable {
    /// The category type of a signing platform.
    public var category: Swift.String?
    /// The maximum number of results to be returned by this operation.
    public var maxResults: Swift.Int?
    /// Value for specifying the next set of paginated results to return. After you receive a response with truncated results, use this parameter in a subsequent request. Set it to the value of nextToken from the response that you just received.
    public var nextToken: Swift.String?
    /// Any partner entities connected to a signing platform.
    public var partner: Swift.String?
    /// The validation template that is used by the target signing platform.
    public var target: Swift.String?

    public init(
        category: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        partner: Swift.String? = nil,
        target: Swift.String? = nil
    )
    {
        self.category = category
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.partner = partner
        self.target = target
    }
}

extension SignerClientTypes {

    /// Contains information about the signing configurations and parameters that are used to perform a code-signing job.
    public struct SigningPlatform: Swift.Sendable {
        /// The category of a signing platform.
        public var category: SignerClientTypes.Category?
        /// The display name of a signing platform.
        public var displayName: Swift.String?
        /// The maximum size (in MB) of code that can be signed by a signing platform.
        public var maxSizeInMB: Swift.Int
        /// Any partner entities linked to a signing platform.
        public var partner: Swift.String?
        /// The ID of a signing platform.
        public var platformId: Swift.String?
        /// Indicates whether revocation is supported for the platform.
        public var revocationSupported: Swift.Bool
        /// The configuration of a signing platform. This includes the designated hash algorithm and encryption algorithm of a signing platform.
        public var signingConfiguration: SignerClientTypes.SigningConfiguration?
        /// The image format of a AWS Signer platform or profile.
        public var signingImageFormat: SignerClientTypes.SigningImageFormat?
        /// The types of targets that can be signed by a signing platform.
        public var target: Swift.String?

        public init(
            category: SignerClientTypes.Category? = nil,
            displayName: Swift.String? = nil,
            maxSizeInMB: Swift.Int = 0,
            partner: Swift.String? = nil,
            platformId: Swift.String? = nil,
            revocationSupported: Swift.Bool = false,
            signingConfiguration: SignerClientTypes.SigningConfiguration? = nil,
            signingImageFormat: SignerClientTypes.SigningImageFormat? = nil,
            target: Swift.String? = nil
        )
        {
            self.category = category
            self.displayName = displayName
            self.maxSizeInMB = maxSizeInMB
            self.partner = partner
            self.platformId = platformId
            self.revocationSupported = revocationSupported
            self.signingConfiguration = signingConfiguration
            self.signingImageFormat = signingImageFormat
            self.target = target
        }
    }
}

public struct ListSigningPlatformsOutput: Swift.Sendable {
    /// Value for specifying the next set of paginated results to return.
    public var nextToken: Swift.String?
    /// A list of all platforms that match the request parameters.
    public var platforms: [SignerClientTypes.SigningPlatform]?

    public init(
        nextToken: Swift.String? = nil,
        platforms: [SignerClientTypes.SigningPlatform]? = nil
    )
    {
        self.nextToken = nextToken
        self.platforms = platforms
    }
}

public struct ListSigningProfilesInput: Swift.Sendable {
    /// Designates whether to include profiles with the status of CANCELED.
    public var includeCanceled: Swift.Bool?
    /// The maximum number of profiles to be returned.
    public var maxResults: Swift.Int?
    /// Value for specifying the next set of paginated results to return. After you receive a response with truncated results, use this parameter in a subsequent request. Set it to the value of nextToken from the response that you just received.
    public var nextToken: Swift.String?
    /// Filters results to return only signing jobs initiated for a specified signing platform.
    public var platformId: Swift.String?
    /// Filters results to return only signing jobs with statuses in the specified list.
    public var statuses: [SignerClientTypes.SigningProfileStatus]?

    public init(
        includeCanceled: Swift.Bool? = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        platformId: Swift.String? = nil,
        statuses: [SignerClientTypes.SigningProfileStatus]? = nil
    )
    {
        self.includeCanceled = includeCanceled
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.platformId = platformId
        self.statuses = statuses
    }
}

extension SignerClientTypes {

    /// Contains information about the ACM certificates and signing configuration parameters that can be used by a given code signing user.
    public struct SigningProfile: Swift.Sendable {
        /// The Amazon Resource Name (ARN) for the signing profile.
        public var arn: Swift.String?
        /// The name of the signing platform.
        public var platformDisplayName: Swift.String?
        /// The ID of a platform that is available for use by a signing profile.
        public var platformId: Swift.String?
        /// The name of the signing profile.
        public var profileName: Swift.String?
        /// The version of a signing profile.
        public var profileVersion: Swift.String?
        /// The ARN of a signing profile, including the profile version.
        public var profileVersionArn: Swift.String?
        /// The validity period for a signing job created using this signing profile.
        public var signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod?
        /// The ACM certificate that is available for use by a signing profile.
        public var signingMaterial: SignerClientTypes.SigningMaterial?
        /// The parameters that are available for use by a Signer user.
        public var signingParameters: [Swift.String: Swift.String]?
        /// The status of a signing profile.
        public var status: SignerClientTypes.SigningProfileStatus?
        /// A list of tags associated with the signing profile.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            platformDisplayName: Swift.String? = nil,
            platformId: Swift.String? = nil,
            profileName: Swift.String? = nil,
            profileVersion: Swift.String? = nil,
            profileVersionArn: Swift.String? = nil,
            signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod? = nil,
            signingMaterial: SignerClientTypes.SigningMaterial? = nil,
            signingParameters: [Swift.String: Swift.String]? = nil,
            status: SignerClientTypes.SigningProfileStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.platformDisplayName = platformDisplayName
            self.platformId = platformId
            self.profileName = profileName
            self.profileVersion = profileVersion
            self.profileVersionArn = profileVersionArn
            self.signatureValidityPeriod = signatureValidityPeriod
            self.signingMaterial = signingMaterial
            self.signingParameters = signingParameters
            self.status = status
            self.tags = tags
        }
    }
}

public struct ListSigningProfilesOutput: Swift.Sendable {
    /// Value for specifying the next set of paginated results to return.
    public var nextToken: Swift.String?
    /// A list of profiles that are available in the AWS account. This includes profiles with the status of CANCELED if the includeCanceled parameter is set to true.
    public var profiles: [SignerClientTypes.SigningProfile]?

    public init(
        nextToken: Swift.String? = nil,
        profiles: [SignerClientTypes.SigningProfile]? = nil
    )
    {
        self.nextToken = nextToken
        self.profiles = profiles
    }
}

/// The signing profile was not found.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the signing profile.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A list of tags associated with the signing profile.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct PutSigningProfileInput: Swift.Sendable {
    /// A subfield of platform. This specifies any different configuration options that you want to apply to the chosen platform (such as a different hash-algorithm or signing-algorithm).
    public var overrides: SignerClientTypes.SigningPlatformOverrides?
    /// The ID of the signing platform to be created.
    /// This member is required.
    public var platformId: Swift.String?
    /// The name of the signing profile to be created.
    /// This member is required.
    public var profileName: Swift.String?
    /// The default validity period override for any signature generated using this signing profile. If unspecified, the default is 135 months.
    public var signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod?
    /// The AWS Certificate Manager certificate that will be used to sign code with the new signing profile.
    public var signingMaterial: SignerClientTypes.SigningMaterial?
    /// Map of key-value pairs for signing. These can include any information that you want to use during signing.
    public var signingParameters: [Swift.String: Swift.String]?
    /// Tags to be associated with the signing profile that is being created.
    public var tags: [Swift.String: Swift.String]?

    public init(
        overrides: SignerClientTypes.SigningPlatformOverrides? = nil,
        platformId: Swift.String? = nil,
        profileName: Swift.String? = nil,
        signatureValidityPeriod: SignerClientTypes.SignatureValidityPeriod? = nil,
        signingMaterial: SignerClientTypes.SigningMaterial? = nil,
        signingParameters: [Swift.String: Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.overrides = overrides
        self.platformId = platformId
        self.profileName = profileName
        self.signatureValidityPeriod = signatureValidityPeriod
        self.signingMaterial = signingMaterial
        self.signingParameters = signingParameters
        self.tags = tags
    }
}

public struct PutSigningProfileOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the signing profile created.
    public var arn: Swift.String?
    /// The version of the signing profile being created.
    public var profileVersion: Swift.String?
    /// The signing profile ARN, including the profile version.
    public var profileVersionArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        profileVersion: Swift.String? = nil,
        profileVersionArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.profileVersion = profileVersion
        self.profileVersionArn = profileVersionArn
    }
}

public struct RemoveProfilePermissionInput: Swift.Sendable {
    /// A human-readable name for the signing profile with permissions to be removed.
    /// This member is required.
    public var profileName: Swift.String?
    /// An identifier for the current revision of the signing profile permissions.
    /// This member is required.
    public var revisionId: Swift.String?
    /// A unique identifier for the cross-account permissions statement.
    /// This member is required.
    public var statementId: Swift.String?

    public init(
        profileName: Swift.String? = nil,
        revisionId: Swift.String? = nil,
        statementId: Swift.String? = nil
    )
    {
        self.profileName = profileName
        self.revisionId = revisionId
        self.statementId = statementId
    }
}

public struct RemoveProfilePermissionOutput: Swift.Sendable {
    /// An identifier for the current revision of the profile permissions.
    public var revisionId: Swift.String?

    public init(
        revisionId: Swift.String? = nil
    )
    {
        self.revisionId = revisionId
    }
}

public struct RevokeSignatureInput: Swift.Sendable {
    /// ID of the signing job to be revoked.
    /// This member is required.
    public var jobId: Swift.String?
    /// AWS account ID of the job owner.
    public var jobOwner: Swift.String?
    /// The reason for revoking the signing job.
    /// This member is required.
    public var reason: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        jobOwner: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.jobOwner = jobOwner
        self.reason = reason
    }
}

public struct RevokeSigningProfileInput: Swift.Sendable {
    /// A timestamp for when revocation of a Signing Profile should become effective. Signatures generated using the signing profile after this timestamp are not trusted.
    /// This member is required.
    public var effectiveTime: Foundation.Date?
    /// The name of the signing profile to be revoked.
    /// This member is required.
    public var profileName: Swift.String?
    /// The version of the signing profile to be revoked.
    /// This member is required.
    public var profileVersion: Swift.String?
    /// The reason for revoking a signing profile.
    /// This member is required.
    public var reason: Swift.String?

    public init(
        effectiveTime: Foundation.Date? = nil,
        profileName: Swift.String? = nil,
        profileVersion: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.effectiveTime = effectiveTime
        self.profileName = profileName
        self.profileVersion = profileVersion
        self.reason = reason
    }
}

public struct SignPayloadInput: Swift.Sendable {
    /// Specifies the object digest (hash) to sign.
    /// This member is required.
    public var payload: Foundation.Data?
    /// Payload content type. The single valid type is application/vnd.cncf.notary.payload.v1+json.
    /// This member is required.
    public var payloadFormat: Swift.String?
    /// The name of the signing profile.
    /// This member is required.
    public var profileName: Swift.String?
    /// The AWS account ID of the profile owner.
    public var profileOwner: Swift.String?

    public init(
        payload: Foundation.Data? = nil,
        payloadFormat: Swift.String? = nil,
        profileName: Swift.String? = nil,
        profileOwner: Swift.String? = nil
    )
    {
        self.payload = payload
        self.payloadFormat = payloadFormat
        self.profileName = profileName
        self.profileOwner = profileOwner
    }
}

public struct SignPayloadOutput: Swift.Sendable {
    /// Unique identifier of the signing job.
    public var jobId: Swift.String?
    /// The AWS account ID of the job owner.
    public var jobOwner: Swift.String?
    /// Information including the signing profile ARN and the signing job ID.
    public var metadata: [Swift.String: Swift.String]?
    /// A cryptographic signature.
    public var signature: Foundation.Data?

    public init(
        jobId: Swift.String? = nil,
        jobOwner: Swift.String? = nil,
        metadata: [Swift.String: Swift.String]? = nil,
        signature: Foundation.Data? = nil
    )
    {
        self.jobId = jobId
        self.jobOwner = jobOwner
        self.metadata = metadata
        self.signature = signature
    }
}

/// The request was denied due to request throttling. Instead of this error, TooManyRequestsException should be used.
@available(*, deprecated, message: "Instead of this error, TooManyRequestsException should be used.")
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct StartSigningJobInput: Swift.Sendable {
    /// String that identifies the signing request. All calls after the first that use this token return the same response as the first call.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The S3 bucket in which to save your signed object. The destination contains the name of your bucket and an optional prefix.
    /// This member is required.
    public var destination: SignerClientTypes.Destination?
    /// The name of the signing profile.
    /// This member is required.
    public var profileName: Swift.String?
    /// The AWS account ID of the signing profile owner.
    public var profileOwner: Swift.String?
    /// The S3 bucket that contains the object to sign or a BLOB that contains your raw code.
    /// This member is required.
    public var source: SignerClientTypes.Source?

    public init(
        clientRequestToken: Swift.String? = nil,
        destination: SignerClientTypes.Destination? = nil,
        profileName: Swift.String? = nil,
        profileOwner: Swift.String? = nil,
        source: SignerClientTypes.Source? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.destination = destination
        self.profileName = profileName
        self.profileOwner = profileOwner
        self.source = source
    }
}

public struct StartSigningJobOutput: Swift.Sendable {
    /// The ID of your signing job.
    public var jobId: Swift.String?
    /// The AWS account ID of the signing job owner.
    public var jobOwner: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        jobOwner: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.jobOwner = jobOwner
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the signing profile.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags to be associated with the signing profile.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the signing profile.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag keys to be removed from the signing profile.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension AddProfilePermissionInput {

    static func urlPathProvider(_ value: AddProfilePermissionInput) -> Swift.String? {
        guard let profileName = value.profileName else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())/permissions"
    }
}

extension CancelSigningProfileInput {

    static func urlPathProvider(_ value: CancelSigningProfileInput) -> Swift.String? {
        guard let profileName = value.profileName else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())"
    }
}

extension DescribeSigningJobInput {

    static func urlPathProvider(_ value: DescribeSigningJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/signing-jobs/\(jobId.urlPercentEncoding())"
    }
}

extension GetRevocationStatusInput {

    static func urlPathProvider(_ value: GetRevocationStatusInput) -> Swift.String? {
        return "/revocations"
    }
}

extension GetRevocationStatusInput {

    static func queryItemProvider(_ value: GetRevocationStatusInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let certificateHashes = value.certificateHashes else {
            let message = "Creating a URL Query Item failed. certificateHashes is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        certificateHashes.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "certificateHashes".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        guard let profileVersionArn = value.profileVersionArn else {
            let message = "Creating a URL Query Item failed. profileVersionArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let profileVersionArnQueryItem = Smithy.URIQueryItem(name: "profileVersionArn".urlPercentEncoding(), value: Swift.String(profileVersionArn).urlPercentEncoding())
        items.append(profileVersionArnQueryItem)
        guard let platformId = value.platformId else {
            let message = "Creating a URL Query Item failed. platformId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let platformIdQueryItem = Smithy.URIQueryItem(name: "platformId".urlPercentEncoding(), value: Swift.String(platformId).urlPercentEncoding())
        items.append(platformIdQueryItem)
        guard let jobArn = value.jobArn else {
            let message = "Creating a URL Query Item failed. jobArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let jobArnQueryItem = Smithy.URIQueryItem(name: "jobArn".urlPercentEncoding(), value: Swift.String(jobArn).urlPercentEncoding())
        items.append(jobArnQueryItem)
        guard let signatureTimestamp = value.signatureTimestamp else {
            let message = "Creating a URL Query Item failed. signatureTimestamp is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let signatureTimestampQueryItem = Smithy.URIQueryItem(name: "signatureTimestamp".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: signatureTimestamp)).urlPercentEncoding())
        items.append(signatureTimestampQueryItem)
        return items
    }
}

extension GetSigningPlatformInput {

    static func urlPathProvider(_ value: GetSigningPlatformInput) -> Swift.String? {
        guard let platformId = value.platformId else {
            return nil
        }
        return "/signing-platforms/\(platformId.urlPercentEncoding())"
    }
}

extension GetSigningProfileInput {

    static func urlPathProvider(_ value: GetSigningProfileInput) -> Swift.String? {
        guard let profileName = value.profileName else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())"
    }
}

extension GetSigningProfileInput {

    static func queryItemProvider(_ value: GetSigningProfileInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let profileOwner = value.profileOwner {
            let profileOwnerQueryItem = Smithy.URIQueryItem(name: "profileOwner".urlPercentEncoding(), value: Swift.String(profileOwner).urlPercentEncoding())
            items.append(profileOwnerQueryItem)
        }
        return items
    }
}

extension ListProfilePermissionsInput {

    static func urlPathProvider(_ value: ListProfilePermissionsInput) -> Swift.String? {
        guard let profileName = value.profileName else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())/permissions"
    }
}

extension ListProfilePermissionsInput {

    static func queryItemProvider(_ value: ListProfilePermissionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListSigningJobsInput {

    static func urlPathProvider(_ value: ListSigningJobsInput) -> Swift.String? {
        return "/signing-jobs"
    }
}

extension ListSigningJobsInput {

    static func queryItemProvider(_ value: ListSigningJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let isRevoked = value.isRevoked {
            let isRevokedQueryItem = Smithy.URIQueryItem(name: "isRevoked".urlPercentEncoding(), value: Swift.String(isRevoked).urlPercentEncoding())
            items.append(isRevokedQueryItem)
        }
        if let requestedBy = value.requestedBy {
            let requestedByQueryItem = Smithy.URIQueryItem(name: "requestedBy".urlPercentEncoding(), value: Swift.String(requestedBy).urlPercentEncoding())
            items.append(requestedByQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let signatureExpiresBefore = value.signatureExpiresBefore {
            let signatureExpiresBeforeQueryItem = Smithy.URIQueryItem(name: "signatureExpiresBefore".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: signatureExpiresBefore)).urlPercentEncoding())
            items.append(signatureExpiresBeforeQueryItem)
        }
        if let jobInvoker = value.jobInvoker {
            let jobInvokerQueryItem = Smithy.URIQueryItem(name: "jobInvoker".urlPercentEncoding(), value: Swift.String(jobInvoker).urlPercentEncoding())
            items.append(jobInvokerQueryItem)
        }
        if let platformId = value.platformId {
            let platformIdQueryItem = Smithy.URIQueryItem(name: "platformId".urlPercentEncoding(), value: Swift.String(platformId).urlPercentEncoding())
            items.append(platformIdQueryItem)
        }
        if let signatureExpiresAfter = value.signatureExpiresAfter {
            let signatureExpiresAfterQueryItem = Smithy.URIQueryItem(name: "signatureExpiresAfter".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: signatureExpiresAfter)).urlPercentEncoding())
            items.append(signatureExpiresAfterQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListSigningPlatformsInput {

    static func urlPathProvider(_ value: ListSigningPlatformsInput) -> Swift.String? {
        return "/signing-platforms"
    }
}

extension ListSigningPlatformsInput {

    static func queryItemProvider(_ value: ListSigningPlatformsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let partner = value.partner {
            let partnerQueryItem = Smithy.URIQueryItem(name: "partner".urlPercentEncoding(), value: Swift.String(partner).urlPercentEncoding())
            items.append(partnerQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let category = value.category {
            let categoryQueryItem = Smithy.URIQueryItem(name: "category".urlPercentEncoding(), value: Swift.String(category).urlPercentEncoding())
            items.append(categoryQueryItem)
        }
        if let target = value.target {
            let targetQueryItem = Smithy.URIQueryItem(name: "target".urlPercentEncoding(), value: Swift.String(target).urlPercentEncoding())
            items.append(targetQueryItem)
        }
        return items
    }
}

extension ListSigningProfilesInput {

    static func urlPathProvider(_ value: ListSigningProfilesInput) -> Swift.String? {
        return "/signing-profiles"
    }
}

extension ListSigningProfilesInput {

    static func queryItemProvider(_ value: ListSigningProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let includeCanceled = value.includeCanceled {
            let includeCanceledQueryItem = Smithy.URIQueryItem(name: "includeCanceled".urlPercentEncoding(), value: Swift.String(includeCanceled).urlPercentEncoding())
            items.append(includeCanceledQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let statuses = value.statuses {
            statuses.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "statuses".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let platformId = value.platformId {
            let platformIdQueryItem = Smithy.URIQueryItem(name: "platformId".urlPercentEncoding(), value: Swift.String(platformId).urlPercentEncoding())
            items.append(platformIdQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension PutSigningProfileInput {

    static func urlPathProvider(_ value: PutSigningProfileInput) -> Swift.String? {
        guard let profileName = value.profileName else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())"
    }
}

extension RemoveProfilePermissionInput {

    static func urlPathProvider(_ value: RemoveProfilePermissionInput) -> Swift.String? {
        guard let profileName = value.profileName else {
            return nil
        }
        guard let statementId = value.statementId else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())/permissions/\(statementId.urlPercentEncoding())"
    }
}

extension RemoveProfilePermissionInput {

    static func queryItemProvider(_ value: RemoveProfilePermissionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let revisionId = value.revisionId else {
            let message = "Creating a URL Query Item failed. revisionId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let revisionIdQueryItem = Smithy.URIQueryItem(name: "revisionId".urlPercentEncoding(), value: Swift.String(revisionId).urlPercentEncoding())
        items.append(revisionIdQueryItem)
        return items
    }
}

extension RevokeSignatureInput {

    static func urlPathProvider(_ value: RevokeSignatureInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/signing-jobs/\(jobId.urlPercentEncoding())/revoke"
    }
}

extension RevokeSigningProfileInput {

    static func urlPathProvider(_ value: RevokeSigningProfileInput) -> Swift.String? {
        guard let profileName = value.profileName else {
            return nil
        }
        return "/signing-profiles/\(profileName.urlPercentEncoding())/revoke"
    }
}

extension SignPayloadInput {

    static func urlPathProvider(_ value: SignPayloadInput) -> Swift.String? {
        return "/signing-jobs/with-payload"
    }
}

extension StartSigningJobInput {

    static func urlPathProvider(_ value: StartSigningJobInput) -> Swift.String? {
        return "/signing-jobs"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension AddProfilePermissionInput {

    static func write(value: AddProfilePermissionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["principal"].write(value.principal)
        try writer["profileVersion"].write(value.profileVersion)
        try writer["revisionId"].write(value.revisionId)
        try writer["statementId"].write(value.statementId)
    }
}

extension PutSigningProfileInput {

    static func write(value: PutSigningProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["overrides"].write(value.overrides, with: SignerClientTypes.SigningPlatformOverrides.write(value:to:))
        try writer["platformId"].write(value.platformId)
        try writer["signatureValidityPeriod"].write(value.signatureValidityPeriod, with: SignerClientTypes.SignatureValidityPeriod.write(value:to:))
        try writer["signingMaterial"].write(value.signingMaterial, with: SignerClientTypes.SigningMaterial.write(value:to:))
        try writer["signingParameters"].writeMap(value.signingParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension RevokeSignatureInput {

    static func write(value: RevokeSignatureInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jobOwner"].write(value.jobOwner)
        try writer["reason"].write(value.reason)
    }
}

extension RevokeSigningProfileInput {

    static func write(value: RevokeSigningProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["effectiveTime"].writeTimestamp(value.effectiveTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["profileVersion"].write(value.profileVersion)
        try writer["reason"].write(value.reason)
    }
}

extension SignPayloadInput {

    static func write(value: SignPayloadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["payload"].write(value.payload)
        try writer["payloadFormat"].write(value.payloadFormat)
        try writer["profileName"].write(value.profileName)
        try writer["profileOwner"].write(value.profileOwner)
    }
}

extension StartSigningJobInput {

    static func write(value: StartSigningJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientRequestToken"].write(value.clientRequestToken)
        try writer["destination"].write(value.destination, with: SignerClientTypes.Destination.write(value:to:))
        try writer["profileName"].write(value.profileName)
        try writer["profileOwner"].write(value.profileOwner)
        try writer["source"].write(value.source, with: SignerClientTypes.Source.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension AddProfilePermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddProfilePermissionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddProfilePermissionOutput()
        value.revisionId = try reader["revisionId"].readIfPresent()
        return value
    }
}

extension CancelSigningProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelSigningProfileOutput {
        return CancelSigningProfileOutput()
    }
}

extension DescribeSigningJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSigningJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSigningJobOutput()
        value.completedAt = try reader["completedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.jobId = try reader["jobId"].readIfPresent()
        value.jobInvoker = try reader["jobInvoker"].readIfPresent()
        value.jobOwner = try reader["jobOwner"].readIfPresent()
        value.overrides = try reader["overrides"].readIfPresent(with: SignerClientTypes.SigningPlatformOverrides.read(from:))
        value.platformDisplayName = try reader["platformDisplayName"].readIfPresent()
        value.platformId = try reader["platformId"].readIfPresent()
        value.profileName = try reader["profileName"].readIfPresent()
        value.profileVersion = try reader["profileVersion"].readIfPresent()
        value.requestedBy = try reader["requestedBy"].readIfPresent()
        value.revocationRecord = try reader["revocationRecord"].readIfPresent(with: SignerClientTypes.SigningJobRevocationRecord.read(from:))
        value.signatureExpiresAt = try reader["signatureExpiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.signedObject = try reader["signedObject"].readIfPresent(with: SignerClientTypes.SignedObject.read(from:))
        value.signingMaterial = try reader["signingMaterial"].readIfPresent(with: SignerClientTypes.SigningMaterial.read(from:))
        value.signingParameters = try reader["signingParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.source = try reader["source"].readIfPresent(with: SignerClientTypes.Source.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        return value
    }
}

extension GetRevocationStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRevocationStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRevocationStatusOutput()
        value.revokedEntities = try reader["revokedEntities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetSigningPlatformOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSigningPlatformOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSigningPlatformOutput()
        value.category = try reader["category"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.maxSizeInMB = try reader["maxSizeInMB"].readIfPresent() ?? 0
        value.partner = try reader["partner"].readIfPresent()
        value.platformId = try reader["platformId"].readIfPresent()
        value.revocationSupported = try reader["revocationSupported"].readIfPresent() ?? false
        value.signingConfiguration = try reader["signingConfiguration"].readIfPresent(with: SignerClientTypes.SigningConfiguration.read(from:))
        value.signingImageFormat = try reader["signingImageFormat"].readIfPresent(with: SignerClientTypes.SigningImageFormat.read(from:))
        value.target = try reader["target"].readIfPresent()
        return value
    }
}

extension GetSigningProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSigningProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSigningProfileOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.overrides = try reader["overrides"].readIfPresent(with: SignerClientTypes.SigningPlatformOverrides.read(from:))
        value.platformDisplayName = try reader["platformDisplayName"].readIfPresent()
        value.platformId = try reader["platformId"].readIfPresent()
        value.profileName = try reader["profileName"].readIfPresent()
        value.profileVersion = try reader["profileVersion"].readIfPresent()
        value.profileVersionArn = try reader["profileVersionArn"].readIfPresent()
        value.revocationRecord = try reader["revocationRecord"].readIfPresent(with: SignerClientTypes.SigningProfileRevocationRecord.read(from:))
        value.signatureValidityPeriod = try reader["signatureValidityPeriod"].readIfPresent(with: SignerClientTypes.SignatureValidityPeriod.read(from:))
        value.signingMaterial = try reader["signingMaterial"].readIfPresent(with: SignerClientTypes.SigningMaterial.read(from:))
        value.signingParameters = try reader["signingParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.statusReason = try reader["statusReason"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListProfilePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProfilePermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProfilePermissionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.permissions = try reader["permissions"].readListIfPresent(memberReadingClosure: SignerClientTypes.Permission.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.policySizeBytes = try reader["policySizeBytes"].readIfPresent() ?? 0
        value.revisionId = try reader["revisionId"].readIfPresent()
        return value
    }
}

extension ListSigningJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSigningJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSigningJobsOutput()
        value.jobs = try reader["jobs"].readListIfPresent(memberReadingClosure: SignerClientTypes.SigningJob.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListSigningPlatformsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSigningPlatformsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSigningPlatformsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.platforms = try reader["platforms"].readListIfPresent(memberReadingClosure: SignerClientTypes.SigningPlatform.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSigningProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSigningProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSigningProfilesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.profiles = try reader["profiles"].readListIfPresent(memberReadingClosure: SignerClientTypes.SigningProfile.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PutSigningProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutSigningProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutSigningProfileOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.profileVersion = try reader["profileVersion"].readIfPresent()
        value.profileVersionArn = try reader["profileVersionArn"].readIfPresent()
        return value
    }
}

extension RemoveProfilePermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveProfilePermissionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RemoveProfilePermissionOutput()
        value.revisionId = try reader["revisionId"].readIfPresent()
        return value
    }
}

extension RevokeSignatureOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RevokeSignatureOutput {
        return RevokeSignatureOutput()
    }
}

extension RevokeSigningProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RevokeSigningProfileOutput {
        return RevokeSigningProfileOutput()
    }
}

extension SignPayloadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SignPayloadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SignPayloadOutput()
        value.jobId = try reader["jobId"].readIfPresent()
        value.jobOwner = try reader["jobOwner"].readIfPresent()
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.signature = try reader["signature"].readIfPresent()
        return value
    }
}

extension StartSigningJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartSigningJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartSigningJobOutput()
        value.jobId = try reader["jobId"].readIfPresent()
        value.jobOwner = try reader["jobOwner"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum AddProfilePermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceLimitExceededException": return try ServiceLimitExceededException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelSigningProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSigningJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRevocationStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSigningPlatformOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSigningProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProfilePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSigningJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSigningPlatformsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSigningProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutSigningProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveProfilePermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RevokeSignatureOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RevokeSigningProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SignPayloadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartSigningJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServiceErrorException": return try InternalServiceErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceLimitExceededException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServiceErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServiceErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServiceErrorException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SignerClientTypes.Source {

    static func write(value: SignerClientTypes.Source?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3"].write(value.s3, with: SignerClientTypes.S3Source.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SignerClientTypes.Source {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SignerClientTypes.Source()
        value.s3 = try reader["s3"].readIfPresent(with: SignerClientTypes.S3Source.read(from:))
        return value
    }
}

extension SignerClientTypes.S3Source {

    static func write(value: SignerClientTypes.S3Source?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["key"].write(value.key)
        try writer["version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SignerClientTypes.S3Source {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SignerClientTypes.S3Source()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        value.key = try reader["key"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension SignerClientTypes.SigningMaterial {

    static func write(value: SignerClientTypes.SigningMaterial?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateArn"].write(value.certificateArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SignerClientTypes.SigningMaterial {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SignerClientTypes.SigningMaterial()
        value.certificateArn = try reader["certificateArn"].readIfPresent() ?? ""
        return value
    }
}

extension SignerClientTypes.SigningPlatformOverrides {

    static func write(value: SignerClientTypes.SigningPlatformOverrides?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["signingConfiguration"].write(value.signingConfiguration, with: SignerClientTypes.SigningConfigurationOverrides.write(value:to:))
        try writer["signingImageFormat"].write(value.signingImageFormat)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SignerClientTypes.SigningPlatformOverrides {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SignerClientTypes.SigningPlatformOverrides()
        value.signingConfiguration = try reader["signingConfiguration"].readIfPresent(with: SignerClientTypes.SigningConfigurationOverrides.read(from:))
        value.signingImageFormat = try reader["signingImageFormat"].readIfPresent()
        return value
    }
}

extension SignerClientTypes.SigningConfigurationOverrides {

    static func write(value: SignerClientTypes.SigningConfigurationOverrides?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionAlgorithm"].write(value.encryptionAlgorithm)
        try writer["hashAlgorithm"].write(value.hashAlgorithm)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SignerClientTypes.SigningConfigurationOverrides {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SignerClientTypes.SigningConfigurationOverrides()
        value.encryptionAlgorithm = try reader["encryptionAlgorithm"].readIfPresent()
        value.hashAlgorithm = try reader["hashAlgorithm"].readIfPresent()
        return value
    }
}

extension SignerClientTypes.SigningJobRevocationRecord {

    static func read(from reader: SmithyJSON.Reader) throws -> SignerClientTypes.SigningJobRevocationRecord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SignerClientTypes.SigningJobRevocationRecord()
        value.reason = try reader["reason"].readIfPresent()
        value.revokedAt = try reader["revokedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.revokedBy = try reader["revokedBy"].readIfPresent()
        return value
    }
}

extension SignerClientTypes.SignedObject {

    static func read(from reader: SmithyJSON.Reader) throws -> SignerClientTypes.SignedObject {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SignerClientTypes.SignedObject()
        value.s3 = try reader["s3"].readIfPresent(with: SignerClientTypes.S3SignedObject.read(from:))
        return value
    }
}

extension SignerClientTypes.S3SignedObject {

    static func read(from reader: SmithyJSON.Reader) throws -> SignerClientTypes.S3SignedObject {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SignerClientTypes.S3SignedObject()
        value.bucketName = try reader["bucketName"].readIfPresent()
        value.key = try reader["key"].readIfPresent()
        return value
    }
}

extension SignerClientTypes.SigningConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> SignerClientTypes.SigningConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SignerClientTypes.SigningConfiguration()
        value.encryptionAlgorithmOptions = try reader["encryptionAlgorithmOptions"].readIfPresent(with: SignerClientTypes.EncryptionAlgorithmOptions.read(from:))
        value.hashAlgorithmOptions = try reader["hashAlgorithmOptions"].readIfPresent(with: SignerClientTypes.HashAlgorithmOptions.read(from:))
        return value
    }
}

extension SignerClientTypes.HashAlgorithmOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> SignerClientTypes.HashAlgorithmOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SignerClientTypes.HashAlgorithmOptions()
        value.allowedValues = try reader["allowedValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<SignerClientTypes.HashAlgorithm>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.defaultValue = try reader["defaultValue"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension SignerClientTypes.EncryptionAlgorithmOptions {

    static func read(from reader: SmithyJSON.Reader) throws -> SignerClientTypes.EncryptionAlgorithmOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SignerClientTypes.EncryptionAlgorithmOptions()
        value.allowedValues = try reader["allowedValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<SignerClientTypes.EncryptionAlgorithm>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.defaultValue = try reader["defaultValue"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension SignerClientTypes.SigningImageFormat {

    static func read(from reader: SmithyJSON.Reader) throws -> SignerClientTypes.SigningImageFormat {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SignerClientTypes.SigningImageFormat()
        value.supportedFormats = try reader["supportedFormats"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<SignerClientTypes.ImageFormat>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.defaultFormat = try reader["defaultFormat"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension SignerClientTypes.SigningProfileRevocationRecord {

    static func read(from reader: SmithyJSON.Reader) throws -> SignerClientTypes.SigningProfileRevocationRecord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SignerClientTypes.SigningProfileRevocationRecord()
        value.revocationEffectiveFrom = try reader["revocationEffectiveFrom"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.revokedAt = try reader["revokedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.revokedBy = try reader["revokedBy"].readIfPresent()
        return value
    }
}

extension SignerClientTypes.SignatureValidityPeriod {

    static func write(value: SignerClientTypes.SignatureValidityPeriod?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SignerClientTypes.SignatureValidityPeriod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SignerClientTypes.SignatureValidityPeriod()
        value.value = try reader["value"].readIfPresent() ?? 0
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension SignerClientTypes.Permission {

    static func read(from reader: SmithyJSON.Reader) throws -> SignerClientTypes.Permission {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SignerClientTypes.Permission()
        value.action = try reader["action"].readIfPresent()
        value.principal = try reader["principal"].readIfPresent()
        value.statementId = try reader["statementId"].readIfPresent()
        value.profileVersion = try reader["profileVersion"].readIfPresent()
        return value
    }
}

extension SignerClientTypes.SigningJob {

    static func read(from reader: SmithyJSON.Reader) throws -> SignerClientTypes.SigningJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SignerClientTypes.SigningJob()
        value.jobId = try reader["jobId"].readIfPresent()
        value.source = try reader["source"].readIfPresent(with: SignerClientTypes.Source.read(from:))
        value.signedObject = try reader["signedObject"].readIfPresent(with: SignerClientTypes.SignedObject.read(from:))
        value.signingMaterial = try reader["signingMaterial"].readIfPresent(with: SignerClientTypes.SigningMaterial.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.isRevoked = try reader["isRevoked"].readIfPresent() ?? false
        value.profileName = try reader["profileName"].readIfPresent()
        value.profileVersion = try reader["profileVersion"].readIfPresent()
        value.platformId = try reader["platformId"].readIfPresent()
        value.platformDisplayName = try reader["platformDisplayName"].readIfPresent()
        value.signatureExpiresAt = try reader["signatureExpiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.jobOwner = try reader["jobOwner"].readIfPresent()
        value.jobInvoker = try reader["jobInvoker"].readIfPresent()
        return value
    }
}

extension SignerClientTypes.SigningPlatform {

    static func read(from reader: SmithyJSON.Reader) throws -> SignerClientTypes.SigningPlatform {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SignerClientTypes.SigningPlatform()
        value.platformId = try reader["platformId"].readIfPresent()
        value.displayName = try reader["displayName"].readIfPresent()
        value.partner = try reader["partner"].readIfPresent()
        value.target = try reader["target"].readIfPresent()
        value.category = try reader["category"].readIfPresent()
        value.signingConfiguration = try reader["signingConfiguration"].readIfPresent(with: SignerClientTypes.SigningConfiguration.read(from:))
        value.signingImageFormat = try reader["signingImageFormat"].readIfPresent(with: SignerClientTypes.SigningImageFormat.read(from:))
        value.maxSizeInMB = try reader["maxSizeInMB"].readIfPresent() ?? 0
        value.revocationSupported = try reader["revocationSupported"].readIfPresent() ?? false
        return value
    }
}

extension SignerClientTypes.SigningProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> SignerClientTypes.SigningProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SignerClientTypes.SigningProfile()
        value.profileName = try reader["profileName"].readIfPresent()
        value.profileVersion = try reader["profileVersion"].readIfPresent()
        value.profileVersionArn = try reader["profileVersionArn"].readIfPresent()
        value.signingMaterial = try reader["signingMaterial"].readIfPresent(with: SignerClientTypes.SigningMaterial.read(from:))
        value.signatureValidityPeriod = try reader["signatureValidityPeriod"].readIfPresent(with: SignerClientTypes.SignatureValidityPeriod.read(from:))
        value.platformId = try reader["platformId"].readIfPresent()
        value.platformDisplayName = try reader["platformDisplayName"].readIfPresent()
        value.signingParameters = try reader["signingParameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SignerClientTypes.Destination {

    static func write(value: SignerClientTypes.Destination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3"].write(value.s3, with: SignerClientTypes.S3Destination.write(value:to:))
    }
}

extension SignerClientTypes.S3Destination {

    static func write(value: SignerClientTypes.S3Destination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["prefix"].write(value.`prefix`)
    }
}

public enum SignerClientTypes {}
