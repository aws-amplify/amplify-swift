//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension InspectorClient {
    /// Paginate over `[GetExclusionsPreviewOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetExclusionsPreviewInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetExclusionsPreviewOutput`
    public func getExclusionsPreviewPaginated(input: GetExclusionsPreviewInput) -> ClientRuntime.PaginatorSequence<GetExclusionsPreviewInput, GetExclusionsPreviewOutput> {
        return ClientRuntime.PaginatorSequence<GetExclusionsPreviewInput, GetExclusionsPreviewOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getExclusionsPreview(input:))
    }
}

extension GetExclusionsPreviewInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetExclusionsPreviewInput {
        return GetExclusionsPreviewInput(
            assessmentTemplateArn: self.assessmentTemplateArn,
            locale: self.locale,
            maxResults: self.maxResults,
            nextToken: token,
            previewToken: self.previewToken
        )}
}
extension InspectorClient {
    /// Paginate over `[ListAssessmentRunAgentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAssessmentRunAgentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAssessmentRunAgentsOutput`
    public func listAssessmentRunAgentsPaginated(input: ListAssessmentRunAgentsInput) -> ClientRuntime.PaginatorSequence<ListAssessmentRunAgentsInput, ListAssessmentRunAgentsOutput> {
        return ClientRuntime.PaginatorSequence<ListAssessmentRunAgentsInput, ListAssessmentRunAgentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAssessmentRunAgents(input:))
    }
}

extension ListAssessmentRunAgentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssessmentRunAgentsInput {
        return ListAssessmentRunAgentsInput(
            assessmentRunArn: self.assessmentRunArn,
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension InspectorClient {
    /// Paginate over `[ListAssessmentRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAssessmentRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAssessmentRunsOutput`
    public func listAssessmentRunsPaginated(input: ListAssessmentRunsInput) -> ClientRuntime.PaginatorSequence<ListAssessmentRunsInput, ListAssessmentRunsOutput> {
        return ClientRuntime.PaginatorSequence<ListAssessmentRunsInput, ListAssessmentRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAssessmentRuns(input:))
    }
}

extension ListAssessmentRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssessmentRunsInput {
        return ListAssessmentRunsInput(
            assessmentTemplateArns: self.assessmentTemplateArns,
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension InspectorClient {
    /// Paginate over `[ListAssessmentTargetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAssessmentTargetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAssessmentTargetsOutput`
    public func listAssessmentTargetsPaginated(input: ListAssessmentTargetsInput) -> ClientRuntime.PaginatorSequence<ListAssessmentTargetsInput, ListAssessmentTargetsOutput> {
        return ClientRuntime.PaginatorSequence<ListAssessmentTargetsInput, ListAssessmentTargetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAssessmentTargets(input:))
    }
}

extension ListAssessmentTargetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssessmentTargetsInput {
        return ListAssessmentTargetsInput(
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension InspectorClient {
    /// Paginate over `[ListAssessmentTemplatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAssessmentTemplatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAssessmentTemplatesOutput`
    public func listAssessmentTemplatesPaginated(input: ListAssessmentTemplatesInput) -> ClientRuntime.PaginatorSequence<ListAssessmentTemplatesInput, ListAssessmentTemplatesOutput> {
        return ClientRuntime.PaginatorSequence<ListAssessmentTemplatesInput, ListAssessmentTemplatesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAssessmentTemplates(input:))
    }
}

extension ListAssessmentTemplatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssessmentTemplatesInput {
        return ListAssessmentTemplatesInput(
            assessmentTargetArns: self.assessmentTargetArns,
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension InspectorClient {
    /// Paginate over `[ListEventSubscriptionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListEventSubscriptionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListEventSubscriptionsOutput`
    public func listEventSubscriptionsPaginated(input: ListEventSubscriptionsInput) -> ClientRuntime.PaginatorSequence<ListEventSubscriptionsInput, ListEventSubscriptionsOutput> {
        return ClientRuntime.PaginatorSequence<ListEventSubscriptionsInput, ListEventSubscriptionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listEventSubscriptions(input:))
    }
}

extension ListEventSubscriptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEventSubscriptionsInput {
        return ListEventSubscriptionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}
extension InspectorClient {
    /// Paginate over `[ListExclusionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListExclusionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListExclusionsOutput`
    public func listExclusionsPaginated(input: ListExclusionsInput) -> ClientRuntime.PaginatorSequence<ListExclusionsInput, ListExclusionsOutput> {
        return ClientRuntime.PaginatorSequence<ListExclusionsInput, ListExclusionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listExclusions(input:))
    }
}

extension ListExclusionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListExclusionsInput {
        return ListExclusionsInput(
            assessmentRunArn: self.assessmentRunArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension InspectorClient {
    /// Paginate over `[ListFindingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFindingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFindingsOutput`
    public func listFindingsPaginated(input: ListFindingsInput) -> ClientRuntime.PaginatorSequence<ListFindingsInput, ListFindingsOutput> {
        return ClientRuntime.PaginatorSequence<ListFindingsInput, ListFindingsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFindings(input:))
    }
}

extension ListFindingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFindingsInput {
        return ListFindingsInput(
            assessmentRunArns: self.assessmentRunArns,
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension InspectorClient {
    /// Paginate over `[ListRulesPackagesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRulesPackagesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRulesPackagesOutput`
    public func listRulesPackagesPaginated(input: ListRulesPackagesInput) -> ClientRuntime.PaginatorSequence<ListRulesPackagesInput, ListRulesPackagesOutput> {
        return ClientRuntime.PaginatorSequence<ListRulesPackagesInput, ListRulesPackagesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRulesPackages(input:))
    }
}

extension ListRulesPackagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRulesPackagesInput {
        return ListRulesPackagesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension InspectorClient {
    /// Paginate over `[PreviewAgentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[PreviewAgentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `PreviewAgentsOutput`
    public func previewAgentsPaginated(input: PreviewAgentsInput) -> ClientRuntime.PaginatorSequence<PreviewAgentsInput, PreviewAgentsOutput> {
        return ClientRuntime.PaginatorSequence<PreviewAgentsInput, PreviewAgentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.previewAgents(input:))
    }
}

extension PreviewAgentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> PreviewAgentsInput {
        return PreviewAgentsInput(
            maxResults: self.maxResults,
            nextToken: token,
            previewAgentsArn: self.previewAgentsArn
        )}
}
