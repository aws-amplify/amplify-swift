//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension GuardDutyClient {
    /// Paginate over `[DescribeMalwareScansOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeMalwareScansInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeMalwareScansOutput`
    public func describeMalwareScansPaginated(input: DescribeMalwareScansInput) -> ClientRuntime.PaginatorSequence<DescribeMalwareScansInput, DescribeMalwareScansOutput> {
        return ClientRuntime.PaginatorSequence<DescribeMalwareScansInput, DescribeMalwareScansOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeMalwareScans(input:))
    }
}

extension DescribeMalwareScansInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMalwareScansInput {
        return DescribeMalwareScansInput(
            detectorId: self.detectorId,
            filterCriteria: self.filterCriteria,
            maxResults: self.maxResults,
            nextToken: token,
            sortCriteria: self.sortCriteria
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeMalwareScansInput, OperationStackOutput == DescribeMalwareScansOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeMalwareScansPaginated`
    /// to access the nested member `[GuardDutyClientTypes.Scan]`
    /// - Returns: `[GuardDutyClientTypes.Scan]`
    public func scans() async throws -> [GuardDutyClientTypes.Scan] {
        return try await self.asyncCompactMap { item in item.scans }
    }
}
extension GuardDutyClient {
    /// Paginate over `[DescribeOrganizationConfigurationOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeOrganizationConfigurationInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeOrganizationConfigurationOutput`
    public func describeOrganizationConfigurationPaginated(input: DescribeOrganizationConfigurationInput) -> ClientRuntime.PaginatorSequence<DescribeOrganizationConfigurationInput, DescribeOrganizationConfigurationOutput> {
        return ClientRuntime.PaginatorSequence<DescribeOrganizationConfigurationInput, DescribeOrganizationConfigurationOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeOrganizationConfiguration(input:))
    }
}

extension DescribeOrganizationConfigurationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeOrganizationConfigurationInput {
        return DescribeOrganizationConfigurationInput(
            detectorId: self.detectorId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GuardDutyClient {
    /// Paginate over `[GetUsageStatisticsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetUsageStatisticsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetUsageStatisticsOutput`
    public func getUsageStatisticsPaginated(input: GetUsageStatisticsInput) -> ClientRuntime.PaginatorSequence<GetUsageStatisticsInput, GetUsageStatisticsOutput> {
        return ClientRuntime.PaginatorSequence<GetUsageStatisticsInput, GetUsageStatisticsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getUsageStatistics(input:))
    }
}

extension GetUsageStatisticsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetUsageStatisticsInput {
        return GetUsageStatisticsInput(
            detectorId: self.detectorId,
            maxResults: self.maxResults,
            nextToken: token,
            unit: self.unit,
            usageCriteria: self.usageCriteria,
            usageStatisticType: self.usageStatisticType
        )}
}
extension GuardDutyClient {
    /// Paginate over `[ListCoverageOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCoverageInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCoverageOutput`
    public func listCoveragePaginated(input: ListCoverageInput) -> ClientRuntime.PaginatorSequence<ListCoverageInput, ListCoverageOutput> {
        return ClientRuntime.PaginatorSequence<ListCoverageInput, ListCoverageOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCoverage(input:))
    }
}

extension ListCoverageInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCoverageInput {
        return ListCoverageInput(
            detectorId: self.detectorId,
            filterCriteria: self.filterCriteria,
            maxResults: self.maxResults,
            nextToken: token,
            sortCriteria: self.sortCriteria
        )}
}

extension PaginatorSequence where OperationStackInput == ListCoverageInput, OperationStackOutput == ListCoverageOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCoveragePaginated`
    /// to access the nested member `[GuardDutyClientTypes.CoverageResource]`
    /// - Returns: `[GuardDutyClientTypes.CoverageResource]`
    public func resources() async throws -> [GuardDutyClientTypes.CoverageResource] {
        return try await self.asyncCompactMap { item in item.resources }
    }
}
extension GuardDutyClient {
    /// Paginate over `[ListDetectorsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDetectorsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDetectorsOutput`
    public func listDetectorsPaginated(input: ListDetectorsInput) -> ClientRuntime.PaginatorSequence<ListDetectorsInput, ListDetectorsOutput> {
        return ClientRuntime.PaginatorSequence<ListDetectorsInput, ListDetectorsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDetectors(input:))
    }
}

extension ListDetectorsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDetectorsInput {
        return ListDetectorsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDetectorsInput, OperationStackOutput == ListDetectorsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDetectorsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func detectorIds() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.detectorIds }
    }
}
extension GuardDutyClient {
    /// Paginate over `[ListFiltersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFiltersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFiltersOutput`
    public func listFiltersPaginated(input: ListFiltersInput) -> ClientRuntime.PaginatorSequence<ListFiltersInput, ListFiltersOutput> {
        return ClientRuntime.PaginatorSequence<ListFiltersInput, ListFiltersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFilters(input:))
    }
}

extension ListFiltersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFiltersInput {
        return ListFiltersInput(
            detectorId: self.detectorId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListFiltersInput, OperationStackOutput == ListFiltersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFiltersPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func filterNames() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.filterNames }
    }
}
extension GuardDutyClient {
    /// Paginate over `[ListFindingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFindingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFindingsOutput`
    public func listFindingsPaginated(input: ListFindingsInput) -> ClientRuntime.PaginatorSequence<ListFindingsInput, ListFindingsOutput> {
        return ClientRuntime.PaginatorSequence<ListFindingsInput, ListFindingsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFindings(input:))
    }
}

extension ListFindingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFindingsInput {
        return ListFindingsInput(
            detectorId: self.detectorId,
            findingCriteria: self.findingCriteria,
            maxResults: self.maxResults,
            nextToken: token,
            sortCriteria: self.sortCriteria
        )}
}

extension PaginatorSequence where OperationStackInput == ListFindingsInput, OperationStackOutput == ListFindingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFindingsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func findingIds() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.findingIds }
    }
}
extension GuardDutyClient {
    /// Paginate over `[ListInvitationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInvitationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInvitationsOutput`
    public func listInvitationsPaginated(input: ListInvitationsInput) -> ClientRuntime.PaginatorSequence<ListInvitationsInput, ListInvitationsOutput> {
        return ClientRuntime.PaginatorSequence<ListInvitationsInput, ListInvitationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listInvitations(input:))
    }
}

extension ListInvitationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInvitationsInput {
        return ListInvitationsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListInvitationsInput, OperationStackOutput == ListInvitationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInvitationsPaginated`
    /// to access the nested member `[GuardDutyClientTypes.Invitation]`
    /// - Returns: `[GuardDutyClientTypes.Invitation]`
    public func invitations() async throws -> [GuardDutyClientTypes.Invitation] {
        return try await self.asyncCompactMap { item in item.invitations }
    }
}
extension GuardDutyClient {
    /// Paginate over `[ListIPSetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIPSetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIPSetsOutput`
    public func listIPSetsPaginated(input: ListIPSetsInput) -> ClientRuntime.PaginatorSequence<ListIPSetsInput, ListIPSetsOutput> {
        return ClientRuntime.PaginatorSequence<ListIPSetsInput, ListIPSetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listIPSets(input:))
    }
}

extension ListIPSetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIPSetsInput {
        return ListIPSetsInput(
            detectorId: self.detectorId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListIPSetsInput, OperationStackOutput == ListIPSetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listIPSetsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func ipSetIds() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.ipSetIds }
    }
}
extension GuardDutyClient {
    /// Paginate over `[ListMembersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMembersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMembersOutput`
    public func listMembersPaginated(input: ListMembersInput) -> ClientRuntime.PaginatorSequence<ListMembersInput, ListMembersOutput> {
        return ClientRuntime.PaginatorSequence<ListMembersInput, ListMembersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMembers(input:))
    }
}

extension ListMembersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMembersInput {
        return ListMembersInput(
            detectorId: self.detectorId,
            maxResults: self.maxResults,
            nextToken: token,
            onlyAssociated: self.onlyAssociated
        )}
}

extension PaginatorSequence where OperationStackInput == ListMembersInput, OperationStackOutput == ListMembersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMembersPaginated`
    /// to access the nested member `[GuardDutyClientTypes.Member]`
    /// - Returns: `[GuardDutyClientTypes.Member]`
    public func members() async throws -> [GuardDutyClientTypes.Member] {
        return try await self.asyncCompactMap { item in item.members }
    }
}
extension GuardDutyClient {
    /// Paginate over `[ListOrganizationAdminAccountsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOrganizationAdminAccountsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOrganizationAdminAccountsOutput`
    public func listOrganizationAdminAccountsPaginated(input: ListOrganizationAdminAccountsInput) -> ClientRuntime.PaginatorSequence<ListOrganizationAdminAccountsInput, ListOrganizationAdminAccountsOutput> {
        return ClientRuntime.PaginatorSequence<ListOrganizationAdminAccountsInput, ListOrganizationAdminAccountsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listOrganizationAdminAccounts(input:))
    }
}

extension ListOrganizationAdminAccountsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOrganizationAdminAccountsInput {
        return ListOrganizationAdminAccountsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListOrganizationAdminAccountsInput, OperationStackOutput == ListOrganizationAdminAccountsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOrganizationAdminAccountsPaginated`
    /// to access the nested member `[GuardDutyClientTypes.AdminAccount]`
    /// - Returns: `[GuardDutyClientTypes.AdminAccount]`
    public func adminAccounts() async throws -> [GuardDutyClientTypes.AdminAccount] {
        return try await self.asyncCompactMap { item in item.adminAccounts }
    }
}
extension GuardDutyClient {
    /// Paginate over `[ListPublishingDestinationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPublishingDestinationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPublishingDestinationsOutput`
    public func listPublishingDestinationsPaginated(input: ListPublishingDestinationsInput) -> ClientRuntime.PaginatorSequence<ListPublishingDestinationsInput, ListPublishingDestinationsOutput> {
        return ClientRuntime.PaginatorSequence<ListPublishingDestinationsInput, ListPublishingDestinationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPublishingDestinations(input:))
    }
}

extension ListPublishingDestinationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPublishingDestinationsInput {
        return ListPublishingDestinationsInput(
            detectorId: self.detectorId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension GuardDutyClient {
    /// Paginate over `[ListThreatIntelSetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListThreatIntelSetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListThreatIntelSetsOutput`
    public func listThreatIntelSetsPaginated(input: ListThreatIntelSetsInput) -> ClientRuntime.PaginatorSequence<ListThreatIntelSetsInput, ListThreatIntelSetsOutput> {
        return ClientRuntime.PaginatorSequence<ListThreatIntelSetsInput, ListThreatIntelSetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listThreatIntelSets(input:))
    }
}

extension ListThreatIntelSetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThreatIntelSetsInput {
        return ListThreatIntelSetsInput(
            detectorId: self.detectorId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListThreatIntelSetsInput, OperationStackOutput == ListThreatIntelSetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listThreatIntelSetsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func threatIntelSetIds() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.threatIntelSetIds }
    }
}
