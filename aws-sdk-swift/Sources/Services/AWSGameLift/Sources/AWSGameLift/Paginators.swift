//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension GameLiftClient {
    /// Paginate over `[DescribeFleetAttributesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeFleetAttributesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeFleetAttributesOutput`
    public func describeFleetAttributesPaginated(input: DescribeFleetAttributesInput) -> ClientRuntime.PaginatorSequence<DescribeFleetAttributesInput, DescribeFleetAttributesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeFleetAttributesInput, DescribeFleetAttributesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeFleetAttributes(input:))
    }
}

extension DescribeFleetAttributesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFleetAttributesInput {
        return DescribeFleetAttributesInput(
            fleetIds: self.fleetIds,
            limit: self.limit,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeFleetAttributesInput, OperationStackOutput == DescribeFleetAttributesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeFleetAttributesPaginated`
    /// to access the nested member `[GameLiftClientTypes.FleetAttributes]`
    /// - Returns: `[GameLiftClientTypes.FleetAttributes]`
    public func fleetAttributes() async throws -> [GameLiftClientTypes.FleetAttributes] {
        return try await self.asyncCompactMap { item in item.fleetAttributes }
    }
}
extension GameLiftClient {
    /// Paginate over `[DescribeFleetCapacityOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeFleetCapacityInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeFleetCapacityOutput`
    public func describeFleetCapacityPaginated(input: DescribeFleetCapacityInput) -> ClientRuntime.PaginatorSequence<DescribeFleetCapacityInput, DescribeFleetCapacityOutput> {
        return ClientRuntime.PaginatorSequence<DescribeFleetCapacityInput, DescribeFleetCapacityOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeFleetCapacity(input:))
    }
}

extension DescribeFleetCapacityInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFleetCapacityInput {
        return DescribeFleetCapacityInput(
            fleetIds: self.fleetIds,
            limit: self.limit,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeFleetCapacityInput, OperationStackOutput == DescribeFleetCapacityOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeFleetCapacityPaginated`
    /// to access the nested member `[GameLiftClientTypes.FleetCapacity]`
    /// - Returns: `[GameLiftClientTypes.FleetCapacity]`
    public func fleetCapacity() async throws -> [GameLiftClientTypes.FleetCapacity] {
        return try await self.asyncCompactMap { item in item.fleetCapacity }
    }
}
extension GameLiftClient {
    /// Paginate over `[DescribeFleetEventsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeFleetEventsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeFleetEventsOutput`
    public func describeFleetEventsPaginated(input: DescribeFleetEventsInput) -> ClientRuntime.PaginatorSequence<DescribeFleetEventsInput, DescribeFleetEventsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeFleetEventsInput, DescribeFleetEventsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeFleetEvents(input:))
    }
}

extension DescribeFleetEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFleetEventsInput {
        return DescribeFleetEventsInput(
            endTime: self.endTime,
            fleetId: self.fleetId,
            limit: self.limit,
            nextToken: token,
            startTime: self.startTime
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeFleetEventsInput, OperationStackOutput == DescribeFleetEventsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeFleetEventsPaginated`
    /// to access the nested member `[GameLiftClientTypes.Event]`
    /// - Returns: `[GameLiftClientTypes.Event]`
    public func events() async throws -> [GameLiftClientTypes.Event] {
        return try await self.asyncCompactMap { item in item.events }
    }
}
extension GameLiftClient {
    /// Paginate over `[DescribeFleetLocationAttributesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeFleetLocationAttributesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeFleetLocationAttributesOutput`
    public func describeFleetLocationAttributesPaginated(input: DescribeFleetLocationAttributesInput) -> ClientRuntime.PaginatorSequence<DescribeFleetLocationAttributesInput, DescribeFleetLocationAttributesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeFleetLocationAttributesInput, DescribeFleetLocationAttributesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeFleetLocationAttributes(input:))
    }
}

extension DescribeFleetLocationAttributesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFleetLocationAttributesInput {
        return DescribeFleetLocationAttributesInput(
            fleetId: self.fleetId,
            limit: self.limit,
            locations: self.locations,
            nextToken: token
        )}
}
extension GameLiftClient {
    /// Paginate over `[DescribeFleetUtilizationOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeFleetUtilizationInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeFleetUtilizationOutput`
    public func describeFleetUtilizationPaginated(input: DescribeFleetUtilizationInput) -> ClientRuntime.PaginatorSequence<DescribeFleetUtilizationInput, DescribeFleetUtilizationOutput> {
        return ClientRuntime.PaginatorSequence<DescribeFleetUtilizationInput, DescribeFleetUtilizationOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeFleetUtilization(input:))
    }
}

extension DescribeFleetUtilizationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFleetUtilizationInput {
        return DescribeFleetUtilizationInput(
            fleetIds: self.fleetIds,
            limit: self.limit,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeFleetUtilizationInput, OperationStackOutput == DescribeFleetUtilizationOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeFleetUtilizationPaginated`
    /// to access the nested member `[GameLiftClientTypes.FleetUtilization]`
    /// - Returns: `[GameLiftClientTypes.FleetUtilization]`
    public func fleetUtilization() async throws -> [GameLiftClientTypes.FleetUtilization] {
        return try await self.asyncCompactMap { item in item.fleetUtilization }
    }
}
extension GameLiftClient {
    /// Paginate over `[DescribeGameServerInstancesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeGameServerInstancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeGameServerInstancesOutput`
    public func describeGameServerInstancesPaginated(input: DescribeGameServerInstancesInput) -> ClientRuntime.PaginatorSequence<DescribeGameServerInstancesInput, DescribeGameServerInstancesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeGameServerInstancesInput, DescribeGameServerInstancesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeGameServerInstances(input:))
    }
}

extension DescribeGameServerInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeGameServerInstancesInput {
        return DescribeGameServerInstancesInput(
            gameServerGroupName: self.gameServerGroupName,
            instanceIds: self.instanceIds,
            limit: self.limit,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeGameServerInstancesInput, OperationStackOutput == DescribeGameServerInstancesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeGameServerInstancesPaginated`
    /// to access the nested member `[GameLiftClientTypes.GameServerInstance]`
    /// - Returns: `[GameLiftClientTypes.GameServerInstance]`
    public func gameServerInstances() async throws -> [GameLiftClientTypes.GameServerInstance] {
        return try await self.asyncCompactMap { item in item.gameServerInstances }
    }
}
extension GameLiftClient {
    /// Paginate over `[DescribeGameSessionDetailsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeGameSessionDetailsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeGameSessionDetailsOutput`
    public func describeGameSessionDetailsPaginated(input: DescribeGameSessionDetailsInput) -> ClientRuntime.PaginatorSequence<DescribeGameSessionDetailsInput, DescribeGameSessionDetailsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeGameSessionDetailsInput, DescribeGameSessionDetailsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeGameSessionDetails(input:))
    }
}

extension DescribeGameSessionDetailsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeGameSessionDetailsInput {
        return DescribeGameSessionDetailsInput(
            aliasId: self.aliasId,
            fleetId: self.fleetId,
            gameSessionId: self.gameSessionId,
            limit: self.limit,
            location: self.location,
            nextToken: token,
            statusFilter: self.statusFilter
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeGameSessionDetailsInput, OperationStackOutput == DescribeGameSessionDetailsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeGameSessionDetailsPaginated`
    /// to access the nested member `[GameLiftClientTypes.GameSessionDetail]`
    /// - Returns: `[GameLiftClientTypes.GameSessionDetail]`
    public func gameSessionDetails() async throws -> [GameLiftClientTypes.GameSessionDetail] {
        return try await self.asyncCompactMap { item in item.gameSessionDetails }
    }
}
extension GameLiftClient {
    /// Paginate over `[DescribeGameSessionQueuesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeGameSessionQueuesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeGameSessionQueuesOutput`
    public func describeGameSessionQueuesPaginated(input: DescribeGameSessionQueuesInput) -> ClientRuntime.PaginatorSequence<DescribeGameSessionQueuesInput, DescribeGameSessionQueuesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeGameSessionQueuesInput, DescribeGameSessionQueuesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeGameSessionQueues(input:))
    }
}

extension DescribeGameSessionQueuesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeGameSessionQueuesInput {
        return DescribeGameSessionQueuesInput(
            limit: self.limit,
            names: self.names,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeGameSessionQueuesInput, OperationStackOutput == DescribeGameSessionQueuesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeGameSessionQueuesPaginated`
    /// to access the nested member `[GameLiftClientTypes.GameSessionQueue]`
    /// - Returns: `[GameLiftClientTypes.GameSessionQueue]`
    public func gameSessionQueues() async throws -> [GameLiftClientTypes.GameSessionQueue] {
        return try await self.asyncCompactMap { item in item.gameSessionQueues }
    }
}
extension GameLiftClient {
    /// Paginate over `[DescribeGameSessionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeGameSessionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeGameSessionsOutput`
    public func describeGameSessionsPaginated(input: DescribeGameSessionsInput) -> ClientRuntime.PaginatorSequence<DescribeGameSessionsInput, DescribeGameSessionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeGameSessionsInput, DescribeGameSessionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeGameSessions(input:))
    }
}

extension DescribeGameSessionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeGameSessionsInput {
        return DescribeGameSessionsInput(
            aliasId: self.aliasId,
            fleetId: self.fleetId,
            gameSessionId: self.gameSessionId,
            limit: self.limit,
            location: self.location,
            nextToken: token,
            statusFilter: self.statusFilter
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeGameSessionsInput, OperationStackOutput == DescribeGameSessionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeGameSessionsPaginated`
    /// to access the nested member `[GameLiftClientTypes.GameSession]`
    /// - Returns: `[GameLiftClientTypes.GameSession]`
    public func gameSessions() async throws -> [GameLiftClientTypes.GameSession] {
        return try await self.asyncCompactMap { item in item.gameSessions }
    }
}
extension GameLiftClient {
    /// Paginate over `[DescribeInstancesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeInstancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeInstancesOutput`
    public func describeInstancesPaginated(input: DescribeInstancesInput) -> ClientRuntime.PaginatorSequence<DescribeInstancesInput, DescribeInstancesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeInstancesInput, DescribeInstancesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeInstances(input:))
    }
}

extension DescribeInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstancesInput {
        return DescribeInstancesInput(
            fleetId: self.fleetId,
            instanceId: self.instanceId,
            limit: self.limit,
            location: self.location,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeInstancesInput, OperationStackOutput == DescribeInstancesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeInstancesPaginated`
    /// to access the nested member `[GameLiftClientTypes.Instance]`
    /// - Returns: `[GameLiftClientTypes.Instance]`
    public func instances() async throws -> [GameLiftClientTypes.Instance] {
        return try await self.asyncCompactMap { item in item.instances }
    }
}
extension GameLiftClient {
    /// Paginate over `[DescribeMatchmakingConfigurationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeMatchmakingConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeMatchmakingConfigurationsOutput`
    public func describeMatchmakingConfigurationsPaginated(input: DescribeMatchmakingConfigurationsInput) -> ClientRuntime.PaginatorSequence<DescribeMatchmakingConfigurationsInput, DescribeMatchmakingConfigurationsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeMatchmakingConfigurationsInput, DescribeMatchmakingConfigurationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeMatchmakingConfigurations(input:))
    }
}

extension DescribeMatchmakingConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMatchmakingConfigurationsInput {
        return DescribeMatchmakingConfigurationsInput(
            limit: self.limit,
            names: self.names,
            nextToken: token,
            ruleSetName: self.ruleSetName
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeMatchmakingConfigurationsInput, OperationStackOutput == DescribeMatchmakingConfigurationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeMatchmakingConfigurationsPaginated`
    /// to access the nested member `[GameLiftClientTypes.MatchmakingConfiguration]`
    /// - Returns: `[GameLiftClientTypes.MatchmakingConfiguration]`
    public func configurations() async throws -> [GameLiftClientTypes.MatchmakingConfiguration] {
        return try await self.asyncCompactMap { item in item.configurations }
    }
}
extension GameLiftClient {
    /// Paginate over `[DescribeMatchmakingRuleSetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeMatchmakingRuleSetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeMatchmakingRuleSetsOutput`
    public func describeMatchmakingRuleSetsPaginated(input: DescribeMatchmakingRuleSetsInput) -> ClientRuntime.PaginatorSequence<DescribeMatchmakingRuleSetsInput, DescribeMatchmakingRuleSetsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeMatchmakingRuleSetsInput, DescribeMatchmakingRuleSetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeMatchmakingRuleSets(input:))
    }
}

extension DescribeMatchmakingRuleSetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMatchmakingRuleSetsInput {
        return DescribeMatchmakingRuleSetsInput(
            limit: self.limit,
            names: self.names,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeMatchmakingRuleSetsInput, OperationStackOutput == DescribeMatchmakingRuleSetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeMatchmakingRuleSetsPaginated`
    /// to access the nested member `[GameLiftClientTypes.MatchmakingRuleSet]`
    /// - Returns: `[GameLiftClientTypes.MatchmakingRuleSet]`
    public func ruleSets() async throws -> [GameLiftClientTypes.MatchmakingRuleSet] {
        return try await self.asyncCompactMap { item in item.ruleSets }
    }
}
extension GameLiftClient {
    /// Paginate over `[DescribePlayerSessionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribePlayerSessionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribePlayerSessionsOutput`
    public func describePlayerSessionsPaginated(input: DescribePlayerSessionsInput) -> ClientRuntime.PaginatorSequence<DescribePlayerSessionsInput, DescribePlayerSessionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribePlayerSessionsInput, DescribePlayerSessionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describePlayerSessions(input:))
    }
}

extension DescribePlayerSessionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePlayerSessionsInput {
        return DescribePlayerSessionsInput(
            gameSessionId: self.gameSessionId,
            limit: self.limit,
            nextToken: token,
            playerId: self.playerId,
            playerSessionId: self.playerSessionId,
            playerSessionStatusFilter: self.playerSessionStatusFilter
        )}
}

extension PaginatorSequence where OperationStackInput == DescribePlayerSessionsInput, OperationStackOutput == DescribePlayerSessionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describePlayerSessionsPaginated`
    /// to access the nested member `[GameLiftClientTypes.PlayerSession]`
    /// - Returns: `[GameLiftClientTypes.PlayerSession]`
    public func playerSessions() async throws -> [GameLiftClientTypes.PlayerSession] {
        return try await self.asyncCompactMap { item in item.playerSessions }
    }
}
extension GameLiftClient {
    /// Paginate over `[DescribeScalingPoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeScalingPoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeScalingPoliciesOutput`
    public func describeScalingPoliciesPaginated(input: DescribeScalingPoliciesInput) -> ClientRuntime.PaginatorSequence<DescribeScalingPoliciesInput, DescribeScalingPoliciesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeScalingPoliciesInput, DescribeScalingPoliciesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeScalingPolicies(input:))
    }
}

extension DescribeScalingPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeScalingPoliciesInput {
        return DescribeScalingPoliciesInput(
            fleetId: self.fleetId,
            limit: self.limit,
            location: self.location,
            nextToken: token,
            statusFilter: self.statusFilter
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeScalingPoliciesInput, OperationStackOutput == DescribeScalingPoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeScalingPoliciesPaginated`
    /// to access the nested member `[GameLiftClientTypes.ScalingPolicy]`
    /// - Returns: `[GameLiftClientTypes.ScalingPolicy]`
    public func scalingPolicies() async throws -> [GameLiftClientTypes.ScalingPolicy] {
        return try await self.asyncCompactMap { item in item.scalingPolicies }
    }
}
extension GameLiftClient {
    /// Paginate over `[ListAliasesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAliasesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAliasesOutput`
    public func listAliasesPaginated(input: ListAliasesInput) -> ClientRuntime.PaginatorSequence<ListAliasesInput, ListAliasesOutput> {
        return ClientRuntime.PaginatorSequence<ListAliasesInput, ListAliasesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAliases(input:))
    }
}

extension ListAliasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAliasesInput {
        return ListAliasesInput(
            limit: self.limit,
            name: self.name,
            nextToken: token,
            routingStrategyType: self.routingStrategyType
        )}
}

extension PaginatorSequence where OperationStackInput == ListAliasesInput, OperationStackOutput == ListAliasesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAliasesPaginated`
    /// to access the nested member `[GameLiftClientTypes.Alias]`
    /// - Returns: `[GameLiftClientTypes.Alias]`
    public func aliases() async throws -> [GameLiftClientTypes.Alias] {
        return try await self.asyncCompactMap { item in item.aliases }
    }
}
extension GameLiftClient {
    /// Paginate over `[ListBuildsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBuildsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBuildsOutput`
    public func listBuildsPaginated(input: ListBuildsInput) -> ClientRuntime.PaginatorSequence<ListBuildsInput, ListBuildsOutput> {
        return ClientRuntime.PaginatorSequence<ListBuildsInput, ListBuildsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBuilds(input:))
    }
}

extension ListBuildsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBuildsInput {
        return ListBuildsInput(
            limit: self.limit,
            nextToken: token,
            status: self.status
        )}
}

extension PaginatorSequence where OperationStackInput == ListBuildsInput, OperationStackOutput == ListBuildsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listBuildsPaginated`
    /// to access the nested member `[GameLiftClientTypes.Build]`
    /// - Returns: `[GameLiftClientTypes.Build]`
    public func builds() async throws -> [GameLiftClientTypes.Build] {
        return try await self.asyncCompactMap { item in item.builds }
    }
}
extension GameLiftClient {
    /// Paginate over `[ListComputeOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListComputeInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListComputeOutput`
    public func listComputePaginated(input: ListComputeInput) -> ClientRuntime.PaginatorSequence<ListComputeInput, ListComputeOutput> {
        return ClientRuntime.PaginatorSequence<ListComputeInput, ListComputeOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCompute(input:))
    }
}

extension ListComputeInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListComputeInput {
        return ListComputeInput(
            fleetId: self.fleetId,
            limit: self.limit,
            location: self.location,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListComputeInput, OperationStackOutput == ListComputeOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listComputePaginated`
    /// to access the nested member `[GameLiftClientTypes.Compute]`
    /// - Returns: `[GameLiftClientTypes.Compute]`
    public func computeList() async throws -> [GameLiftClientTypes.Compute] {
        return try await self.asyncCompactMap { item in item.computeList }
    }
}
extension GameLiftClient {
    /// Paginate over `[ListContainerGroupDefinitionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListContainerGroupDefinitionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListContainerGroupDefinitionsOutput`
    public func listContainerGroupDefinitionsPaginated(input: ListContainerGroupDefinitionsInput) -> ClientRuntime.PaginatorSequence<ListContainerGroupDefinitionsInput, ListContainerGroupDefinitionsOutput> {
        return ClientRuntime.PaginatorSequence<ListContainerGroupDefinitionsInput, ListContainerGroupDefinitionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listContainerGroupDefinitions(input:))
    }
}

extension ListContainerGroupDefinitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListContainerGroupDefinitionsInput {
        return ListContainerGroupDefinitionsInput(
            limit: self.limit,
            nextToken: token,
            schedulingStrategy: self.schedulingStrategy
        )}
}

extension PaginatorSequence where OperationStackInput == ListContainerGroupDefinitionsInput, OperationStackOutput == ListContainerGroupDefinitionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listContainerGroupDefinitionsPaginated`
    /// to access the nested member `[GameLiftClientTypes.ContainerGroupDefinition]`
    /// - Returns: `[GameLiftClientTypes.ContainerGroupDefinition]`
    public func containerGroupDefinitions() async throws -> [GameLiftClientTypes.ContainerGroupDefinition] {
        return try await self.asyncCompactMap { item in item.containerGroupDefinitions }
    }
}
extension GameLiftClient {
    /// Paginate over `[ListFleetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFleetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFleetsOutput`
    public func listFleetsPaginated(input: ListFleetsInput) -> ClientRuntime.PaginatorSequence<ListFleetsInput, ListFleetsOutput> {
        return ClientRuntime.PaginatorSequence<ListFleetsInput, ListFleetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFleets(input:))
    }
}

extension ListFleetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFleetsInput {
        return ListFleetsInput(
            buildId: self.buildId,
            containerGroupDefinitionName: self.containerGroupDefinitionName,
            limit: self.limit,
            nextToken: token,
            scriptId: self.scriptId
        )}
}

extension PaginatorSequence where OperationStackInput == ListFleetsInput, OperationStackOutput == ListFleetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFleetsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func fleetIds() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.fleetIds }
    }
}
extension GameLiftClient {
    /// Paginate over `[ListGameServerGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListGameServerGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListGameServerGroupsOutput`
    public func listGameServerGroupsPaginated(input: ListGameServerGroupsInput) -> ClientRuntime.PaginatorSequence<ListGameServerGroupsInput, ListGameServerGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListGameServerGroupsInput, ListGameServerGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listGameServerGroups(input:))
    }
}

extension ListGameServerGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGameServerGroupsInput {
        return ListGameServerGroupsInput(
            limit: self.limit,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListGameServerGroupsInput, OperationStackOutput == ListGameServerGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listGameServerGroupsPaginated`
    /// to access the nested member `[GameLiftClientTypes.GameServerGroup]`
    /// - Returns: `[GameLiftClientTypes.GameServerGroup]`
    public func gameServerGroups() async throws -> [GameLiftClientTypes.GameServerGroup] {
        return try await self.asyncCompactMap { item in item.gameServerGroups }
    }
}
extension GameLiftClient {
    /// Paginate over `[ListGameServersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListGameServersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListGameServersOutput`
    public func listGameServersPaginated(input: ListGameServersInput) -> ClientRuntime.PaginatorSequence<ListGameServersInput, ListGameServersOutput> {
        return ClientRuntime.PaginatorSequence<ListGameServersInput, ListGameServersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listGameServers(input:))
    }
}

extension ListGameServersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGameServersInput {
        return ListGameServersInput(
            gameServerGroupName: self.gameServerGroupName,
            limit: self.limit,
            nextToken: token,
            sortOrder: self.sortOrder
        )}
}

extension PaginatorSequence where OperationStackInput == ListGameServersInput, OperationStackOutput == ListGameServersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listGameServersPaginated`
    /// to access the nested member `[GameLiftClientTypes.GameServer]`
    /// - Returns: `[GameLiftClientTypes.GameServer]`
    public func gameServers() async throws -> [GameLiftClientTypes.GameServer] {
        return try await self.asyncCompactMap { item in item.gameServers }
    }
}
extension GameLiftClient {
    /// Paginate over `[ListLocationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLocationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLocationsOutput`
    public func listLocationsPaginated(input: ListLocationsInput) -> ClientRuntime.PaginatorSequence<ListLocationsInput, ListLocationsOutput> {
        return ClientRuntime.PaginatorSequence<ListLocationsInput, ListLocationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listLocations(input:))
    }
}

extension ListLocationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLocationsInput {
        return ListLocationsInput(
            filters: self.filters,
            limit: self.limit,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListLocationsInput, OperationStackOutput == ListLocationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listLocationsPaginated`
    /// to access the nested member `[GameLiftClientTypes.LocationModel]`
    /// - Returns: `[GameLiftClientTypes.LocationModel]`
    public func locations() async throws -> [GameLiftClientTypes.LocationModel] {
        return try await self.asyncCompactMap { item in item.locations }
    }
}
extension GameLiftClient {
    /// Paginate over `[ListScriptsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListScriptsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListScriptsOutput`
    public func listScriptsPaginated(input: ListScriptsInput) -> ClientRuntime.PaginatorSequence<ListScriptsInput, ListScriptsOutput> {
        return ClientRuntime.PaginatorSequence<ListScriptsInput, ListScriptsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listScripts(input:))
    }
}

extension ListScriptsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListScriptsInput {
        return ListScriptsInput(
            limit: self.limit,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListScriptsInput, OperationStackOutput == ListScriptsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listScriptsPaginated`
    /// to access the nested member `[GameLiftClientTypes.Script]`
    /// - Returns: `[GameLiftClientTypes.Script]`
    public func scripts() async throws -> [GameLiftClientTypes.Script] {
        return try await self.asyncCompactMap { item in item.scripts }
    }
}
extension GameLiftClient {
    /// Paginate over `[SearchGameSessionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[SearchGameSessionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `SearchGameSessionsOutput`
    public func searchGameSessionsPaginated(input: SearchGameSessionsInput) -> ClientRuntime.PaginatorSequence<SearchGameSessionsInput, SearchGameSessionsOutput> {
        return ClientRuntime.PaginatorSequence<SearchGameSessionsInput, SearchGameSessionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.searchGameSessions(input:))
    }
}

extension SearchGameSessionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchGameSessionsInput {
        return SearchGameSessionsInput(
            aliasId: self.aliasId,
            filterExpression: self.filterExpression,
            fleetId: self.fleetId,
            limit: self.limit,
            location: self.location,
            nextToken: token,
            sortExpression: self.sortExpression
        )}
}

extension PaginatorSequence where OperationStackInput == SearchGameSessionsInput, OperationStackOutput == SearchGameSessionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `searchGameSessionsPaginated`
    /// to access the nested member `[GameLiftClientTypes.GameSession]`
    /// - Returns: `[GameLiftClientTypes.GameSession]`
    public func gameSessions() async throws -> [GameLiftClientTypes.GameSession] {
        return try await self.asyncCompactMap { item in item.gameSessions }
    }
}
