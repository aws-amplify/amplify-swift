//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension RedshiftClient {
    /// Paginate over `[DescribeClusterDbRevisionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClusterDbRevisionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClusterDbRevisionsOutput`
    public func describeClusterDbRevisionsPaginated(input: DescribeClusterDbRevisionsInput) -> ClientRuntime.PaginatorSequence<DescribeClusterDbRevisionsInput, DescribeClusterDbRevisionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeClusterDbRevisionsInput, DescribeClusterDbRevisionsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeClusterDbRevisions(input:))
    }
}

extension DescribeClusterDbRevisionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClusterDbRevisionsInput {
        return DescribeClusterDbRevisionsInput(
            clusterIdentifier: self.clusterIdentifier,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeClusterDbRevisionsInput, OperationStackOutput == DescribeClusterDbRevisionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeClusterDbRevisionsPaginated`
    /// to access the nested member `[RedshiftClientTypes.ClusterDbRevision]`
    /// - Returns: `[RedshiftClientTypes.ClusterDbRevision]`
    public func clusterDbRevisions() async throws -> [RedshiftClientTypes.ClusterDbRevision] {
        return try await self.asyncCompactMap { item in item.clusterDbRevisions }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeClusterParameterGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClusterParameterGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClusterParameterGroupsOutput`
    public func describeClusterParameterGroupsPaginated(input: DescribeClusterParameterGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeClusterParameterGroupsInput, DescribeClusterParameterGroupsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeClusterParameterGroupsInput, DescribeClusterParameterGroupsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeClusterParameterGroups(input:))
    }
}

extension DescribeClusterParameterGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClusterParameterGroupsInput {
        return DescribeClusterParameterGroupsInput(
            marker: token,
            maxRecords: self.maxRecords,
            parameterGroupName: self.parameterGroupName,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeClusterParameterGroupsInput, OperationStackOutput == DescribeClusterParameterGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeClusterParameterGroupsPaginated`
    /// to access the nested member `[RedshiftClientTypes.ClusterParameterGroup]`
    /// - Returns: `[RedshiftClientTypes.ClusterParameterGroup]`
    public func parameterGroups() async throws -> [RedshiftClientTypes.ClusterParameterGroup] {
        return try await self.asyncCompactMap { item in item.parameterGroups }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeClusterParametersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClusterParametersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClusterParametersOutput`
    public func describeClusterParametersPaginated(input: DescribeClusterParametersInput) -> ClientRuntime.PaginatorSequence<DescribeClusterParametersInput, DescribeClusterParametersOutput> {
        return ClientRuntime.PaginatorSequence<DescribeClusterParametersInput, DescribeClusterParametersOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeClusterParameters(input:))
    }
}

extension DescribeClusterParametersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClusterParametersInput {
        return DescribeClusterParametersInput(
            marker: token,
            maxRecords: self.maxRecords,
            parameterGroupName: self.parameterGroupName,
            source: self.source
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeClusterParametersInput, OperationStackOutput == DescribeClusterParametersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeClusterParametersPaginated`
    /// to access the nested member `[RedshiftClientTypes.Parameter]`
    /// - Returns: `[RedshiftClientTypes.Parameter]`
    public func parameters() async throws -> [RedshiftClientTypes.Parameter] {
        return try await self.asyncCompactMap { item in item.parameters }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeClustersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClustersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClustersOutput`
    public func describeClustersPaginated(input: DescribeClustersInput) -> ClientRuntime.PaginatorSequence<DescribeClustersInput, DescribeClustersOutput> {
        return ClientRuntime.PaginatorSequence<DescribeClustersInput, DescribeClustersOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeClusters(input:))
    }
}

extension DescribeClustersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClustersInput {
        return DescribeClustersInput(
            clusterIdentifier: self.clusterIdentifier,
            marker: token,
            maxRecords: self.maxRecords,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeClustersInput, OperationStackOutput == DescribeClustersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeClustersPaginated`
    /// to access the nested member `[RedshiftClientTypes.Cluster]`
    /// - Returns: `[RedshiftClientTypes.Cluster]`
    public func clusters() async throws -> [RedshiftClientTypes.Cluster] {
        return try await self.asyncCompactMap { item in item.clusters }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeClusterSecurityGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClusterSecurityGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClusterSecurityGroupsOutput`
    public func describeClusterSecurityGroupsPaginated(input: DescribeClusterSecurityGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeClusterSecurityGroupsInput, DescribeClusterSecurityGroupsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeClusterSecurityGroupsInput, DescribeClusterSecurityGroupsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeClusterSecurityGroups(input:))
    }
}

extension DescribeClusterSecurityGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClusterSecurityGroupsInput {
        return DescribeClusterSecurityGroupsInput(
            clusterSecurityGroupName: self.clusterSecurityGroupName,
            marker: token,
            maxRecords: self.maxRecords,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeClusterSecurityGroupsInput, OperationStackOutput == DescribeClusterSecurityGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeClusterSecurityGroupsPaginated`
    /// to access the nested member `[RedshiftClientTypes.ClusterSecurityGroup]`
    /// - Returns: `[RedshiftClientTypes.ClusterSecurityGroup]`
    public func clusterSecurityGroups() async throws -> [RedshiftClientTypes.ClusterSecurityGroup] {
        return try await self.asyncCompactMap { item in item.clusterSecurityGroups }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeClusterSnapshotsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClusterSnapshotsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClusterSnapshotsOutput`
    public func describeClusterSnapshotsPaginated(input: DescribeClusterSnapshotsInput) -> ClientRuntime.PaginatorSequence<DescribeClusterSnapshotsInput, DescribeClusterSnapshotsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeClusterSnapshotsInput, DescribeClusterSnapshotsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeClusterSnapshots(input:))
    }
}

extension DescribeClusterSnapshotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClusterSnapshotsInput {
        return DescribeClusterSnapshotsInput(
            clusterExists: self.clusterExists,
            clusterIdentifier: self.clusterIdentifier,
            endTime: self.endTime,
            marker: token,
            maxRecords: self.maxRecords,
            ownerAccount: self.ownerAccount,
            snapshotArn: self.snapshotArn,
            snapshotIdentifier: self.snapshotIdentifier,
            snapshotType: self.snapshotType,
            sortingEntities: self.sortingEntities,
            startTime: self.startTime,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeClusterSnapshotsInput, OperationStackOutput == DescribeClusterSnapshotsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeClusterSnapshotsPaginated`
    /// to access the nested member `[RedshiftClientTypes.Snapshot]`
    /// - Returns: `[RedshiftClientTypes.Snapshot]`
    public func snapshots() async throws -> [RedshiftClientTypes.Snapshot] {
        return try await self.asyncCompactMap { item in item.snapshots }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeClusterSubnetGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClusterSubnetGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClusterSubnetGroupsOutput`
    public func describeClusterSubnetGroupsPaginated(input: DescribeClusterSubnetGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeClusterSubnetGroupsInput, DescribeClusterSubnetGroupsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeClusterSubnetGroupsInput, DescribeClusterSubnetGroupsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeClusterSubnetGroups(input:))
    }
}

extension DescribeClusterSubnetGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClusterSubnetGroupsInput {
        return DescribeClusterSubnetGroupsInput(
            clusterSubnetGroupName: self.clusterSubnetGroupName,
            marker: token,
            maxRecords: self.maxRecords,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeClusterSubnetGroupsInput, OperationStackOutput == DescribeClusterSubnetGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeClusterSubnetGroupsPaginated`
    /// to access the nested member `[RedshiftClientTypes.ClusterSubnetGroup]`
    /// - Returns: `[RedshiftClientTypes.ClusterSubnetGroup]`
    public func clusterSubnetGroups() async throws -> [RedshiftClientTypes.ClusterSubnetGroup] {
        return try await self.asyncCompactMap { item in item.clusterSubnetGroups }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeClusterTracksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClusterTracksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClusterTracksOutput`
    public func describeClusterTracksPaginated(input: DescribeClusterTracksInput) -> ClientRuntime.PaginatorSequence<DescribeClusterTracksInput, DescribeClusterTracksOutput> {
        return ClientRuntime.PaginatorSequence<DescribeClusterTracksInput, DescribeClusterTracksOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeClusterTracks(input:))
    }
}

extension DescribeClusterTracksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClusterTracksInput {
        return DescribeClusterTracksInput(
            maintenanceTrackName: self.maintenanceTrackName,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeClusterTracksInput, OperationStackOutput == DescribeClusterTracksOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeClusterTracksPaginated`
    /// to access the nested member `[RedshiftClientTypes.MaintenanceTrack]`
    /// - Returns: `[RedshiftClientTypes.MaintenanceTrack]`
    public func maintenanceTracks() async throws -> [RedshiftClientTypes.MaintenanceTrack] {
        return try await self.asyncCompactMap { item in item.maintenanceTracks }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeClusterVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClusterVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClusterVersionsOutput`
    public func describeClusterVersionsPaginated(input: DescribeClusterVersionsInput) -> ClientRuntime.PaginatorSequence<DescribeClusterVersionsInput, DescribeClusterVersionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeClusterVersionsInput, DescribeClusterVersionsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeClusterVersions(input:))
    }
}

extension DescribeClusterVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClusterVersionsInput {
        return DescribeClusterVersionsInput(
            clusterParameterGroupFamily: self.clusterParameterGroupFamily,
            clusterVersion: self.clusterVersion,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeClusterVersionsInput, OperationStackOutput == DescribeClusterVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeClusterVersionsPaginated`
    /// to access the nested member `[RedshiftClientTypes.ClusterVersion]`
    /// - Returns: `[RedshiftClientTypes.ClusterVersion]`
    public func clusterVersions() async throws -> [RedshiftClientTypes.ClusterVersion] {
        return try await self.asyncCompactMap { item in item.clusterVersions }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeCustomDomainAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeCustomDomainAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeCustomDomainAssociationsOutput`
    public func describeCustomDomainAssociationsPaginated(input: DescribeCustomDomainAssociationsInput) -> ClientRuntime.PaginatorSequence<DescribeCustomDomainAssociationsInput, DescribeCustomDomainAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeCustomDomainAssociationsInput, DescribeCustomDomainAssociationsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeCustomDomainAssociations(input:))
    }
}

extension DescribeCustomDomainAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeCustomDomainAssociationsInput {
        return DescribeCustomDomainAssociationsInput(
            customDomainCertificateArn: self.customDomainCertificateArn,
            customDomainName: self.customDomainName,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeCustomDomainAssociationsInput, OperationStackOutput == DescribeCustomDomainAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeCustomDomainAssociationsPaginated`
    /// to access the nested member `[RedshiftClientTypes.Association]`
    /// - Returns: `[RedshiftClientTypes.Association]`
    public func associations() async throws -> [RedshiftClientTypes.Association] {
        return try await self.asyncCompactMap { item in item.associations }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeDataSharesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDataSharesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDataSharesOutput`
    public func describeDataSharesPaginated(input: DescribeDataSharesInput) -> ClientRuntime.PaginatorSequence<DescribeDataSharesInput, DescribeDataSharesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDataSharesInput, DescribeDataSharesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDataShares(input:))
    }
}

extension DescribeDataSharesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDataSharesInput {
        return DescribeDataSharesInput(
            dataShareArn: self.dataShareArn,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDataSharesInput, OperationStackOutput == DescribeDataSharesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDataSharesPaginated`
    /// to access the nested member `[RedshiftClientTypes.DataShare]`
    /// - Returns: `[RedshiftClientTypes.DataShare]`
    public func dataShares() async throws -> [RedshiftClientTypes.DataShare] {
        return try await self.asyncCompactMap { item in item.dataShares }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeDataSharesForConsumerOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDataSharesForConsumerInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDataSharesForConsumerOutput`
    public func describeDataSharesForConsumerPaginated(input: DescribeDataSharesForConsumerInput) -> ClientRuntime.PaginatorSequence<DescribeDataSharesForConsumerInput, DescribeDataSharesForConsumerOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDataSharesForConsumerInput, DescribeDataSharesForConsumerOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDataSharesForConsumer(input:))
    }
}

extension DescribeDataSharesForConsumerInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDataSharesForConsumerInput {
        return DescribeDataSharesForConsumerInput(
            consumerArn: self.consumerArn,
            marker: token,
            maxRecords: self.maxRecords,
            status: self.status
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDataSharesForConsumerInput, OperationStackOutput == DescribeDataSharesForConsumerOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDataSharesForConsumerPaginated`
    /// to access the nested member `[RedshiftClientTypes.DataShare]`
    /// - Returns: `[RedshiftClientTypes.DataShare]`
    public func dataShares() async throws -> [RedshiftClientTypes.DataShare] {
        return try await self.asyncCompactMap { item in item.dataShares }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeDataSharesForProducerOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDataSharesForProducerInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDataSharesForProducerOutput`
    public func describeDataSharesForProducerPaginated(input: DescribeDataSharesForProducerInput) -> ClientRuntime.PaginatorSequence<DescribeDataSharesForProducerInput, DescribeDataSharesForProducerOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDataSharesForProducerInput, DescribeDataSharesForProducerOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeDataSharesForProducer(input:))
    }
}

extension DescribeDataSharesForProducerInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDataSharesForProducerInput {
        return DescribeDataSharesForProducerInput(
            marker: token,
            maxRecords: self.maxRecords,
            producerArn: self.producerArn,
            status: self.status
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDataSharesForProducerInput, OperationStackOutput == DescribeDataSharesForProducerOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDataSharesForProducerPaginated`
    /// to access the nested member `[RedshiftClientTypes.DataShare]`
    /// - Returns: `[RedshiftClientTypes.DataShare]`
    public func dataShares() async throws -> [RedshiftClientTypes.DataShare] {
        return try await self.asyncCompactMap { item in item.dataShares }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeDefaultClusterParametersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeDefaultClusterParametersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeDefaultClusterParametersOutput`
    public func describeDefaultClusterParametersPaginated(input: DescribeDefaultClusterParametersInput) -> ClientRuntime.PaginatorSequence<DescribeDefaultClusterParametersInput, DescribeDefaultClusterParametersOutput> {
        return ClientRuntime.PaginatorSequence<DescribeDefaultClusterParametersInput, DescribeDefaultClusterParametersOutput>(input: input, inputKey: \.marker, outputKey: \.defaultClusterParameters?.marker, paginationFunction: self.describeDefaultClusterParameters(input:))
    }
}

extension DescribeDefaultClusterParametersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeDefaultClusterParametersInput {
        return DescribeDefaultClusterParametersInput(
            marker: token,
            maxRecords: self.maxRecords,
            parameterGroupFamily: self.parameterGroupFamily
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeDefaultClusterParametersInput, OperationStackOutput == DescribeDefaultClusterParametersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeDefaultClusterParametersPaginated`
    /// to access the nested member `[RedshiftClientTypes.Parameter]`
    /// - Returns: `[RedshiftClientTypes.Parameter]`
    public func parameters() async throws -> [RedshiftClientTypes.Parameter] {
        return try await self.asyncCompactMap { item in item.defaultClusterParameters?.parameters }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeEndpointAccessOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEndpointAccessInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEndpointAccessOutput`
    public func describeEndpointAccessPaginated(input: DescribeEndpointAccessInput) -> ClientRuntime.PaginatorSequence<DescribeEndpointAccessInput, DescribeEndpointAccessOutput> {
        return ClientRuntime.PaginatorSequence<DescribeEndpointAccessInput, DescribeEndpointAccessOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeEndpointAccess(input:))
    }
}

extension DescribeEndpointAccessInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEndpointAccessInput {
        return DescribeEndpointAccessInput(
            clusterIdentifier: self.clusterIdentifier,
            endpointName: self.endpointName,
            marker: token,
            maxRecords: self.maxRecords,
            resourceOwner: self.resourceOwner,
            vpcId: self.vpcId
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeEndpointAccessInput, OperationStackOutput == DescribeEndpointAccessOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeEndpointAccessPaginated`
    /// to access the nested member `[RedshiftClientTypes.EndpointAccess]`
    /// - Returns: `[RedshiftClientTypes.EndpointAccess]`
    public func endpointAccessList() async throws -> [RedshiftClientTypes.EndpointAccess] {
        return try await self.asyncCompactMap { item in item.endpointAccessList }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeEndpointAuthorizationOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEndpointAuthorizationInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEndpointAuthorizationOutput`
    public func describeEndpointAuthorizationPaginated(input: DescribeEndpointAuthorizationInput) -> ClientRuntime.PaginatorSequence<DescribeEndpointAuthorizationInput, DescribeEndpointAuthorizationOutput> {
        return ClientRuntime.PaginatorSequence<DescribeEndpointAuthorizationInput, DescribeEndpointAuthorizationOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeEndpointAuthorization(input:))
    }
}

extension DescribeEndpointAuthorizationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEndpointAuthorizationInput {
        return DescribeEndpointAuthorizationInput(
            account: self.account,
            clusterIdentifier: self.clusterIdentifier,
            grantee: self.grantee,
            marker: token,
            maxRecords: self.maxRecords
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeEndpointAuthorizationInput, OperationStackOutput == DescribeEndpointAuthorizationOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeEndpointAuthorizationPaginated`
    /// to access the nested member `[RedshiftClientTypes.EndpointAuthorization]`
    /// - Returns: `[RedshiftClientTypes.EndpointAuthorization]`
    public func endpointAuthorizationList() async throws -> [RedshiftClientTypes.EndpointAuthorization] {
        return try await self.asyncCompactMap { item in item.endpointAuthorizationList }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeEventsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEventsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEventsOutput`
    public func describeEventsPaginated(input: DescribeEventsInput) -> ClientRuntime.PaginatorSequence<DescribeEventsInput, DescribeEventsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeEventsInput, DescribeEventsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeEvents(input:))
    }
}

extension DescribeEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventsInput {
        return DescribeEventsInput(
            duration: self.duration,
            endTime: self.endTime,
            marker: token,
            maxRecords: self.maxRecords,
            sourceIdentifier: self.sourceIdentifier,
            sourceType: self.sourceType,
            startTime: self.startTime
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeEventsInput, OperationStackOutput == DescribeEventsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeEventsPaginated`
    /// to access the nested member `[RedshiftClientTypes.Event]`
    /// - Returns: `[RedshiftClientTypes.Event]`
    public func events() async throws -> [RedshiftClientTypes.Event] {
        return try await self.asyncCompactMap { item in item.events }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeEventSubscriptionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEventSubscriptionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEventSubscriptionsOutput`
    public func describeEventSubscriptionsPaginated(input: DescribeEventSubscriptionsInput) -> ClientRuntime.PaginatorSequence<DescribeEventSubscriptionsInput, DescribeEventSubscriptionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeEventSubscriptionsInput, DescribeEventSubscriptionsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeEventSubscriptions(input:))
    }
}

extension DescribeEventSubscriptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventSubscriptionsInput {
        return DescribeEventSubscriptionsInput(
            marker: token,
            maxRecords: self.maxRecords,
            subscriptionName: self.subscriptionName,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeEventSubscriptionsInput, OperationStackOutput == DescribeEventSubscriptionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeEventSubscriptionsPaginated`
    /// to access the nested member `[RedshiftClientTypes.EventSubscription]`
    /// - Returns: `[RedshiftClientTypes.EventSubscription]`
    public func eventSubscriptionsList() async throws -> [RedshiftClientTypes.EventSubscription] {
        return try await self.asyncCompactMap { item in item.eventSubscriptionsList }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeHsmClientCertificatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeHsmClientCertificatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeHsmClientCertificatesOutput`
    public func describeHsmClientCertificatesPaginated(input: DescribeHsmClientCertificatesInput) -> ClientRuntime.PaginatorSequence<DescribeHsmClientCertificatesInput, DescribeHsmClientCertificatesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeHsmClientCertificatesInput, DescribeHsmClientCertificatesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeHsmClientCertificates(input:))
    }
}

extension DescribeHsmClientCertificatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeHsmClientCertificatesInput {
        return DescribeHsmClientCertificatesInput(
            hsmClientCertificateIdentifier: self.hsmClientCertificateIdentifier,
            marker: token,
            maxRecords: self.maxRecords,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeHsmClientCertificatesInput, OperationStackOutput == DescribeHsmClientCertificatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeHsmClientCertificatesPaginated`
    /// to access the nested member `[RedshiftClientTypes.HsmClientCertificate]`
    /// - Returns: `[RedshiftClientTypes.HsmClientCertificate]`
    public func hsmClientCertificates() async throws -> [RedshiftClientTypes.HsmClientCertificate] {
        return try await self.asyncCompactMap { item in item.hsmClientCertificates }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeHsmConfigurationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeHsmConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeHsmConfigurationsOutput`
    public func describeHsmConfigurationsPaginated(input: DescribeHsmConfigurationsInput) -> ClientRuntime.PaginatorSequence<DescribeHsmConfigurationsInput, DescribeHsmConfigurationsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeHsmConfigurationsInput, DescribeHsmConfigurationsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeHsmConfigurations(input:))
    }
}

extension DescribeHsmConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeHsmConfigurationsInput {
        return DescribeHsmConfigurationsInput(
            hsmConfigurationIdentifier: self.hsmConfigurationIdentifier,
            marker: token,
            maxRecords: self.maxRecords,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeHsmConfigurationsInput, OperationStackOutput == DescribeHsmConfigurationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeHsmConfigurationsPaginated`
    /// to access the nested member `[RedshiftClientTypes.HsmConfiguration]`
    /// - Returns: `[RedshiftClientTypes.HsmConfiguration]`
    public func hsmConfigurations() async throws -> [RedshiftClientTypes.HsmConfiguration] {
        return try await self.asyncCompactMap { item in item.hsmConfigurations }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeInboundIntegrationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeInboundIntegrationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeInboundIntegrationsOutput`
    public func describeInboundIntegrationsPaginated(input: DescribeInboundIntegrationsInput) -> ClientRuntime.PaginatorSequence<DescribeInboundIntegrationsInput, DescribeInboundIntegrationsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeInboundIntegrationsInput, DescribeInboundIntegrationsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeInboundIntegrations(input:))
    }
}

extension DescribeInboundIntegrationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInboundIntegrationsInput {
        return DescribeInboundIntegrationsInput(
            integrationArn: self.integrationArn,
            marker: token,
            maxRecords: self.maxRecords,
            targetArn: self.targetArn
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeInboundIntegrationsInput, OperationStackOutput == DescribeInboundIntegrationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeInboundIntegrationsPaginated`
    /// to access the nested member `[RedshiftClientTypes.InboundIntegration]`
    /// - Returns: `[RedshiftClientTypes.InboundIntegration]`
    public func inboundIntegrations() async throws -> [RedshiftClientTypes.InboundIntegration] {
        return try await self.asyncCompactMap { item in item.inboundIntegrations }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeNodeConfigurationOptionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeNodeConfigurationOptionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeNodeConfigurationOptionsOutput`
    public func describeNodeConfigurationOptionsPaginated(input: DescribeNodeConfigurationOptionsInput) -> ClientRuntime.PaginatorSequence<DescribeNodeConfigurationOptionsInput, DescribeNodeConfigurationOptionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeNodeConfigurationOptionsInput, DescribeNodeConfigurationOptionsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeNodeConfigurationOptions(input:))
    }
}

extension DescribeNodeConfigurationOptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeNodeConfigurationOptionsInput {
        return DescribeNodeConfigurationOptionsInput(
            actionType: self.actionType,
            clusterIdentifier: self.clusterIdentifier,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            ownerAccount: self.ownerAccount,
            snapshotArn: self.snapshotArn,
            snapshotIdentifier: self.snapshotIdentifier
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeNodeConfigurationOptionsInput, OperationStackOutput == DescribeNodeConfigurationOptionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeNodeConfigurationOptionsPaginated`
    /// to access the nested member `[RedshiftClientTypes.NodeConfigurationOption]`
    /// - Returns: `[RedshiftClientTypes.NodeConfigurationOption]`
    public func nodeConfigurationOptionList() async throws -> [RedshiftClientTypes.NodeConfigurationOption] {
        return try await self.asyncCompactMap { item in item.nodeConfigurationOptionList }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeOrderableClusterOptionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeOrderableClusterOptionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeOrderableClusterOptionsOutput`
    public func describeOrderableClusterOptionsPaginated(input: DescribeOrderableClusterOptionsInput) -> ClientRuntime.PaginatorSequence<DescribeOrderableClusterOptionsInput, DescribeOrderableClusterOptionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeOrderableClusterOptionsInput, DescribeOrderableClusterOptionsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeOrderableClusterOptions(input:))
    }
}

extension DescribeOrderableClusterOptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeOrderableClusterOptionsInput {
        return DescribeOrderableClusterOptionsInput(
            clusterVersion: self.clusterVersion,
            marker: token,
            maxRecords: self.maxRecords,
            nodeType: self.nodeType
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeOrderableClusterOptionsInput, OperationStackOutput == DescribeOrderableClusterOptionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeOrderableClusterOptionsPaginated`
    /// to access the nested member `[RedshiftClientTypes.OrderableClusterOption]`
    /// - Returns: `[RedshiftClientTypes.OrderableClusterOption]`
    public func orderableClusterOptions() async throws -> [RedshiftClientTypes.OrderableClusterOption] {
        return try await self.asyncCompactMap { item in item.orderableClusterOptions }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeRedshiftIdcApplicationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeRedshiftIdcApplicationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeRedshiftIdcApplicationsOutput`
    public func describeRedshiftIdcApplicationsPaginated(input: DescribeRedshiftIdcApplicationsInput) -> ClientRuntime.PaginatorSequence<DescribeRedshiftIdcApplicationsInput, DescribeRedshiftIdcApplicationsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeRedshiftIdcApplicationsInput, DescribeRedshiftIdcApplicationsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeRedshiftIdcApplications(input:))
    }
}

extension DescribeRedshiftIdcApplicationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeRedshiftIdcApplicationsInput {
        return DescribeRedshiftIdcApplicationsInput(
            marker: token,
            maxRecords: self.maxRecords,
            redshiftIdcApplicationArn: self.redshiftIdcApplicationArn
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeRedshiftIdcApplicationsInput, OperationStackOutput == DescribeRedshiftIdcApplicationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeRedshiftIdcApplicationsPaginated`
    /// to access the nested member `[RedshiftClientTypes.RedshiftIdcApplication]`
    /// - Returns: `[RedshiftClientTypes.RedshiftIdcApplication]`
    public func redshiftIdcApplications() async throws -> [RedshiftClientTypes.RedshiftIdcApplication] {
        return try await self.asyncCompactMap { item in item.redshiftIdcApplications }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeReservedNodeExchangeStatusOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReservedNodeExchangeStatusInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReservedNodeExchangeStatusOutput`
    public func describeReservedNodeExchangeStatusPaginated(input: DescribeReservedNodeExchangeStatusInput) -> ClientRuntime.PaginatorSequence<DescribeReservedNodeExchangeStatusInput, DescribeReservedNodeExchangeStatusOutput> {
        return ClientRuntime.PaginatorSequence<DescribeReservedNodeExchangeStatusInput, DescribeReservedNodeExchangeStatusOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeReservedNodeExchangeStatus(input:))
    }
}

extension DescribeReservedNodeExchangeStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReservedNodeExchangeStatusInput {
        return DescribeReservedNodeExchangeStatusInput(
            marker: token,
            maxRecords: self.maxRecords,
            reservedNodeExchangeRequestId: self.reservedNodeExchangeRequestId,
            reservedNodeId: self.reservedNodeId
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeReservedNodeExchangeStatusInput, OperationStackOutput == DescribeReservedNodeExchangeStatusOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeReservedNodeExchangeStatusPaginated`
    /// to access the nested member `[RedshiftClientTypes.ReservedNodeExchangeStatus]`
    /// - Returns: `[RedshiftClientTypes.ReservedNodeExchangeStatus]`
    public func reservedNodeExchangeStatusDetails() async throws -> [RedshiftClientTypes.ReservedNodeExchangeStatus] {
        return try await self.asyncCompactMap { item in item.reservedNodeExchangeStatusDetails }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeReservedNodeOfferingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReservedNodeOfferingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReservedNodeOfferingsOutput`
    public func describeReservedNodeOfferingsPaginated(input: DescribeReservedNodeOfferingsInput) -> ClientRuntime.PaginatorSequence<DescribeReservedNodeOfferingsInput, DescribeReservedNodeOfferingsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeReservedNodeOfferingsInput, DescribeReservedNodeOfferingsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeReservedNodeOfferings(input:))
    }
}

extension DescribeReservedNodeOfferingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReservedNodeOfferingsInput {
        return DescribeReservedNodeOfferingsInput(
            marker: token,
            maxRecords: self.maxRecords,
            reservedNodeOfferingId: self.reservedNodeOfferingId
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeReservedNodeOfferingsInput, OperationStackOutput == DescribeReservedNodeOfferingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeReservedNodeOfferingsPaginated`
    /// to access the nested member `[RedshiftClientTypes.ReservedNodeOffering]`
    /// - Returns: `[RedshiftClientTypes.ReservedNodeOffering]`
    public func reservedNodeOfferings() async throws -> [RedshiftClientTypes.ReservedNodeOffering] {
        return try await self.asyncCompactMap { item in item.reservedNodeOfferings }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeReservedNodesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReservedNodesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReservedNodesOutput`
    public func describeReservedNodesPaginated(input: DescribeReservedNodesInput) -> ClientRuntime.PaginatorSequence<DescribeReservedNodesInput, DescribeReservedNodesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeReservedNodesInput, DescribeReservedNodesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeReservedNodes(input:))
    }
}

extension DescribeReservedNodesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReservedNodesInput {
        return DescribeReservedNodesInput(
            marker: token,
            maxRecords: self.maxRecords,
            reservedNodeId: self.reservedNodeId
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeReservedNodesInput, OperationStackOutput == DescribeReservedNodesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeReservedNodesPaginated`
    /// to access the nested member `[RedshiftClientTypes.ReservedNode]`
    /// - Returns: `[RedshiftClientTypes.ReservedNode]`
    public func reservedNodes() async throws -> [RedshiftClientTypes.ReservedNode] {
        return try await self.asyncCompactMap { item in item.reservedNodes }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeScheduledActionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeScheduledActionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeScheduledActionsOutput`
    public func describeScheduledActionsPaginated(input: DescribeScheduledActionsInput) -> ClientRuntime.PaginatorSequence<DescribeScheduledActionsInput, DescribeScheduledActionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeScheduledActionsInput, DescribeScheduledActionsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeScheduledActions(input:))
    }
}

extension DescribeScheduledActionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeScheduledActionsInput {
        return DescribeScheduledActionsInput(
            active: self.active,
            endTime: self.endTime,
            filters: self.filters,
            marker: token,
            maxRecords: self.maxRecords,
            scheduledActionName: self.scheduledActionName,
            startTime: self.startTime,
            targetActionType: self.targetActionType
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeScheduledActionsInput, OperationStackOutput == DescribeScheduledActionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeScheduledActionsPaginated`
    /// to access the nested member `[RedshiftClientTypes.ScheduledAction]`
    /// - Returns: `[RedshiftClientTypes.ScheduledAction]`
    public func scheduledActions() async throws -> [RedshiftClientTypes.ScheduledAction] {
        return try await self.asyncCompactMap { item in item.scheduledActions }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeSnapshotCopyGrantsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeSnapshotCopyGrantsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeSnapshotCopyGrantsOutput`
    public func describeSnapshotCopyGrantsPaginated(input: DescribeSnapshotCopyGrantsInput) -> ClientRuntime.PaginatorSequence<DescribeSnapshotCopyGrantsInput, DescribeSnapshotCopyGrantsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeSnapshotCopyGrantsInput, DescribeSnapshotCopyGrantsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeSnapshotCopyGrants(input:))
    }
}

extension DescribeSnapshotCopyGrantsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSnapshotCopyGrantsInput {
        return DescribeSnapshotCopyGrantsInput(
            marker: token,
            maxRecords: self.maxRecords,
            snapshotCopyGrantName: self.snapshotCopyGrantName,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeSnapshotCopyGrantsInput, OperationStackOutput == DescribeSnapshotCopyGrantsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeSnapshotCopyGrantsPaginated`
    /// to access the nested member `[RedshiftClientTypes.SnapshotCopyGrant]`
    /// - Returns: `[RedshiftClientTypes.SnapshotCopyGrant]`
    public func snapshotCopyGrants() async throws -> [RedshiftClientTypes.SnapshotCopyGrant] {
        return try await self.asyncCompactMap { item in item.snapshotCopyGrants }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeSnapshotSchedulesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeSnapshotSchedulesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeSnapshotSchedulesOutput`
    public func describeSnapshotSchedulesPaginated(input: DescribeSnapshotSchedulesInput) -> ClientRuntime.PaginatorSequence<DescribeSnapshotSchedulesInput, DescribeSnapshotSchedulesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeSnapshotSchedulesInput, DescribeSnapshotSchedulesOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeSnapshotSchedules(input:))
    }
}

extension DescribeSnapshotSchedulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSnapshotSchedulesInput {
        return DescribeSnapshotSchedulesInput(
            clusterIdentifier: self.clusterIdentifier,
            marker: token,
            maxRecords: self.maxRecords,
            scheduleIdentifier: self.scheduleIdentifier,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeSnapshotSchedulesInput, OperationStackOutput == DescribeSnapshotSchedulesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeSnapshotSchedulesPaginated`
    /// to access the nested member `[RedshiftClientTypes.SnapshotSchedule]`
    /// - Returns: `[RedshiftClientTypes.SnapshotSchedule]`
    public func snapshotSchedules() async throws -> [RedshiftClientTypes.SnapshotSchedule] {
        return try await self.asyncCompactMap { item in item.snapshotSchedules }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeTableRestoreStatusOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeTableRestoreStatusInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeTableRestoreStatusOutput`
    public func describeTableRestoreStatusPaginated(input: DescribeTableRestoreStatusInput) -> ClientRuntime.PaginatorSequence<DescribeTableRestoreStatusInput, DescribeTableRestoreStatusOutput> {
        return ClientRuntime.PaginatorSequence<DescribeTableRestoreStatusInput, DescribeTableRestoreStatusOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeTableRestoreStatus(input:))
    }
}

extension DescribeTableRestoreStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTableRestoreStatusInput {
        return DescribeTableRestoreStatusInput(
            clusterIdentifier: self.clusterIdentifier,
            marker: token,
            maxRecords: self.maxRecords,
            tableRestoreRequestId: self.tableRestoreRequestId
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeTableRestoreStatusInput, OperationStackOutput == DescribeTableRestoreStatusOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeTableRestoreStatusPaginated`
    /// to access the nested member `[RedshiftClientTypes.TableRestoreStatus]`
    /// - Returns: `[RedshiftClientTypes.TableRestoreStatus]`
    public func tableRestoreStatusDetails() async throws -> [RedshiftClientTypes.TableRestoreStatus] {
        return try await self.asyncCompactMap { item in item.tableRestoreStatusDetails }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeTagsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeTagsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeTagsOutput`
    public func describeTagsPaginated(input: DescribeTagsInput) -> ClientRuntime.PaginatorSequence<DescribeTagsInput, DescribeTagsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeTagsInput, DescribeTagsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeTags(input:))
    }
}

extension DescribeTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTagsInput {
        return DescribeTagsInput(
            marker: token,
            maxRecords: self.maxRecords,
            resourceName: self.resourceName,
            resourceType: self.resourceType,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeTagsInput, OperationStackOutput == DescribeTagsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeTagsPaginated`
    /// to access the nested member `[RedshiftClientTypes.TaggedResource]`
    /// - Returns: `[RedshiftClientTypes.TaggedResource]`
    public func taggedResources() async throws -> [RedshiftClientTypes.TaggedResource] {
        return try await self.asyncCompactMap { item in item.taggedResources }
    }
}
extension RedshiftClient {
    /// Paginate over `[DescribeUsageLimitsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeUsageLimitsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeUsageLimitsOutput`
    public func describeUsageLimitsPaginated(input: DescribeUsageLimitsInput) -> ClientRuntime.PaginatorSequence<DescribeUsageLimitsInput, DescribeUsageLimitsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeUsageLimitsInput, DescribeUsageLimitsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.describeUsageLimits(input:))
    }
}

extension DescribeUsageLimitsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeUsageLimitsInput {
        return DescribeUsageLimitsInput(
            clusterIdentifier: self.clusterIdentifier,
            featureType: self.featureType,
            marker: token,
            maxRecords: self.maxRecords,
            tagKeys: self.tagKeys,
            tagValues: self.tagValues,
            usageLimitId: self.usageLimitId
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeUsageLimitsInput, OperationStackOutput == DescribeUsageLimitsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeUsageLimitsPaginated`
    /// to access the nested member `[RedshiftClientTypes.UsageLimit]`
    /// - Returns: `[RedshiftClientTypes.UsageLimit]`
    public func usageLimits() async throws -> [RedshiftClientTypes.UsageLimit] {
        return try await self.asyncCompactMap { item in item.usageLimits }
    }
}
extension RedshiftClient {
    /// Paginate over `[GetReservedNodeExchangeConfigurationOptionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetReservedNodeExchangeConfigurationOptionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetReservedNodeExchangeConfigurationOptionsOutput`
    public func getReservedNodeExchangeConfigurationOptionsPaginated(input: GetReservedNodeExchangeConfigurationOptionsInput) -> ClientRuntime.PaginatorSequence<GetReservedNodeExchangeConfigurationOptionsInput, GetReservedNodeExchangeConfigurationOptionsOutput> {
        return ClientRuntime.PaginatorSequence<GetReservedNodeExchangeConfigurationOptionsInput, GetReservedNodeExchangeConfigurationOptionsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.getReservedNodeExchangeConfigurationOptions(input:))
    }
}

extension GetReservedNodeExchangeConfigurationOptionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetReservedNodeExchangeConfigurationOptionsInput {
        return GetReservedNodeExchangeConfigurationOptionsInput(
            actionType: self.actionType,
            clusterIdentifier: self.clusterIdentifier,
            marker: token,
            maxRecords: self.maxRecords,
            snapshotIdentifier: self.snapshotIdentifier
        )}
}

extension PaginatorSequence where OperationStackInput == GetReservedNodeExchangeConfigurationOptionsInput, OperationStackOutput == GetReservedNodeExchangeConfigurationOptionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getReservedNodeExchangeConfigurationOptionsPaginated`
    /// to access the nested member `[RedshiftClientTypes.ReservedNodeConfigurationOption]`
    /// - Returns: `[RedshiftClientTypes.ReservedNodeConfigurationOption]`
    public func reservedNodeConfigurationOptionList() async throws -> [RedshiftClientTypes.ReservedNodeConfigurationOption] {
        return try await self.asyncCompactMap { item in item.reservedNodeConfigurationOptionList }
    }
}
extension RedshiftClient {
    /// Paginate over `[GetReservedNodeExchangeOfferingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetReservedNodeExchangeOfferingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetReservedNodeExchangeOfferingsOutput`
    public func getReservedNodeExchangeOfferingsPaginated(input: GetReservedNodeExchangeOfferingsInput) -> ClientRuntime.PaginatorSequence<GetReservedNodeExchangeOfferingsInput, GetReservedNodeExchangeOfferingsOutput> {
        return ClientRuntime.PaginatorSequence<GetReservedNodeExchangeOfferingsInput, GetReservedNodeExchangeOfferingsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.getReservedNodeExchangeOfferings(input:))
    }
}

extension GetReservedNodeExchangeOfferingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetReservedNodeExchangeOfferingsInput {
        return GetReservedNodeExchangeOfferingsInput(
            marker: token,
            maxRecords: self.maxRecords,
            reservedNodeId: self.reservedNodeId
        )}
}

extension PaginatorSequence where OperationStackInput == GetReservedNodeExchangeOfferingsInput, OperationStackOutput == GetReservedNodeExchangeOfferingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getReservedNodeExchangeOfferingsPaginated`
    /// to access the nested member `[RedshiftClientTypes.ReservedNodeOffering]`
    /// - Returns: `[RedshiftClientTypes.ReservedNodeOffering]`
    public func reservedNodeOfferings() async throws -> [RedshiftClientTypes.ReservedNodeOffering] {
        return try await self.asyncCompactMap { item in item.reservedNodeOfferings }
    }
}
extension RedshiftClient {
    /// Paginate over `[ListRecommendationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRecommendationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRecommendationsOutput`
    public func listRecommendationsPaginated(input: ListRecommendationsInput) -> ClientRuntime.PaginatorSequence<ListRecommendationsInput, ListRecommendationsOutput> {
        return ClientRuntime.PaginatorSequence<ListRecommendationsInput, ListRecommendationsOutput>(input: input, inputKey: \.marker, outputKey: \.marker, paginationFunction: self.listRecommendations(input:))
    }
}

extension ListRecommendationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRecommendationsInput {
        return ListRecommendationsInput(
            clusterIdentifier: self.clusterIdentifier,
            marker: token,
            maxRecords: self.maxRecords,
            namespaceArn: self.namespaceArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListRecommendationsInput, OperationStackOutput == ListRecommendationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRecommendationsPaginated`
    /// to access the nested member `[RedshiftClientTypes.Recommendation]`
    /// - Returns: `[RedshiftClientTypes.Recommendation]`
    public func recommendations() async throws -> [RedshiftClientTypes.Recommendation] {
        return try await self.asyncCompactMap { item in item.recommendations }
    }
}
