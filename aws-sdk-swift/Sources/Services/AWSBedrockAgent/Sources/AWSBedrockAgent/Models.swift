//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// The request is denied because of missing access permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockAgentClientTypes {

    public enum CustomControlMethod: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case returnControl
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomControlMethod] {
            return [
                .returnControl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .returnControl: return "RETURN_CONTROL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
    public enum ActionGroupExecutor: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action.
        case lambda(Swift.String)
        /// To return the action group invocation results directly in the InvokeAgent response, specify RETURN_CONTROL.
        case customcontrol(BedrockAgentClientTypes.CustomControlMethod)
        case sdkUnknown(Swift.String)
    }
}

/// There was a conflict performing an operation.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource Amazon Resource Name (ARN) was not found. Check the Amazon Resource Name (ARN) and try your request again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of requests exceeds the service quota. Resubmit your request later.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of requests exceeds the limit. Resubmit your request later.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BedrockAgentClientTypes {

    /// Stores information about a field passed inside a request that resulted in an validation error.
    public struct ValidationExceptionField: Swift.Sendable {
        /// A message describing why this field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

/// Input validation failed. Check your request parameters and retry the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A list of objects containing fields that caused validation errors and their corresponding validation error messages.
        public internal(set) var fieldList: [BedrockAgentClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [BedrockAgentClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
    }
}

extension BedrockAgentClientTypes {

    public enum ActionGroupState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionGroupState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// The identifier information for an Amazon S3 bucket.
    public struct S3Identifier: Swift.Sendable {
        /// The name of the S3 bucket.
        public var s3BucketName: Swift.String?
        /// The S3 object key for the S3 resource.
        public var s3ObjectKey: Swift.String?

        public init(
            s3BucketName: Swift.String? = nil,
            s3ObjectKey: Swift.String? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3ObjectKey = s3ObjectKey
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about the OpenAPI schema for the action group. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html). You can either include the schema directly in the payload field or you can upload it to an S3 bucket and specify the S3 bucket location in the s3 field.
    public enum APISchema: Swift.Sendable {
        /// Contains details about the S3 object containing the OpenAPI schema for the action group. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html).
        case s3(BedrockAgentClientTypes.S3Identifier)
        /// The JSON or YAML-formatted payload defining the OpenAPI schema for the action group. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html).
        case payload(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentClientTypes {

    public enum ModelType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case array
        case boolean
        case integer
        case number
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .array,
                .boolean,
                .integer,
                .number,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .array: return "array"
            case .boolean: return "boolean"
            case .integer: return "integer"
            case .number: return "number"
            case .string: return "string"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about a parameter in a function for an action group. This data type is used in the following API operations:
    ///
    /// * [CreateAgentActionGroup request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_RequestSyntax)
    ///
    /// * [CreateAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_ResponseSyntax)
    ///
    /// * [UpdateAgentActionGroup request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_RequestSyntax)
    ///
    /// * [UpdateAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_ResponseSyntax)
    ///
    /// * [GetAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_GetAgentActionGroup.html#API_agent_GetAgentActionGroup_ResponseSyntax)
    public struct ParameterDetail: Swift.Sendable {
        /// A description of the parameter. Helps the foundation model determine how to elicit the parameters from the user.
        public var description: Swift.String?
        /// Whether the parameter is required for the agent to complete the function for action group invocation.
        public var `required`: Swift.Bool?
        /// The data type of the parameter.
        /// This member is required.
        public var type: BedrockAgentClientTypes.ModelType?

        public init(
            description: Swift.String? = nil,
            `required`: Swift.Bool? = nil,
            type: BedrockAgentClientTypes.ModelType? = nil
        )
        {
            self.description = description
            self.`required` = `required`
            self.type = type
        }
    }
}

extension BedrockAgentClientTypes {

    /// ENUM to check if action requires user confirmation
    public enum RequireConfirmation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [RequireConfirmation] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// Defines parameters that the agent needs to invoke from the user to complete the function. Corresponds to an action in an action group. This data type is used in the following API operations:
    ///
    /// * [CreateAgentActionGroup request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_RequestSyntax)
    ///
    /// * [CreateAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_ResponseSyntax)
    ///
    /// * [UpdateAgentActionGroup request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_RequestSyntax)
    ///
    /// * [UpdateAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_ResponseSyntax)
    ///
    /// * [GetAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_GetAgentActionGroup.html#API_agent_GetAgentActionGroup_ResponseSyntax)
    public struct Function: Swift.Sendable {
        /// A description of the function and its purpose.
        public var description: Swift.String?
        /// A name for the function.
        /// This member is required.
        public var name: Swift.String?
        /// The parameters that the agent elicits from the user to fulfill the function.
        public var parameters: [Swift.String: BedrockAgentClientTypes.ParameterDetail]?
        /// Contains information if user confirmation is required to invoke the function.
        public var requireConfirmation: BedrockAgentClientTypes.RequireConfirmation?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            parameters: [Swift.String: BedrockAgentClientTypes.ParameterDetail]? = nil,
            requireConfirmation: BedrockAgentClientTypes.RequireConfirmation? = nil
        )
        {
            self.description = description
            self.name = name
            self.parameters = parameters
            self.requireConfirmation = requireConfirmation
        }
    }
}

extension BedrockAgentClientTypes {

    /// Defines functions that each define parameters that the agent needs to invoke from the user. Each function represents an action in an action group. This data type is used in the following API operations:
    ///
    /// * [CreateAgentActionGroup request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_RequestSyntax)
    ///
    /// * [CreateAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_CreateAgentActionGroup.html#API_agent_CreateAgentActionGroup_ResponseSyntax)
    ///
    /// * [UpdateAgentActionGroup request](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_RequestSyntax)
    ///
    /// * [UpdateAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_UpdateAgentActionGroup.html#API_agent_UpdateAgentActionGroup_ResponseSyntax)
    ///
    /// * [GetAgentActionGroup response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_GetAgentActionGroup.html#API_agent_GetAgentActionGroup_ResponseSyntax)
    public enum FunctionSchema: Swift.Sendable {
        /// A list of functions that each define an action in the action group.
        case functions([BedrockAgentClientTypes.Function])
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentClientTypes {

    public enum ActionGroupSignature: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonCodeinterpreter
        case amazonUserinput
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionGroupSignature] {
            return [
                .amazonCodeinterpreter,
                .amazonUserinput
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonCodeinterpreter: return "AMAZON.CodeInterpreter"
            case .amazonUserinput: return "AMAZON.UserInput"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateAgentActionGroupInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
    public var actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor?
    /// The name to give the action group.
    /// This member is required.
    public var actionGroupName: Swift.String?
    /// Specifies whether the action group is available for the agent to invoke or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
    public var actionGroupState: BedrockAgentClientTypes.ActionGroupState?
    /// The unique identifier of the agent for which to create the action group.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent for which to create the action group.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html).
    public var apiSchema: BedrockAgentClientTypes.APISchema?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// A description of the action group.
    public var description: Swift.String?
    /// Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
    public var functionSchema: BedrockAgentClientTypes.FunctionSchema?
    /// To allow your agent to request the user for additional information when trying to complete a task, set this field to AMAZON.UserInput. You must leave the description, apiSchema, and actionGroupExecutor fields blank for this action group. To allow your agent to generate, run, and troubleshoot code when trying to complete a task, set this field to AMAZON.CodeInterpreter. You must leave the description, apiSchema, and actionGroupExecutor fields blank for this action group. During orchestration, if your agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an [Observation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Observation.html) reprompting the user for more information.
    public var parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature?

    public init(
        actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor? = nil,
        actionGroupName: Swift.String? = nil,
        actionGroupState: BedrockAgentClientTypes.ActionGroupState? = nil,
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        apiSchema: BedrockAgentClientTypes.APISchema? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        functionSchema: BedrockAgentClientTypes.FunctionSchema? = nil,
        parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature? = nil
    )
    {
        self.actionGroupExecutor = actionGroupExecutor
        self.actionGroupName = actionGroupName
        self.actionGroupState = actionGroupState
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.apiSchema = apiSchema
        self.clientToken = clientToken
        self.description = description
        self.functionSchema = functionSchema
        self.parentActionGroupSignature = parentActionGroupSignature
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about an action group.
    public struct AgentActionGroup: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
        public var actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor?
        /// The unique identifier of the action group.
        /// This member is required.
        public var actionGroupId: Swift.String?
        /// The name of the action group.
        /// This member is required.
        public var actionGroupName: Swift.String?
        /// Specifies whether the action group is available for the agent to invoke or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        /// This member is required.
        public var actionGroupState: BedrockAgentClientTypes.ActionGroupState?
        /// The unique identifier of the agent to which the action group belongs.
        /// This member is required.
        public var agentId: Swift.String?
        /// The version of the agent to which the action group belongs.
        /// This member is required.
        public var agentVersion: Swift.String?
        /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html).
        public var apiSchema: BedrockAgentClientTypes.APISchema?
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
        public var clientToken: Swift.String?
        /// The time at which the action group was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the action group.
        public var description: Swift.String?
        /// Defines functions that each define parameters that the agent needs to invoke from the user. Each function represents an action in an action group.
        public var functionSchema: BedrockAgentClientTypes.FunctionSchema?
        /// If this field is set as AMAZON.UserInput, the agent can request the user for additional information when trying to complete a task. The description, apiSchema, and actionGroupExecutor fields must be blank for this action group. During orchestration, if the agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an [Observation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Observation.html) reprompting the user for more information.
        public var parentActionSignature: BedrockAgentClientTypes.ActionGroupSignature?
        /// The time at which the action group was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor? = nil,
            actionGroupId: Swift.String? = nil,
            actionGroupName: Swift.String? = nil,
            actionGroupState: BedrockAgentClientTypes.ActionGroupState? = nil,
            agentId: Swift.String? = nil,
            agentVersion: Swift.String? = nil,
            apiSchema: BedrockAgentClientTypes.APISchema? = nil,
            clientToken: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            functionSchema: BedrockAgentClientTypes.FunctionSchema? = nil,
            parentActionSignature: BedrockAgentClientTypes.ActionGroupSignature? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.actionGroupExecutor = actionGroupExecutor
            self.actionGroupId = actionGroupId
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.apiSchema = apiSchema
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.functionSchema = functionSchema
            self.parentActionSignature = parentActionSignature
            self.updatedAt = updatedAt
        }
    }
}

public struct CreateAgentActionGroupOutput: Swift.Sendable {
    /// Contains details about the action group that was created.
    /// This member is required.
    public var agentActionGroup: BedrockAgentClientTypes.AgentActionGroup?

    public init(
        agentActionGroup: BedrockAgentClientTypes.AgentActionGroup? = nil
    )
    {
        self.agentActionGroup = agentActionGroup
    }
}

public struct DeleteAgentActionGroupInput: Swift.Sendable {
    /// The unique identifier of the action group to delete.
    /// This member is required.
    public var actionGroupId: Swift.String?
    /// The unique identifier of the agent that the action group belongs to.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent that the action group belongs to.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
    public var skipResourceInUseCheck: Swift.Bool?

    public init(
        actionGroupId: Swift.String? = nil,
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        skipResourceInUseCheck: Swift.Bool? = nil
    )
    {
        self.actionGroupId = actionGroupId
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

public struct DeleteAgentActionGroupOutput: Swift.Sendable {

    public init() { }
}

public struct GetAgentActionGroupInput: Swift.Sendable {
    /// The unique identifier of the action group for which to get information.
    /// This member is required.
    public var actionGroupId: Swift.String?
    /// The unique identifier of the agent that the action group belongs to.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent that the action group belongs to.
    /// This member is required.
    public var agentVersion: Swift.String?

    public init(
        actionGroupId: Swift.String? = nil,
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil
    )
    {
        self.actionGroupId = actionGroupId
        self.agentId = agentId
        self.agentVersion = agentVersion
    }
}

public struct GetAgentActionGroupOutput: Swift.Sendable {
    /// Contains details about the action group.
    /// This member is required.
    public var agentActionGroup: BedrockAgentClientTypes.AgentActionGroup?

    public init(
        agentActionGroup: BedrockAgentClientTypes.AgentActionGroup? = nil
    )
    {
        self.agentActionGroup = agentActionGroup
    }
}

public struct ListAgentActionGroupsInput: Swift.Sendable {
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about an action group.
    public struct ActionGroupSummary: Swift.Sendable {
        /// The unique identifier of the action group.
        /// This member is required.
        public var actionGroupId: Swift.String?
        /// The name of the action group.
        /// This member is required.
        public var actionGroupName: Swift.String?
        /// Specifies whether the action group is available for the agent to invoke or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        /// This member is required.
        public var actionGroupState: BedrockAgentClientTypes.ActionGroupState?
        /// The description of the action group.
        public var description: Swift.String?
        /// The time at which the action group was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            actionGroupId: Swift.String? = nil,
            actionGroupName: Swift.String? = nil,
            actionGroupState: BedrockAgentClientTypes.ActionGroupState? = nil,
            description: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.actionGroupId = actionGroupId
            self.actionGroupName = actionGroupName
            self.actionGroupState = actionGroupState
            self.description = description
            self.updatedAt = updatedAt
        }
    }
}

public struct ListAgentActionGroupsOutput: Swift.Sendable {
    /// A list of objects, each of which contains information about an action group.
    /// This member is required.
    public var actionGroupSummaries: [BedrockAgentClientTypes.ActionGroupSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        actionGroupSummaries: [BedrockAgentClientTypes.ActionGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionGroupSummaries = actionGroupSummaries
        self.nextToken = nextToken
    }
}

public struct UpdateAgentActionGroupInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action.
    public var actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor?
    /// The unique identifier of the action group.
    /// This member is required.
    public var actionGroupId: Swift.String?
    /// Specifies a new name for the action group.
    /// This member is required.
    public var actionGroupName: Swift.String?
    /// Specifies whether the action group is available for the agent to invoke or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
    public var actionGroupState: BedrockAgentClientTypes.ActionGroupState?
    /// The unique identifier of the agent for which to update the action group.
    /// This member is required.
    public var agentId: Swift.String?
    /// The unique identifier of the agent version for which to update the action group.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html).
    public var apiSchema: BedrockAgentClientTypes.APISchema?
    /// Specifies a new name for the action group.
    public var description: Swift.String?
    /// Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
    public var functionSchema: BedrockAgentClientTypes.FunctionSchema?
    /// To allow your agent to request the user for additional information when trying to complete a task, set this field to AMAZON.UserInput. You must leave the description, apiSchema, and actionGroupExecutor fields blank for this action group. During orchestration, if your agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an [Observation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Observation.html) reprompting the user for more information.
    public var parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature?

    public init(
        actionGroupExecutor: BedrockAgentClientTypes.ActionGroupExecutor? = nil,
        actionGroupId: Swift.String? = nil,
        actionGroupName: Swift.String? = nil,
        actionGroupState: BedrockAgentClientTypes.ActionGroupState? = nil,
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        apiSchema: BedrockAgentClientTypes.APISchema? = nil,
        description: Swift.String? = nil,
        functionSchema: BedrockAgentClientTypes.FunctionSchema? = nil,
        parentActionGroupSignature: BedrockAgentClientTypes.ActionGroupSignature? = nil
    )
    {
        self.actionGroupExecutor = actionGroupExecutor
        self.actionGroupId = actionGroupId
        self.actionGroupName = actionGroupName
        self.actionGroupState = actionGroupState
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.apiSchema = apiSchema
        self.description = description
        self.functionSchema = functionSchema
        self.parentActionGroupSignature = parentActionGroupSignature
    }
}

public struct UpdateAgentActionGroupOutput: Swift.Sendable {
    /// Contains details about the action group that was updated.
    /// This member is required.
    public var agentActionGroup: BedrockAgentClientTypes.AgentActionGroup?

    public init(
        agentActionGroup: BedrockAgentClientTypes.AgentActionGroup? = nil
    )
    {
        self.agentActionGroup = agentActionGroup
    }
}

extension BedrockAgentClientTypes {

    public enum AgentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case failed
        case notPrepared
        case prepared
        case preparing
        case updating
        case versioning
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentStatus] {
            return [
                .creating,
                .deleting,
                .failed,
                .notPrepared,
                .prepared,
                .preparing,
                .updating,
                .versioning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .notPrepared: return "NOT_PREPARED"
            case .prepared: return "PREPARED"
            case .preparing: return "PREPARING"
            case .updating: return "UPDATING"
            case .versioning: return "VERSIONING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about a guardrail associated with a resource.
    public struct GuardrailConfiguration: Swift.Sendable {
        /// The unique identifier of the guardrail.
        public var guardrailIdentifier: Swift.String?
        /// The version of the guardrail.
        public var guardrailVersion: Swift.String?

        public init(
            guardrailIdentifier: Swift.String? = nil,
            guardrailVersion: Swift.String? = nil
        )
        {
            self.guardrailIdentifier = guardrailIdentifier
            self.guardrailVersion = guardrailVersion
        }
    }
}

extension BedrockAgentClientTypes {

    public enum MemoryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sessionSummary
        case sdkUnknown(Swift.String)

        public static var allCases: [MemoryType] {
            return [
                .sessionSummary
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sessionSummary: return "SESSION_SUMMARY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details of the memory configuration.
    public struct MemoryConfiguration: Swift.Sendable {
        /// The type of memory that is stored.
        /// This member is required.
        public var enabledMemoryTypes: [BedrockAgentClientTypes.MemoryType]?
        /// The number of days the agent is configured to retain the conversational context.
        public var storageDays: Swift.Int?

        public init(
            enabledMemoryTypes: [BedrockAgentClientTypes.MemoryType]? = nil,
            storageDays: Swift.Int? = 30
        )
        {
            self.enabledMemoryTypes = enabledMemoryTypes
            self.storageDays = storageDays
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the promptType. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
    public struct InferenceConfiguration: Swift.Sendable {
        /// The maximum number of tokens to allow in the generated response.
        public var maximumLength: Swift.Int?
        /// A list of stop sequences. A stop sequence is a sequence of characters that causes the model to stop generating the response.
        public var stopSequences: [Swift.String]?
        /// The likelihood of the model selecting higher-probability options while generating a response. A lower value makes the model more likely to choose higher-probability options, while a higher value makes the model more likely to choose lower-probability options.
        public var temperature: Swift.Float?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for topK is the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topK to 50, the model selects the next token from among the top 50 most likely choices.
        public var topk: Swift.Int?
        /// While generating a response, the model determines the probability of the following token at each point of generation. The value that you set for Top P determines the number of most-likely candidates from which the model chooses the next token in the sequence. For example, if you set topP to 80, the model only selects the next token from the top 80% of the probability distribution of next tokens.
        public var topp: Swift.Float?

        public init(
            maximumLength: Swift.Int? = nil,
            stopSequences: [Swift.String]? = nil,
            temperature: Swift.Float? = nil,
            topk: Swift.Int? = nil,
            topp: Swift.Float? = nil
        )
        {
            self.maximumLength = maximumLength
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topk = topk
            self.topp = topp
        }
    }
}

extension BedrockAgentClientTypes {

    public enum CreationMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case overridden
        case sdkUnknown(Swift.String)

        public static var allCases: [CreationMode] {
            return [
                .default,
                .overridden
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .overridden: return "OVERRIDDEN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    public enum PromptState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PromptState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    public enum PromptType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case knowledgeBaseResponseGeneration
        case orchestration
        case postProcessing
        case preProcessing
        case sdkUnknown(Swift.String)

        public static var allCases: [PromptType] {
            return [
                .knowledgeBaseResponseGeneration,
                .orchestration,
                .postProcessing,
                .preProcessing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .knowledgeBaseResponseGeneration: return "KNOWLEDGE_BASE_RESPONSE_GENERATION"
            case .orchestration: return "ORCHESTRATION"
            case .postProcessing: return "POST_PROCESSING"
            case .preProcessing: return "PRE_PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations to override a prompt template in one part of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
    public struct PromptConfiguration: Swift.Sendable {
        /// Defines the prompt template with which to replace the default prompt template. You can use placeholder variables in the base prompt template to customize the prompt. For more information, see [Prompt template placeholder variables](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-placeholders.html). For more information, see [Configure the prompt templates](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts-configure.html).
        public var basePromptTemplate: Swift.String?
        /// Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the promptType. For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        public var inferenceConfiguration: BedrockAgentClientTypes.InferenceConfiguration?
        /// Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the promptType. If you set the field as OVERRIDEN, the overrideLambda field in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) must be specified with the ARN of a Lambda function.
        public var parserMode: BedrockAgentClientTypes.CreationMode?
        /// Specifies whether to override the default prompt template for this promptType. Set this value to OVERRIDDEN to use the prompt that you provide in the basePromptTemplate. If you leave it as DEFAULT, the agent uses a default prompt template.
        public var promptCreationMode: BedrockAgentClientTypes.CreationMode?
        /// Specifies whether to allow the agent to carry out the step specified in the promptType. If you set this value to DISABLED, the agent skips that step. The default state for each promptType is as follows.
        ///
        /// * PRE_PROCESSING  ENABLED
        ///
        /// * ORCHESTRATION  ENABLED
        ///
        /// * KNOWLEDGE_BASE_RESPONSE_GENERATION  ENABLED
        ///
        /// * POST_PROCESSING  DISABLED
        public var promptState: BedrockAgentClientTypes.PromptState?
        /// The step in the agent sequence that this prompt configuration applies to.
        public var promptType: BedrockAgentClientTypes.PromptType?

        public init(
            basePromptTemplate: Swift.String? = nil,
            inferenceConfiguration: BedrockAgentClientTypes.InferenceConfiguration? = nil,
            parserMode: BedrockAgentClientTypes.CreationMode? = nil,
            promptCreationMode: BedrockAgentClientTypes.CreationMode? = nil,
            promptState: BedrockAgentClientTypes.PromptState? = nil,
            promptType: BedrockAgentClientTypes.PromptType? = nil
        )
        {
            self.basePromptTemplate = basePromptTemplate
            self.inferenceConfiguration = inferenceConfiguration
            self.parserMode = parserMode
            self.promptCreationMode = promptCreationMode
            self.promptState = promptState
            self.promptType = promptType
        }
    }
}

extension BedrockAgentClientTypes.PromptConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PromptConfiguration(inferenceConfiguration: \(Swift.String(describing: inferenceConfiguration)), parserMode: \(Swift.String(describing: parserMode)), promptCreationMode: \(Swift.String(describing: promptCreationMode)), promptState: \(Swift.String(describing: promptState)), promptType: \(Swift.String(describing: promptType)), basePromptTemplate: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentClientTypes {

    /// Contains configurations to override prompts in different parts of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
    public struct PromptOverrideConfiguration: Swift.Sendable {
        /// The ARN of the Lambda function to use when parsing the raw foundation model output in parts of the agent sequence. If you specify this field, at least one of the promptConfigurations must contain a parserMode value that is set to OVERRIDDEN. For more information, see [Parser Lambda function in Amazon Bedrock Agents](https://docs.aws.amazon.com/bedrock/latest/userguide/lambda-parser.html).
        public var overrideLambda: Swift.String?
        /// Contains configurations to override a prompt template in one part of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
        /// This member is required.
        public var promptConfigurations: [BedrockAgentClientTypes.PromptConfiguration]?

        public init(
            overrideLambda: Swift.String? = nil,
            promptConfigurations: [BedrockAgentClientTypes.PromptConfiguration]? = nil
        )
        {
            self.overrideLambda = overrideLambda
            self.promptConfigurations = promptConfigurations
        }
    }
}

extension BedrockAgentClientTypes.PromptOverrideConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about an agent.
    public struct Agent: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the agent.
        /// This member is required.
        public var agentArn: Swift.String?
        /// The unique identifier of the agent.
        /// This member is required.
        public var agentId: Swift.String?
        /// The name of the agent.
        /// This member is required.
        public var agentName: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
        /// This member is required.
        public var agentResourceRoleArn: Swift.String?
        /// The status of the agent and whether it is ready for use. The following statuses are possible:
        ///
        /// * CREATING  The agent is being created.
        ///
        /// * PREPARING  The agent is being prepared.
        ///
        /// * PREPARED  The agent is prepared and ready to be invoked.
        ///
        /// * NOT_PREPARED  The agent has been created but not yet prepared.
        ///
        /// * FAILED  The agent API operation failed.
        ///
        /// * UPDATING  The agent is being updated.
        ///
        /// * DELETING  The agent is being deleted.
        /// This member is required.
        public var agentStatus: BedrockAgentClientTypes.AgentStatus?
        /// The version of the agent.
        /// This member is required.
        public var agentVersion: Swift.String?
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
        public var clientToken: Swift.String?
        /// The time at which the agent was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the KMS key that encrypts the agent.
        public var customerEncryptionKeyArn: Swift.String?
        /// The description of the agent.
        public var description: Swift.String?
        /// Contains reasons that the agent-related API that you invoked failed.
        public var failureReasons: [Swift.String]?
        /// The foundation model used for orchestration by the agent.
        public var foundationModel: Swift.String?
        /// Details about the guardrail associated with the agent.
        public var guardrailConfiguration: BedrockAgentClientTypes.GuardrailConfiguration?
        /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        /// This member is required.
        public var idleSessionTTLInSeconds: Swift.Int?
        /// Instructions that tell the agent what it should do and how it should interact with users.
        public var instruction: Swift.String?
        /// Contains memory configuration for the agent.
        public var memoryConfiguration: BedrockAgentClientTypes.MemoryConfiguration?
        /// The time at which the agent was last prepared.
        public var preparedAt: Foundation.Date?
        /// Contains configurations to override prompt templates in different parts of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
        public var promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?
        /// Contains recommended actions to take for the agent-related API that you invoked to succeed.
        public var recommendedActions: [Swift.String]?
        /// The time at which the agent was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            agentArn: Swift.String? = nil,
            agentId: Swift.String? = nil,
            agentName: Swift.String? = nil,
            agentResourceRoleArn: Swift.String? = nil,
            agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
            agentVersion: Swift.String? = nil,
            clientToken: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            customerEncryptionKeyArn: Swift.String? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            foundationModel: Swift.String? = nil,
            guardrailConfiguration: BedrockAgentClientTypes.GuardrailConfiguration? = nil,
            idleSessionTTLInSeconds: Swift.Int? = nil,
            instruction: Swift.String? = nil,
            memoryConfiguration: BedrockAgentClientTypes.MemoryConfiguration? = nil,
            preparedAt: Foundation.Date? = nil,
            promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration? = nil,
            recommendedActions: [Swift.String]? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.agentArn = agentArn
            self.agentId = agentId
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.description = description
            self.failureReasons = failureReasons
            self.foundationModel = foundationModel
            self.guardrailConfiguration = guardrailConfiguration
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.memoryConfiguration = memoryConfiguration
            self.preparedAt = preparedAt
            self.promptOverrideConfiguration = promptOverrideConfiguration
            self.recommendedActions = recommendedActions
            self.updatedAt = updatedAt
        }
    }
}

extension BedrockAgentClientTypes.Agent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Agent(agentArn: \(Swift.String(describing: agentArn)), agentId: \(Swift.String(describing: agentId)), agentName: \(Swift.String(describing: agentName)), agentResourceRoleArn: \(Swift.String(describing: agentResourceRoleArn)), agentStatus: \(Swift.String(describing: agentStatus)), agentVersion: \(Swift.String(describing: agentVersion)), clientToken: \(Swift.String(describing: clientToken)), createdAt: \(Swift.String(describing: createdAt)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), failureReasons: \(Swift.String(describing: failureReasons)), foundationModel: \(Swift.String(describing: foundationModel)), guardrailConfiguration: \(Swift.String(describing: guardrailConfiguration)), idleSessionTTLInSeconds: \(Swift.String(describing: idleSessionTTLInSeconds)), memoryConfiguration: \(Swift.String(describing: memoryConfiguration)), preparedAt: \(Swift.String(describing: preparedAt)), recommendedActions: \(Swift.String(describing: recommendedActions)), updatedAt: \(Swift.String(describing: updatedAt)), instruction: \"CONTENT_REDACTED\", promptOverrideConfiguration: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentClientTypes {

    /// Contains details about the routing configuration of the alias.
    public struct AgentAliasRoutingConfigurationListItem: Swift.Sendable {
        /// The version of the agent with which the alias is associated.
        public var agentVersion: Swift.String?
        /// Information on the Provisioned Throughput assigned to an agent alias.
        public var provisionedThroughput: Swift.String?

        public init(
            agentVersion: Swift.String? = nil,
            provisionedThroughput: Swift.String? = nil
        )
        {
            self.agentVersion = agentVersion
            self.provisionedThroughput = provisionedThroughput
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about the history of the alias.
    public struct AgentAliasHistoryEvent: Swift.Sendable {
        /// The date that the alias stopped being associated to the version in the routingConfiguration object
        public var endDate: Foundation.Date?
        /// Contains details about the version of the agent with which the alias is associated.
        public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
        /// The date that the alias began being associated to the version in the routingConfiguration object.
        public var startDate: Foundation.Date?

        public init(
            endDate: Foundation.Date? = nil,
            routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil,
            startDate: Foundation.Date? = nil
        )
        {
            self.endDate = endDate
            self.routingConfiguration = routingConfiguration
            self.startDate = startDate
        }
    }
}

extension BedrockAgentClientTypes {

    public enum AgentAliasStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case failed
        case prepared
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AgentAliasStatus] {
            return [
                .creating,
                .deleting,
                .failed,
                .prepared,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .prepared: return "PREPARED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about an alias of an agent.
    public struct AgentAlias: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the alias of the agent.
        /// This member is required.
        public var agentAliasArn: Swift.String?
        /// Contains details about the history of the alias.
        public var agentAliasHistoryEvents: [BedrockAgentClientTypes.AgentAliasHistoryEvent]?
        /// The unique identifier of the alias of the agent.
        /// This member is required.
        public var agentAliasId: Swift.String?
        /// The name of the alias of the agent.
        /// This member is required.
        public var agentAliasName: Swift.String?
        /// The status of the alias of the agent and whether it is ready for use. The following statuses are possible:
        ///
        /// * CREATING  The agent alias is being created.
        ///
        /// * PREPARED  The agent alias is finished being created or updated and is ready to be invoked.
        ///
        /// * FAILED  The agent alias API operation failed.
        ///
        /// * UPDATING  The agent alias is being updated.
        ///
        /// * DELETING  The agent alias is being deleted.
        /// This member is required.
        public var agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus?
        /// The unique identifier of the agent.
        /// This member is required.
        public var agentId: Swift.String?
        /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
        public var clientToken: Swift.String?
        /// The time at which the alias of the agent was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the alias of the agent.
        public var description: Swift.String?
        /// Information on the failure of Provisioned Throughput assigned to an agent alias.
        public var failureReasons: [Swift.String]?
        /// Contains details about the routing configuration of the alias.
        /// This member is required.
        public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
        /// The time at which the alias was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            agentAliasArn: Swift.String? = nil,
            agentAliasHistoryEvents: [BedrockAgentClientTypes.AgentAliasHistoryEvent]? = nil,
            agentAliasId: Swift.String? = nil,
            agentAliasName: Swift.String? = nil,
            agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus? = nil,
            agentId: Swift.String? = nil,
            clientToken: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.agentAliasArn = agentAliasArn
            self.agentAliasHistoryEvents = agentAliasHistoryEvents
            self.agentAliasId = agentAliasId
            self.agentAliasName = agentAliasName
            self.agentAliasStatus = agentAliasStatus
            self.agentId = agentId
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.failureReasons = failureReasons
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about an alias of an agent.
    public struct AgentAliasSummary: Swift.Sendable {
        /// Contains details about
        /// This member is required.
        public var agentAliasId: Swift.String?
        /// The name of the alias.
        /// This member is required.
        public var agentAliasName: Swift.String?
        /// The status of the alias.
        /// This member is required.
        public var agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus?
        /// The time at which the alias of the agent was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the alias.
        public var description: Swift.String?
        /// Contains details about the version of the agent with which the alias is associated.
        public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
        /// The time at which the alias was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            agentAliasId: Swift.String? = nil,
            agentAliasName: Swift.String? = nil,
            agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.agentAliasId = agentAliasId
            self.agentAliasName = agentAliasName
            self.agentAliasStatus = agentAliasStatus
            self.createdAt = createdAt
            self.description = description
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }
    }
}

extension BedrockAgentClientTypes {

    /// Defines an agent node in your flow. You specify the agent to invoke at this point in the flow. For more information, see [Node types in Amazon Bedrock works](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html) in the Amazon Bedrock User Guide.
    public struct AgentFlowNodeConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the alias of the agent to invoke.
        /// This member is required.
        public var agentAliasArn: Swift.String?

        public init(
            agentAliasArn: Swift.String? = nil
        )
        {
            self.agentAliasArn = agentAliasArn
        }
    }
}

extension BedrockAgentClientTypes {

    public enum KnowledgeBaseState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about a knowledge base that is associated with an agent.
    public struct AgentKnowledgeBase: Swift.Sendable {
        /// The unique identifier of the agent with which the knowledge base is associated.
        /// This member is required.
        public var agentId: Swift.String?
        /// The version of the agent with which the knowledge base is associated.
        /// This member is required.
        public var agentVersion: Swift.String?
        /// The time at which the association between the agent and the knowledge base was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the association between the agent and the knowledge base.
        /// This member is required.
        public var description: Swift.String?
        /// The unique identifier of the association between the agent and the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// Specifies whether to use the knowledge base or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        /// This member is required.
        public var knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?
        /// The time at which the association between the agent and the knowledge base was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            agentId: Swift.String? = nil,
            agentVersion: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.agentId = agentId
            self.agentVersion = agentVersion
            self.createdAt = createdAt
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
            self.updatedAt = updatedAt
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about a knowledge base associated with an agent.
    public struct AgentKnowledgeBaseSummary: Swift.Sendable {
        /// The description of the knowledge base associated with an agent.
        public var description: Swift.String?
        /// The unique identifier of the knowledge base associated with an agent.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// Specifies whether the agent uses the knowledge base or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        /// This member is required.
        public var knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?
        /// The time at which the knowledge base associated with an agent was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            description: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.knowledgeBaseState = knowledgeBaseState
            self.updatedAt = updatedAt
        }
    }
}

public struct CreateAgentInput: Swift.Sendable {
    /// A name for the agent that you create.
    /// This member is required.
    public var agentName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
    public var agentResourceRoleArn: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key with which to encrypt the agent.
    public var customerEncryptionKeyArn: Swift.String?
    /// A description of the agent.
    public var description: Swift.String?
    /// The identifier for the model that you want to be used for orchestration by the agent you create. The modelId to provide depends on the type of model or throughput that you use:
    ///
    /// * If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see [Amazon Bedrock base model IDs (on-demand throughput)](https://docs.aws.amazon.com/bedrock/latest/userguide/model-ids.html#model-ids-arns) in the Amazon Bedrock User Guide.
    ///
    /// * If you use an inference profile, specify the inference profile ID or its ARN. For a list of inference profile IDs, see [Supported Regions and models for cross-region inference](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference-support.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see [Run inference using a Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-thru-use.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see [Use a custom model in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-use.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use an [imported model](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-import-model.html), specify the ARN of the imported model. You can get the model ARN from a successful call to [CreateModelImportJob](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_CreateModelImportJob.html) or from the Imported models page in the Amazon Bedrock console.
    public var foundationModel: Swift.String?
    /// The unique Guardrail configuration assigned to the agent when it is created.
    public var guardrailConfiguration: BedrockAgentClientTypes.GuardrailConfiguration?
    /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
    public var idleSessionTTLInSeconds: Swift.Int?
    /// Instructions that tell the agent what it should do and how it should interact with users.
    public var instruction: Swift.String?
    /// Contains the details of the memory configured for the agent.
    public var memoryConfiguration: BedrockAgentClientTypes.MemoryConfiguration?
    /// Contains configurations to override prompts in different parts of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
    public var promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?
    /// Any tags that you want to attach to the agent.
    public var tags: [Swift.String: Swift.String]?

    public init(
        agentName: Swift.String? = nil,
        agentResourceRoleArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        description: Swift.String? = nil,
        foundationModel: Swift.String? = nil,
        guardrailConfiguration: BedrockAgentClientTypes.GuardrailConfiguration? = nil,
        idleSessionTTLInSeconds: Swift.Int? = nil,
        instruction: Swift.String? = nil,
        memoryConfiguration: BedrockAgentClientTypes.MemoryConfiguration? = nil,
        promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.agentName = agentName
        self.agentResourceRoleArn = agentResourceRoleArn
        self.clientToken = clientToken
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.description = description
        self.foundationModel = foundationModel
        self.guardrailConfiguration = guardrailConfiguration
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.instruction = instruction
        self.memoryConfiguration = memoryConfiguration
        self.promptOverrideConfiguration = promptOverrideConfiguration
        self.tags = tags
    }
}

extension CreateAgentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAgentInput(agentName: \(Swift.String(describing: agentName)), agentResourceRoleArn: \(Swift.String(describing: agentResourceRoleArn)), clientToken: \(Swift.String(describing: clientToken)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), foundationModel: \(Swift.String(describing: foundationModel)), guardrailConfiguration: \(Swift.String(describing: guardrailConfiguration)), idleSessionTTLInSeconds: \(Swift.String(describing: idleSessionTTLInSeconds)), memoryConfiguration: \(Swift.String(describing: memoryConfiguration)), tags: \(Swift.String(describing: tags)), instruction: \"CONTENT_REDACTED\", promptOverrideConfiguration: \"CONTENT_REDACTED\")"}
}

public struct CreateAgentOutput: Swift.Sendable {
    /// Contains details about the agent created.
    /// This member is required.
    public var agent: BedrockAgentClientTypes.Agent?

    public init(
        agent: BedrockAgentClientTypes.Agent? = nil
    )
    {
        self.agent = agent
    }
}

public struct DeleteAgentInput: Swift.Sendable {
    /// The unique identifier of the agent to delete.
    /// This member is required.
    public var agentId: Swift.String?
    /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
    public var skipResourceInUseCheck: Swift.Bool?

    public init(
        agentId: Swift.String? = nil,
        skipResourceInUseCheck: Swift.Bool? = nil
    )
    {
        self.agentId = agentId
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

public struct DeleteAgentOutput: Swift.Sendable {
    /// The unique identifier of the agent that was deleted.
    /// This member is required.
    public var agentId: Swift.String?
    /// The status of the agent.
    /// This member is required.
    public var agentStatus: BedrockAgentClientTypes.AgentStatus?

    public init(
        agentId: Swift.String? = nil,
        agentStatus: BedrockAgentClientTypes.AgentStatus? = nil
    )
    {
        self.agentId = agentId
        self.agentStatus = agentStatus
    }
}

public struct GetAgentInput: Swift.Sendable {
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentId: Swift.String? = nil
    )
    {
        self.agentId = agentId
    }
}

public struct GetAgentOutput: Swift.Sendable {
    /// Contains details about the agent.
    /// This member is required.
    public var agent: BedrockAgentClientTypes.Agent?

    public init(
        agent: BedrockAgentClientTypes.Agent? = nil
    )
    {
        self.agent = agent
    }
}

public struct ListAgentsInput: Swift.Sendable {
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about an agent.
    public struct AgentSummary: Swift.Sendable {
        /// The unique identifier of the agent.
        /// This member is required.
        public var agentId: Swift.String?
        /// The name of the agent.
        /// This member is required.
        public var agentName: Swift.String?
        /// The status of the agent.
        /// This member is required.
        public var agentStatus: BedrockAgentClientTypes.AgentStatus?
        /// The description of the agent.
        public var description: Swift.String?
        /// Details about the guardrail associated with the agent.
        public var guardrailConfiguration: BedrockAgentClientTypes.GuardrailConfiguration?
        /// The latest version of the agent.
        public var latestAgentVersion: Swift.String?
        /// The time at which the agent was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            agentId: Swift.String? = nil,
            agentName: Swift.String? = nil,
            agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
            description: Swift.String? = nil,
            guardrailConfiguration: BedrockAgentClientTypes.GuardrailConfiguration? = nil,
            latestAgentVersion: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.agentId = agentId
            self.agentName = agentName
            self.agentStatus = agentStatus
            self.description = description
            self.guardrailConfiguration = guardrailConfiguration
            self.latestAgentVersion = latestAgentVersion
            self.updatedAt = updatedAt
        }
    }
}

public struct ListAgentsOutput: Swift.Sendable {
    /// A list of objects, each of which contains information about an agent.
    /// This member is required.
    public var agentSummaries: [BedrockAgentClientTypes.AgentSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentSummaries: [BedrockAgentClientTypes.AgentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentSummaries = agentSummaries
        self.nextToken = nextToken
    }
}

public struct PrepareAgentInput: Swift.Sendable {
    /// The unique identifier of the agent for which to create a DRAFT version.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentId: Swift.String? = nil
    )
    {
        self.agentId = agentId
    }
}

public struct PrepareAgentOutput: Swift.Sendable {
    /// The unique identifier of the agent for which the DRAFT version was created.
    /// This member is required.
    public var agentId: Swift.String?
    /// The status of the DRAFT version and whether it is ready for use.
    /// This member is required.
    public var agentStatus: BedrockAgentClientTypes.AgentStatus?
    /// The version of the agent.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// The time at which the DRAFT version of the agent was last prepared.
    /// This member is required.
    public var preparedAt: Foundation.Date?

    public init(
        agentId: Swift.String? = nil,
        agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
        agentVersion: Swift.String? = nil,
        preparedAt: Foundation.Date? = nil
    )
    {
        self.agentId = agentId
        self.agentStatus = agentStatus
        self.agentVersion = agentVersion
        self.preparedAt = preparedAt
    }
}

public struct UpdateAgentInput: Swift.Sendable {
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// Specifies a new name for the agent.
    /// This member is required.
    public var agentName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
    /// This member is required.
    public var agentResourceRoleArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key with which to encrypt the agent.
    public var customerEncryptionKeyArn: Swift.String?
    /// Specifies a new description of the agent.
    public var description: Swift.String?
    /// The identifier for the model that you want to be used for orchestration by the agent you create. The modelId to provide depends on the type of model or throughput that you use:
    ///
    /// * If you use a base model, specify the model ID or its ARN. For a list of model IDs for base models, see [Amazon Bedrock base model IDs (on-demand throughput)](https://docs.aws.amazon.com/bedrock/latest/userguide/model-ids.html#model-ids-arns) in the Amazon Bedrock User Guide.
    ///
    /// * If you use an inference profile, specify the inference profile ID or its ARN. For a list of inference profile IDs, see [Supported Regions and models for cross-region inference](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference-support.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a provisioned model, specify the ARN of the Provisioned Throughput. For more information, see [Run inference using a Provisioned Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-thru-use.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use a custom model, first purchase Provisioned Throughput for it. Then specify the ARN of the resulting provisioned model. For more information, see [Use a custom model in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-use.html) in the Amazon Bedrock User Guide.
    ///
    /// * If you use an [imported model](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-import-model.html), specify the ARN of the imported model. You can get the model ARN from a successful call to [CreateModelImportJob](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_CreateModelImportJob.html) or from the Imported models page in the Amazon Bedrock console.
    /// This member is required.
    public var foundationModel: Swift.String?
    /// The unique Guardrail configuration assigned to the agent when it is updated.
    public var guardrailConfiguration: BedrockAgentClientTypes.GuardrailConfiguration?
    /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
    public var idleSessionTTLInSeconds: Swift.Int?
    /// Specifies new instructions that tell the agent what it should do and how it should interact with users.
    public var instruction: Swift.String?
    /// Specifies the new memory configuration for the agent.
    public var memoryConfiguration: BedrockAgentClientTypes.MemoryConfiguration?
    /// Contains configurations to override prompts in different parts of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
    public var promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?

    public init(
        agentId: Swift.String? = nil,
        agentName: Swift.String? = nil,
        agentResourceRoleArn: Swift.String? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        description: Swift.String? = nil,
        foundationModel: Swift.String? = nil,
        guardrailConfiguration: BedrockAgentClientTypes.GuardrailConfiguration? = nil,
        idleSessionTTLInSeconds: Swift.Int? = nil,
        instruction: Swift.String? = nil,
        memoryConfiguration: BedrockAgentClientTypes.MemoryConfiguration? = nil,
        promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration? = nil
    )
    {
        self.agentId = agentId
        self.agentName = agentName
        self.agentResourceRoleArn = agentResourceRoleArn
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.description = description
        self.foundationModel = foundationModel
        self.guardrailConfiguration = guardrailConfiguration
        self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
        self.instruction = instruction
        self.memoryConfiguration = memoryConfiguration
        self.promptOverrideConfiguration = promptOverrideConfiguration
    }
}

extension UpdateAgentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAgentInput(agentId: \(Swift.String(describing: agentId)), agentName: \(Swift.String(describing: agentName)), agentResourceRoleArn: \(Swift.String(describing: agentResourceRoleArn)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), foundationModel: \(Swift.String(describing: foundationModel)), guardrailConfiguration: \(Swift.String(describing: guardrailConfiguration)), idleSessionTTLInSeconds: \(Swift.String(describing: idleSessionTTLInSeconds)), memoryConfiguration: \(Swift.String(describing: memoryConfiguration)), instruction: \"CONTENT_REDACTED\", promptOverrideConfiguration: \"CONTENT_REDACTED\")"}
}

public struct UpdateAgentOutput: Swift.Sendable {
    /// Contains details about the agent that was updated.
    /// This member is required.
    public var agent: BedrockAgentClientTypes.Agent?

    public init(
        agent: BedrockAgentClientTypes.Agent? = nil
    )
    {
        self.agent = agent
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about a version of an agent.
    public struct AgentVersion: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the agent that the version belongs to.
        /// This member is required.
        public var agentArn: Swift.String?
        /// The unique identifier of the agent that the version belongs to.
        /// This member is required.
        public var agentId: Swift.String?
        /// The name of the agent that the version belongs to.
        /// This member is required.
        public var agentName: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the agent.
        /// This member is required.
        public var agentResourceRoleArn: Swift.String?
        /// The status of the agent that the version belongs to.
        /// This member is required.
        public var agentStatus: BedrockAgentClientTypes.AgentStatus?
        /// The time at which the version was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the KMS key that encrypts the agent.
        public var customerEncryptionKeyArn: Swift.String?
        /// The description of the version.
        public var description: Swift.String?
        /// A list of reasons that the API operation on the version failed.
        public var failureReasons: [Swift.String]?
        /// The foundation model that the version invokes.
        public var foundationModel: Swift.String?
        /// Details about the guardrail associated with the agent.
        public var guardrailConfiguration: BedrockAgentClientTypes.GuardrailConfiguration?
        /// The number of seconds for which Amazon Bedrock keeps information about a user's conversation with the agent. A user interaction remains active for the amount of time specified. If no conversation occurs during this time, the session expires and Amazon Bedrock deletes any data provided before the timeout.
        /// This member is required.
        public var idleSessionTTLInSeconds: Swift.Int?
        /// The instructions provided to the agent.
        public var instruction: Swift.String?
        /// Contains details of the memory configuration on the version of the agent.
        public var memoryConfiguration: BedrockAgentClientTypes.MemoryConfiguration?
        /// Contains configurations to override prompt templates in different parts of an agent sequence. For more information, see [Advanced prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
        public var promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration?
        /// A list of recommended actions to take for the failed API operation on the version to succeed.
        public var recommendedActions: [Swift.String]?
        /// The time at which the version was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?
        /// The version number.
        /// This member is required.
        public var version: Swift.String?

        public init(
            agentArn: Swift.String? = nil,
            agentId: Swift.String? = nil,
            agentName: Swift.String? = nil,
            agentResourceRoleArn: Swift.String? = nil,
            agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
            createdAt: Foundation.Date? = nil,
            customerEncryptionKeyArn: Swift.String? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            foundationModel: Swift.String? = nil,
            guardrailConfiguration: BedrockAgentClientTypes.GuardrailConfiguration? = nil,
            idleSessionTTLInSeconds: Swift.Int? = nil,
            instruction: Swift.String? = nil,
            memoryConfiguration: BedrockAgentClientTypes.MemoryConfiguration? = nil,
            promptOverrideConfiguration: BedrockAgentClientTypes.PromptOverrideConfiguration? = nil,
            recommendedActions: [Swift.String]? = nil,
            updatedAt: Foundation.Date? = nil,
            version: Swift.String? = nil
        )
        {
            self.agentArn = agentArn
            self.agentId = agentId
            self.agentName = agentName
            self.agentResourceRoleArn = agentResourceRoleArn
            self.agentStatus = agentStatus
            self.createdAt = createdAt
            self.customerEncryptionKeyArn = customerEncryptionKeyArn
            self.description = description
            self.failureReasons = failureReasons
            self.foundationModel = foundationModel
            self.guardrailConfiguration = guardrailConfiguration
            self.idleSessionTTLInSeconds = idleSessionTTLInSeconds
            self.instruction = instruction
            self.memoryConfiguration = memoryConfiguration
            self.promptOverrideConfiguration = promptOverrideConfiguration
            self.recommendedActions = recommendedActions
            self.updatedAt = updatedAt
            self.version = version
        }
    }
}

extension BedrockAgentClientTypes.AgentVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AgentVersion(agentArn: \(Swift.String(describing: agentArn)), agentId: \(Swift.String(describing: agentId)), agentName: \(Swift.String(describing: agentName)), agentResourceRoleArn: \(Swift.String(describing: agentResourceRoleArn)), agentStatus: \(Swift.String(describing: agentStatus)), createdAt: \(Swift.String(describing: createdAt)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), failureReasons: \(Swift.String(describing: failureReasons)), foundationModel: \(Swift.String(describing: foundationModel)), guardrailConfiguration: \(Swift.String(describing: guardrailConfiguration)), idleSessionTTLInSeconds: \(Swift.String(describing: idleSessionTTLInSeconds)), memoryConfiguration: \(Swift.String(describing: memoryConfiguration)), recommendedActions: \(Swift.String(describing: recommendedActions)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), instruction: \"CONTENT_REDACTED\", promptOverrideConfiguration: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentClientTypes {

    /// Contains details about a version of an agent.
    public struct AgentVersionSummary: Swift.Sendable {
        /// The name of the agent to which the version belongs.
        /// This member is required.
        public var agentName: Swift.String?
        /// The status of the agent to which the version belongs.
        /// This member is required.
        public var agentStatus: BedrockAgentClientTypes.AgentStatus?
        /// The version of the agent.
        /// This member is required.
        public var agentVersion: Swift.String?
        /// The time at which the version was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the version of the agent.
        public var description: Swift.String?
        /// Details about the guardrail associated with the agent.
        public var guardrailConfiguration: BedrockAgentClientTypes.GuardrailConfiguration?
        /// The time at which the version was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            agentName: Swift.String? = nil,
            agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
            agentVersion: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            guardrailConfiguration: BedrockAgentClientTypes.GuardrailConfiguration? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.agentName = agentName
            self.agentStatus = agentStatus
            self.agentVersion = agentVersion
            self.createdAt = createdAt
            self.description = description
            self.guardrailConfiguration = guardrailConfiguration
            self.updatedAt = updatedAt
        }
    }
}

public struct CreateAgentAliasInput: Swift.Sendable {
    /// The name of the alias.
    /// This member is required.
    public var agentAliasName: Swift.String?
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// A description of the alias of the agent.
    public var description: Swift.String?
    /// Contains details about the routing configuration of the alias.
    public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?
    /// Any tags that you want to attach to the alias of the agent.
    public var tags: [Swift.String: Swift.String]?

    public init(
        agentAliasName: Swift.String? = nil,
        agentId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.agentAliasName = agentAliasName
        self.agentId = agentId
        self.clientToken = clientToken
        self.description = description
        self.routingConfiguration = routingConfiguration
        self.tags = tags
    }
}

public struct CreateAgentAliasOutput: Swift.Sendable {
    /// Contains details about the alias that was created.
    /// This member is required.
    public var agentAlias: BedrockAgentClientTypes.AgentAlias?

    public init(
        agentAlias: BedrockAgentClientTypes.AgentAlias? = nil
    )
    {
        self.agentAlias = agentAlias
    }
}

public struct DeleteAgentAliasInput: Swift.Sendable {
    /// The unique identifier of the alias to delete.
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// The unique identifier of the agent that the alias belongs to.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentAliasId: Swift.String? = nil,
        agentId: Swift.String? = nil
    )
    {
        self.agentAliasId = agentAliasId
        self.agentId = agentId
    }
}

public struct DeleteAgentAliasOutput: Swift.Sendable {
    /// The unique identifier of the alias that was deleted.
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// The status of the alias.
    /// This member is required.
    public var agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus?
    /// The unique identifier of the agent that the alias belongs to.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentAliasId: Swift.String? = nil,
        agentAliasStatus: BedrockAgentClientTypes.AgentAliasStatus? = nil,
        agentId: Swift.String? = nil
    )
    {
        self.agentAliasId = agentAliasId
        self.agentAliasStatus = agentAliasStatus
        self.agentId = agentId
    }
}

public struct GetAgentAliasInput: Swift.Sendable {
    /// The unique identifier of the alias for which to get information.
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// The unique identifier of the agent to which the alias to get information belongs.
    /// This member is required.
    public var agentId: Swift.String?

    public init(
        agentAliasId: Swift.String? = nil,
        agentId: Swift.String? = nil
    )
    {
        self.agentAliasId = agentAliasId
        self.agentId = agentId
    }
}

public struct GetAgentAliasOutput: Swift.Sendable {
    /// Contains information about the alias.
    /// This member is required.
    public var agentAlias: BedrockAgentClientTypes.AgentAlias?

    public init(
        agentAlias: BedrockAgentClientTypes.AgentAlias? = nil
    )
    {
        self.agentAlias = agentAlias
    }
}

public struct ListAgentAliasesInput: Swift.Sendable {
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAgentAliasesOutput: Swift.Sendable {
    /// A list of objects, each of which contains information about an alias of the agent.
    /// This member is required.
    public var agentAliasSummaries: [BedrockAgentClientTypes.AgentAliasSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentAliasSummaries: [BedrockAgentClientTypes.AgentAliasSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentAliasSummaries = agentAliasSummaries
        self.nextToken = nextToken
    }
}

public struct UpdateAgentAliasInput: Swift.Sendable {
    /// The unique identifier of the alias.
    /// This member is required.
    public var agentAliasId: Swift.String?
    /// Specifies a new name for the alias.
    /// This member is required.
    public var agentAliasName: Swift.String?
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// Specifies a new description for the alias.
    public var description: Swift.String?
    /// Contains details about the routing configuration of the alias.
    public var routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]?

    public init(
        agentAliasId: Swift.String? = nil,
        agentAliasName: Swift.String? = nil,
        agentId: Swift.String? = nil,
        description: Swift.String? = nil,
        routingConfiguration: [BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem]? = nil
    )
    {
        self.agentAliasId = agentAliasId
        self.agentAliasName = agentAliasName
        self.agentId = agentId
        self.description = description
        self.routingConfiguration = routingConfiguration
    }
}

public struct UpdateAgentAliasOutput: Swift.Sendable {
    /// Contains details about the alias that was updated.
    /// This member is required.
    public var agentAlias: BedrockAgentClientTypes.AgentAlias?

    public init(
        agentAlias: BedrockAgentClientTypes.AgentAlias? = nil
    )
    {
        self.agentAlias = agentAlias
    }
}

extension BedrockAgentClientTypes {

    public enum DataDeletionPolicy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case delete
        case retain
        case sdkUnknown(Swift.String)

        public static var allCases: [DataDeletionPolicy] {
            return [
                .delete,
                .retain
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .retain: return "RETAIN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// The specific filters applied to your data source content. You can filter out or include certain content.
    public struct PatternObjectFilter: Swift.Sendable {
        /// A list of one or more exclusion regular expression patterns to exclude certain object types that adhere to the pattern. If you specify an inclusion and exclusion filter/pattern and both match a document, the exclusion filter takes precedence and the document isnt crawled.
        public var exclusionFilters: [Swift.String]?
        /// A list of one or more inclusion regular expression patterns to include certain object types that adhere to the pattern. If you specify an inclusion and exclusion filter/pattern and both match a document, the exclusion filter takes precedence and the document isnt crawled.
        public var inclusionFilters: [Swift.String]?
        /// The supported object type or content type of the data source.
        /// This member is required.
        public var objectType: Swift.String?

        public init(
            exclusionFilters: [Swift.String]? = nil,
            inclusionFilters: [Swift.String]? = nil,
            objectType: Swift.String? = nil
        )
        {
            self.exclusionFilters = exclusionFilters
            self.inclusionFilters = inclusionFilters
            self.objectType = objectType
        }
    }
}

extension BedrockAgentClientTypes.PatternObjectFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PatternObjectFilter(exclusionFilters: \"CONTENT_REDACTED\", inclusionFilters: \"CONTENT_REDACTED\", objectType: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentClientTypes {

    /// The configuration of filtering certain objects or content types of the data source.
    public struct PatternObjectFilterConfiguration: Swift.Sendable {
        /// The configuration of specific filters applied to your data source content. You can filter out or include certain content.
        /// This member is required.
        public var filters: [BedrockAgentClientTypes.PatternObjectFilter]?

        public init(
            filters: [BedrockAgentClientTypes.PatternObjectFilter]? = nil
        )
        {
            self.filters = filters
        }
    }
}

extension BedrockAgentClientTypes.PatternObjectFilterConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PatternObjectFilterConfiguration(filters: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentClientTypes {

    public enum CrawlFilterConfigurationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pattern
        case sdkUnknown(Swift.String)

        public static var allCases: [CrawlFilterConfigurationType] {
            return [
                .pattern
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pattern: return "PATTERN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// The configuration of filtering the data source content. For example, configuring regular expression patterns to include or exclude certain content.
    public struct CrawlFilterConfiguration: Swift.Sendable {
        /// The configuration of filtering certain objects or content types of the data source.
        public var patternObjectFilter: BedrockAgentClientTypes.PatternObjectFilterConfiguration?
        /// The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        /// This member is required.
        public var type: BedrockAgentClientTypes.CrawlFilterConfigurationType?

        public init(
            patternObjectFilter: BedrockAgentClientTypes.PatternObjectFilterConfiguration? = nil,
            type: BedrockAgentClientTypes.CrawlFilterConfigurationType? = nil
        )
        {
            self.patternObjectFilter = patternObjectFilter
            self.type = type
        }
    }
}

extension BedrockAgentClientTypes {

    /// The configuration of the Confluence content. For example, configuring specific types of Confluence content.
    public struct ConfluenceCrawlerConfiguration: Swift.Sendable {
        /// The configuration of filtering the Confluence content. For example, configuring regular expression patterns to include or exclude certain content.
        public var filterConfiguration: BedrockAgentClientTypes.CrawlFilterConfiguration?

        public init(
            filterConfiguration: BedrockAgentClientTypes.CrawlFilterConfiguration? = nil
        )
        {
            self.filterConfiguration = filterConfiguration
        }
    }
}

extension BedrockAgentClientTypes {

    public enum ConfluenceAuthType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case basic
        case oauth2ClientCredentials
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfluenceAuthType] {
            return [
                .basic,
                .oauth2ClientCredentials
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .oauth2ClientCredentials: return "OAUTH2_CLIENT_CREDENTIALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    public enum ConfluenceHostType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case saas
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfluenceHostType] {
            return [
                .saas
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .saas: return "SAAS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// The endpoint information to connect to your Confluence data source.
    public struct ConfluenceSourceConfiguration: Swift.Sendable {
        /// The supported authentication type to authenticate and connect to your Confluence instance.
        /// This member is required.
        public var authType: BedrockAgentClientTypes.ConfluenceAuthType?
        /// The Amazon Resource Name of an Secrets Manager secret that stores your authentication credentials for your Confluence instance URL. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see [Confluence connection configuration](https://docs.aws.amazon.com/bedrock/latest/userguide/confluence-data-source-connector.html#configuration-confluence-connector).
        /// This member is required.
        public var credentialsSecretArn: Swift.String?
        /// The supported host type, whether online/cloud or server/on-premises.
        /// This member is required.
        public var hostType: BedrockAgentClientTypes.ConfluenceHostType?
        /// The Confluence host URL or instance URL.
        /// This member is required.
        public var hostUrl: Swift.String?

        public init(
            authType: BedrockAgentClientTypes.ConfluenceAuthType? = nil,
            credentialsSecretArn: Swift.String? = nil,
            hostType: BedrockAgentClientTypes.ConfluenceHostType? = nil,
            hostUrl: Swift.String? = nil
        )
        {
            self.authType = authType
            self.credentialsSecretArn = credentialsSecretArn
            self.hostType = hostType
            self.hostUrl = hostUrl
        }
    }
}

extension BedrockAgentClientTypes {

    /// The configuration information to connect to Confluence as your data source.
    public struct ConfluenceDataSourceConfiguration: Swift.Sendable {
        /// The configuration of the Confluence content. For example, configuring specific types of Confluence content.
        public var crawlerConfiguration: BedrockAgentClientTypes.ConfluenceCrawlerConfiguration?
        /// The endpoint information to connect to your Confluence data source.
        /// This member is required.
        public var sourceConfiguration: BedrockAgentClientTypes.ConfluenceSourceConfiguration?

        public init(
            crawlerConfiguration: BedrockAgentClientTypes.ConfluenceCrawlerConfiguration? = nil,
            sourceConfiguration: BedrockAgentClientTypes.ConfluenceSourceConfiguration? = nil
        )
        {
            self.crawlerConfiguration = crawlerConfiguration
            self.sourceConfiguration = sourceConfiguration
        }
    }
}

extension BedrockAgentClientTypes {

    /// The configuration information to connect to Amazon S3 as your data source.
    public struct S3DataSourceConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the S3 bucket that contains your data.
        /// This member is required.
        public var bucketArn: Swift.String?
        /// The account ID for the owner of the S3 bucket.
        public var bucketOwnerAccountId: Swift.String?
        /// A list of S3 prefixes to include certain files or content. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html).
        public var inclusionPrefixes: [Swift.String]?

        public init(
            bucketArn: Swift.String? = nil,
            bucketOwnerAccountId: Swift.String? = nil,
            inclusionPrefixes: [Swift.String]? = nil
        )
        {
            self.bucketArn = bucketArn
            self.bucketOwnerAccountId = bucketOwnerAccountId
            self.inclusionPrefixes = inclusionPrefixes
        }
    }
}

extension BedrockAgentClientTypes.S3DataSourceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3DataSourceConfiguration(bucketArn: \(Swift.String(describing: bucketArn)), bucketOwnerAccountId: \(Swift.String(describing: bucketOwnerAccountId)), inclusionPrefixes: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentClientTypes {

    /// The configuration of the Salesforce content. For example, configuring specific types of Salesforce content.
    public struct SalesforceCrawlerConfiguration: Swift.Sendable {
        /// The configuration of filtering the Salesforce content. For example, configuring regular expression patterns to include or exclude certain content.
        public var filterConfiguration: BedrockAgentClientTypes.CrawlFilterConfiguration?

        public init(
            filterConfiguration: BedrockAgentClientTypes.CrawlFilterConfiguration? = nil
        )
        {
            self.filterConfiguration = filterConfiguration
        }
    }
}

extension BedrockAgentClientTypes {

    public enum SalesforceAuthType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oauth2ClientCredentials
        case sdkUnknown(Swift.String)

        public static var allCases: [SalesforceAuthType] {
            return [
                .oauth2ClientCredentials
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oauth2ClientCredentials: return "OAUTH2_CLIENT_CREDENTIALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// The endpoint information to connect to your Salesforce data source.
    public struct SalesforceSourceConfiguration: Swift.Sendable {
        /// The supported authentication type to authenticate and connect to your Salesforce instance.
        /// This member is required.
        public var authType: BedrockAgentClientTypes.SalesforceAuthType?
        /// The Amazon Resource Name of an Secrets Manager secret that stores your authentication credentials for your Salesforce instance URL. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see [Salesforce connection configuration](https://docs.aws.amazon.com/bedrock/latest/userguide/salesforce-data-source-connector.html#configuration-salesforce-connector).
        /// This member is required.
        public var credentialsSecretArn: Swift.String?
        /// The Salesforce host URL or instance URL.
        /// This member is required.
        public var hostUrl: Swift.String?

        public init(
            authType: BedrockAgentClientTypes.SalesforceAuthType? = nil,
            credentialsSecretArn: Swift.String? = nil,
            hostUrl: Swift.String? = nil
        )
        {
            self.authType = authType
            self.credentialsSecretArn = credentialsSecretArn
            self.hostUrl = hostUrl
        }
    }
}

extension BedrockAgentClientTypes {

    /// The configuration information to connect to Salesforce as your data source.
    public struct SalesforceDataSourceConfiguration: Swift.Sendable {
        /// The configuration of the Salesforce content. For example, configuring specific types of Salesforce content.
        public var crawlerConfiguration: BedrockAgentClientTypes.SalesforceCrawlerConfiguration?
        /// The endpoint information to connect to your Salesforce data source.
        /// This member is required.
        public var sourceConfiguration: BedrockAgentClientTypes.SalesforceSourceConfiguration?

        public init(
            crawlerConfiguration: BedrockAgentClientTypes.SalesforceCrawlerConfiguration? = nil,
            sourceConfiguration: BedrockAgentClientTypes.SalesforceSourceConfiguration? = nil
        )
        {
            self.crawlerConfiguration = crawlerConfiguration
            self.sourceConfiguration = sourceConfiguration
        }
    }
}

extension BedrockAgentClientTypes {

    /// The configuration of the SharePoint content. For example, configuring specific types of SharePoint content.
    public struct SharePointCrawlerConfiguration: Swift.Sendable {
        /// The configuration of filtering the SharePoint content. For example, configuring regular expression patterns to include or exclude certain content.
        public var filterConfiguration: BedrockAgentClientTypes.CrawlFilterConfiguration?

        public init(
            filterConfiguration: BedrockAgentClientTypes.CrawlFilterConfiguration? = nil
        )
        {
            self.filterConfiguration = filterConfiguration
        }
    }
}

extension BedrockAgentClientTypes {

    public enum SharePointAuthType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oauth2ClientCredentials
        case sdkUnknown(Swift.String)

        public static var allCases: [SharePointAuthType] {
            return [
                .oauth2ClientCredentials
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oauth2ClientCredentials: return "OAUTH2_CLIENT_CREDENTIALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    public enum SharePointHostType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case online
        case sdkUnknown(Swift.String)

        public static var allCases: [SharePointHostType] {
            return [
                .online
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .online: return "ONLINE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// The endpoint information to connect to your SharePoint data source.
    public struct SharePointSourceConfiguration: Swift.Sendable {
        /// The supported authentication type to authenticate and connect to your SharePoint site/sites.
        /// This member is required.
        public var authType: BedrockAgentClientTypes.SharePointAuthType?
        /// The Amazon Resource Name of an Secrets Manager secret that stores your authentication credentials for your SharePoint site/sites. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see [SharePoint connection configuration](https://docs.aws.amazon.com/bedrock/latest/userguide/sharepoint-data-source-connector.html#configuration-sharepoint-connector).
        /// This member is required.
        public var credentialsSecretArn: Swift.String?
        /// The domain of your SharePoint instance or site URL/URLs.
        /// This member is required.
        public var domain: Swift.String?
        /// The supported host type, whether online/cloud or server/on-premises.
        /// This member is required.
        public var hostType: BedrockAgentClientTypes.SharePointHostType?
        /// A list of one or more SharePoint site URLs.
        /// This member is required.
        public var siteUrls: [Swift.String]?
        /// The identifier of your Microsoft 365 tenant.
        public var tenantId: Swift.String?

        public init(
            authType: BedrockAgentClientTypes.SharePointAuthType? = nil,
            credentialsSecretArn: Swift.String? = nil,
            domain: Swift.String? = nil,
            hostType: BedrockAgentClientTypes.SharePointHostType? = nil,
            siteUrls: [Swift.String]? = nil,
            tenantId: Swift.String? = nil
        )
        {
            self.authType = authType
            self.credentialsSecretArn = credentialsSecretArn
            self.domain = domain
            self.hostType = hostType
            self.siteUrls = siteUrls
            self.tenantId = tenantId
        }
    }
}

extension BedrockAgentClientTypes {

    /// The configuration information to connect to SharePoint as your data source.
    public struct SharePointDataSourceConfiguration: Swift.Sendable {
        /// The configuration of the SharePoint content. For example, configuring specific types of SharePoint content.
        public var crawlerConfiguration: BedrockAgentClientTypes.SharePointCrawlerConfiguration?
        /// The endpoint information to connect to your SharePoint data source.
        /// This member is required.
        public var sourceConfiguration: BedrockAgentClientTypes.SharePointSourceConfiguration?

        public init(
            crawlerConfiguration: BedrockAgentClientTypes.SharePointCrawlerConfiguration? = nil,
            sourceConfiguration: BedrockAgentClientTypes.SharePointSourceConfiguration? = nil
        )
        {
            self.crawlerConfiguration = crawlerConfiguration
            self.sourceConfiguration = sourceConfiguration
        }
    }
}

extension BedrockAgentClientTypes {

    public enum DataSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case confluence
        case s3
        case salesforce
        case sharepoint
        case web
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .confluence,
                .s3,
                .salesforce,
                .sharepoint,
                .web
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .confluence: return "CONFLUENCE"
            case .s3: return "S3"
            case .salesforce: return "SALESFORCE"
            case .sharepoint: return "SHAREPOINT"
            case .web: return "WEB"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// The rate limits for the URLs that you want to crawl. You should be authorized to crawl the URLs.
    public struct WebCrawlerLimits: Swift.Sendable {
        /// The max rate at which pages are crawled, up to 300 per minute per host.
        public var rateLimit: Swift.Int?

        public init(
            rateLimit: Swift.Int? = nil
        )
        {
            self.rateLimit = rateLimit
        }
    }
}

extension BedrockAgentClientTypes {

    public enum WebScopeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hostOnly
        case subdomains
        case sdkUnknown(Swift.String)

        public static var allCases: [WebScopeType] {
            return [
                .hostOnly,
                .subdomains
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hostOnly: return "HOST_ONLY"
            case .subdomains: return "SUBDOMAINS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// The configuration of web URLs that you want to crawl. You should be authorized to crawl the URLs.
    public struct WebCrawlerConfiguration: Swift.Sendable {
        /// The configuration of crawl limits for the web URLs.
        public var crawlerLimits: BedrockAgentClientTypes.WebCrawlerLimits?
        /// A list of one or more exclusion regular expression patterns to exclude certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isnt crawled.
        public var exclusionFilters: [Swift.String]?
        /// A list of one or more inclusion regular expression patterns to include certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isnt crawled.
        public var inclusionFilters: [Swift.String]?
        /// The scope of what is crawled for your URLs. You can choose to crawl only web pages that belong to the same host or primary domain. For example, only web pages that contain the seed URL "https://docs.aws.amazon.com/bedrock/latest/userguide/" and no other domains. You can choose to include sub domains in addition to the host or primary domain. For example, web pages that contain "aws.amazon.com" can also include sub domain "docs.aws.amazon.com".
        public var scope: BedrockAgentClientTypes.WebScopeType?

        public init(
            crawlerLimits: BedrockAgentClientTypes.WebCrawlerLimits? = nil,
            exclusionFilters: [Swift.String]? = nil,
            inclusionFilters: [Swift.String]? = nil,
            scope: BedrockAgentClientTypes.WebScopeType? = nil
        )
        {
            self.crawlerLimits = crawlerLimits
            self.exclusionFilters = exclusionFilters
            self.inclusionFilters = inclusionFilters
            self.scope = scope
        }
    }
}

extension BedrockAgentClientTypes.WebCrawlerConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WebCrawlerConfiguration(crawlerLimits: \(Swift.String(describing: crawlerLimits)), scope: \(Swift.String(describing: scope)), exclusionFilters: \"CONTENT_REDACTED\", inclusionFilters: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentClientTypes {

    /// The seed or starting point URL. You should be authorized to crawl the URL.
    public struct SeedUrl: Swift.Sendable {
        /// A seed or starting point URL.
        public var url: Swift.String?

        public init(
            url: Swift.String? = nil
        )
        {
            self.url = url
        }
    }
}

extension BedrockAgentClientTypes {

    /// The configuration of web URLs that you want to crawl. You should be authorized to crawl the URLs.
    public struct UrlConfiguration: Swift.Sendable {
        /// One or more seed or starting point URLs.
        public var seedUrls: [BedrockAgentClientTypes.SeedUrl]?

        public init(
            seedUrls: [BedrockAgentClientTypes.SeedUrl]? = nil
        )
        {
            self.seedUrls = seedUrls
        }
    }
}

extension BedrockAgentClientTypes {

    /// The configuration of the URL/URLs for the web content that you want to crawl. You should be authorized to crawl the URLs.
    public struct WebSourceConfiguration: Swift.Sendable {
        /// The configuration of the URL/URLs.
        /// This member is required.
        public var urlConfiguration: BedrockAgentClientTypes.UrlConfiguration?

        public init(
            urlConfiguration: BedrockAgentClientTypes.UrlConfiguration? = nil
        )
        {
            self.urlConfiguration = urlConfiguration
        }
    }
}

extension BedrockAgentClientTypes {

    /// The configuration details for the web data source.
    public struct WebDataSourceConfiguration: Swift.Sendable {
        /// The Web Crawler configuration details for the web data source.
        public var crawlerConfiguration: BedrockAgentClientTypes.WebCrawlerConfiguration?
        /// The source configuration details for the web data source.
        /// This member is required.
        public var sourceConfiguration: BedrockAgentClientTypes.WebSourceConfiguration?

        public init(
            crawlerConfiguration: BedrockAgentClientTypes.WebCrawlerConfiguration? = nil,
            sourceConfiguration: BedrockAgentClientTypes.WebSourceConfiguration? = nil
        )
        {
            self.crawlerConfiguration = crawlerConfiguration
            self.sourceConfiguration = sourceConfiguration
        }
    }
}

extension BedrockAgentClientTypes {

    /// The connection configuration for the data source.
    public struct DataSourceConfiguration: Swift.Sendable {
        /// The configuration information to connect to Confluence as your data source. Confluence data source connector is in preview release and is subject to change.
        public var confluenceConfiguration: BedrockAgentClientTypes.ConfluenceDataSourceConfiguration?
        /// The configuration information to connect to Amazon S3 as your data source.
        public var s3Configuration: BedrockAgentClientTypes.S3DataSourceConfiguration?
        /// The configuration information to connect to Salesforce as your data source. Salesforce data source connector is in preview release and is subject to change.
        public var salesforceConfiguration: BedrockAgentClientTypes.SalesforceDataSourceConfiguration?
        /// The configuration information to connect to SharePoint as your data source. SharePoint data source connector is in preview release and is subject to change.
        public var sharePointConfiguration: BedrockAgentClientTypes.SharePointDataSourceConfiguration?
        /// The type of data source.
        /// This member is required.
        public var type: BedrockAgentClientTypes.DataSourceType?
        /// The configuration of web URLs to crawl for your data source. You should be authorized to crawl the URLs. Crawling web URLs as your data source is in preview release and is subject to change.
        public var webConfiguration: BedrockAgentClientTypes.WebDataSourceConfiguration?

        public init(
            confluenceConfiguration: BedrockAgentClientTypes.ConfluenceDataSourceConfiguration? = nil,
            s3Configuration: BedrockAgentClientTypes.S3DataSourceConfiguration? = nil,
            salesforceConfiguration: BedrockAgentClientTypes.SalesforceDataSourceConfiguration? = nil,
            sharePointConfiguration: BedrockAgentClientTypes.SharePointDataSourceConfiguration? = nil,
            type: BedrockAgentClientTypes.DataSourceType? = nil,
            webConfiguration: BedrockAgentClientTypes.WebDataSourceConfiguration? = nil
        )
        {
            self.confluenceConfiguration = confluenceConfiguration
            self.s3Configuration = s3Configuration
            self.salesforceConfiguration = salesforceConfiguration
            self.sharePointConfiguration = sharePointConfiguration
            self.type = type
            self.webConfiguration = webConfiguration
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains the configuration for server-side encryption.
    public struct ServerSideEncryptionConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the KMS key used to encrypt the resource.
        public var kmsKeyArn: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
        }
    }
}

extension BedrockAgentClientTypes {

    public enum ChunkingStrategy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fixedSize
        case hierarchical
        case `none`
        case semantic
        case sdkUnknown(Swift.String)

        public static var allCases: [ChunkingStrategy] {
            return [
                .fixedSize,
                .hierarchical,
                .none,
                .semantic
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fixedSize: return "FIXED_SIZE"
            case .hierarchical: return "HIERARCHICAL"
            case .none: return "NONE"
            case .semantic: return "SEMANTIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.
    public struct FixedSizeChunkingConfiguration: Swift.Sendable {
        /// The maximum number of tokens to include in a chunk.
        /// This member is required.
        public var maxTokens: Swift.Int?
        /// The percentage of overlap between adjacent chunks of a data source.
        /// This member is required.
        public var overlapPercentage: Swift.Int?

        public init(
            maxTokens: Swift.Int? = nil,
            overlapPercentage: Swift.Int? = nil
        )
        {
            self.maxTokens = maxTokens
            self.overlapPercentage = overlapPercentage
        }
    }
}

extension BedrockAgentClientTypes {

    /// Token settings for a layer in a hierarchical chunking configuration.
    public struct HierarchicalChunkingLevelConfiguration: Swift.Sendable {
        /// The maximum number of tokens that a chunk can contain in this layer.
        /// This member is required.
        public var maxTokens: Swift.Int?

        public init(
            maxTokens: Swift.Int? = nil
        )
        {
            self.maxTokens = maxTokens
        }
    }
}

extension BedrockAgentClientTypes {

    /// Settings for hierarchical document chunking for a data source. Hierarchical chunking splits documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer. You configure the number of tokens to overlap, or repeat across adjacent chunks. For example, if you set overlap tokens to 60, the last 60 tokens in the first chunk are also included at the beginning of the second chunk. For each layer, you must also configure the maximum number of tokens in a chunk.
    public struct HierarchicalChunkingConfiguration: Swift.Sendable {
        /// Token settings for each layer.
        /// This member is required.
        public var levelConfigurations: [BedrockAgentClientTypes.HierarchicalChunkingLevelConfiguration]?
        /// The number of tokens to repeat across chunks in the same layer.
        /// This member is required.
        public var overlapTokens: Swift.Int?

        public init(
            levelConfigurations: [BedrockAgentClientTypes.HierarchicalChunkingLevelConfiguration]? = nil,
            overlapTokens: Swift.Int? = nil
        )
        {
            self.levelConfigurations = levelConfigurations
            self.overlapTokens = overlapTokens
        }
    }
}

extension BedrockAgentClientTypes {

    /// Settings for semantic document chunking for a data source. Semantic chunking splits a document into into smaller documents based on groups of similar content derived from the text with natural language processing. With semantic chunking, each sentence is compared to the next to determine how similar they are. You specify a threshold in the form of a percentile, where adjacent sentences that are less similar than that percentage of sentence pairs are divided into separate chunks. For example, if you set the threshold to 90, then the 10 percent of sentence pairs that are least similar are split. So if you have 101 sentences, 100 sentence pairs are compared, and the 10 with the least similarity are split, creating 11 chunks. These chunks are further split if they exceed the max token size. You must also specify a buffer size, which determines whether sentences are compared in isolation, or within a moving context window that includes the previous and following sentence. For example, if you set the buffer size to 1, the embedding for sentence 10 is derived from sentences 9, 10, and 11 combined.
    public struct SemanticChunkingConfiguration: Swift.Sendable {
        /// The dissimilarity threshold for splitting chunks.
        /// This member is required.
        public var breakpointPercentileThreshold: Swift.Int?
        /// The buffer size.
        /// This member is required.
        public var bufferSize: Swift.Int?
        /// The maximum number of tokens that a chunk can contain.
        /// This member is required.
        public var maxTokens: Swift.Int?

        public init(
            breakpointPercentileThreshold: Swift.Int? = nil,
            bufferSize: Swift.Int? = nil,
            maxTokens: Swift.Int? = nil
        )
        {
            self.breakpointPercentileThreshold = breakpointPercentileThreshold
            self.bufferSize = bufferSize
            self.maxTokens = maxTokens
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
    public struct ChunkingConfiguration: Swift.Sendable {
        /// Knowledge base can split your source data into chunks. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for NONE, then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.
        ///
        /// * FIXED_SIZE  Amazon Bedrock splits your source data into chunks of the approximate size that you set in the fixedSizeChunkingConfiguration.
        ///
        /// * HIERARCHICAL  Split documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
        ///
        /// * SEMANTIC  Split documents into chunks based on groups of similar content derived with natural language processing.
        ///
        /// * NONE  Amazon Bedrock treats each file as one chunk. If you choose this option, you may want to pre-process your documents by splitting them into separate files.
        /// This member is required.
        public var chunkingStrategy: BedrockAgentClientTypes.ChunkingStrategy?
        /// Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.
        public var fixedSizeChunkingConfiguration: BedrockAgentClientTypes.FixedSizeChunkingConfiguration?
        /// Settings for hierarchical document chunking for a data source. Hierarchical chunking splits documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
        public var hierarchicalChunkingConfiguration: BedrockAgentClientTypes.HierarchicalChunkingConfiguration?
        /// Settings for semantic document chunking for a data source. Semantic chunking splits a document into into smaller documents based on groups of similar content derived from the text with natural language processing.
        public var semanticChunkingConfiguration: BedrockAgentClientTypes.SemanticChunkingConfiguration?

        public init(
            chunkingStrategy: BedrockAgentClientTypes.ChunkingStrategy? = nil,
            fixedSizeChunkingConfiguration: BedrockAgentClientTypes.FixedSizeChunkingConfiguration? = nil,
            hierarchicalChunkingConfiguration: BedrockAgentClientTypes.HierarchicalChunkingConfiguration? = nil,
            semanticChunkingConfiguration: BedrockAgentClientTypes.SemanticChunkingConfiguration? = nil
        )
        {
            self.chunkingStrategy = chunkingStrategy
            self.fixedSizeChunkingConfiguration = fixedSizeChunkingConfiguration
            self.hierarchicalChunkingConfiguration = hierarchicalChunkingConfiguration
            self.semanticChunkingConfiguration = semanticChunkingConfiguration
        }
    }
}

extension BedrockAgentClientTypes {

    /// An Amazon S3 location.
    public struct S3Location: Swift.Sendable {
        /// The location's URI. For example, s3://my-bucket/chunk-processor/.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        )
        {
            self.uri = uri
        }
    }
}

extension BedrockAgentClientTypes {

    /// A location for storing content from data sources temporarily as it is processed by custom components in the ingestion pipeline.
    public struct IntermediateStorage: Swift.Sendable {
        /// An S3 bucket path.
        /// This member is required.
        public var s3Location: BedrockAgentClientTypes.S3Location?

        public init(
            s3Location: BedrockAgentClientTypes.S3Location? = nil
        )
        {
            self.s3Location = s3Location
        }
    }
}

extension BedrockAgentClientTypes {

    public enum StepType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case postChunking
        case sdkUnknown(Swift.String)

        public static var allCases: [StepType] {
            return [
                .postChunking
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .postChunking: return "POST_CHUNKING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// A Lambda function that processes documents.
    public struct TransformationLambdaConfiguration: Swift.Sendable {
        /// The function's ARN identifier.
        /// This member is required.
        public var lambdaArn: Swift.String?

        public init(
            lambdaArn: Swift.String? = nil
        )
        {
            self.lambdaArn = lambdaArn
        }
    }
}

extension BedrockAgentClientTypes {

    /// A Lambda function that processes documents.
    public struct TransformationFunction: Swift.Sendable {
        /// The Lambda function.
        /// This member is required.
        public var transformationLambdaConfiguration: BedrockAgentClientTypes.TransformationLambdaConfiguration?

        public init(
            transformationLambdaConfiguration: BedrockAgentClientTypes.TransformationLambdaConfiguration? = nil
        )
        {
            self.transformationLambdaConfiguration = transformationLambdaConfiguration
        }
    }
}

extension BedrockAgentClientTypes {

    /// A custom processing step for documents moving through a data source ingestion pipeline. To process documents after they have been converted into chunks, set the step to apply to POST_CHUNKING.
    public struct Transformation: Swift.Sendable {
        /// When the service applies the transformation.
        /// This member is required.
        public var stepToApply: BedrockAgentClientTypes.StepType?
        /// A Lambda function that processes documents.
        /// This member is required.
        public var transformationFunction: BedrockAgentClientTypes.TransformationFunction?

        public init(
            stepToApply: BedrockAgentClientTypes.StepType? = nil,
            transformationFunction: BedrockAgentClientTypes.TransformationFunction? = nil
        )
        {
            self.stepToApply = stepToApply
            self.transformationFunction = transformationFunction
        }
    }
}

extension BedrockAgentClientTypes {

    /// Settings for customizing steps in the data source content ingestion pipeline. You can configure the data source to process documents with a Lambda function after they are parsed and converted into chunks. When you add a post-chunking transformation, the service stores chunked documents in an S3 bucket and invokes a Lambda function to process them. To process chunked documents with a Lambda function, define an S3 bucket path for input and output objects, and a transformation that specifies the Lambda function to invoke. You can use the Lambda function to customize how chunks are split, and the metadata for each chunk.
    public struct CustomTransformationConfiguration: Swift.Sendable {
        /// An S3 bucket path for input and output objects.
        /// This member is required.
        public var intermediateStorage: BedrockAgentClientTypes.IntermediateStorage?
        /// A Lambda function that processes documents.
        /// This member is required.
        public var transformations: [BedrockAgentClientTypes.Transformation]?

        public init(
            intermediateStorage: BedrockAgentClientTypes.IntermediateStorage? = nil,
            transformations: [BedrockAgentClientTypes.Transformation]? = nil
        )
        {
            self.intermediateStorage = intermediateStorage
            self.transformations = transformations
        }
    }
}

extension BedrockAgentClientTypes {

    /// Instructions for interpreting the contents of a document.
    public struct ParsingPrompt: Swift.Sendable {
        /// Instructions for interpreting the contents of a document.
        /// This member is required.
        public var parsingPromptText: Swift.String?

        public init(
            parsingPromptText: Swift.String? = nil
        )
        {
            self.parsingPromptText = parsingPromptText
        }
    }
}

extension BedrockAgentClientTypes {

    /// Settings for a foundation model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html) used to parse documents for a data source.
    public struct BedrockFoundationModelConfiguration: Swift.Sendable {
        /// The ARN of the foundation model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html).
        /// This member is required.
        public var modelArn: Swift.String?
        /// Instructions for interpreting the contents of a document.
        public var parsingPrompt: BedrockAgentClientTypes.ParsingPrompt?

        public init(
            modelArn: Swift.String? = nil,
            parsingPrompt: BedrockAgentClientTypes.ParsingPrompt? = nil
        )
        {
            self.modelArn = modelArn
            self.parsingPrompt = parsingPrompt
        }
    }
}

extension BedrockAgentClientTypes {

    public enum ParsingStrategy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bedrockFoundationModel
        case sdkUnknown(Swift.String)

        public static var allCases: [ParsingStrategy] {
            return [
                .bedrockFoundationModel
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bedrockFoundationModel: return "BEDROCK_FOUNDATION_MODEL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// Settings for parsing document contents. By default, the service converts the contents of each document into text before splitting it into chunks. To improve processing of PDF files with tables and images, you can configure the data source to convert the pages of text into images and use a model to describe the contents of each page. To use a model to parse PDF documents, set the parsing strategy to BEDROCK_FOUNDATION_MODEL and specify the model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html) to use by ARN. You can also override the default parsing prompt with instructions for how to interpret images and tables in your documents. The following models are supported.
    ///
    /// * Anthropic Claude 3 Sonnet - anthropic.claude-3-sonnet-20240229-v1:0
    ///
    /// * Anthropic Claude 3 Haiku - anthropic.claude-3-haiku-20240307-v1:0
    ///
    ///
    /// You can get the ARN of a model with the [ListFoundationModels](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_ListFoundationModels.html) action. Standard model usage charges apply for the foundation model parsing strategy.
    public struct ParsingConfiguration: Swift.Sendable {
        /// Settings for a foundation model used to parse documents for a data source.
        public var bedrockFoundationModelConfiguration: BedrockAgentClientTypes.BedrockFoundationModelConfiguration?
        /// The parsing strategy for the data source.
        /// This member is required.
        public var parsingStrategy: BedrockAgentClientTypes.ParsingStrategy?

        public init(
            bedrockFoundationModelConfiguration: BedrockAgentClientTypes.BedrockFoundationModelConfiguration? = nil,
            parsingStrategy: BedrockAgentClientTypes.ParsingStrategy? = nil
        )
        {
            self.bedrockFoundationModelConfiguration = bedrockFoundationModelConfiguration
            self.parsingStrategy = parsingStrategy
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about how to ingest the documents in a data source.
    public struct VectorIngestionConfiguration: Swift.Sendable {
        /// Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        public var chunkingConfiguration: BedrockAgentClientTypes.ChunkingConfiguration?
        /// A custom document transformer for parsed data source documents.
        public var customTransformationConfiguration: BedrockAgentClientTypes.CustomTransformationConfiguration?
        /// A custom parser for data source documents.
        public var parsingConfiguration: BedrockAgentClientTypes.ParsingConfiguration?

        public init(
            chunkingConfiguration: BedrockAgentClientTypes.ChunkingConfiguration? = nil,
            customTransformationConfiguration: BedrockAgentClientTypes.CustomTransformationConfiguration? = nil,
            parsingConfiguration: BedrockAgentClientTypes.ParsingConfiguration? = nil
        )
        {
            self.chunkingConfiguration = chunkingConfiguration
            self.customTransformationConfiguration = customTransformationConfiguration
            self.parsingConfiguration = parsingConfiguration
        }
    }
}

public struct CreateDataSourceInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The data deletion policy for the data source. You can set the data deletion policy to:
    ///
    /// * DELETE: Deletes all data from your data source thats converted into vector embeddings upon deletion of a knowledge base or data source resource. Note that the vector store itself is not deleted, only the data. This flag is ignored if an Amazon Web Services account is deleted.
    ///
    /// * RETAIN: Retains all data from your data source thats converted into vector embeddings upon deletion of a knowledge base or data source resource. Note that the vector store itself is not deleted if you delete a knowledge base or data source resource.
    public var dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy?
    /// The connection configuration for the data source.
    /// This member is required.
    public var dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration?
    /// A description of the data source.
    public var description: Swift.String?
    /// The unique identifier of the knowledge base to which to add the data source.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The name of the data source.
    /// This member is required.
    public var name: Swift.String?
    /// Contains details about the server-side encryption for the data source.
    public var serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration?
    /// Contains details about how to ingest the documents in the data source.
    public var vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration?

    public init(
        clientToken: Swift.String? = nil,
        dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy? = nil,
        dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration? = nil,
        vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration? = nil
    )
    {
        self.clientToken = clientToken
        self.dataDeletionPolicy = dataDeletionPolicy
        self.dataSourceConfiguration = dataSourceConfiguration
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.vectorIngestionConfiguration = vectorIngestionConfiguration
    }
}

extension BedrockAgentClientTypes {

    public enum DataSourceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleteUnsuccessful
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceStatus] {
            return [
                .available,
                .deleteUnsuccessful,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleteUnsuccessful: return "DELETE_UNSUCCESSFUL"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about a data source.
    public struct DataSource: Swift.Sendable {
        /// The time at which the data source was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The data deletion policy for the data source.
        public var dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy?
        /// The connection configuration for the data source.
        /// This member is required.
        public var dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration?
        /// The unique identifier of the data source.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// The description of the data source.
        public var description: Swift.String?
        /// The detailed reasons on the failure to delete a data source.
        public var failureReasons: [Swift.String]?
        /// The unique identifier of the knowledge base to which the data source belongs.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// Contains details about the configuration of the server-side encryption.
        public var serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration?
        /// The status of the data source. The following statuses are possible:
        ///
        /// * Available  The data source has been created and is ready for ingestion into the knowledge base.
        ///
        /// * Deleting  The data source is being deleted.
        /// This member is required.
        public var status: BedrockAgentClientTypes.DataSourceStatus?
        /// The time at which the data source was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?
        /// Contains details about how to ingest the documents in the data source.
        public var vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration?

        public init(
            createdAt: Foundation.Date? = nil,
            dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy? = nil,
            dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration? = nil,
            dataSourceId: Swift.String? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            knowledgeBaseId: Swift.String? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration? = nil,
            status: BedrockAgentClientTypes.DataSourceStatus? = nil,
            updatedAt: Foundation.Date? = nil,
            vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration? = nil
        )
        {
            self.createdAt = createdAt
            self.dataDeletionPolicy = dataDeletionPolicy
            self.dataSourceConfiguration = dataSourceConfiguration
            self.dataSourceId = dataSourceId
            self.description = description
            self.failureReasons = failureReasons
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.status = status
            self.updatedAt = updatedAt
            self.vectorIngestionConfiguration = vectorIngestionConfiguration
        }
    }
}

public struct CreateDataSourceOutput: Swift.Sendable {
    /// Contains details about the data source.
    /// This member is required.
    public var dataSource: BedrockAgentClientTypes.DataSource?

    public init(
        dataSource: BedrockAgentClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

public struct DeleteDataSourceInput: Swift.Sendable {
    /// The unique identifier of the data source to delete.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The unique identifier of the knowledge base from which to delete the data source.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        dataSourceId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct DeleteDataSourceOutput: Swift.Sendable {
    /// The unique identifier of the data source that was deleted.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The unique identifier of the knowledge base to which the data source that was deleted belonged.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The status of the data source.
    /// This member is required.
    public var status: BedrockAgentClientTypes.DataSourceStatus?

    public init(
        dataSourceId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        status: BedrockAgentClientTypes.DataSourceStatus? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.knowledgeBaseId = knowledgeBaseId
        self.status = status
    }
}

public struct GetDataSourceInput: Swift.Sendable {
    /// The unique identifier of the data source.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The unique identifier of the knowledge base for the data source.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        dataSourceId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct GetDataSourceOutput: Swift.Sendable {
    /// Contains details about the data source.
    /// This member is required.
    public var dataSource: BedrockAgentClientTypes.DataSource?

    public init(
        dataSource: BedrockAgentClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

public struct ListDataSourcesInput: Swift.Sendable {
    /// The unique identifier of the knowledge base for which to return a list of information.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about a data source.
    public struct DataSourceSummary: Swift.Sendable {
        /// The unique identifier of the data source.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// The description of the data source.
        public var description: Swift.String?
        /// The unique identifier of the knowledge base to which the data source belongs.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The name of the data source.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the data source.
        /// This member is required.
        public var status: BedrockAgentClientTypes.DataSourceStatus?
        /// The time at which the data source was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            dataSourceId: Swift.String? = nil,
            description: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            name: Swift.String? = nil,
            status: BedrockAgentClientTypes.DataSourceStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.dataSourceId = dataSourceId
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct ListDataSourcesOutput: Swift.Sendable {
    /// A list of objects, each of which contains information about a data source.
    /// This member is required.
    public var dataSourceSummaries: [BedrockAgentClientTypes.DataSourceSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        dataSourceSummaries: [BedrockAgentClientTypes.DataSourceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataSourceSummaries = dataSourceSummaries
        self.nextToken = nextToken
    }
}

public struct UpdateDataSourceInput: Swift.Sendable {
    /// The data deletion policy for the data source that you want to update.
    public var dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy?
    /// The connection configuration for the data source that you want to update.
    /// This member is required.
    public var dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration?
    /// The unique identifier of the data source.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// Specifies a new description for the data source.
    public var description: Swift.String?
    /// The unique identifier of the knowledge base for the data source.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// Specifies a new name for the data source.
    /// This member is required.
    public var name: Swift.String?
    /// Contains details about server-side encryption of the data source.
    public var serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration?
    /// Contains details about how to ingest the documents in the data source.
    public var vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration?

    public init(
        dataDeletionPolicy: BedrockAgentClientTypes.DataDeletionPolicy? = nil,
        dataSourceConfiguration: BedrockAgentClientTypes.DataSourceConfiguration? = nil,
        dataSourceId: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: BedrockAgentClientTypes.ServerSideEncryptionConfiguration? = nil,
        vectorIngestionConfiguration: BedrockAgentClientTypes.VectorIngestionConfiguration? = nil
    )
    {
        self.dataDeletionPolicy = dataDeletionPolicy
        self.dataSourceConfiguration = dataSourceConfiguration
        self.dataSourceId = dataSourceId
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.vectorIngestionConfiguration = vectorIngestionConfiguration
    }
}

public struct UpdateDataSourceOutput: Swift.Sendable {
    /// Contains details about the data source.
    /// This member is required.
    public var dataSource: BedrockAgentClientTypes.DataSource?

    public init(
        dataSource: BedrockAgentClientTypes.DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

extension BedrockAgentClientTypes {

    /// The configuration of a connection between a condition node and another node.
    public struct FlowConditionalConnectionConfiguration: Swift.Sendable {
        /// The condition that triggers this connection. For more information about how to write conditions, see the Condition node type in the [Node types](https://docs.aws.amazon.com/bedrock/latest/userguide/node-types.html) topic in the Amazon Bedrock User Guide.
        /// This member is required.
        public var condition: Swift.String?

        public init(
            condition: Swift.String? = nil
        )
        {
            self.condition = condition
        }
    }
}

extension BedrockAgentClientTypes {

    /// The configuration of a connection originating from a node that isn't a Condition node.
    public struct FlowDataConnectionConfiguration: Swift.Sendable {
        /// The name of the output in the source node that the connection begins from.
        /// This member is required.
        public var sourceOutput: Swift.String?
        /// The name of the input in the target node that the connection ends at.
        /// This member is required.
        public var targetInput: Swift.String?

        public init(
            sourceOutput: Swift.String? = nil,
            targetInput: Swift.String? = nil
        )
        {
            self.sourceOutput = sourceOutput
            self.targetInput = targetInput
        }
    }
}

extension BedrockAgentClientTypes {

    /// The configuration of the connection.
    public enum FlowConnectionConfiguration: Swift.Sendable {
        /// The configuration of a connection originating from a node that isn't a Condition node.
        case data(BedrockAgentClientTypes.FlowDataConnectionConfiguration)
        /// The configuration of a connection originating from a Condition node.
        case conditional(BedrockAgentClientTypes.FlowConditionalConnectionConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentClientTypes {

    public enum FlowConnectionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case conditional
        case data
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowConnectionType] {
            return [
                .conditional,
                .data
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .conditional: return "Conditional"
            case .data: return "Data"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains information about a connection between two nodes in the flow.
    public struct FlowConnection: Swift.Sendable {
        /// The configuration of the connection.
        public var configuration: BedrockAgentClientTypes.FlowConnectionConfiguration?
        /// A name for the connection that you can reference.
        /// This member is required.
        public var name: Swift.String?
        /// The node that the connection starts at.
        /// This member is required.
        public var source: Swift.String?
        /// The node that the connection ends at.
        /// This member is required.
        public var target: Swift.String?
        /// Whether the source node that the connection begins from is a condition node (Conditional) or not (Data).
        /// This member is required.
        public var type: BedrockAgentClientTypes.FlowConnectionType?

        public init(
            configuration: BedrockAgentClientTypes.FlowConnectionConfiguration? = nil,
            name: Swift.String? = nil,
            source: Swift.String? = nil,
            target: Swift.String? = nil,
            type: BedrockAgentClientTypes.FlowConnectionType? = nil
        )
        {
            self.configuration = configuration
            self.name = name
            self.source = source
            self.target = target
            self.type = type
        }
    }
}

extension BedrockAgentClientTypes {

    /// Defines a collector node in your flow. This node takes an iteration of inputs and consolidates them into an array in the output. For more information, see [Node types in Amazon Bedrock works](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html) in the Amazon Bedrock User Guide.
    public struct CollectorFlowNodeConfiguration: Swift.Sendable {

        public init() { }
    }
}

extension BedrockAgentClientTypes {

    /// Defines a condition in the condition node.
    public struct FlowCondition: Swift.Sendable {
        /// Defines the condition. You must refer to at least one of the inputs in the condition. For more information, expand the Condition node section in [Node types in prompt flows](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-how-it-works.html#flows-nodes).
        public var expression: Swift.String?
        /// A name for the condition that you can reference.
        /// This member is required.
        public var name: Swift.String?

        public init(
            expression: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.expression = expression
            self.name = name
        }
    }
}

extension BedrockAgentClientTypes.FlowCondition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FlowCondition(name: \(Swift.String(describing: name)), expression: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentClientTypes {

    /// Defines a condition node in your flow. You can specify conditions that determine which node comes next in the flow. For more information, see [Node types in Amazon Bedrock works](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html) in the Amazon Bedrock User Guide.
    public struct ConditionFlowNodeConfiguration: Swift.Sendable {
        /// An array of conditions. Each member contains the name of a condition and an expression that defines the condition.
        /// This member is required.
        public var conditions: [BedrockAgentClientTypes.FlowCondition]?

        public init(
            conditions: [BedrockAgentClientTypes.FlowCondition]? = nil
        )
        {
            self.conditions = conditions
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for the input flow node for a flow. This node takes the input from flow invocation and passes it to the next node in the data type that you specify.
    public struct InputFlowNodeConfiguration: Swift.Sendable {

        public init() { }
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for an iterator node in a flow. Takes an input that is an array and iteratively sends each item of the array as an output to the following node. The size of the array is also returned in the output. The output flow node at the end of the flow iteration will return a response for each member of the array. To return only one response, you can include a collector node downstream from the iterator node.
    public struct IteratorFlowNodeConfiguration: Swift.Sendable {

        public init() { }
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for a knowledge base node in a flow. This node takes a query as the input and returns, as the output, the retrieved responses directly (as an array) or a response generated based on the retrieved responses. For more information, see [Node types in Amazon Bedrock works](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html) in the Amazon Bedrock User Guide.
    public struct KnowledgeBaseFlowNodeConfiguration: Swift.Sendable {
        /// Contains configurations for a guardrail to apply during query and response generation for the knowledge base in this configuration.
        public var guardrailConfiguration: BedrockAgentClientTypes.GuardrailConfiguration?
        /// The unique identifier of the knowledge base to query.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The unique identifier of the model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html) to use to generate a response from the query results. Omit this field if you want to return the retrieved results as an array.
        public var modelId: Swift.String?

        public init(
            guardrailConfiguration: BedrockAgentClientTypes.GuardrailConfiguration? = nil,
            knowledgeBaseId: Swift.String? = nil,
            modelId: Swift.String? = nil
        )
        {
            self.guardrailConfiguration = guardrailConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.modelId = modelId
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for a Lambda function node in the flow. You specify the Lambda function to invoke and the inputs into the function. The output is the response that is defined in the Lambda function. For more information, see [Node types in Amazon Bedrock works](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html) in the Amazon Bedrock User Guide.
    public struct LambdaFunctionFlowNodeConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Lambda function to invoke.
        /// This member is required.
        public var lambdaArn: Swift.String?

        public init(
            lambdaArn: Swift.String? = nil
        )
        {
            self.lambdaArn = lambdaArn
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for a Lex node in the flow. You specify a Amazon Lex bot to invoke. This node takes an utterance as the input and returns as the output the intent identified by the Amazon Lex bot. For more information, see [Node types in Amazon Bedrock works](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html) in the Amazon Bedrock User Guide.
    public struct LexFlowNodeConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Amazon Lex bot alias to invoke.
        /// This member is required.
        public var botAliasArn: Swift.String?
        /// The Region to invoke the Amazon Lex bot in.
        /// This member is required.
        public var localeId: Swift.String?

        public init(
            botAliasArn: Swift.String? = nil,
            localeId: Swift.String? = nil
        )
        {
            self.botAliasArn = botAliasArn
            self.localeId = localeId
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for an output flow node in the flow. You specify the data type expected for the input into the node in the type field and how to return the final output in the expression field.
    public struct OutputFlowNodeConfiguration: Swift.Sendable {

        public init() { }
    }
}

extension BedrockAgentClientTypes {

    /// Contains inference configurations related to model inference for a prompt. For more information, see [Inference parameters](https://docs.aws.amazon.com/bedrock/latest/userguide/inference-parameters.html).
    public struct PromptModelInferenceConfiguration: Swift.Sendable {
        /// The maximum number of tokens to return in the response.
        public var maxTokens: Swift.Int?
        /// A list of strings that define sequences after which the model will stop generating.
        public var stopSequences: [Swift.String]?
        /// Controls the randomness of the response. Choose a lower value for more predictable outputs and a higher value for more surprising outputs.
        public var temperature: Swift.Float?
        /// The percentage of most-likely candidates that the model considers for the next token.
        public var topp: Swift.Float?

        public init(
            maxTokens: Swift.Int? = nil,
            stopSequences: [Swift.String]? = nil,
            temperature: Swift.Float? = nil,
            topp: Swift.Float? = nil
        )
        {
            self.maxTokens = maxTokens
            self.stopSequences = stopSequences
            self.temperature = temperature
            self.topp = topp
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains inference configurations for the prompt.
    public enum PromptInferenceConfiguration: Swift.Sendable {
        /// Contains inference configurations for a text prompt.
        case text(BedrockAgentClientTypes.PromptModelInferenceConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentClientTypes {

    /// Contains information about a variable in the prompt.
    public struct PromptInputVariable: Swift.Sendable {
        /// The name of the variable.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains the content for the message you pass to, or receive from a model. For more information, see [Create a prompt using Prompt management](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management-create.html).
    public enum ContentBlock: Swift.Sendable {
        /// The text in the message.
        case text(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentClientTypes {

    public enum ConversationRole: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assistant
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [ConversationRole] {
            return [
                .assistant,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assistant: return "assistant"
            case .user: return "user"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// A message input or response from a model. For more information, see [Create a prompt using Prompt management](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management-create.html).
    public struct Message: Swift.Sendable {
        /// The content in the message.
        /// This member is required.
        public var content: [BedrockAgentClientTypes.ContentBlock]?
        /// The role that the message belongs to.
        /// This member is required.
        public var role: BedrockAgentClientTypes.ConversationRole?

        public init(
            content: [BedrockAgentClientTypes.ContentBlock]? = nil,
            role: BedrockAgentClientTypes.ConversationRole? = nil
        )
        {
            self.content = content
            self.role = role
        }
    }
}

extension BedrockAgentClientTypes.Message: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Message(role: \(Swift.String(describing: role)), content: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentClientTypes {

    /// Contains a system prompt to provide context to the model or to describe how it should behave. For more information, see [Create a prompt using Prompt management](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management-create.html).
    public enum SystemContentBlock: Swift.Sendable {
        /// The text in the system prompt.
        case text(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentClientTypes {

    /// Defines tools, at least one of which must be requested by the model. No text is generated but the results of tool use are sent back to the model to help generate a response. For more information, see [Use a tool to complete an Amazon Bedrock model response](https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html).
    public struct AnyToolChoice: Swift.Sendable {

        public init() { }
    }
}

extension BedrockAgentClientTypes {

    /// Defines tools. The model automatically decides whether to call a tool or to generate text instead. For more information, see [Use a tool to complete an Amazon Bedrock model response](https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html).
    public struct AutoToolChoice: Swift.Sendable {

        public init() { }
    }
}

extension BedrockAgentClientTypes {

    /// Defines a specific tool that the model must request. No text is generated but the results of tool use are sent back to the model to help generate a response. For more information, see [Use a tool to complete an Amazon Bedrock model response](https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html).
    public struct SpecificToolChoice: Swift.Sendable {
        /// The name of the tool.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }
}

extension BedrockAgentClientTypes {

    /// Defines which tools the model should request when invoked. For more information, see [Use a tool to complete an Amazon Bedrock model response](https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html).
    public enum ToolChoice: Swift.Sendable {
        /// Defines tools. The model automatically decides whether to call a tool or to generate text instead.
        case auto(BedrockAgentClientTypes.AutoToolChoice)
        /// Defines tools, at least one of which must be requested by the model. No text is generated but the results of tool use are sent back to the model to help generate a response.
        case any(BedrockAgentClientTypes.AnyToolChoice)
        /// Defines a specific tool that the model must request. No text is generated but the results of tool use are sent back to the model to help generate a response.
        case tool(BedrockAgentClientTypes.SpecificToolChoice)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentClientTypes {

    /// The input schema for the tool. For more information, see [Use a tool to complete an Amazon Bedrock model response](https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html).
    public enum ToolInputSchema: Swift.Sendable {
        /// A JSON object defining the input schema for the tool.
        case json(Smithy.Document)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentClientTypes {

    /// Contains a specification for a tool. For more information, see [Use a tool to complete an Amazon Bedrock model response](https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html).
    public struct ToolSpecification: Swift.Sendable {
        /// The description of the tool.
        public var description: Swift.String?
        /// The input schema for the tool.
        /// This member is required.
        public var inputSchema: BedrockAgentClientTypes.ToolInputSchema?
        /// The name of the tool.
        /// This member is required.
        public var name: Swift.String?

        public init(
            description: Swift.String? = nil,
            inputSchema: BedrockAgentClientTypes.ToolInputSchema? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.inputSchema = inputSchema
            self.name = name
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for a tool that a model can use when generating a response. For more information, see [Use a tool to complete an Amazon Bedrock model response](https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html).
    public enum Tool: Swift.Sendable {
        /// The specification for the tool.
        case toolspec(BedrockAgentClientTypes.ToolSpecification)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentClientTypes {

    /// Configuration information for the tools that the model can use when generating a response. For more information, see [Use a tool to complete an Amazon Bedrock model response](https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html).
    public struct ToolConfiguration: Swift.Sendable {
        /// Defines which tools the model should request when invoked.
        public var toolChoice: BedrockAgentClientTypes.ToolChoice?
        /// An array of tools to pass to a model.
        /// This member is required.
        public var tools: [BedrockAgentClientTypes.Tool]?

        public init(
            toolChoice: BedrockAgentClientTypes.ToolChoice? = nil,
            tools: [BedrockAgentClientTypes.Tool]? = nil
        )
        {
            self.toolChoice = toolChoice
            self.tools = tools
        }
    }
}

extension BedrockAgentClientTypes.ToolConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ToolConfiguration(toolChoice: \"CONTENT_REDACTED\", tools: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentClientTypes {

    /// Contains configurations to use a prompt in a conversational format. For more information, see [Create a prompt using Prompt management](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management-create.html).
    public struct ChatPromptTemplateConfiguration: Swift.Sendable {
        /// An array of the variables in the prompt template.
        public var inputVariables: [BedrockAgentClientTypes.PromptInputVariable]?
        /// Contains messages in the chat for the prompt.
        /// This member is required.
        public var messages: [BedrockAgentClientTypes.Message]?
        /// Contains system prompts to provide context to the model or to describe how it should behave.
        public var system: [BedrockAgentClientTypes.SystemContentBlock]?
        /// Configuration information for the tools that the model can use when generating a response.
        public var toolConfiguration: BedrockAgentClientTypes.ToolConfiguration?

        public init(
            inputVariables: [BedrockAgentClientTypes.PromptInputVariable]? = nil,
            messages: [BedrockAgentClientTypes.Message]? = nil,
            system: [BedrockAgentClientTypes.SystemContentBlock]? = nil,
            toolConfiguration: BedrockAgentClientTypes.ToolConfiguration? = nil
        )
        {
            self.inputVariables = inputVariables
            self.messages = messages
            self.system = system
            self.toolConfiguration = toolConfiguration
        }
    }
}

extension BedrockAgentClientTypes.ChatPromptTemplateConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for a text prompt template. To include a variable, enclose a word in double curly braces as in {{variable}}.
    public struct TextPromptTemplateConfiguration: Swift.Sendable {
        /// An array of the variables in the prompt template.
        public var inputVariables: [BedrockAgentClientTypes.PromptInputVariable]?
        /// The message for the prompt.
        /// This member is required.
        public var text: Swift.String?

        public init(
            inputVariables: [BedrockAgentClientTypes.PromptInputVariable]? = nil,
            text: Swift.String? = nil
        )
        {
            self.inputVariables = inputVariables
            self.text = text
        }
    }
}

extension BedrockAgentClientTypes.TextPromptTemplateConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentClientTypes {

    /// Contains the message for a prompt. For more information, see [Construct and store reusable prompts with Prompt management in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management.html).
    public enum PromptTemplateConfiguration: Swift.Sendable {
        /// Contains configurations for the text in a message for a prompt.
        case text(BedrockAgentClientTypes.TextPromptTemplateConfiguration)
        /// Contains configurations to use the prompt in a conversational format.
        case chat(BedrockAgentClientTypes.ChatPromptTemplateConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentClientTypes {

    public enum PromptTemplateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case chat
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [PromptTemplateType] {
            return [
                .chat,
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .chat: return "CHAT"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for a prompt defined inline in the node.
    public struct PromptFlowNodeInlineConfiguration: Swift.Sendable {
        /// Additional fields to be included in the model request for the Prompt node.
        public var additionalModelRequestFields: Smithy.Document?
        /// Contains inference configurations for the prompt.
        public var inferenceConfiguration: BedrockAgentClientTypes.PromptInferenceConfiguration?
        /// The unique identifier of the model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html) to run inference with.
        /// This member is required.
        public var modelId: Swift.String?
        /// Contains a prompt and variables in the prompt that can be replaced with values at runtime.
        /// This member is required.
        public var templateConfiguration: BedrockAgentClientTypes.PromptTemplateConfiguration?
        /// The type of prompt template.
        /// This member is required.
        public var templateType: BedrockAgentClientTypes.PromptTemplateType?

        public init(
            additionalModelRequestFields: Smithy.Document? = nil,
            inferenceConfiguration: BedrockAgentClientTypes.PromptInferenceConfiguration? = nil,
            modelId: Swift.String? = nil,
            templateConfiguration: BedrockAgentClientTypes.PromptTemplateConfiguration? = nil,
            templateType: BedrockAgentClientTypes.PromptTemplateType? = nil
        )
        {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.inferenceConfiguration = inferenceConfiguration
            self.modelId = modelId
            self.templateConfiguration = templateConfiguration
            self.templateType = templateType
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for a prompt from Prompt management to use in a node.
    public struct PromptFlowNodeResourceConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the prompt from Prompt management.
        /// This member is required.
        public var promptArn: Swift.String?

        public init(
            promptArn: Swift.String? = nil
        )
        {
            self.promptArn = promptArn
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for a prompt and whether it is from Prompt management or defined inline.
    public enum PromptFlowNodeSourceConfiguration: Swift.Sendable {
        /// Contains configurations for a prompt from Prompt management.
        case resource(BedrockAgentClientTypes.PromptFlowNodeResourceConfiguration)
        /// Contains configurations for a prompt that is defined inline
        case inline(BedrockAgentClientTypes.PromptFlowNodeInlineConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for a prompt node in the flow. You can use a prompt from Prompt management or you can define one in this node. If the prompt contains variables, the inputs into this node will fill in the variables. The output from this node is the response generated by the model. For more information, see [Node types in Amazon Bedrock works](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html) in the Amazon Bedrock User Guide.
    public struct PromptFlowNodeConfiguration: Swift.Sendable {
        /// Contains configurations for a guardrail to apply to the prompt in this node and the response generated from it.
        public var guardrailConfiguration: BedrockAgentClientTypes.GuardrailConfiguration?
        /// Specifies whether the prompt is from Prompt management or defined inline.
        /// This member is required.
        public var sourceConfiguration: BedrockAgentClientTypes.PromptFlowNodeSourceConfiguration?

        public init(
            guardrailConfiguration: BedrockAgentClientTypes.GuardrailConfiguration? = nil,
            sourceConfiguration: BedrockAgentClientTypes.PromptFlowNodeSourceConfiguration? = nil
        )
        {
            self.guardrailConfiguration = guardrailConfiguration
            self.sourceConfiguration = sourceConfiguration
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for the Amazon S3 location from which to retrieve data to return as the output from the node.
    public struct RetrievalFlowNodeS3Configuration: Swift.Sendable {
        /// The name of the Amazon S3 bucket from which to retrieve data.
        /// This member is required.
        public var bucketName: Swift.String?

        public init(
            bucketName: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for the service to use for retrieving data to return as the output from the node.
    public enum RetrievalFlowNodeServiceConfiguration: Swift.Sendable {
        /// Contains configurations for the Amazon S3 location from which to retrieve data to return as the output from the node.
        case s3(BedrockAgentClientTypes.RetrievalFlowNodeS3Configuration)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for a Retrieval node in a flow. This node retrieves data from the Amazon S3 location that you specify and returns it as the output.
    public struct RetrievalFlowNodeConfiguration: Swift.Sendable {
        /// Contains configurations for the service to use for retrieving data to return as the output from the node.
        /// This member is required.
        public var serviceConfiguration: BedrockAgentClientTypes.RetrievalFlowNodeServiceConfiguration?

        public init(
            serviceConfiguration: BedrockAgentClientTypes.RetrievalFlowNodeServiceConfiguration? = nil
        )
        {
            self.serviceConfiguration = serviceConfiguration
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for the Amazon S3 location in which to store the input into the node.
    public struct StorageFlowNodeS3Configuration: Swift.Sendable {
        /// The name of the Amazon S3 bucket in which to store the input into the node.
        /// This member is required.
        public var bucketName: Swift.String?

        public init(
            bucketName: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for the service to use for storing the input into the node.
    public enum StorageFlowNodeServiceConfiguration: Swift.Sendable {
        /// Contains configurations for the Amazon S3 location in which to store the input into the node.
        case s3(BedrockAgentClientTypes.StorageFlowNodeS3Configuration)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for a Storage node in a flow. This node stores the input in an Amazon S3 location that you specify.
    public struct StorageFlowNodeConfiguration: Swift.Sendable {
        /// Contains configurations for the service to use for storing the input into the node.
        /// This member is required.
        public var serviceConfiguration: BedrockAgentClientTypes.StorageFlowNodeServiceConfiguration?

        public init(
            serviceConfiguration: BedrockAgentClientTypes.StorageFlowNodeServiceConfiguration? = nil
        )
        {
            self.serviceConfiguration = serviceConfiguration
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for a node in your flow. For more information, see [Node types in Amazon Bedrock works](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-nodes.html) in the Amazon Bedrock User Guide.
    public enum FlowNodeConfiguration: Swift.Sendable {
        /// Contains configurations for an input flow node in your flow. The first node in the flow. inputs can't be specified for this node.
        case input(BedrockAgentClientTypes.InputFlowNodeConfiguration)
        /// Contains configurations for an output flow node in your flow. The last node in the flow. outputs can't be specified for this node.
        case output(BedrockAgentClientTypes.OutputFlowNodeConfiguration)
        /// Contains configurations for a knowledge base node in your flow. Queries a knowledge base and returns the retrieved results or generated response.
        case knowledgebase(BedrockAgentClientTypes.KnowledgeBaseFlowNodeConfiguration)
        /// Contains configurations for a Condition node in your flow. Defines conditions that lead to different branches of the flow.
        case condition(BedrockAgentClientTypes.ConditionFlowNodeConfiguration)
        /// Contains configurations for a Lex node in your flow. Invokes an Amazon Lex bot to identify the intent of the input and return the intent as the output.
        case lex(BedrockAgentClientTypes.LexFlowNodeConfiguration)
        /// Contains configurations for a prompt node in your flow. Runs a prompt and generates the model response as the output. You can use a prompt from Prompt management or you can configure one in this node.
        case prompt(BedrockAgentClientTypes.PromptFlowNodeConfiguration)
        /// Contains configurations for a Lambda function node in your flow. Invokes an Lambda function.
        case lambdafunction(BedrockAgentClientTypes.LambdaFunctionFlowNodeConfiguration)
        /// Contains configurations for a Storage node in your flow. Stores an input in an Amazon S3 location.
        case storage(BedrockAgentClientTypes.StorageFlowNodeConfiguration)
        /// Contains configurations for an agent node in your flow. Invokes an alias of an agent and returns the response.
        case agent(BedrockAgentClientTypes.AgentFlowNodeConfiguration)
        /// Contains configurations for a Retrieval node in your flow. Retrieves data from an Amazon S3 location and returns it as the output.
        case retrieval(BedrockAgentClientTypes.RetrievalFlowNodeConfiguration)
        /// Contains configurations for an iterator node in your flow. Takes an input that is an array and iteratively sends each item of the array as an output to the following node. The size of the array is also returned in the output. The output flow node at the end of the flow iteration will return a response for each member of the array. To return only one response, you can include a collector node downstream from the iterator node.
        case iterator(BedrockAgentClientTypes.IteratorFlowNodeConfiguration)
        /// Contains configurations for a collector node in your flow. Collects an iteration of inputs and consolidates them into an array of outputs.
        case collector(BedrockAgentClientTypes.CollectorFlowNodeConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentClientTypes {

    public enum FlowNodeIODataType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case array
        case boolean
        case number
        case object
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowNodeIODataType] {
            return [
                .array,
                .boolean,
                .number,
                .object,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .array: return "Array"
            case .boolean: return "Boolean"
            case .number: return "Number"
            case .object: return "Object"
            case .string: return "String"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations for an input to a node.
    public struct FlowNodeInput: Swift.Sendable {
        /// An expression that formats the input for the node. For an explanation of how to create expressions, see [Expressions in Prompt flows in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-expressions.html).
        /// This member is required.
        public var expression: Swift.String?
        /// A name for the input that you can reference.
        /// This member is required.
        public var name: Swift.String?
        /// The data type of the input. If the input doesn't match this type at runtime, a validation error will be thrown.
        /// This member is required.
        public var type: BedrockAgentClientTypes.FlowNodeIODataType?

        public init(
            expression: Swift.String? = nil,
            name: Swift.String? = nil,
            type: BedrockAgentClientTypes.FlowNodeIODataType? = nil
        )
        {
            self.expression = expression
            self.name = name
            self.type = type
        }
    }
}

extension BedrockAgentClientTypes.FlowNodeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FlowNodeInput(name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)), expression: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentClientTypes {

    /// Contains configurations for an output from a node.
    public struct FlowNodeOutput: Swift.Sendable {
        /// A name for the output that you can reference.
        /// This member is required.
        public var name: Swift.String?
        /// The data type of the output. If the output doesn't match this type at runtime, a validation error will be thrown.
        /// This member is required.
        public var type: BedrockAgentClientTypes.FlowNodeIODataType?

        public init(
            name: Swift.String? = nil,
            type: BedrockAgentClientTypes.FlowNodeIODataType? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }
}

extension BedrockAgentClientTypes {

    public enum FlowNodeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agent
        case collector
        case condition
        case input
        case iterator
        case knowledgeBase
        case lambdaFunction
        case lex
        case output
        case prompt
        case retrieval
        case storage
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowNodeType] {
            return [
                .agent,
                .collector,
                .condition,
                .input,
                .iterator,
                .knowledgeBase,
                .lambdaFunction,
                .lex,
                .output,
                .prompt,
                .retrieval,
                .storage
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agent: return "Agent"
            case .collector: return "Collector"
            case .condition: return "Condition"
            case .input: return "Input"
            case .iterator: return "Iterator"
            case .knowledgeBase: return "KnowledgeBase"
            case .lambdaFunction: return "LambdaFunction"
            case .lex: return "Lex"
            case .output: return "Output"
            case .prompt: return "Prompt"
            case .retrieval: return "Retrieval"
            case .storage: return "Storage"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains configurations about a node in the flow.
    public struct FlowNode: Swift.Sendable {
        /// Contains configurations for the node.
        public var configuration: BedrockAgentClientTypes.FlowNodeConfiguration?
        /// An array of objects, each of which contains information about an input into the node.
        public var inputs: [BedrockAgentClientTypes.FlowNodeInput]?
        /// A name for the node.
        /// This member is required.
        public var name: Swift.String?
        /// A list of objects, each of which contains information about an output from the node.
        public var outputs: [BedrockAgentClientTypes.FlowNodeOutput]?
        /// The type of node. This value must match the name of the key that you provide in the configuration you provide in the FlowNodeConfiguration field.
        /// This member is required.
        public var type: BedrockAgentClientTypes.FlowNodeType?

        public init(
            configuration: BedrockAgentClientTypes.FlowNodeConfiguration? = nil,
            inputs: [BedrockAgentClientTypes.FlowNodeInput]? = nil,
            name: Swift.String? = nil,
            outputs: [BedrockAgentClientTypes.FlowNodeOutput]? = nil,
            type: BedrockAgentClientTypes.FlowNodeType? = nil
        )
        {
            self.configuration = configuration
            self.inputs = inputs
            self.name = name
            self.outputs = outputs
            self.type = type
        }
    }
}

extension BedrockAgentClientTypes {

    /// The definition of the nodes and connections between nodes in the flow.
    public struct FlowDefinition: Swift.Sendable {
        /// An array of connection definitions in the flow.
        public var connections: [BedrockAgentClientTypes.FlowConnection]?
        /// An array of node definitions in the flow.
        public var nodes: [BedrockAgentClientTypes.FlowNode]?

        public init(
            connections: [BedrockAgentClientTypes.FlowConnection]? = nil,
            nodes: [BedrockAgentClientTypes.FlowNode]? = nil
        )
        {
            self.connections = connections
            self.nodes = nodes
        }
    }
}

extension BedrockAgentClientTypes.FlowDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct CreateFlowInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key to encrypt the flow.
    public var customerEncryptionKeyArn: Swift.String?
    /// A definition of the nodes and connections between nodes in the flow.
    public var definition: BedrockAgentClientTypes.FlowDefinition?
    /// A description for the flow.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the service role with permissions to create and manage a flow. For more information, see [Create a service role for flows in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-permissions.html) in the Amazon Bedrock User Guide.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// A name for the flow.
    /// This member is required.
    public var name: Swift.String?
    /// Any tags that you want to attach to the flow. For more information, see [Tagging resources in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/tagging.html).
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        definition: BedrockAgentClientTypes.FlowDefinition? = nil,
        description: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.definition = definition
        self.description = description
        self.executionRoleArn = executionRoleArn
        self.name = name
        self.tags = tags
    }
}

extension CreateFlowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFlowInput(clientToken: \(Swift.String(describing: clientToken)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), definition: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentClientTypes {

    public enum FlowStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case notPrepared
        case prepared
        case preparing
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowStatus] {
            return [
                .failed,
                .notPrepared,
                .prepared,
                .preparing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .notPrepared: return "NotPrepared"
            case .prepared: return "Prepared"
            case .preparing: return "Preparing"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateFlowOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var arn: Swift.String?
    /// The time at which the flow was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the KMS key that you encrypted the flow with.
    public var customerEncryptionKeyArn: Swift.String?
    /// A definition of the nodes and connections between nodes in the flow.
    public var definition: BedrockAgentClientTypes.FlowDefinition?
    /// The description of the flow.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the service role with permissions to create a flow. For more information, see [Create a service role for flows in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-permissions.html) in the Amazon Bedrock User Guide.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The unique identifier of the flow.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the flow.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the flow. When you submit this request, the status will be NotPrepared. If creation fails, the status becomes Failed.
    /// This member is required.
    public var status: BedrockAgentClientTypes.FlowStatus?
    /// The time at which the flow was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The version of the flow. When you create a flow, the version created is the DRAFT version.
    /// This member is required.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        definition: BedrockAgentClientTypes.FlowDefinition? = nil,
        description: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: BedrockAgentClientTypes.FlowStatus? = nil,
        updatedAt: Foundation.Date? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.definition = definition
        self.description = description
        self.executionRoleArn = executionRoleArn
        self.id = id
        self.name = name
        self.status = status
        self.updatedAt = updatedAt
        self.version = version
    }
}

extension CreateFlowOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFlowOutput(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), definition: \"CONTENT_REDACTED\")"}
}

public struct DeleteFlowInput: Swift.Sendable {
    /// The unique identifier of the flow.
    /// This member is required.
    public var flowIdentifier: Swift.String?
    /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
    public var skipResourceInUseCheck: Swift.Bool?

    public init(
        flowIdentifier: Swift.String? = nil,
        skipResourceInUseCheck: Swift.Bool? = nil
    )
    {
        self.flowIdentifier = flowIdentifier
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

public struct DeleteFlowOutput: Swift.Sendable {
    /// The unique identifier of the flow.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension BedrockAgentClientTypes {

    /// Contains information about a version that the alias maps to.
    public struct FlowAliasRoutingConfigurationListItem: Swift.Sendable {
        /// The version that the alias maps to.
        public var flowVersion: Swift.String?

        public init(
            flowVersion: Swift.String? = nil
        )
        {
            self.flowVersion = flowVersion
        }
    }
}

public struct CreateFlowAliasInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// A description for the alias.
    public var description: Swift.String?
    /// The unique identifier of the flow for which to create an alias.
    /// This member is required.
    public var flowIdentifier: Swift.String?
    /// A name for the alias.
    /// This member is required.
    public var name: Swift.String?
    /// Contains information about the version to which to map the alias.
    /// This member is required.
    public var routingConfiguration: [BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem]?
    /// Any tags that you want to attach to the alias of the flow. For more information, see [Tagging resources in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/tagging.html).
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        flowIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        routingConfiguration: [BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.flowIdentifier = flowIdentifier
        self.name = name
        self.routingConfiguration = routingConfiguration
        self.tags = tags
    }
}

public struct CreateFlowAliasOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the alias.
    /// This member is required.
    public var arn: Swift.String?
    /// The time at which the alias was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the alias.
    public var description: Swift.String?
    /// The unique identifier of the flow that the alias belongs to.
    /// This member is required.
    public var flowId: Swift.String?
    /// The unique identifier of the alias.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?
    /// Contains information about the version that the alias is mapped to.
    /// This member is required.
    public var routingConfiguration: [BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem]?
    /// The time at which the alias of the flow was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        flowId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        routingConfiguration: [BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem]? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.flowId = flowId
        self.id = id
        self.name = name
        self.routingConfiguration = routingConfiguration
        self.updatedAt = updatedAt
    }
}

public struct DeleteFlowAliasInput: Swift.Sendable {
    /// The unique identifier of the alias to be deleted.
    /// This member is required.
    public var aliasIdentifier: Swift.String?
    /// The unique identifier of the flow that the alias belongs to.
    /// This member is required.
    public var flowIdentifier: Swift.String?

    public init(
        aliasIdentifier: Swift.String? = nil,
        flowIdentifier: Swift.String? = nil
    )
    {
        self.aliasIdentifier = aliasIdentifier
        self.flowIdentifier = flowIdentifier
    }
}

public struct DeleteFlowAliasOutput: Swift.Sendable {
    /// The unique identifier of the flow that the alias belongs to.
    /// This member is required.
    public var flowId: Swift.String?
    /// The unique identifier of the flow.
    /// This member is required.
    public var id: Swift.String?

    public init(
        flowId: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.flowId = flowId
        self.id = id
    }
}

public struct GetFlowAliasInput: Swift.Sendable {
    /// The unique identifier of the alias for which to retrieve information.
    /// This member is required.
    public var aliasIdentifier: Swift.String?
    /// The unique identifier of the flow that the alias belongs to.
    /// This member is required.
    public var flowIdentifier: Swift.String?

    public init(
        aliasIdentifier: Swift.String? = nil,
        flowIdentifier: Swift.String? = nil
    )
    {
        self.aliasIdentifier = aliasIdentifier
        self.flowIdentifier = flowIdentifier
    }
}

public struct GetFlowAliasOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var arn: Swift.String?
    /// The time at which the flow was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the flow.
    public var description: Swift.String?
    /// The unique identifier of the flow that the alias belongs to.
    /// This member is required.
    public var flowId: Swift.String?
    /// The unique identifier of the alias of the flow.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?
    /// Contains information about the version that the alias is mapped to.
    /// This member is required.
    public var routingConfiguration: [BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem]?
    /// The time at which the alias was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        flowId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        routingConfiguration: [BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem]? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.flowId = flowId
        self.id = id
        self.name = name
        self.routingConfiguration = routingConfiguration
        self.updatedAt = updatedAt
    }
}

public struct ListFlowAliasesInput: Swift.Sendable {
    /// The unique identifier of the flow for which aliases are being returned.
    /// This member is required.
    public var flowIdentifier: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        flowIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flowIdentifier = flowIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockAgentClientTypes {

    /// Contains information about an alias of a flow. This data type is used in the following API operations:
    ///
    /// * [ListFlowAliases response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_ListFlowAliases.html#API_agent_ListFlowAliases_ResponseSyntax)
    public struct FlowAliasSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the alias.
        /// This member is required.
        public var arn: Swift.String?
        /// The time at which the alias was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// A description of the alias.
        public var description: Swift.String?
        /// The unique identifier of the flow.
        /// This member is required.
        public var flowId: Swift.String?
        /// The unique identifier of the alias of the flow.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the alias.
        /// This member is required.
        public var name: Swift.String?
        /// A list of configurations about the versions that the alias maps to. Currently, you can only specify one.
        /// This member is required.
        public var routingConfiguration: [BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem]?
        /// The time at which the alias was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            flowId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            routingConfiguration: [BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem]? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.flowId = flowId
            self.id = id
            self.name = name
            self.routingConfiguration = routingConfiguration
            self.updatedAt = updatedAt
        }
    }
}

public struct ListFlowAliasesOutput: Swift.Sendable {
    /// A list, each member of which contains information about an alias.
    /// This member is required.
    public var flowAliasSummaries: [BedrockAgentClientTypes.FlowAliasSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        flowAliasSummaries: [BedrockAgentClientTypes.FlowAliasSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flowAliasSummaries = flowAliasSummaries
        self.nextToken = nextToken
    }
}

public struct UpdateFlowAliasInput: Swift.Sendable {
    /// The unique identifier of the alias.
    /// This member is required.
    public var aliasIdentifier: Swift.String?
    /// A description for the alias.
    public var description: Swift.String?
    /// The unique identifier of the flow.
    /// This member is required.
    public var flowIdentifier: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?
    /// Contains information about the version to which to map the alias.
    /// This member is required.
    public var routingConfiguration: [BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem]?

    public init(
        aliasIdentifier: Swift.String? = nil,
        description: Swift.String? = nil,
        flowIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        routingConfiguration: [BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem]? = nil
    )
    {
        self.aliasIdentifier = aliasIdentifier
        self.description = description
        self.flowIdentifier = flowIdentifier
        self.name = name
        self.routingConfiguration = routingConfiguration
    }
}

public struct UpdateFlowAliasOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var arn: Swift.String?
    /// The time at which the flow was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the flow.
    public var description: Swift.String?
    /// The unique identifier of the flow.
    /// This member is required.
    public var flowId: Swift.String?
    /// The unique identifier of the alias.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the alias.
    /// This member is required.
    public var name: Swift.String?
    /// Contains information about the version that the alias is mapped to.
    /// This member is required.
    public var routingConfiguration: [BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem]?
    /// The time at which the alias was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        flowId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        routingConfiguration: [BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem]? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.flowId = flowId
        self.id = id
        self.name = name
        self.routingConfiguration = routingConfiguration
        self.updatedAt = updatedAt
    }
}

public struct CreateFlowVersionInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// A description of the version of the flow.
    public var description: Swift.String?
    /// The unique identifier of the flow that you want to create a version of.
    /// This member is required.
    public var flowIdentifier: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        flowIdentifier: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.flowIdentifier = flowIdentifier
    }
}

public struct CreateFlowVersionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var arn: Swift.String?
    /// The time at which the flow was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The KMS key that the flow is encrypted with.
    public var customerEncryptionKeyArn: Swift.String?
    /// A definition of the nodes and connections in the flow.
    public var definition: BedrockAgentClientTypes.FlowDefinition?
    /// The description of the version.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the service role with permissions to create a flow. For more information, see [Create a service role for flows in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-permissions.html) in the Amazon Bedrock User Guide.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The unique identifier of the flow.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the version.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the flow.
    /// This member is required.
    public var status: BedrockAgentClientTypes.FlowStatus?
    /// The version of the flow that was created. Versions are numbered incrementally, starting from 1.
    /// This member is required.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        definition: BedrockAgentClientTypes.FlowDefinition? = nil,
        description: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: BedrockAgentClientTypes.FlowStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.definition = definition
        self.description = description
        self.executionRoleArn = executionRoleArn
        self.id = id
        self.name = name
        self.status = status
        self.version = version
    }
}

extension CreateFlowVersionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFlowVersionOutput(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), version: \(Swift.String(describing: version)), definition: \"CONTENT_REDACTED\")"}
}

public struct DeleteFlowVersionInput: Swift.Sendable {
    /// The unique identifier of the flow whose version that you want to delete
    /// This member is required.
    public var flowIdentifier: Swift.String?
    /// The version of the flow that you want to delete.
    /// This member is required.
    public var flowVersion: Swift.String?
    /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
    public var skipResourceInUseCheck: Swift.Bool?

    public init(
        flowIdentifier: Swift.String? = nil,
        flowVersion: Swift.String? = nil,
        skipResourceInUseCheck: Swift.Bool? = nil
    )
    {
        self.flowIdentifier = flowIdentifier
        self.flowVersion = flowVersion
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

public struct DeleteFlowVersionOutput: Swift.Sendable {
    /// The unique identifier of the flow.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the flow being deleted.
    /// This member is required.
    public var version: Swift.String?

    public init(
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.id = id
        self.version = version
    }
}

public struct GetFlowVersionInput: Swift.Sendable {
    /// The unique identifier of the flow for which to get information.
    /// This member is required.
    public var flowIdentifier: Swift.String?
    /// The version of the flow for which to get information.
    /// This member is required.
    public var flowVersion: Swift.String?

    public init(
        flowIdentifier: Swift.String? = nil,
        flowVersion: Swift.String? = nil
    )
    {
        self.flowIdentifier = flowIdentifier
        self.flowVersion = flowVersion
    }
}

public struct GetFlowVersionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var arn: Swift.String?
    /// The time at which the flow was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the KMS key that the version of the flow is encrypted with.
    public var customerEncryptionKeyArn: Swift.String?
    /// The definition of the nodes and connections between nodes in the flow.
    public var definition: BedrockAgentClientTypes.FlowDefinition?
    /// The description of the flow.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the service role with permissions to create a flow. For more information, see [Create a service role for flows in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-permissions.html) in the Amazon Bedrock User Guide.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The unique identifier of the flow.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the version.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the flow.
    /// This member is required.
    public var status: BedrockAgentClientTypes.FlowStatus?
    /// The version of the flow for which information was retrieved.
    /// This member is required.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        definition: BedrockAgentClientTypes.FlowDefinition? = nil,
        description: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: BedrockAgentClientTypes.FlowStatus? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.definition = definition
        self.description = description
        self.executionRoleArn = executionRoleArn
        self.id = id
        self.name = name
        self.status = status
        self.version = version
    }
}

extension GetFlowVersionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFlowVersionOutput(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), version: \(Swift.String(describing: version)), definition: \"CONTENT_REDACTED\")"}
}

public struct ListFlowVersionsInput: Swift.Sendable {
    /// The unique identifier of the flow.
    /// This member is required.
    public var flowIdentifier: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        flowIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flowIdentifier = flowIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockAgentClientTypes {

    /// Contains information about a version of a flow. This data type is used in the following API operations:
    ///
    /// * [ListFlowVersions response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_ListFlowVersions.html#API_agent_ListFlowVersions_ResponseSyntax)
    public struct FlowVersionSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the flow that the version belongs to.
        /// This member is required.
        public var arn: Swift.String?
        /// The time at the version was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique identifier of the flow.
        /// This member is required.
        public var id: Swift.String?
        /// The status of the flow.
        /// This member is required.
        public var status: BedrockAgentClientTypes.FlowStatus?
        /// The version of the flow.
        /// This member is required.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            status: BedrockAgentClientTypes.FlowStatus? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.id = id
            self.status = status
            self.version = version
        }
    }
}

public struct ListFlowVersionsOutput: Swift.Sendable {
    /// A list, each member of which contains information about a flow.
    /// This member is required.
    public var flowVersionSummaries: [BedrockAgentClientTypes.FlowVersionSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        flowVersionSummaries: [BedrockAgentClientTypes.FlowVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flowVersionSummaries = flowVersionSummaries
        self.nextToken = nextToken
    }
}

public struct GetFlowInput: Swift.Sendable {
    /// The unique identifier of the flow.
    /// This member is required.
    public var flowIdentifier: Swift.String?

    public init(
        flowIdentifier: Swift.String? = nil
    )
    {
        self.flowIdentifier = flowIdentifier
    }
}

extension BedrockAgentClientTypes {

    /// Details about a cyclic connection detected in the flow.
    public struct CyclicConnectionFlowValidationDetails: Swift.Sendable {
        /// The name of the connection that causes the cycle in the flow.
        /// This member is required.
        public var connection: Swift.String?

        public init(
            connection: Swift.String? = nil
        )
        {
            self.connection = connection
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about duplicate condition expressions found in a condition node.
    public struct DuplicateConditionExpressionFlowValidationDetails: Swift.Sendable {
        /// The duplicated condition expression.
        /// This member is required.
        public var expression: Swift.String?
        /// The name of the node containing the duplicate condition expressions.
        /// This member is required.
        public var node: Swift.String?

        public init(
            expression: Swift.String? = nil,
            node: Swift.String? = nil
        )
        {
            self.expression = expression
            self.node = node
        }
    }
}

extension BedrockAgentClientTypes.DuplicateConditionExpressionFlowValidationDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DuplicateConditionExpressionFlowValidationDetails(node: \(Swift.String(describing: node)), expression: \"CONTENT_REDACTED\")"}
}

extension BedrockAgentClientTypes {

    /// Details about duplicate connections found between two nodes in the flow.
    public struct DuplicateConnectionsFlowValidationDetails: Swift.Sendable {
        /// The name of the source node where the duplicate connection starts.
        /// This member is required.
        public var source: Swift.String?
        /// The name of the target node where the duplicate connection ends.
        /// This member is required.
        public var target: Swift.String?

        public init(
            source: Swift.String? = nil,
            target: Swift.String? = nil
        )
        {
            self.source = source
            self.target = target
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about incompatible data types in a connection between nodes.
    public struct IncompatibleConnectionDataTypeFlowValidationDetails: Swift.Sendable {
        /// The name of the connection with incompatible data types.
        /// This member is required.
        public var connection: Swift.String?

        public init(
            connection: Swift.String? = nil
        )
        {
            self.connection = connection
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about a malformed condition expression in a node.
    public struct MalformedConditionExpressionFlowValidationDetails: Swift.Sendable {
        /// The error message describing why the condition expression is malformed.
        /// This member is required.
        public var cause: Swift.String?
        /// The name of the malformed condition.
        /// This member is required.
        public var condition: Swift.String?
        /// The name of the node containing the malformed condition expression.
        /// This member is required.
        public var node: Swift.String?

        public init(
            cause: Swift.String? = nil,
            condition: Swift.String? = nil,
            node: Swift.String? = nil
        )
        {
            self.cause = cause
            self.condition = condition
            self.node = node
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about a malformed input expression in a node.
    public struct MalformedNodeInputExpressionFlowValidationDetails: Swift.Sendable {
        /// The error message describing why the input expression is malformed.
        /// This member is required.
        public var cause: Swift.String?
        /// The name of the input with the malformed expression.
        /// This member is required.
        public var input: Swift.String?
        /// The name of the node containing the malformed input expression.
        /// This member is required.
        public var node: Swift.String?

        public init(
            cause: Swift.String? = nil,
            input: Swift.String? = nil,
            node: Swift.String? = nil
        )
        {
            self.cause = cause
            self.input = input
            self.node = node
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about mismatched input data types in a node.
    public struct MismatchedNodeInputTypeFlowValidationDetails: Swift.Sendable {
        /// The expected data type for the node input.
        /// This member is required.
        public var expectedType: BedrockAgentClientTypes.FlowNodeIODataType?
        /// The name of the input with the mismatched data type.
        /// This member is required.
        public var input: Swift.String?
        /// The name of the node containing the input with the mismatched data type.
        /// This member is required.
        public var node: Swift.String?

        public init(
            expectedType: BedrockAgentClientTypes.FlowNodeIODataType? = nil,
            input: Swift.String? = nil,
            node: Swift.String? = nil
        )
        {
            self.expectedType = expectedType
            self.input = input
            self.node = node
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about mismatched output data types in a node.
    public struct MismatchedNodeOutputTypeFlowValidationDetails: Swift.Sendable {
        /// The expected data type for the node output.
        /// This member is required.
        public var expectedType: BedrockAgentClientTypes.FlowNodeIODataType?
        /// The name of the node containing the output with the mismatched data type.
        /// This member is required.
        public var node: Swift.String?
        /// The name of the output with the mismatched data type.
        /// This member is required.
        public var output: Swift.String?

        public init(
            expectedType: BedrockAgentClientTypes.FlowNodeIODataType? = nil,
            node: Swift.String? = nil,
            output: Swift.String? = nil
        )
        {
            self.expectedType = expectedType
            self.node = node
            self.output = output
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about a connection missing required configuration.
    public struct MissingConnectionConfigurationFlowValidationDetails: Swift.Sendable {
        /// The name of the connection missing configuration.
        /// This member is required.
        public var connection: Swift.String?

        public init(
            connection: Swift.String? = nil
        )
        {
            self.connection = connection
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about a missing default condition in a conditional node.
    public struct MissingDefaultConditionFlowValidationDetails: Swift.Sendable {
        /// The name of the node missing the default condition.
        /// This member is required.
        public var node: Swift.String?

        public init(
            node: Swift.String? = nil
        )
        {
            self.node = node
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about missing ending nodes (such as FlowOutputNode) in the flow.
    public struct MissingEndingNodesFlowValidationDetails: Swift.Sendable {

        public init() { }
    }
}

extension BedrockAgentClientTypes {

    /// Details about a node missing required configuration.
    public struct MissingNodeConfigurationFlowValidationDetails: Swift.Sendable {
        /// The name of the node missing configuration.
        /// This member is required.
        public var node: Swift.String?

        public init(
            node: Swift.String? = nil
        )
        {
            self.node = node
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about a missing required input in a node.
    public struct MissingNodeInputFlowValidationDetails: Swift.Sendable {
        /// The name of the missing input.
        /// This member is required.
        public var input: Swift.String?
        /// The name of the node missing the required input.
        /// This member is required.
        public var node: Swift.String?

        public init(
            input: Swift.String? = nil,
            node: Swift.String? = nil
        )
        {
            self.input = input
            self.node = node
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about a missing required output in a node.
    public struct MissingNodeOutputFlowValidationDetails: Swift.Sendable {
        /// The name of the node missing the required output.
        /// This member is required.
        public var node: Swift.String?
        /// The name of the missing output.
        /// This member is required.
        public var output: Swift.String?

        public init(
            node: Swift.String? = nil,
            output: Swift.String? = nil
        )
        {
            self.node = node
            self.output = output
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about missing starting nodes (such as FlowInputNode) in the flow.
    public struct MissingStartingNodesFlowValidationDetails: Swift.Sendable {

        public init() { }
    }
}

extension BedrockAgentClientTypes {

    /// Details about multiple connections to a single node input.
    public struct MultipleNodeInputConnectionsFlowValidationDetails: Swift.Sendable {
        /// The name of the input with multiple connections to it.
        /// This member is required.
        public var input: Swift.String?
        /// The name of the node containing the input with multiple connections.
        /// This member is required.
        public var node: Swift.String?

        public init(
            input: Swift.String? = nil,
            node: Swift.String? = nil
        )
        {
            self.input = input
            self.node = node
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about an unfulfilled node input with no valid connections.
    public struct UnfulfilledNodeInputFlowValidationDetails: Swift.Sendable {
        /// The name of the unfulfilled input. An input is unfulfilled if there are no data connections to it.
        /// This member is required.
        public var input: Swift.String?
        /// The name of the node containing the unfulfilled input.
        /// This member is required.
        public var node: Swift.String?

        public init(
            input: Swift.String? = nil,
            node: Swift.String? = nil
        )
        {
            self.input = input
            self.node = node
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about an unknown condition for a connection.
    public struct UnknownConnectionConditionFlowValidationDetails: Swift.Sendable {
        /// The name of the connection with the unknown condition.
        /// This member is required.
        public var connection: Swift.String?

        public init(
            connection: Swift.String? = nil
        )
        {
            self.connection = connection
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about an unknown source node for a connection.
    public struct UnknownConnectionSourceFlowValidationDetails: Swift.Sendable {
        /// The name of the connection with the unknown source.
        /// This member is required.
        public var connection: Swift.String?

        public init(
            connection: Swift.String? = nil
        )
        {
            self.connection = connection
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about an unknown source output for a connection.
    public struct UnknownConnectionSourceOutputFlowValidationDetails: Swift.Sendable {
        /// The name of the connection with the unknown source output.
        /// This member is required.
        public var connection: Swift.String?

        public init(
            connection: Swift.String? = nil
        )
        {
            self.connection = connection
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about an unknown target node for a connection.
    public struct UnknownConnectionTargetFlowValidationDetails: Swift.Sendable {
        /// The name of the connection with the unknown target.
        /// This member is required.
        public var connection: Swift.String?

        public init(
            connection: Swift.String? = nil
        )
        {
            self.connection = connection
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about an unknown target input for a connection.
    public struct UnknownConnectionTargetInputFlowValidationDetails: Swift.Sendable {
        /// The name of the connection with the unknown target input.
        /// This member is required.
        public var connection: Swift.String?

        public init(
            connection: Swift.String? = nil
        )
        {
            self.connection = connection
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about an unreachable node in the flow. A node is unreachable when there are no paths to it from any starting node.
    public struct UnreachableNodeFlowValidationDetails: Swift.Sendable {
        /// The name of the unreachable node.
        /// This member is required.
        public var node: Swift.String?

        public init(
            node: Swift.String? = nil
        )
        {
            self.node = node
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about unsatisfied conditions for a connection. A condition is unsatisfied if it can never be true, for example two branches of condition node cannot be simultaneously true.
    public struct UnsatisfiedConnectionConditionsFlowValidationDetails: Swift.Sendable {
        /// The name of the connection with unsatisfied conditions.
        /// This member is required.
        public var connection: Swift.String?

        public init(
            connection: Swift.String? = nil
        )
        {
            self.connection = connection
        }
    }
}

extension BedrockAgentClientTypes {

    /// Details about an unspecified validation that doesn't fit other categories.
    public struct UnspecifiedFlowValidationDetails: Swift.Sendable {

        public init() { }
    }
}

extension BedrockAgentClientTypes {

    /// A union type containing various possible validation issues in the flow.
    public enum FlowValidationDetails: Swift.Sendable {
        /// Details about a cyclic connection in the flow.
        case cyclicconnection(BedrockAgentClientTypes.CyclicConnectionFlowValidationDetails)
        /// Details about duplicate connections between nodes.
        case duplicateconnections(BedrockAgentClientTypes.DuplicateConnectionsFlowValidationDetails)
        /// Details about duplicate condition expressions in a node.
        case duplicateconditionexpression(BedrockAgentClientTypes.DuplicateConditionExpressionFlowValidationDetails)
        /// Details about an unreachable node in the flow.
        case unreachablenode(BedrockAgentClientTypes.UnreachableNodeFlowValidationDetails)
        /// Details about an unknown source node for a connection.
        case unknownconnectionsource(BedrockAgentClientTypes.UnknownConnectionSourceFlowValidationDetails)
        /// Details about an unknown source output for a connection.
        case unknownconnectionsourceoutput(BedrockAgentClientTypes.UnknownConnectionSourceOutputFlowValidationDetails)
        /// Details about an unknown target node for a connection.
        case unknownconnectiontarget(BedrockAgentClientTypes.UnknownConnectionTargetFlowValidationDetails)
        /// Details about an unknown target input for a connection.
        case unknownconnectiontargetinput(BedrockAgentClientTypes.UnknownConnectionTargetInputFlowValidationDetails)
        /// Details about an unknown condition for a connection.
        case unknownconnectioncondition(BedrockAgentClientTypes.UnknownConnectionConditionFlowValidationDetails)
        /// Details about a malformed condition expression in a node.
        case malformedconditionexpression(BedrockAgentClientTypes.MalformedConditionExpressionFlowValidationDetails)
        /// Details about a malformed input expression in a node.
        case malformednodeinputexpression(BedrockAgentClientTypes.MalformedNodeInputExpressionFlowValidationDetails)
        /// Details about mismatched input data types in a node.
        case mismatchednodeinputtype(BedrockAgentClientTypes.MismatchedNodeInputTypeFlowValidationDetails)
        /// Details about mismatched output data types in a node.
        case mismatchednodeoutputtype(BedrockAgentClientTypes.MismatchedNodeOutputTypeFlowValidationDetails)
        /// Details about incompatible data types in a connection.
        case incompatibleconnectiondatatype(BedrockAgentClientTypes.IncompatibleConnectionDataTypeFlowValidationDetails)
        /// Details about missing configuration for a connection.
        case missingconnectionconfiguration(BedrockAgentClientTypes.MissingConnectionConfigurationFlowValidationDetails)
        /// Details about a missing default condition in a conditional node.
        case missingdefaultcondition(BedrockAgentClientTypes.MissingDefaultConditionFlowValidationDetails)
        /// Details about missing ending nodes in the flow.
        case missingendingnodes(BedrockAgentClientTypes.MissingEndingNodesFlowValidationDetails)
        /// Details about missing configuration for a node.
        case missingnodeconfiguration(BedrockAgentClientTypes.MissingNodeConfigurationFlowValidationDetails)
        /// Details about a missing required input in a node.
        case missingnodeinput(BedrockAgentClientTypes.MissingNodeInputFlowValidationDetails)
        /// Details about a missing required output in a node.
        case missingnodeoutput(BedrockAgentClientTypes.MissingNodeOutputFlowValidationDetails)
        /// Details about missing starting nodes in the flow.
        case missingstartingnodes(BedrockAgentClientTypes.MissingStartingNodesFlowValidationDetails)
        /// Details about multiple connections to a single node input.
        case multiplenodeinputconnections(BedrockAgentClientTypes.MultipleNodeInputConnectionsFlowValidationDetails)
        /// Details about an unfulfilled node input with no valid connections.
        case unfulfillednodeinput(BedrockAgentClientTypes.UnfulfilledNodeInputFlowValidationDetails)
        /// Details about unsatisfied conditions for a connection.
        case unsatisfiedconnectionconditions(BedrockAgentClientTypes.UnsatisfiedConnectionConditionsFlowValidationDetails)
        /// Details about an unspecified validation.
        case unspecified(BedrockAgentClientTypes.UnspecifiedFlowValidationDetails)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentClientTypes {

    public enum FlowValidationSeverity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowValidationSeverity] {
            return [
                .error,
                .warning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "Error"
            case .warning: return "Warning"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    public enum FlowValidationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cyclicConnection
        case duplicateConditionExpression
        case duplicateConnections
        case incompatibleConnectionDataType
        case malformedConditionExpression
        case malformedNodeInputExpression
        case mismatchedNodeInputType
        case mismatchedNodeOutputType
        case missingConnectionConfiguration
        case missingDefaultCondition
        case missingEndingNodes
        case missingNodeConfiguration
        case missingNodeInput
        case missingNodeOutput
        case missingStartingNodes
        case multipleNodeInputConnections
        case unfulfilledNodeInput
        case unknownConnectionCondition
        case unknownConnectionSource
        case unknownConnectionSourceOutput
        case unknownConnectionTarget
        case unknownConnectionTargetInput
        case unreachableNode
        case unsatisfiedConnectionConditions
        case unspecified
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowValidationType] {
            return [
                .cyclicConnection,
                .duplicateConditionExpression,
                .duplicateConnections,
                .incompatibleConnectionDataType,
                .malformedConditionExpression,
                .malformedNodeInputExpression,
                .mismatchedNodeInputType,
                .mismatchedNodeOutputType,
                .missingConnectionConfiguration,
                .missingDefaultCondition,
                .missingEndingNodes,
                .missingNodeConfiguration,
                .missingNodeInput,
                .missingNodeOutput,
                .missingStartingNodes,
                .multipleNodeInputConnections,
                .unfulfilledNodeInput,
                .unknownConnectionCondition,
                .unknownConnectionSource,
                .unknownConnectionSourceOutput,
                .unknownConnectionTarget,
                .unknownConnectionTargetInput,
                .unreachableNode,
                .unsatisfiedConnectionConditions,
                .unspecified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cyclicConnection: return "CyclicConnection"
            case .duplicateConditionExpression: return "DuplicateConditionExpression"
            case .duplicateConnections: return "DuplicateConnections"
            case .incompatibleConnectionDataType: return "IncompatibleConnectionDataType"
            case .malformedConditionExpression: return "MalformedConditionExpression"
            case .malformedNodeInputExpression: return "MalformedNodeInputExpression"
            case .mismatchedNodeInputType: return "MismatchedNodeInputType"
            case .mismatchedNodeOutputType: return "MismatchedNodeOutputType"
            case .missingConnectionConfiguration: return "MissingConnectionConfiguration"
            case .missingDefaultCondition: return "MissingDefaultCondition"
            case .missingEndingNodes: return "MissingEndingNodes"
            case .missingNodeConfiguration: return "MissingNodeConfiguration"
            case .missingNodeInput: return "MissingNodeInput"
            case .missingNodeOutput: return "MissingNodeOutput"
            case .missingStartingNodes: return "MissingStartingNodes"
            case .multipleNodeInputConnections: return "MultipleNodeInputConnections"
            case .unfulfilledNodeInput: return "UnfulfilledNodeInput"
            case .unknownConnectionCondition: return "UnknownConnectionCondition"
            case .unknownConnectionSource: return "UnknownConnectionSource"
            case .unknownConnectionSourceOutput: return "UnknownConnectionSourceOutput"
            case .unknownConnectionTarget: return "UnknownConnectionTarget"
            case .unknownConnectionTargetInput: return "UnknownConnectionTargetInput"
            case .unreachableNode: return "UnreachableNode"
            case .unsatisfiedConnectionConditions: return "UnsatisfiedConnectionConditions"
            case .unspecified: return "Unspecified"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains information about validation of the flow. This data type is used in the following API operations:
    ///
    /// * [GetFlow response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_GetFlow.html#API_agent_GetFlow_ResponseSyntax)
    ///
    /// * [GetFlowVersion response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_GetFlowVersion.html#API_agent_GetFlowVersion_ResponseSyntax)
    public struct FlowValidation: Swift.Sendable {
        /// Specific details about the validation issue encountered in the flow.
        public var details: BedrockAgentClientTypes.FlowValidationDetails?
        /// A message describing the validation error.
        /// This member is required.
        public var message: Swift.String?
        /// The severity of the issue described in the message.
        /// This member is required.
        public var severity: BedrockAgentClientTypes.FlowValidationSeverity?
        /// The type of validation issue encountered in the flow.
        public var type: BedrockAgentClientTypes.FlowValidationType?

        public init(
            details: BedrockAgentClientTypes.FlowValidationDetails? = nil,
            message: Swift.String? = nil,
            severity: BedrockAgentClientTypes.FlowValidationSeverity? = nil,
            type: BedrockAgentClientTypes.FlowValidationType? = nil
        )
        {
            self.details = details
            self.message = message
            self.severity = severity
            self.type = type
        }
    }
}

public struct GetFlowOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var arn: Swift.String?
    /// The time at which the flow was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the KMS key that the flow is encrypted with.
    public var customerEncryptionKeyArn: Swift.String?
    /// The definition of the nodes and connections between the nodes in the flow.
    public var definition: BedrockAgentClientTypes.FlowDefinition?
    /// The description of the flow.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the service role with permissions to create a flow. For more information, see [Create a service row for flows](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-permissions.html) in the Amazon Bedrock User Guide.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The unique identifier of the flow.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the flow.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the flow. The following statuses are possible:
    ///
    /// * NotPrepared  The flow has been created or updated, but hasn't been prepared. If you just created the flow, you can't test it. If you updated the flow, the DRAFT version won't contain the latest changes for testing. Send a [PrepareFlow](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PrepareFlow.html) request to package the latest changes into the DRAFT version.
    ///
    /// * Preparing  The flow is being prepared so that the DRAFT version contains the latest changes for testing.
    ///
    /// * Prepared  The flow is prepared and the DRAFT version contains the latest changes for testing.
    ///
    /// * Failed  The last API operation that you invoked on the flow failed. Send a [GetFlow](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_GetFlow.html) request and check the error message in the validations field.
    /// This member is required.
    public var status: BedrockAgentClientTypes.FlowStatus?
    /// The time at which the flow was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// A list of validation error messages related to the last failed operation on the flow.
    public var validations: [BedrockAgentClientTypes.FlowValidation]?
    /// The version of the flow for which information was retrieved.
    /// This member is required.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        definition: BedrockAgentClientTypes.FlowDefinition? = nil,
        description: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: BedrockAgentClientTypes.FlowStatus? = nil,
        updatedAt: Foundation.Date? = nil,
        validations: [BedrockAgentClientTypes.FlowValidation]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.definition = definition
        self.description = description
        self.executionRoleArn = executionRoleArn
        self.id = id
        self.name = name
        self.status = status
        self.updatedAt = updatedAt
        self.validations = validations
        self.version = version
    }
}

extension GetFlowOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFlowOutput(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), validations: \(Swift.String(describing: validations)), version: \(Swift.String(describing: version)), definition: \"CONTENT_REDACTED\")"}
}

public struct ListFlowsInput: Swift.Sendable {
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockAgentClientTypes {

    /// Contains the definition of a flow.
    public struct FlowSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the flow.
        /// This member is required.
        public var arn: Swift.String?
        /// The time at which the flow was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// A description of the flow.
        public var description: Swift.String?
        /// The unique identifier of the flow.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the flow.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the flow. The following statuses are possible:
        ///
        /// * NotPrepared  The flow has been created or updated, but hasn't been prepared. If you just created the flow, you can't test it. If you updated the flow, the DRAFT version won't contain the latest changes for testing. Send a [PrepareFlow](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PrepareFlow.html) request to package the latest changes into the DRAFT version.
        ///
        /// * Preparing  The flow is being prepared so that the DRAFT version contains the latest changes for testing.
        ///
        /// * Prepared  The flow is prepared and the DRAFT version contains the latest changes for testing.
        ///
        /// * Failed  The last API operation that you invoked on the flow failed. Send a [GetFlow](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_GetFlow.html) request and check the error message in the validations field.
        /// This member is required.
        public var status: BedrockAgentClientTypes.FlowStatus?
        /// The time at which the flow was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?
        /// The latest version of the flow.
        /// This member is required.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: BedrockAgentClientTypes.FlowStatus? = nil,
            updatedAt: Foundation.Date? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
            self.version = version
        }
    }
}

public struct ListFlowsOutput: Swift.Sendable {
    /// A list, each member of which contains information about a flow.
    /// This member is required.
    public var flowSummaries: [BedrockAgentClientTypes.FlowSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        flowSummaries: [BedrockAgentClientTypes.FlowSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flowSummaries = flowSummaries
        self.nextToken = nextToken
    }
}

public struct PrepareFlowInput: Swift.Sendable {
    /// The unique identifier of the flow.
    /// This member is required.
    public var flowIdentifier: Swift.String?

    public init(
        flowIdentifier: Swift.String? = nil
    )
    {
        self.flowIdentifier = flowIdentifier
    }
}

public struct PrepareFlowOutput: Swift.Sendable {
    /// The unique identifier of the flow.
    /// This member is required.
    public var id: Swift.String?
    /// The status of the flow. When you submit this request, the status will be NotPrepared. If preparation succeeds, the status becomes Prepared. If it fails, the status becomes FAILED.
    /// This member is required.
    public var status: BedrockAgentClientTypes.FlowStatus?

    public init(
        id: Swift.String? = nil,
        status: BedrockAgentClientTypes.FlowStatus? = nil
    )
    {
        self.id = id
        self.status = status
    }
}

public struct UpdateFlowInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the KMS key to encrypt the flow.
    public var customerEncryptionKeyArn: Swift.String?
    /// A definition of the nodes and the connections between the nodes in the flow.
    public var definition: BedrockAgentClientTypes.FlowDefinition?
    /// A description for the flow.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the service role with permissions to create and manage a flow. For more information, see [Create a service role for flows in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-permissions.html) in the Amazon Bedrock User Guide.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The unique identifier of the flow.
    /// This member is required.
    public var flowIdentifier: Swift.String?
    /// A name for the flow.
    /// This member is required.
    public var name: Swift.String?

    public init(
        customerEncryptionKeyArn: Swift.String? = nil,
        definition: BedrockAgentClientTypes.FlowDefinition? = nil,
        description: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        flowIdentifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.definition = definition
        self.description = description
        self.executionRoleArn = executionRoleArn
        self.flowIdentifier = flowIdentifier
        self.name = name
    }
}

extension UpdateFlowInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFlowInput(customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), flowIdentifier: \(Swift.String(describing: flowIdentifier)), name: \(Swift.String(describing: name)), definition: \"CONTENT_REDACTED\")"}
}

public struct UpdateFlowOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var arn: Swift.String?
    /// The time at which the flow was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the KMS key that the flow was encrypted with.
    public var customerEncryptionKeyArn: Swift.String?
    /// A definition of the nodes and the connections between nodes in the flow.
    public var definition: BedrockAgentClientTypes.FlowDefinition?
    /// The description of the flow.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the service role with permissions to create a flow. For more information, see [Create a service role for flows in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-permissions.html) in the Amazon Bedrock User Guide.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The unique identifier of the flow.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the flow.
    /// This member is required.
    public var name: Swift.String?
    /// The status of the flow. When you submit this request, the status will be NotPrepared. If updating fails, the status becomes Failed.
    /// This member is required.
    public var status: BedrockAgentClientTypes.FlowStatus?
    /// The time at which the flow was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The version of the flow. When you update a flow, the version updated is the DRAFT version.
    /// This member is required.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        definition: BedrockAgentClientTypes.FlowDefinition? = nil,
        description: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: BedrockAgentClientTypes.FlowStatus? = nil,
        updatedAt: Foundation.Date? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.definition = definition
        self.description = description
        self.executionRoleArn = executionRoleArn
        self.id = id
        self.name = name
        self.status = status
        self.updatedAt = updatedAt
        self.version = version
    }
}

extension UpdateFlowOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFlowOutput(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), description: \(Swift.String(describing: description)), executionRoleArn: \(Swift.String(describing: executionRoleArn)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), definition: \"CONTENT_REDACTED\")"}
}

public struct GetIngestionJobInput: Swift.Sendable {
    /// The unique identifier of the data source for the data ingestion job you want to get information on.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The unique identifier of the data ingestion job you want to get information on.
    /// This member is required.
    public var ingestionJobId: Swift.String?
    /// The unique identifier of the knowledge base for the data ingestion job you want to get information on.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        dataSourceId: Swift.String? = nil,
        ingestionJobId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.ingestionJobId = ingestionJobId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

extension BedrockAgentClientTypes {

    /// Contains the statistics for the data ingestion job.
    public struct IngestionJobStatistics: Swift.Sendable {
        /// The number of source documents that were deleted.
        public var numberOfDocumentsDeleted: Swift.Int
        /// The number of source documents that failed to be ingested.
        public var numberOfDocumentsFailed: Swift.Int
        /// The total number of source documents that were scanned. Includes new, updated, and unchanged documents.
        public var numberOfDocumentsScanned: Swift.Int
        /// The number of metadata files that were updated or deleted.
        public var numberOfMetadataDocumentsModified: Swift.Int
        /// The total number of metadata files that were scanned. Includes new, updated, and unchanged files.
        public var numberOfMetadataDocumentsScanned: Swift.Int
        /// The number of modified source documents in the data source that were successfully indexed.
        public var numberOfModifiedDocumentsIndexed: Swift.Int
        /// The number of new source documents in the data source that were successfully indexed.
        public var numberOfNewDocumentsIndexed: Swift.Int

        public init(
            numberOfDocumentsDeleted: Swift.Int = 0,
            numberOfDocumentsFailed: Swift.Int = 0,
            numberOfDocumentsScanned: Swift.Int = 0,
            numberOfMetadataDocumentsModified: Swift.Int = 0,
            numberOfMetadataDocumentsScanned: Swift.Int = 0,
            numberOfModifiedDocumentsIndexed: Swift.Int = 0,
            numberOfNewDocumentsIndexed: Swift.Int = 0
        )
        {
            self.numberOfDocumentsDeleted = numberOfDocumentsDeleted
            self.numberOfDocumentsFailed = numberOfDocumentsFailed
            self.numberOfDocumentsScanned = numberOfDocumentsScanned
            self.numberOfMetadataDocumentsModified = numberOfMetadataDocumentsModified
            self.numberOfMetadataDocumentsScanned = numberOfMetadataDocumentsScanned
            self.numberOfModifiedDocumentsIndexed = numberOfModifiedDocumentsIndexed
            self.numberOfNewDocumentsIndexed = numberOfNewDocumentsIndexed
        }
    }
}

extension BedrockAgentClientTypes {

    public enum IngestionJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case failed
        case inProgress
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionJobStatus] {
            return [
                .complete,
                .failed,
                .inProgress,
                .starting,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about a data ingestion job. Data sources are ingested into a knowledge base so that Large Language Models (LLMs) can use your data. This data type is used in the following API operations:
    ///
    /// * [StartIngestionJob response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_StartIngestionJob.html#API_agent_StartIngestionJob_ResponseSyntax)
    ///
    /// * [GetIngestionJob response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_GetIngestionJob.html#API_agent_GetIngestionJob_ResponseSyntax)
    ///
    /// * [ListIngestionJob response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_ListIngestionJobs.html#API_agent_ListIngestionJobs_ResponseSyntax)
    public struct IngestionJob: Swift.Sendable {
        /// The unique identifier of the data source for the data ingestion job.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// The description of the data ingestion job.
        public var description: Swift.String?
        /// A list of reasons that the data ingestion job failed.
        public var failureReasons: [Swift.String]?
        /// The unique identifier of the data ingestion job.
        /// This member is required.
        public var ingestionJobId: Swift.String?
        /// The unique identifier of the knowledge for the data ingestion job.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The time the data ingestion job started. If you stop a data ingestion job, the startedAt time is the time the job was started before the job was stopped.
        /// This member is required.
        public var startedAt: Foundation.Date?
        /// Contains statistics about the data ingestion job.
        public var statistics: BedrockAgentClientTypes.IngestionJobStatistics?
        /// The status of the data ingestion job.
        /// This member is required.
        public var status: BedrockAgentClientTypes.IngestionJobStatus?
        /// The time the data ingestion job was last updated. If you stop a data ingestion job, the updatedAt time is the time the job was stopped.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            dataSourceId: Swift.String? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            ingestionJobId: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            startedAt: Foundation.Date? = nil,
            statistics: BedrockAgentClientTypes.IngestionJobStatistics? = nil,
            status: BedrockAgentClientTypes.IngestionJobStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.dataSourceId = dataSourceId
            self.description = description
            self.failureReasons = failureReasons
            self.ingestionJobId = ingestionJobId
            self.knowledgeBaseId = knowledgeBaseId
            self.startedAt = startedAt
            self.statistics = statistics
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct GetIngestionJobOutput: Swift.Sendable {
    /// Contains details about the data ingestion job.
    /// This member is required.
    public var ingestionJob: BedrockAgentClientTypes.IngestionJob?

    public init(
        ingestionJob: BedrockAgentClientTypes.IngestionJob? = nil
    )
    {
        self.ingestionJob = ingestionJob
    }
}

extension BedrockAgentClientTypes {

    public enum IngestionJobFilterAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionJobFilterAttribute] {
            return [
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    public enum IngestionJobFilterOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case eq
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionJobFilterOperator] {
            return [
                .eq
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .eq: return "EQ"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// The definition of a filter to filter the data.
    public struct IngestionJobFilter: Swift.Sendable {
        /// The name of field or attribute to apply the filter.
        /// This member is required.
        public var attribute: BedrockAgentClientTypes.IngestionJobFilterAttribute?
        /// The operation to apply to the field or attribute.
        /// This member is required.
        public var `operator`: BedrockAgentClientTypes.IngestionJobFilterOperator?
        /// A list of values that belong to the field or attribute.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            attribute: BedrockAgentClientTypes.IngestionJobFilterAttribute? = nil,
            `operator`: BedrockAgentClientTypes.IngestionJobFilterOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.attribute = attribute
            self.`operator` = `operator`
            self.values = values
        }
    }
}

extension BedrockAgentClientTypes {

    public enum IngestionJobSortByAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case startedAt
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionJobSortByAttribute] {
            return [
                .startedAt,
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .startedAt: return "STARTED_AT"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    public enum SortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// The parameters of sorting the data.
    public struct IngestionJobSortBy: Swift.Sendable {
        /// The name of field or attribute to apply sorting of data.
        /// This member is required.
        public var attribute: BedrockAgentClientTypes.IngestionJobSortByAttribute?
        /// The order for sorting the data.
        /// This member is required.
        public var order: BedrockAgentClientTypes.SortOrder?

        public init(
            attribute: BedrockAgentClientTypes.IngestionJobSortByAttribute? = nil,
            order: BedrockAgentClientTypes.SortOrder? = nil
        )
        {
            self.attribute = attribute
            self.order = order
        }
    }
}

public struct ListIngestionJobsInput: Swift.Sendable {
    /// The unique identifier of the data source for the list of data ingestion jobs.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// Contains information about the filters for filtering the data.
    public var filters: [BedrockAgentClientTypes.IngestionJobFilter]?
    /// The unique identifier of the knowledge base for the list of data ingestion jobs.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// Contains details about how to sort the data.
    public var sortBy: BedrockAgentClientTypes.IngestionJobSortBy?

    public init(
        dataSourceId: Swift.String? = nil,
        filters: [BedrockAgentClientTypes.IngestionJobFilter]? = nil,
        knowledgeBaseId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: BedrockAgentClientTypes.IngestionJobSortBy? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.filters = filters
        self.knowledgeBaseId = knowledgeBaseId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about a data ingestion job.
    public struct IngestionJobSummary: Swift.Sendable {
        /// The unique identifier of the data source for the data ingestion job.
        /// This member is required.
        public var dataSourceId: Swift.String?
        /// The description of the data ingestion job.
        public var description: Swift.String?
        /// The unique identifier of the data ingestion job.
        /// This member is required.
        public var ingestionJobId: Swift.String?
        /// The unique identifier of the knowledge base for the data ingestion job.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The time the data ingestion job started.
        /// This member is required.
        public var startedAt: Foundation.Date?
        /// Contains statistics for the data ingestion job.
        public var statistics: BedrockAgentClientTypes.IngestionJobStatistics?
        /// The status of the data ingestion job.
        /// This member is required.
        public var status: BedrockAgentClientTypes.IngestionJobStatus?
        /// The time the data ingestion job was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            dataSourceId: Swift.String? = nil,
            description: Swift.String? = nil,
            ingestionJobId: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            startedAt: Foundation.Date? = nil,
            statistics: BedrockAgentClientTypes.IngestionJobStatistics? = nil,
            status: BedrockAgentClientTypes.IngestionJobStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.dataSourceId = dataSourceId
            self.description = description
            self.ingestionJobId = ingestionJobId
            self.knowledgeBaseId = knowledgeBaseId
            self.startedAt = startedAt
            self.statistics = statistics
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct ListIngestionJobsOutput: Swift.Sendable {
    /// A list of data ingestion jobs with information about each job.
    /// This member is required.
    public var ingestionJobSummaries: [BedrockAgentClientTypes.IngestionJobSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        ingestionJobSummaries: [BedrockAgentClientTypes.IngestionJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ingestionJobSummaries = ingestionJobSummaries
        self.nextToken = nextToken
    }
}

public struct StartIngestionJobInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The unique identifier of the data source you want to ingest into your knowledge base.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// A description of the data ingestion job.
    public var description: Swift.String?
    /// The unique identifier of the knowledge base for the data ingestion job.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        dataSourceId: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dataSourceId = dataSourceId
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct StartIngestionJobOutput: Swift.Sendable {
    /// Contains information about the data ingestion job.
    /// This member is required.
    public var ingestionJob: BedrockAgentClientTypes.IngestionJob?

    public init(
        ingestionJob: BedrockAgentClientTypes.IngestionJob? = nil
    )
    {
        self.ingestionJob = ingestionJob
    }
}

public struct StopIngestionJobInput: Swift.Sendable {
    /// The unique identifier of the data source for the data ingestion job you want to stop.
    /// This member is required.
    public var dataSourceId: Swift.String?
    /// The unique identifier of the data ingestion job you want to stop.
    /// This member is required.
    public var ingestionJobId: Swift.String?
    /// The unique identifier of the knowledge base for the data ingestion job you want to stop.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        dataSourceId: Swift.String? = nil,
        ingestionJobId: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.dataSourceId = dataSourceId
        self.ingestionJobId = ingestionJobId
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct StopIngestionJobOutput: Swift.Sendable {
    /// Contains information about the stopped data ingestion job.
    /// This member is required.
    public var ingestionJob: BedrockAgentClientTypes.IngestionJob?

    public init(
        ingestionJob: BedrockAgentClientTypes.IngestionJob? = nil
    )
    {
        self.ingestionJob = ingestionJob
    }
}

public struct AssociateAgentKnowledgeBaseInput: Swift.Sendable {
    /// The unique identifier of the agent with which you want to associate the knowledge base.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent with which you want to associate the knowledge base.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// A description of what the agent should use the knowledge base for.
    /// This member is required.
    public var description: Swift.String?
    /// The unique identifier of the knowledge base to associate with the agent.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// Specifies whether to use the knowledge base or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
    public var knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
        self.knowledgeBaseState = knowledgeBaseState
    }
}

public struct AssociateAgentKnowledgeBaseOutput: Swift.Sendable {
    /// Contains details about the knowledge base that has been associated with the agent.
    /// This member is required.
    public var agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase?

    public init(
        agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase? = nil
    )
    {
        self.agentKnowledgeBase = agentKnowledgeBase
    }
}

extension BedrockAgentClientTypes {

    public enum KnowledgeBaseType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case vector
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseType] {
            return [
                .vector
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .vector: return "VECTOR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// The vector configuration details for the Bedrock embeddings model.
    public struct BedrockEmbeddingModelConfiguration: Swift.Sendable {
        /// The dimensions details for the vector configuration used on the Bedrock embeddings model.
        public var dimensions: Swift.Int?

        public init(
            dimensions: Swift.Int? = nil
        )
        {
            self.dimensions = dimensions
        }
    }
}

extension BedrockAgentClientTypes {

    /// The configuration details for the embeddings model.
    public struct EmbeddingModelConfiguration: Swift.Sendable {
        /// The vector configuration details on the Bedrock embeddings model.
        public var bedrockEmbeddingModelConfiguration: BedrockAgentClientTypes.BedrockEmbeddingModelConfiguration?

        public init(
            bedrockEmbeddingModelConfiguration: BedrockAgentClientTypes.BedrockEmbeddingModelConfiguration? = nil
        )
        {
            self.bedrockEmbeddingModelConfiguration = bedrockEmbeddingModelConfiguration
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about the model used to create vector embeddings for the knowledge base.
    public struct VectorKnowledgeBaseConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the model or inference profile used to create vector embeddings for the knowledge base.
        /// This member is required.
        public var embeddingModelArn: Swift.String?
        /// The embeddings model configuration details for the vector model used in Knowledge Base.
        public var embeddingModelConfiguration: BedrockAgentClientTypes.EmbeddingModelConfiguration?

        public init(
            embeddingModelArn: Swift.String? = nil,
            embeddingModelConfiguration: BedrockAgentClientTypes.EmbeddingModelConfiguration? = nil
        )
        {
            self.embeddingModelArn = embeddingModelArn
            self.embeddingModelConfiguration = embeddingModelConfiguration
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about the vector embeddings configuration of the knowledge base.
    public struct KnowledgeBaseConfiguration: Swift.Sendable {
        /// The type of data that the data source is converted into for the knowledge base.
        /// This member is required.
        public var type: BedrockAgentClientTypes.KnowledgeBaseType?
        /// Contains details about the model that's used to convert the data source into vector embeddings.
        public var vectorKnowledgeBaseConfiguration: BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration?

        public init(
            type: BedrockAgentClientTypes.KnowledgeBaseType? = nil,
            vectorKnowledgeBaseConfiguration: BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration? = nil
        )
        {
            self.type = type
            self.vectorKnowledgeBaseConfiguration = vectorKnowledgeBaseConfiguration
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains the names of the fields to which to map information about the vector store.
    public struct MongoDbAtlasFieldMapping: Swift.Sendable {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        /// This member is required.
        public var metadataField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        /// This member is required.
        public var textField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        /// This member is required.
        public var vectorField: Swift.String?

        public init(
            metadataField: Swift.String? = nil,
            textField: Swift.String? = nil,
            vectorField: Swift.String? = nil
        )
        {
            self.metadataField = metadataField
            self.textField = textField
            self.vectorField = vectorField
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about the storage configuration of the knowledge base in MongoDB Atlas.
    public struct MongoDbAtlasConfiguration: Swift.Sendable {
        /// The collection name of the knowledge base in MongoDB Atlas.
        /// This member is required.
        public var collectionName: Swift.String?
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that contains user credentials for your MongoDB Atlas cluster.
        /// This member is required.
        public var credentialsSecretArn: Swift.String?
        /// The database name in your MongoDB Atlas cluster for your knowledge base.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The endpoint URL of your MongoDB Atlas cluster for your knowledge base.
        /// This member is required.
        public var endpoint: Swift.String?
        /// The name of the VPC endpoint service in your account that is connected to your MongoDB Atlas cluster.
        public var endpointServiceName: Swift.String?
        /// Contains the names of the fields to which to map information about the vector store.
        /// This member is required.
        public var fieldMapping: BedrockAgentClientTypes.MongoDbAtlasFieldMapping?
        /// The name of the MongoDB Atlas vector search index.
        /// This member is required.
        public var vectorIndexName: Swift.String?

        public init(
            collectionName: Swift.String? = nil,
            credentialsSecretArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            endpointServiceName: Swift.String? = nil,
            fieldMapping: BedrockAgentClientTypes.MongoDbAtlasFieldMapping? = nil,
            vectorIndexName: Swift.String? = nil
        )
        {
            self.collectionName = collectionName
            self.credentialsSecretArn = credentialsSecretArn
            self.databaseName = databaseName
            self.endpoint = endpoint
            self.endpointServiceName = endpointServiceName
            self.fieldMapping = fieldMapping
            self.vectorIndexName = vectorIndexName
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains the names of the fields to which to map information about the vector store.
    public struct OpenSearchServerlessFieldMapping: Swift.Sendable {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        /// This member is required.
        public var metadataField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        /// This member is required.
        public var textField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        /// This member is required.
        public var vectorField: Swift.String?

        public init(
            metadataField: Swift.String? = nil,
            textField: Swift.String? = nil,
            vectorField: Swift.String? = nil
        )
        {
            self.metadataField = metadataField
            self.textField = textField
            self.vectorField = vectorField
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about the storage configuration of the knowledge base in Amazon OpenSearch Service. For more information, see [Create a vector index in Amazon OpenSearch Service](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-oss.html).
    public struct OpenSearchServerlessConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the OpenSearch Service vector store.
        /// This member is required.
        public var collectionArn: Swift.String?
        /// Contains the names of the fields to which to map information about the vector store.
        /// This member is required.
        public var fieldMapping: BedrockAgentClientTypes.OpenSearchServerlessFieldMapping?
        /// The name of the vector store.
        /// This member is required.
        public var vectorIndexName: Swift.String?

        public init(
            collectionArn: Swift.String? = nil,
            fieldMapping: BedrockAgentClientTypes.OpenSearchServerlessFieldMapping? = nil,
            vectorIndexName: Swift.String? = nil
        )
        {
            self.collectionArn = collectionArn
            self.fieldMapping = fieldMapping
            self.vectorIndexName = vectorIndexName
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains the names of the fields to which to map information about the vector store.
    public struct PineconeFieldMapping: Swift.Sendable {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        /// This member is required.
        public var metadataField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        /// This member is required.
        public var textField: Swift.String?

        public init(
            metadataField: Swift.String? = nil,
            textField: Swift.String? = nil
        )
        {
            self.metadataField = metadataField
            self.textField = textField
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about the storage configuration of the knowledge base in Pinecone. For more information, see [Create a vector index in Pinecone](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-pinecone.html).
    public struct PineconeConfiguration: Swift.Sendable {
        /// The endpoint URL for your index management page.
        /// This member is required.
        public var connectionString: Swift.String?
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that is linked to your Pinecone API key.
        /// This member is required.
        public var credentialsSecretArn: Swift.String?
        /// Contains the names of the fields to which to map information about the vector store.
        /// This member is required.
        public var fieldMapping: BedrockAgentClientTypes.PineconeFieldMapping?
        /// The namespace to be used to write new data to your database.
        public var namespace: Swift.String?

        public init(
            connectionString: Swift.String? = nil,
            credentialsSecretArn: Swift.String? = nil,
            fieldMapping: BedrockAgentClientTypes.PineconeFieldMapping? = nil,
            namespace: Swift.String? = nil
        )
        {
            self.connectionString = connectionString
            self.credentialsSecretArn = credentialsSecretArn
            self.fieldMapping = fieldMapping
            self.namespace = namespace
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains the names of the fields to which to map information about the vector store.
    public struct RdsFieldMapping: Swift.Sendable {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        /// This member is required.
        public var metadataField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the ID for each entry.
        /// This member is required.
        public var primaryKeyField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        /// This member is required.
        public var textField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        /// This member is required.
        public var vectorField: Swift.String?

        public init(
            metadataField: Swift.String? = nil,
            primaryKeyField: Swift.String? = nil,
            textField: Swift.String? = nil,
            vectorField: Swift.String? = nil
        )
        {
            self.metadataField = metadataField
            self.primaryKeyField = primaryKeyField
            self.textField = textField
            self.vectorField = vectorField
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-rds.html).
    public struct RdsConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that is linked to your Amazon RDS database.
        /// This member is required.
        public var credentialsSecretArn: Swift.String?
        /// The name of your Amazon RDS database.
        /// This member is required.
        public var databaseName: Swift.String?
        /// Contains the names of the fields to which to map information about the vector store.
        /// This member is required.
        public var fieldMapping: BedrockAgentClientTypes.RdsFieldMapping?
        /// The Amazon Resource Name (ARN) of the vector store.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The name of the table in the database.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            credentialsSecretArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            fieldMapping: BedrockAgentClientTypes.RdsFieldMapping? = nil,
            resourceArn: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.credentialsSecretArn = credentialsSecretArn
            self.databaseName = databaseName
            self.fieldMapping = fieldMapping
            self.resourceArn = resourceArn
            self.tableName = tableName
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains the names of the fields to which to map information about the vector store.
    public struct RedisEnterpriseCloudFieldMapping: Swift.Sendable {
        /// The name of the field in which Amazon Bedrock stores metadata about the vector store.
        /// This member is required.
        public var metadataField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        /// This member is required.
        public var textField: Swift.String?
        /// The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        /// This member is required.
        public var vectorField: Swift.String?

        public init(
            metadataField: Swift.String? = nil,
            textField: Swift.String? = nil,
            vectorField: Swift.String? = nil
        )
        {
            self.metadataField = metadataField
            self.textField = textField
            self.vectorField = vectorField
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about the storage configuration of the knowledge base in Redis Enterprise Cloud. For more information, see [Create a vector index in Redis Enterprise Cloud](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-oss.html).
    public struct RedisEnterpriseCloudConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the secret that you created in Secrets Manager that is linked to your Redis Enterprise Cloud database.
        /// This member is required.
        public var credentialsSecretArn: Swift.String?
        /// The endpoint URL of the Redis Enterprise Cloud database.
        /// This member is required.
        public var endpoint: Swift.String?
        /// Contains the names of the fields to which to map information about the vector store.
        /// This member is required.
        public var fieldMapping: BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping?
        /// The name of the vector index.
        /// This member is required.
        public var vectorIndexName: Swift.String?

        public init(
            credentialsSecretArn: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            fieldMapping: BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping? = nil,
            vectorIndexName: Swift.String? = nil
        )
        {
            self.credentialsSecretArn = credentialsSecretArn
            self.endpoint = endpoint
            self.fieldMapping = fieldMapping
            self.vectorIndexName = vectorIndexName
        }
    }
}

extension BedrockAgentClientTypes {

    public enum KnowledgeBaseStorageType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mongoDbAtlas
        case opensearchServerless
        case pinecone
        case rds
        case redisEnterpriseCloud
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseStorageType] {
            return [
                .mongoDbAtlas,
                .opensearchServerless,
                .pinecone,
                .rds,
                .redisEnterpriseCloud
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mongoDbAtlas: return "MONGO_DB_ATLAS"
            case .opensearchServerless: return "OPENSEARCH_SERVERLESS"
            case .pinecone: return "PINECONE"
            case .rds: return "RDS"
            case .redisEnterpriseCloud: return "REDIS_ENTERPRISE_CLOUD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains the storage configuration of the knowledge base.
    public struct StorageConfiguration: Swift.Sendable {
        /// Contains the storage configuration of the knowledge base in MongoDB Atlas.
        public var mongoDbAtlasConfiguration: BedrockAgentClientTypes.MongoDbAtlasConfiguration?
        /// Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        public var opensearchServerlessConfiguration: BedrockAgentClientTypes.OpenSearchServerlessConfiguration?
        /// Contains the storage configuration of the knowledge base in Pinecone.
        public var pineconeConfiguration: BedrockAgentClientTypes.PineconeConfiguration?
        /// Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-rds.html).
        public var rdsConfiguration: BedrockAgentClientTypes.RdsConfiguration?
        /// Contains the storage configuration of the knowledge base in Redis Enterprise Cloud.
        public var redisEnterpriseCloudConfiguration: BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration?
        /// The vector store service in which the knowledge base is stored.
        /// This member is required.
        public var type: BedrockAgentClientTypes.KnowledgeBaseStorageType?

        public init(
            mongoDbAtlasConfiguration: BedrockAgentClientTypes.MongoDbAtlasConfiguration? = nil,
            opensearchServerlessConfiguration: BedrockAgentClientTypes.OpenSearchServerlessConfiguration? = nil,
            pineconeConfiguration: BedrockAgentClientTypes.PineconeConfiguration? = nil,
            rdsConfiguration: BedrockAgentClientTypes.RdsConfiguration? = nil,
            redisEnterpriseCloudConfiguration: BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration? = nil,
            type: BedrockAgentClientTypes.KnowledgeBaseStorageType? = nil
        )
        {
            self.mongoDbAtlasConfiguration = mongoDbAtlasConfiguration
            self.opensearchServerlessConfiguration = opensearchServerlessConfiguration
            self.pineconeConfiguration = pineconeConfiguration
            self.rdsConfiguration = rdsConfiguration
            self.redisEnterpriseCloudConfiguration = redisEnterpriseCloudConfiguration
            self.type = type
        }
    }
}

public struct CreateKnowledgeBaseInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// A description of the knowledge base.
    public var description: Swift.String?
    /// Contains details about the embeddings model used for the knowledge base.
    /// This member is required.
    public var knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration?
    /// A name for the knowledge base.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Contains details about the configuration of the vector database used for the knowledge base.
    /// This member is required.
    public var storageConfiguration: BedrockAgentClientTypes.StorageConfiguration?
    /// Specify the key-value pairs for the tags that you want to attach to your knowledge base in this object.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        storageConfiguration: BedrockAgentClientTypes.StorageConfiguration? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
        self.name = name
        self.roleArn = roleArn
        self.storageConfiguration = storageConfiguration
        self.tags = tags
    }
}

extension BedrockAgentClientTypes {

    public enum KnowledgeBaseStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleteUnsuccessful
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [KnowledgeBaseStatus] {
            return [
                .active,
                .creating,
                .deleteUnsuccessful,
                .deleting,
                .failed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleteUnsuccessful: return "DELETE_UNSUCCESSFUL"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockAgentClientTypes {

    /// Contains information about a knowledge base.
    public struct KnowledgeBase: Swift.Sendable {
        /// The time the knowledge base was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the knowledge base.
        public var description: Swift.String?
        /// A list of reasons that the API operation on the knowledge base failed.
        public var failureReasons: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the knowledge base.
        /// This member is required.
        public var knowledgeBaseArn: Swift.String?
        /// Contains details about the embeddings configuration of the knowledge base.
        /// This member is required.
        public var knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration?
        /// The unique identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The name of the knowledge base.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The status of the knowledge base. The following statuses are possible:
        ///
        /// * CREATING  The knowledge base is being created.
        ///
        /// * ACTIVE  The knowledge base is ready to be queried.
        ///
        /// * DELETING  The knowledge base is being deleted.
        ///
        /// * UPDATING  The knowledge base is being updated.
        ///
        /// * FAILED  The knowledge base API operation failed.
        /// This member is required.
        public var status: BedrockAgentClientTypes.KnowledgeBaseStatus?
        /// Contains details about the storage configuration of the knowledge base.
        /// This member is required.
        public var storageConfiguration: BedrockAgentClientTypes.StorageConfiguration?
        /// The time the knowledge base was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            failureReasons: [Swift.String]? = nil,
            knowledgeBaseArn: Swift.String? = nil,
            knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration? = nil,
            knowledgeBaseId: Swift.String? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: BedrockAgentClientTypes.KnowledgeBaseStatus? = nil,
            storageConfiguration: BedrockAgentClientTypes.StorageConfiguration? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.failureReasons = failureReasons
            self.knowledgeBaseArn = knowledgeBaseArn
            self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.roleArn = roleArn
            self.status = status
            self.storageConfiguration = storageConfiguration
            self.updatedAt = updatedAt
        }
    }
}

public struct CreateKnowledgeBaseOutput: Swift.Sendable {
    /// Contains details about the knowledge base.
    /// This member is required.
    public var knowledgeBase: BedrockAgentClientTypes.KnowledgeBase?

    public init(
        knowledgeBase: BedrockAgentClientTypes.KnowledgeBase? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

public struct DeleteKnowledgeBaseInput: Swift.Sendable {
    /// The unique identifier of the knowledge base to delete.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct DeleteKnowledgeBaseOutput: Swift.Sendable {
    /// The unique identifier of the knowledge base that was deleted.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// The status of the knowledge base and whether it has been successfully deleted.
    /// This member is required.
    public var status: BedrockAgentClientTypes.KnowledgeBaseStatus?

    public init(
        knowledgeBaseId: Swift.String? = nil,
        status: BedrockAgentClientTypes.KnowledgeBaseStatus? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
        self.status = status
    }
}

public struct DisassociateAgentKnowledgeBaseInput: Swift.Sendable {
    /// The unique identifier of the agent from which to disassociate the knowledge base.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent from which to disassociate the knowledge base.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// The unique identifier of the knowledge base to disassociate.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct DisassociateAgentKnowledgeBaseOutput: Swift.Sendable {

    public init() { }
}

public struct GetAgentKnowledgeBaseInput: Swift.Sendable {
    /// The unique identifier of the agent with which the knowledge base is associated.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent with which the knowledge base is associated.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// The unique identifier of the knowledge base associated with the agent.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct GetAgentKnowledgeBaseOutput: Swift.Sendable {
    /// Contains details about a knowledge base attached to an agent.
    /// This member is required.
    public var agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase?

    public init(
        agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase? = nil
    )
    {
        self.agentKnowledgeBase = agentKnowledgeBase
    }
}

public struct GetKnowledgeBaseInput: Swift.Sendable {
    /// The unique identifier of the knowledge base you want to get information on.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?

    public init(
        knowledgeBaseId: Swift.String? = nil
    )
    {
        self.knowledgeBaseId = knowledgeBaseId
    }
}

public struct GetKnowledgeBaseOutput: Swift.Sendable {
    /// Contains details about the knowledge base.
    /// This member is required.
    public var knowledgeBase: BedrockAgentClientTypes.KnowledgeBase?

    public init(
        knowledgeBase: BedrockAgentClientTypes.KnowledgeBase? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

public struct ListAgentKnowledgeBasesInput: Swift.Sendable {
    /// The unique identifier of the agent for which to return information about knowledge bases associated with it.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent for which to return information about knowledge bases associated with it.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAgentKnowledgeBasesOutput: Swift.Sendable {
    /// A list of objects, each of which contains information about a knowledge base associated with the agent.
    /// This member is required.
    public var agentKnowledgeBaseSummaries: [BedrockAgentClientTypes.AgentKnowledgeBaseSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentKnowledgeBaseSummaries: [BedrockAgentClientTypes.AgentKnowledgeBaseSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentKnowledgeBaseSummaries = agentKnowledgeBaseSummaries
        self.nextToken = nextToken
    }
}

public struct ListKnowledgeBasesInput: Swift.Sendable {
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about a knowledge base.
    public struct KnowledgeBaseSummary: Swift.Sendable {
        /// The description of the knowledge base.
        public var description: Swift.String?
        /// The unique identifier of the knowledge base.
        /// This member is required.
        public var knowledgeBaseId: Swift.String?
        /// The name of the knowledge base.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the knowledge base.
        /// This member is required.
        public var status: BedrockAgentClientTypes.KnowledgeBaseStatus?
        /// The time the knowledge base was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            description: Swift.String? = nil,
            knowledgeBaseId: Swift.String? = nil,
            name: Swift.String? = nil,
            status: BedrockAgentClientTypes.KnowledgeBaseStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.description = description
            self.knowledgeBaseId = knowledgeBaseId
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct ListKnowledgeBasesOutput: Swift.Sendable {
    /// A list of knowledge bases with information about each knowledge base.
    /// This member is required.
    public var knowledgeBaseSummaries: [BedrockAgentClientTypes.KnowledgeBaseSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        knowledgeBaseSummaries: [BedrockAgentClientTypes.KnowledgeBaseSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.knowledgeBaseSummaries = knowledgeBaseSummaries
        self.nextToken = nextToken
    }
}

public struct UpdateAgentKnowledgeBaseInput: Swift.Sendable {
    /// The unique identifier of the agent associated with the knowledge base that you want to update.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent associated with the knowledge base that you want to update.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// Specifies a new description for the knowledge base associated with an agent.
    public var description: Swift.String?
    /// The unique identifier of the knowledge base that has been associated with an agent.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// Specifies whether the agent uses the knowledge base or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
    public var knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        knowledgeBaseId: Swift.String? = nil,
        knowledgeBaseState: BedrockAgentClientTypes.KnowledgeBaseState? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.description = description
        self.knowledgeBaseId = knowledgeBaseId
        self.knowledgeBaseState = knowledgeBaseState
    }
}

public struct UpdateAgentKnowledgeBaseOutput: Swift.Sendable {
    /// Contains details about the knowledge base that has been associated with an agent.
    /// This member is required.
    public var agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase?

    public init(
        agentKnowledgeBase: BedrockAgentClientTypes.AgentKnowledgeBase? = nil
    )
    {
        self.agentKnowledgeBase = agentKnowledgeBase
    }
}

public struct UpdateKnowledgeBaseInput: Swift.Sendable {
    /// Specifies a new description for the knowledge base.
    public var description: Swift.String?
    /// Specifies the configuration for the embeddings model used for the knowledge base. You must use the same configuration as when the knowledge base was created.
    /// This member is required.
    public var knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration?
    /// The unique identifier of the knowledge base to update.
    /// This member is required.
    public var knowledgeBaseId: Swift.String?
    /// Specifies a new name for the knowledge base.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies a different Amazon Resource Name (ARN) of the IAM role with permissions to invoke API operations on the knowledge base.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Specifies the configuration for the vector store used for the knowledge base. You must use the same configuration as when the knowledge base was created.
    /// This member is required.
    public var storageConfiguration: BedrockAgentClientTypes.StorageConfiguration?

    public init(
        description: Swift.String? = nil,
        knowledgeBaseConfiguration: BedrockAgentClientTypes.KnowledgeBaseConfiguration? = nil,
        knowledgeBaseId: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        storageConfiguration: BedrockAgentClientTypes.StorageConfiguration? = nil
    )
    {
        self.description = description
        self.knowledgeBaseConfiguration = knowledgeBaseConfiguration
        self.knowledgeBaseId = knowledgeBaseId
        self.name = name
        self.roleArn = roleArn
        self.storageConfiguration = storageConfiguration
    }
}

public struct UpdateKnowledgeBaseOutput: Swift.Sendable {
    /// Contains details about the knowledge base.
    /// This member is required.
    public var knowledgeBase: BedrockAgentClientTypes.KnowledgeBase?

    public init(
        knowledgeBase: BedrockAgentClientTypes.KnowledgeBase? = nil
    )
    {
        self.knowledgeBase = knowledgeBase
    }
}

extension BedrockAgentClientTypes {

    /// Contains specifications for an Amazon Bedrock agent with which to use the prompt. For more information, see [Create a prompt using Prompt management](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management-create.html) and [Automate tasks in your application using conversational agents](https://docs.aws.amazon.com/bedrock/latest/userguide/agents.html).
    public struct PromptAgentResource: Swift.Sendable {
        /// The ARN of the agent with which to use the prompt.
        /// This member is required.
        public var agentIdentifier: Swift.String?

        public init(
            agentIdentifier: Swift.String? = nil
        )
        {
            self.agentIdentifier = agentIdentifier
        }
    }
}

extension BedrockAgentClientTypes.PromptAgentResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentClientTypes {

    /// Contains specifications for a generative AI resource with which to use the prompt. For more information, see [Create a prompt using Prompt management](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management-create.html).
    public enum PromptGenAiResource: Swift.Sendable {
        /// Specifies an Amazon Bedrock agent with which to use the prompt.
        case agent(BedrockAgentClientTypes.PromptAgentResource)
        case sdkUnknown(Swift.String)
    }
}

extension BedrockAgentClientTypes {

    /// Contains a key-value pair that defines a metadata tag and value to attach to a prompt variant. For more information, see [Create a prompt using Prompt management](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management-create.html).
    public struct PromptMetadataEntry: Swift.Sendable {
        /// The key of a metadata tag for a prompt variant.
        /// This member is required.
        public var key: Swift.String?
        /// The value of a metadata tag for a prompt variant.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension BedrockAgentClientTypes.PromptMetadataEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension BedrockAgentClientTypes {

    /// Contains details about a variant of the prompt.
    public struct PromptVariant: Swift.Sendable {
        /// Contains model-specific inference configurations that aren't in the inferenceConfiguration field. To see model-specific inference parameters, see [Inference request parameters and response fields for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html).
        public var additionalModelRequestFields: Smithy.Document?
        /// Specifies a generative AI resource with which to use the prompt.
        public var genAiResource: BedrockAgentClientTypes.PromptGenAiResource?
        /// Contains inference configurations for the prompt variant.
        public var inferenceConfiguration: BedrockAgentClientTypes.PromptInferenceConfiguration?
        /// An array of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant.
        public var metadata: [BedrockAgentClientTypes.PromptMetadataEntry]?
        /// The unique identifier of the model or [inference profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html) with which to run inference on the prompt.
        public var modelId: Swift.String?
        /// The name of the prompt variant.
        /// This member is required.
        public var name: Swift.String?
        /// Contains configurations for the prompt template.
        /// This member is required.
        public var templateConfiguration: BedrockAgentClientTypes.PromptTemplateConfiguration?
        /// The type of prompt template to use.
        /// This member is required.
        public var templateType: BedrockAgentClientTypes.PromptTemplateType?

        public init(
            additionalModelRequestFields: Smithy.Document? = nil,
            genAiResource: BedrockAgentClientTypes.PromptGenAiResource? = nil,
            inferenceConfiguration: BedrockAgentClientTypes.PromptInferenceConfiguration? = nil,
            metadata: [BedrockAgentClientTypes.PromptMetadataEntry]? = nil,
            modelId: Swift.String? = nil,
            name: Swift.String? = nil,
            templateConfiguration: BedrockAgentClientTypes.PromptTemplateConfiguration? = nil,
            templateType: BedrockAgentClientTypes.PromptTemplateType? = nil
        )
        {
            self.additionalModelRequestFields = additionalModelRequestFields
            self.genAiResource = genAiResource
            self.inferenceConfiguration = inferenceConfiguration
            self.metadata = metadata
            self.modelId = modelId
            self.name = name
            self.templateConfiguration = templateConfiguration
            self.templateType = templateType
        }
    }
}

extension BedrockAgentClientTypes.PromptVariant: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct CreatePromptInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the KMS key to encrypt the prompt.
    public var customerEncryptionKeyArn: Swift.String?
    /// The name of the default variant for the prompt. This value must match the name field in the relevant [PromptVariant](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptVariant.html) object.
    public var defaultVariant: Swift.String?
    /// A description for the prompt.
    public var description: Swift.String?
    /// A name for the prompt.
    /// This member is required.
    public var name: Swift.String?
    /// Any tags that you want to attach to the prompt. For more information, see [Tagging resources in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/tagging.html).
    public var tags: [Swift.String: Swift.String]?
    /// A list of objects, each containing details about a variant of the prompt.
    public var variants: [BedrockAgentClientTypes.PromptVariant]?

    public init(
        clientToken: Swift.String? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        defaultVariant: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        variants: [BedrockAgentClientTypes.PromptVariant]? = nil
    )
    {
        self.clientToken = clientToken
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.defaultVariant = defaultVariant
        self.description = description
        self.name = name
        self.tags = tags
        self.variants = variants
    }
}

extension CreatePromptInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePromptInput(clientToken: \(Swift.String(describing: clientToken)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), defaultVariant: \(Swift.String(describing: defaultVariant)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), variants: \"CONTENT_REDACTED\")"}
}

public struct CreatePromptOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the prompt.
    /// This member is required.
    public var arn: Swift.String?
    /// The time at which the prompt was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the KMS key that you encrypted the prompt with.
    public var customerEncryptionKeyArn: Swift.String?
    /// The name of the default variant for your prompt.
    public var defaultVariant: Swift.String?
    /// The description of the prompt.
    public var description: Swift.String?
    /// The unique identifier of the prompt.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the prompt.
    /// This member is required.
    public var name: Swift.String?
    /// The time at which the prompt was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// A list of objects, each containing details about a variant of the prompt.
    public var variants: [BedrockAgentClientTypes.PromptVariant]?
    /// The version of the prompt. When you create a prompt, the version created is the DRAFT version.
    /// This member is required.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        defaultVariant: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        variants: [BedrockAgentClientTypes.PromptVariant]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.defaultVariant = defaultVariant
        self.description = description
        self.id = id
        self.name = name
        self.updatedAt = updatedAt
        self.variants = variants
        self.version = version
    }
}

extension CreatePromptOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePromptOutput(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), defaultVariant: \(Swift.String(describing: defaultVariant)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), variants: \"CONTENT_REDACTED\")"}
}

public struct CreatePromptVersionInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure that the API request completes no more than one time. If this token matches a previous request, Amazon Bedrock ignores the request, but does not return an error. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html).
    public var clientToken: Swift.String?
    /// A description for the version of the prompt.
    public var description: Swift.String?
    /// The unique identifier of the prompt that you want to create a version of.
    /// This member is required.
    public var promptIdentifier: Swift.String?
    /// Any tags that you want to attach to the version of the prompt. For more information, see [Tagging resources in Amazon Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/tagging.html).
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        promptIdentifier: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.promptIdentifier = promptIdentifier
        self.tags = tags
    }
}

public struct CreatePromptVersionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the version of the prompt.
    /// This member is required.
    public var arn: Swift.String?
    /// The time at which the prompt was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the KMS key to encrypt the version of the prompt.
    public var customerEncryptionKeyArn: Swift.String?
    /// The name of the default variant for the prompt. This value must match the name field in the relevant [PromptVariant](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptVariant.html) object.
    public var defaultVariant: Swift.String?
    /// A description for the version.
    public var description: Swift.String?
    /// The unique identifier of the prompt.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the prompt.
    /// This member is required.
    public var name: Swift.String?
    /// The time at which the prompt was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// A list of objects, each containing details about a variant of the prompt.
    public var variants: [BedrockAgentClientTypes.PromptVariant]?
    /// The version of the prompt that was created. Versions are numbered incrementally, starting from 1.
    /// This member is required.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        defaultVariant: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        variants: [BedrockAgentClientTypes.PromptVariant]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.defaultVariant = defaultVariant
        self.description = description
        self.id = id
        self.name = name
        self.updatedAt = updatedAt
        self.variants = variants
        self.version = version
    }
}

extension CreatePromptVersionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePromptVersionOutput(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), defaultVariant: \(Swift.String(describing: defaultVariant)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), variants: \"CONTENT_REDACTED\")"}
}

public struct DeletePromptInput: Swift.Sendable {
    /// The unique identifier of the prompt.
    /// This member is required.
    public var promptIdentifier: Swift.String?
    /// The version of the prompt to delete. To delete the prompt, omit this field.
    public var promptVersion: Swift.String?

    public init(
        promptIdentifier: Swift.String? = nil,
        promptVersion: Swift.String? = nil
    )
    {
        self.promptIdentifier = promptIdentifier
        self.promptVersion = promptVersion
    }
}

public struct DeletePromptOutput: Swift.Sendable {
    /// The unique identifier of the prompt that was deleted.
    /// This member is required.
    public var id: Swift.String?
    /// The version of the prompt that was deleted.
    public var version: Swift.String?

    public init(
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.id = id
        self.version = version
    }
}

public struct GetPromptInput: Swift.Sendable {
    /// The unique identifier of the prompt.
    /// This member is required.
    public var promptIdentifier: Swift.String?
    /// The version of the prompt about which you want to retrieve information. Omit this field to return information about the working draft of the prompt.
    public var promptVersion: Swift.String?

    public init(
        promptIdentifier: Swift.String? = nil,
        promptVersion: Swift.String? = nil
    )
    {
        self.promptIdentifier = promptIdentifier
        self.promptVersion = promptVersion
    }
}

public struct GetPromptOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the prompt or the prompt version (if you specified a version in the request).
    /// This member is required.
    public var arn: Swift.String?
    /// The time at which the prompt was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the KMS key that the prompt is encrypted with.
    public var customerEncryptionKeyArn: Swift.String?
    /// The name of the default variant for the prompt. This value must match the name field in the relevant [PromptVariant](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptVariant.html) object.
    public var defaultVariant: Swift.String?
    /// The descriptino of the prompt.
    public var description: Swift.String?
    /// The unique identifier of the prompt.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the prompt.
    /// This member is required.
    public var name: Swift.String?
    /// The time at which the prompt was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// A list of objects, each containing details about a variant of the prompt.
    public var variants: [BedrockAgentClientTypes.PromptVariant]?
    /// The version of the prompt.
    /// This member is required.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        defaultVariant: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        variants: [BedrockAgentClientTypes.PromptVariant]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.defaultVariant = defaultVariant
        self.description = description
        self.id = id
        self.name = name
        self.updatedAt = updatedAt
        self.variants = variants
        self.version = version
    }
}

extension GetPromptOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPromptOutput(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), defaultVariant: \(Swift.String(describing: defaultVariant)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), variants: \"CONTENT_REDACTED\")"}
}

public struct ListPromptsInput: Swift.Sendable {
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?
    /// The unique identifier of the prompt for whose versions you want to return information. Omit this field to list information about all prompts in an account.
    public var promptIdentifier: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        promptIdentifier: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.promptIdentifier = promptIdentifier
    }
}

extension BedrockAgentClientTypes {

    /// Contains information about a prompt in your Prompt management tool. This data type is used in the following API operations:
    ///
    /// * [ListPrompts response](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_ListPrompts.html#API_agent_ListPrompts_ResponseSyntax)
    public struct PromptSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the prompt or the prompt version (if you specified a version in the request).
        /// This member is required.
        public var arn: Swift.String?
        /// The time at which the prompt was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the prompt.
        public var description: Swift.String?
        /// The unique identifier of the prompt.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the prompt.
        /// This member is required.
        public var name: Swift.String?
        /// The time at which the prompt was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?
        /// The version of the prompt that this summary applies to.
        /// This member is required.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.name = name
            self.updatedAt = updatedAt
            self.version = version
        }
    }
}

public struct ListPromptsOutput: Swift.Sendable {
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?
    /// A list, each member of which contains information about a prompt using Prompt management.
    /// This member is required.
    public var promptSummaries: [BedrockAgentClientTypes.PromptSummary]?

    public init(
        nextToken: Swift.String? = nil,
        promptSummaries: [BedrockAgentClientTypes.PromptSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.promptSummaries = promptSummaries
    }
}

public struct UpdatePromptInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the KMS key to encrypt the prompt.
    public var customerEncryptionKeyArn: Swift.String?
    /// The name of the default variant for the prompt. This value must match the name field in the relevant [PromptVariant](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptVariant.html) object.
    public var defaultVariant: Swift.String?
    /// A description for the prompt.
    public var description: Swift.String?
    /// A name for the prompt.
    /// This member is required.
    public var name: Swift.String?
    /// The unique identifier of the prompt.
    /// This member is required.
    public var promptIdentifier: Swift.String?
    /// A list of objects, each containing details about a variant of the prompt.
    public var variants: [BedrockAgentClientTypes.PromptVariant]?

    public init(
        customerEncryptionKeyArn: Swift.String? = nil,
        defaultVariant: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        promptIdentifier: Swift.String? = nil,
        variants: [BedrockAgentClientTypes.PromptVariant]? = nil
    )
    {
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.defaultVariant = defaultVariant
        self.description = description
        self.name = name
        self.promptIdentifier = promptIdentifier
        self.variants = variants
    }
}

extension UpdatePromptInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePromptInput(customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), defaultVariant: \(Swift.String(describing: defaultVariant)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), promptIdentifier: \(Swift.String(describing: promptIdentifier)), variants: \"CONTENT_REDACTED\")"}
}

public struct UpdatePromptOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the prompt.
    /// This member is required.
    public var arn: Swift.String?
    /// The time at which the prompt was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the KMS key to encrypt the prompt.
    public var customerEncryptionKeyArn: Swift.String?
    /// The name of the default variant for the prompt. This value must match the name field in the relevant [PromptVariant](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptVariant.html) object.
    public var defaultVariant: Swift.String?
    /// The description of the prompt.
    public var description: Swift.String?
    /// The unique identifier of the prompt.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the prompt.
    /// This member is required.
    public var name: Swift.String?
    /// The time at which the prompt was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// A list of objects, each containing details about a variant of the prompt.
    public var variants: [BedrockAgentClientTypes.PromptVariant]?
    /// The version of the prompt. When you update a prompt, the version updated is the DRAFT version.
    /// This member is required.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        customerEncryptionKeyArn: Swift.String? = nil,
        defaultVariant: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil,
        variants: [BedrockAgentClientTypes.PromptVariant]? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.customerEncryptionKeyArn = customerEncryptionKeyArn
        self.defaultVariant = defaultVariant
        self.description = description
        self.id = id
        self.name = name
        self.updatedAt = updatedAt
        self.variants = variants
        self.version = version
    }
}

extension UpdatePromptOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePromptOutput(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), customerEncryptionKeyArn: \(Swift.String(describing: customerEncryptionKeyArn)), defaultVariant: \(Swift.String(describing: defaultVariant)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), updatedAt: \(Swift.String(describing: updatedAt)), version: \(Swift.String(describing: version)), variants: \"CONTENT_REDACTED\")"}
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource for which to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The key-value pairs for the tags associated with the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An object containing key-value pairs that define the tags to attach to the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource from which to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct ValidateFlowDefinitionInput: Swift.Sendable {
    /// The definition of a flow to validate.
    /// This member is required.
    public var definition: BedrockAgentClientTypes.FlowDefinition?

    public init(
        definition: BedrockAgentClientTypes.FlowDefinition? = nil
    )
    {
        self.definition = definition
    }
}

extension ValidateFlowDefinitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidateFlowDefinitionInput(definition: \"CONTENT_REDACTED\")"}
}

public struct ValidateFlowDefinitionOutput: Swift.Sendable {
    /// Contains an array of objects, each of which contains an error identified by validation.
    /// This member is required.
    public var validations: [BedrockAgentClientTypes.FlowValidation]?

    public init(
        validations: [BedrockAgentClientTypes.FlowValidation]? = nil
    )
    {
        self.validations = validations
    }
}

public struct DeleteAgentVersionInput: Swift.Sendable {
    /// The unique identifier of the agent that the version belongs to.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent to delete.
    /// This member is required.
    public var agentVersion: Swift.String?
    /// By default, this value is false and deletion is stopped if the resource is in use. If you set it to true, the resource will be deleted even if the resource is in use.
    public var skipResourceInUseCheck: Swift.Bool?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil,
        skipResourceInUseCheck: Swift.Bool? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.skipResourceInUseCheck = skipResourceInUseCheck
    }
}

public struct DeleteAgentVersionOutput: Swift.Sendable {
    /// The unique identifier of the agent that the version belongs to.
    /// This member is required.
    public var agentId: Swift.String?
    /// The status of the agent version.
    /// This member is required.
    public var agentStatus: BedrockAgentClientTypes.AgentStatus?
    /// The version that was deleted.
    /// This member is required.
    public var agentVersion: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentStatus: BedrockAgentClientTypes.AgentStatus? = nil,
        agentVersion: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentStatus = agentStatus
        self.agentVersion = agentVersion
    }
}

public struct GetAgentVersionInput: Swift.Sendable {
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// The version of the agent.
    /// This member is required.
    public var agentVersion: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        agentVersion: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.agentVersion = agentVersion
    }
}

public struct GetAgentVersionOutput: Swift.Sendable {
    /// Contains details about the version of the agent.
    /// This member is required.
    public var agentVersion: BedrockAgentClientTypes.AgentVersion?

    public init(
        agentVersion: BedrockAgentClientTypes.AgentVersion? = nil
    )
    {
        self.agentVersion = agentVersion
    }
}

public struct ListAgentVersionsInput: Swift.Sendable {
    /// The unique identifier of the agent.
    /// This member is required.
    public var agentId: Swift.String?
    /// The maximum number of results to return in the response. If the total number of results is greater than this value, use the token returned in the response in the nextToken field when making another request to return the next batch of results.
    public var maxResults: Swift.Int?
    /// If the total number of results is greater than the maxResults value provided in the request, enter the token returned in the nextToken field in the response in this field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentId = agentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAgentVersionsOutput: Swift.Sendable {
    /// A list of objects, each of which contains information about a version of the agent.
    /// This member is required.
    public var agentVersionSummaries: [BedrockAgentClientTypes.AgentVersionSummary]?
    /// If the total number of results is greater than the maxResults value provided in the request, use this token when making another request in the nextToken field to return the next batch of results.
    public var nextToken: Swift.String?

    public init(
        agentVersionSummaries: [BedrockAgentClientTypes.AgentVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.agentVersionSummaries = agentVersionSummaries
        self.nextToken = nextToken
    }
}

extension AssociateAgentKnowledgeBaseInput {

    static func urlPathProvider(_ value: AssociateAgentKnowledgeBaseInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases"
    }
}

extension CreateAgentInput {

    static func urlPathProvider(_ value: CreateAgentInput) -> Swift.String? {
        return "/agents"
    }
}

extension CreateAgentActionGroupInput {

    static func urlPathProvider(_ value: CreateAgentActionGroupInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups"
    }
}

extension CreateAgentAliasInput {

    static func urlPathProvider(_ value: CreateAgentAliasInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases"
    }
}

extension CreateDataSourceInput {

    static func urlPathProvider(_ value: CreateDataSourceInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources"
    }
}

extension CreateFlowInput {

    static func urlPathProvider(_ value: CreateFlowInput) -> Swift.String? {
        return "/flows"
    }
}

extension CreateFlowAliasInput {

    static func urlPathProvider(_ value: CreateFlowAliasInput) -> Swift.String? {
        guard let flowIdentifier = value.flowIdentifier else {
            return nil
        }
        return "/flows/\(flowIdentifier.urlPercentEncoding())/aliases"
    }
}

extension CreateFlowVersionInput {

    static func urlPathProvider(_ value: CreateFlowVersionInput) -> Swift.String? {
        guard let flowIdentifier = value.flowIdentifier else {
            return nil
        }
        return "/flows/\(flowIdentifier.urlPercentEncoding())/versions"
    }
}

extension CreateKnowledgeBaseInput {

    static func urlPathProvider(_ value: CreateKnowledgeBaseInput) -> Swift.String? {
        return "/knowledgebases"
    }
}

extension CreatePromptInput {

    static func urlPathProvider(_ value: CreatePromptInput) -> Swift.String? {
        return "/prompts"
    }
}

extension CreatePromptVersionInput {

    static func urlPathProvider(_ value: CreatePromptVersionInput) -> Swift.String? {
        guard let promptIdentifier = value.promptIdentifier else {
            return nil
        }
        return "/prompts/\(promptIdentifier.urlPercentEncoding())/versions"
    }
}

extension DeleteAgentInput {

    static func urlPathProvider(_ value: DeleteAgentInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())"
    }
}

extension DeleteAgentInput {

    static func queryItemProvider(_ value: DeleteAgentInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let skipResourceInUseCheck = value.skipResourceInUseCheck {
            let skipResourceInUseCheckQueryItem = Smithy.URIQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: Swift.String(skipResourceInUseCheck).urlPercentEncoding())
            items.append(skipResourceInUseCheckQueryItem)
        }
        return items
    }
}

extension DeleteAgentActionGroupInput {

    static func urlPathProvider(_ value: DeleteAgentActionGroupInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let actionGroupId = value.actionGroupId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups/\(actionGroupId.urlPercentEncoding())"
    }
}

extension DeleteAgentActionGroupInput {

    static func queryItemProvider(_ value: DeleteAgentActionGroupInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let skipResourceInUseCheck = value.skipResourceInUseCheck {
            let skipResourceInUseCheckQueryItem = Smithy.URIQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: Swift.String(skipResourceInUseCheck).urlPercentEncoding())
            items.append(skipResourceInUseCheckQueryItem)
        }
        return items
    }
}

extension DeleteAgentAliasInput {

    static func urlPathProvider(_ value: DeleteAgentAliasInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentAliasId = value.agentAliasId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases/\(agentAliasId.urlPercentEncoding())"
    }
}

extension DeleteAgentVersionInput {

    static func urlPathProvider(_ value: DeleteAgentVersionInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())"
    }
}

extension DeleteAgentVersionInput {

    static func queryItemProvider(_ value: DeleteAgentVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let skipResourceInUseCheck = value.skipResourceInUseCheck {
            let skipResourceInUseCheckQueryItem = Smithy.URIQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: Swift.String(skipResourceInUseCheck).urlPercentEncoding())
            items.append(skipResourceInUseCheckQueryItem)
        }
        return items
    }
}

extension DeleteDataSourceInput {

    static func urlPathProvider(_ value: DeleteDataSourceInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())"
    }
}

extension DeleteFlowInput {

    static func urlPathProvider(_ value: DeleteFlowInput) -> Swift.String? {
        guard let flowIdentifier = value.flowIdentifier else {
            return nil
        }
        return "/flows/\(flowIdentifier.urlPercentEncoding())"
    }
}

extension DeleteFlowInput {

    static func queryItemProvider(_ value: DeleteFlowInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let skipResourceInUseCheck = value.skipResourceInUseCheck {
            let skipResourceInUseCheckQueryItem = Smithy.URIQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: Swift.String(skipResourceInUseCheck).urlPercentEncoding())
            items.append(skipResourceInUseCheckQueryItem)
        }
        return items
    }
}

extension DeleteFlowAliasInput {

    static func urlPathProvider(_ value: DeleteFlowAliasInput) -> Swift.String? {
        guard let flowIdentifier = value.flowIdentifier else {
            return nil
        }
        guard let aliasIdentifier = value.aliasIdentifier else {
            return nil
        }
        return "/flows/\(flowIdentifier.urlPercentEncoding())/aliases/\(aliasIdentifier.urlPercentEncoding())"
    }
}

extension DeleteFlowVersionInput {

    static func urlPathProvider(_ value: DeleteFlowVersionInput) -> Swift.String? {
        guard let flowIdentifier = value.flowIdentifier else {
            return nil
        }
        guard let flowVersion = value.flowVersion else {
            return nil
        }
        return "/flows/\(flowIdentifier.urlPercentEncoding())/versions/\(flowVersion.urlPercentEncoding())"
    }
}

extension DeleteFlowVersionInput {

    static func queryItemProvider(_ value: DeleteFlowVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let skipResourceInUseCheck = value.skipResourceInUseCheck {
            let skipResourceInUseCheckQueryItem = Smithy.URIQueryItem(name: "skipResourceInUseCheck".urlPercentEncoding(), value: Swift.String(skipResourceInUseCheck).urlPercentEncoding())
            items.append(skipResourceInUseCheckQueryItem)
        }
        return items
    }
}

extension DeleteKnowledgeBaseInput {

    static func urlPathProvider(_ value: DeleteKnowledgeBaseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

extension DeletePromptInput {

    static func urlPathProvider(_ value: DeletePromptInput) -> Swift.String? {
        guard let promptIdentifier = value.promptIdentifier else {
            return nil
        }
        return "/prompts/\(promptIdentifier.urlPercentEncoding())"
    }
}

extension DeletePromptInput {

    static func queryItemProvider(_ value: DeletePromptInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let promptVersion = value.promptVersion {
            let promptVersionQueryItem = Smithy.URIQueryItem(name: "promptVersion".urlPercentEncoding(), value: Swift.String(promptVersion).urlPercentEncoding())
            items.append(promptVersionQueryItem)
        }
        return items
    }
}

extension DisassociateAgentKnowledgeBaseInput {

    static func urlPathProvider(_ value: DisassociateAgentKnowledgeBaseInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

extension GetAgentInput {

    static func urlPathProvider(_ value: GetAgentInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())"
    }
}

extension GetAgentActionGroupInput {

    static func urlPathProvider(_ value: GetAgentActionGroupInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let actionGroupId = value.actionGroupId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups/\(actionGroupId.urlPercentEncoding())"
    }
}

extension GetAgentAliasInput {

    static func urlPathProvider(_ value: GetAgentAliasInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentAliasId = value.agentAliasId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases/\(agentAliasId.urlPercentEncoding())"
    }
}

extension GetAgentKnowledgeBaseInput {

    static func urlPathProvider(_ value: GetAgentKnowledgeBaseInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

extension GetAgentVersionInput {

    static func urlPathProvider(_ value: GetAgentVersionInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())"
    }
}

extension GetDataSourceInput {

    static func urlPathProvider(_ value: GetDataSourceInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())"
    }
}

extension GetFlowInput {

    static func urlPathProvider(_ value: GetFlowInput) -> Swift.String? {
        guard let flowIdentifier = value.flowIdentifier else {
            return nil
        }
        return "/flows/\(flowIdentifier.urlPercentEncoding())"
    }
}

extension GetFlowAliasInput {

    static func urlPathProvider(_ value: GetFlowAliasInput) -> Swift.String? {
        guard let flowIdentifier = value.flowIdentifier else {
            return nil
        }
        guard let aliasIdentifier = value.aliasIdentifier else {
            return nil
        }
        return "/flows/\(flowIdentifier.urlPercentEncoding())/aliases/\(aliasIdentifier.urlPercentEncoding())"
    }
}

extension GetFlowVersionInput {

    static func urlPathProvider(_ value: GetFlowVersionInput) -> Swift.String? {
        guard let flowIdentifier = value.flowIdentifier else {
            return nil
        }
        guard let flowVersion = value.flowVersion else {
            return nil
        }
        return "/flows/\(flowIdentifier.urlPercentEncoding())/versions/\(flowVersion.urlPercentEncoding())"
    }
}

extension GetIngestionJobInput {

    static func urlPathProvider(_ value: GetIngestionJobInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        guard let ingestionJobId = value.ingestionJobId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())/ingestionjobs/\(ingestionJobId.urlPercentEncoding())"
    }
}

extension GetKnowledgeBaseInput {

    static func urlPathProvider(_ value: GetKnowledgeBaseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

extension GetPromptInput {

    static func urlPathProvider(_ value: GetPromptInput) -> Swift.String? {
        guard let promptIdentifier = value.promptIdentifier else {
            return nil
        }
        return "/prompts/\(promptIdentifier.urlPercentEncoding())"
    }
}

extension GetPromptInput {

    static func queryItemProvider(_ value: GetPromptInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let promptVersion = value.promptVersion {
            let promptVersionQueryItem = Smithy.URIQueryItem(name: "promptVersion".urlPercentEncoding(), value: Swift.String(promptVersion).urlPercentEncoding())
            items.append(promptVersionQueryItem)
        }
        return items
    }
}

extension ListAgentActionGroupsInput {

    static func urlPathProvider(_ value: ListAgentActionGroupsInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups"
    }
}

extension ListAgentAliasesInput {

    static func urlPathProvider(_ value: ListAgentAliasesInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases"
    }
}

extension ListAgentKnowledgeBasesInput {

    static func urlPathProvider(_ value: ListAgentKnowledgeBasesInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases"
    }
}

extension ListAgentsInput {

    static func urlPathProvider(_ value: ListAgentsInput) -> Swift.String? {
        return "/agents"
    }
}

extension ListAgentVersionsInput {

    static func urlPathProvider(_ value: ListAgentVersionsInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions"
    }
}

extension ListDataSourcesInput {

    static func urlPathProvider(_ value: ListDataSourcesInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources"
    }
}

extension ListFlowAliasesInput {

    static func urlPathProvider(_ value: ListFlowAliasesInput) -> Swift.String? {
        guard let flowIdentifier = value.flowIdentifier else {
            return nil
        }
        return "/flows/\(flowIdentifier.urlPercentEncoding())/aliases"
    }
}

extension ListFlowAliasesInput {

    static func queryItemProvider(_ value: ListFlowAliasesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListFlowsInput {

    static func urlPathProvider(_ value: ListFlowsInput) -> Swift.String? {
        return "/flows"
    }
}

extension ListFlowsInput {

    static func queryItemProvider(_ value: ListFlowsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListFlowVersionsInput {

    static func urlPathProvider(_ value: ListFlowVersionsInput) -> Swift.String? {
        guard let flowIdentifier = value.flowIdentifier else {
            return nil
        }
        return "/flows/\(flowIdentifier.urlPercentEncoding())/versions"
    }
}

extension ListFlowVersionsInput {

    static func queryItemProvider(_ value: ListFlowVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListIngestionJobsInput {

    static func urlPathProvider(_ value: ListIngestionJobsInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())/ingestionjobs"
    }
}

extension ListKnowledgeBasesInput {

    static func urlPathProvider(_ value: ListKnowledgeBasesInput) -> Swift.String? {
        return "/knowledgebases"
    }
}

extension ListPromptsInput {

    static func urlPathProvider(_ value: ListPromptsInput) -> Swift.String? {
        return "/prompts"
    }
}

extension ListPromptsInput {

    static func queryItemProvider(_ value: ListPromptsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let promptIdentifier = value.promptIdentifier {
            let promptIdentifierQueryItem = Smithy.URIQueryItem(name: "promptIdentifier".urlPercentEncoding(), value: Swift.String(promptIdentifier).urlPercentEncoding())
            items.append(promptIdentifierQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension PrepareAgentInput {

    static func urlPathProvider(_ value: PrepareAgentInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())"
    }
}

extension PrepareFlowInput {

    static func urlPathProvider(_ value: PrepareFlowInput) -> Swift.String? {
        guard let flowIdentifier = value.flowIdentifier else {
            return nil
        }
        return "/flows/\(flowIdentifier.urlPercentEncoding())"
    }
}

extension StartIngestionJobInput {

    static func urlPathProvider(_ value: StartIngestionJobInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())/ingestionjobs"
    }
}

extension StopIngestionJobInput {

    static func urlPathProvider(_ value: StopIngestionJobInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        guard let ingestionJobId = value.ingestionJobId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())/ingestionjobs/\(ingestionJobId.urlPercentEncoding())/stop"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAgentInput {

    static func urlPathProvider(_ value: UpdateAgentInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())"
    }
}

extension UpdateAgentActionGroupInput {

    static func urlPathProvider(_ value: UpdateAgentActionGroupInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let actionGroupId = value.actionGroupId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/actiongroups/\(actionGroupId.urlPercentEncoding())"
    }
}

extension UpdateAgentAliasInput {

    static func urlPathProvider(_ value: UpdateAgentAliasInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentAliasId = value.agentAliasId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentaliases/\(agentAliasId.urlPercentEncoding())"
    }
}

extension UpdateAgentKnowledgeBaseInput {

    static func urlPathProvider(_ value: UpdateAgentKnowledgeBaseInput) -> Swift.String? {
        guard let agentId = value.agentId else {
            return nil
        }
        guard let agentVersion = value.agentVersion else {
            return nil
        }
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/agents/\(agentId.urlPercentEncoding())/agentversions/\(agentVersion.urlPercentEncoding())/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

extension UpdateDataSourceInput {

    static func urlPathProvider(_ value: UpdateDataSourceInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        guard let dataSourceId = value.dataSourceId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())/datasources/\(dataSourceId.urlPercentEncoding())"
    }
}

extension UpdateFlowInput {

    static func urlPathProvider(_ value: UpdateFlowInput) -> Swift.String? {
        guard let flowIdentifier = value.flowIdentifier else {
            return nil
        }
        return "/flows/\(flowIdentifier.urlPercentEncoding())"
    }
}

extension UpdateFlowAliasInput {

    static func urlPathProvider(_ value: UpdateFlowAliasInput) -> Swift.String? {
        guard let flowIdentifier = value.flowIdentifier else {
            return nil
        }
        guard let aliasIdentifier = value.aliasIdentifier else {
            return nil
        }
        return "/flows/\(flowIdentifier.urlPercentEncoding())/aliases/\(aliasIdentifier.urlPercentEncoding())"
    }
}

extension UpdateKnowledgeBaseInput {

    static func urlPathProvider(_ value: UpdateKnowledgeBaseInput) -> Swift.String? {
        guard let knowledgeBaseId = value.knowledgeBaseId else {
            return nil
        }
        return "/knowledgebases/\(knowledgeBaseId.urlPercentEncoding())"
    }
}

extension UpdatePromptInput {

    static func urlPathProvider(_ value: UpdatePromptInput) -> Swift.String? {
        guard let promptIdentifier = value.promptIdentifier else {
            return nil
        }
        return "/prompts/\(promptIdentifier.urlPercentEncoding())"
    }
}

extension ValidateFlowDefinitionInput {

    static func urlPathProvider(_ value: ValidateFlowDefinitionInput) -> Swift.String? {
        return "/flows/validate-definition"
    }
}

extension AssociateAgentKnowledgeBaseInput {

    static func write(value: AssociateAgentKnowledgeBaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["knowledgeBaseId"].write(value.knowledgeBaseId)
        try writer["knowledgeBaseState"].write(value.knowledgeBaseState)
    }
}

extension CreateAgentInput {

    static func write(value: CreateAgentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentName"].write(value.agentName)
        try writer["agentResourceRoleArn"].write(value.agentResourceRoleArn)
        try writer["clientToken"].write(value.clientToken)
        try writer["customerEncryptionKeyArn"].write(value.customerEncryptionKeyArn)
        try writer["description"].write(value.description)
        try writer["foundationModel"].write(value.foundationModel)
        try writer["guardrailConfiguration"].write(value.guardrailConfiguration, with: BedrockAgentClientTypes.GuardrailConfiguration.write(value:to:))
        try writer["idleSessionTTLInSeconds"].write(value.idleSessionTTLInSeconds)
        try writer["instruction"].write(value.instruction)
        try writer["memoryConfiguration"].write(value.memoryConfiguration, with: BedrockAgentClientTypes.MemoryConfiguration.write(value:to:))
        try writer["promptOverrideConfiguration"].write(value.promptOverrideConfiguration, with: BedrockAgentClientTypes.PromptOverrideConfiguration.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateAgentActionGroupInput {

    static func write(value: CreateAgentActionGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionGroupExecutor"].write(value.actionGroupExecutor, with: BedrockAgentClientTypes.ActionGroupExecutor.write(value:to:))
        try writer["actionGroupName"].write(value.actionGroupName)
        try writer["actionGroupState"].write(value.actionGroupState)
        try writer["apiSchema"].write(value.apiSchema, with: BedrockAgentClientTypes.APISchema.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["functionSchema"].write(value.functionSchema, with: BedrockAgentClientTypes.FunctionSchema.write(value:to:))
        try writer["parentActionGroupSignature"].write(value.parentActionGroupSignature)
    }
}

extension CreateAgentAliasInput {

    static func write(value: CreateAgentAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentAliasName"].write(value.agentAliasName)
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["routingConfiguration"].writeList(value.routingConfiguration, memberWritingClosure: BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateDataSourceInput {

    static func write(value: CreateDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["dataDeletionPolicy"].write(value.dataDeletionPolicy)
        try writer["dataSourceConfiguration"].write(value.dataSourceConfiguration, with: BedrockAgentClientTypes.DataSourceConfiguration.write(value:to:))
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["serverSideEncryptionConfiguration"].write(value.serverSideEncryptionConfiguration, with: BedrockAgentClientTypes.ServerSideEncryptionConfiguration.write(value:to:))
        try writer["vectorIngestionConfiguration"].write(value.vectorIngestionConfiguration, with: BedrockAgentClientTypes.VectorIngestionConfiguration.write(value:to:))
    }
}

extension CreateFlowInput {

    static func write(value: CreateFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["customerEncryptionKeyArn"].write(value.customerEncryptionKeyArn)
        try writer["definition"].write(value.definition, with: BedrockAgentClientTypes.FlowDefinition.write(value:to:))
        try writer["description"].write(value.description)
        try writer["executionRoleArn"].write(value.executionRoleArn)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateFlowAliasInput {

    static func write(value: CreateFlowAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["routingConfiguration"].writeList(value.routingConfiguration, memberWritingClosure: BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateFlowVersionInput {

    static func write(value: CreateFlowVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
    }
}

extension CreateKnowledgeBaseInput {

    static func write(value: CreateKnowledgeBaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["knowledgeBaseConfiguration"].write(value.knowledgeBaseConfiguration, with: BedrockAgentClientTypes.KnowledgeBaseConfiguration.write(value:to:))
        try writer["name"].write(value.name)
        try writer["roleArn"].write(value.roleArn)
        try writer["storageConfiguration"].write(value.storageConfiguration, with: BedrockAgentClientTypes.StorageConfiguration.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreatePromptInput {

    static func write(value: CreatePromptInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["customerEncryptionKeyArn"].write(value.customerEncryptionKeyArn)
        try writer["defaultVariant"].write(value.defaultVariant)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["variants"].writeList(value.variants, memberWritingClosure: BedrockAgentClientTypes.PromptVariant.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreatePromptVersionInput {

    static func write(value: CreatePromptVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListAgentActionGroupsInput {

    static func write(value: ListAgentActionGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListAgentAliasesInput {

    static func write(value: ListAgentAliasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListAgentKnowledgeBasesInput {

    static func write(value: ListAgentKnowledgeBasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListAgentsInput {

    static func write(value: ListAgentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListAgentVersionsInput {

    static func write(value: ListAgentVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListDataSourcesInput {

    static func write(value: ListDataSourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListIngestionJobsInput {

    static func write(value: ListIngestionJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: BedrockAgentClientTypes.IngestionJobFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["sortBy"].write(value.sortBy, with: BedrockAgentClientTypes.IngestionJobSortBy.write(value:to:))
    }
}

extension ListKnowledgeBasesInput {

    static func write(value: ListKnowledgeBasesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension StartIngestionJobInput {

    static func write(value: StartIngestionJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateAgentInput {

    static func write(value: UpdateAgentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentName"].write(value.agentName)
        try writer["agentResourceRoleArn"].write(value.agentResourceRoleArn)
        try writer["customerEncryptionKeyArn"].write(value.customerEncryptionKeyArn)
        try writer["description"].write(value.description)
        try writer["foundationModel"].write(value.foundationModel)
        try writer["guardrailConfiguration"].write(value.guardrailConfiguration, with: BedrockAgentClientTypes.GuardrailConfiguration.write(value:to:))
        try writer["idleSessionTTLInSeconds"].write(value.idleSessionTTLInSeconds)
        try writer["instruction"].write(value.instruction)
        try writer["memoryConfiguration"].write(value.memoryConfiguration, with: BedrockAgentClientTypes.MemoryConfiguration.write(value:to:))
        try writer["promptOverrideConfiguration"].write(value.promptOverrideConfiguration, with: BedrockAgentClientTypes.PromptOverrideConfiguration.write(value:to:))
    }
}

extension UpdateAgentActionGroupInput {

    static func write(value: UpdateAgentActionGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionGroupExecutor"].write(value.actionGroupExecutor, with: BedrockAgentClientTypes.ActionGroupExecutor.write(value:to:))
        try writer["actionGroupName"].write(value.actionGroupName)
        try writer["actionGroupState"].write(value.actionGroupState)
        try writer["apiSchema"].write(value.apiSchema, with: BedrockAgentClientTypes.APISchema.write(value:to:))
        try writer["description"].write(value.description)
        try writer["functionSchema"].write(value.functionSchema, with: BedrockAgentClientTypes.FunctionSchema.write(value:to:))
        try writer["parentActionGroupSignature"].write(value.parentActionGroupSignature)
    }
}

extension UpdateAgentAliasInput {

    static func write(value: UpdateAgentAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentAliasName"].write(value.agentAliasName)
        try writer["description"].write(value.description)
        try writer["routingConfiguration"].writeList(value.routingConfiguration, memberWritingClosure: BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAgentKnowledgeBaseInput {

    static func write(value: UpdateAgentKnowledgeBaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["knowledgeBaseState"].write(value.knowledgeBaseState)
    }
}

extension UpdateDataSourceInput {

    static func write(value: UpdateDataSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataDeletionPolicy"].write(value.dataDeletionPolicy)
        try writer["dataSourceConfiguration"].write(value.dataSourceConfiguration, with: BedrockAgentClientTypes.DataSourceConfiguration.write(value:to:))
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["serverSideEncryptionConfiguration"].write(value.serverSideEncryptionConfiguration, with: BedrockAgentClientTypes.ServerSideEncryptionConfiguration.write(value:to:))
        try writer["vectorIngestionConfiguration"].write(value.vectorIngestionConfiguration, with: BedrockAgentClientTypes.VectorIngestionConfiguration.write(value:to:))
    }
}

extension UpdateFlowInput {

    static func write(value: UpdateFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customerEncryptionKeyArn"].write(value.customerEncryptionKeyArn)
        try writer["definition"].write(value.definition, with: BedrockAgentClientTypes.FlowDefinition.write(value:to:))
        try writer["description"].write(value.description)
        try writer["executionRoleArn"].write(value.executionRoleArn)
        try writer["name"].write(value.name)
    }
}

extension UpdateFlowAliasInput {

    static func write(value: UpdateFlowAliasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["routingConfiguration"].writeList(value.routingConfiguration, memberWritingClosure: BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateKnowledgeBaseInput {

    static func write(value: UpdateKnowledgeBaseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["knowledgeBaseConfiguration"].write(value.knowledgeBaseConfiguration, with: BedrockAgentClientTypes.KnowledgeBaseConfiguration.write(value:to:))
        try writer["name"].write(value.name)
        try writer["roleArn"].write(value.roleArn)
        try writer["storageConfiguration"].write(value.storageConfiguration, with: BedrockAgentClientTypes.StorageConfiguration.write(value:to:))
    }
}

extension UpdatePromptInput {

    static func write(value: UpdatePromptInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customerEncryptionKeyArn"].write(value.customerEncryptionKeyArn)
        try writer["defaultVariant"].write(value.defaultVariant)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["variants"].writeList(value.variants, memberWritingClosure: BedrockAgentClientTypes.PromptVariant.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ValidateFlowDefinitionInput {

    static func write(value: ValidateFlowDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["definition"].write(value.definition, with: BedrockAgentClientTypes.FlowDefinition.write(value:to:))
    }
}

extension AssociateAgentKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateAgentKnowledgeBaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateAgentKnowledgeBaseOutput()
        value.agentKnowledgeBase = try reader["agentKnowledgeBase"].readIfPresent(with: BedrockAgentClientTypes.AgentKnowledgeBase.read(from:))
        return value
    }
}

extension CreateAgentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAgentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAgentOutput()
        value.agent = try reader["agent"].readIfPresent(with: BedrockAgentClientTypes.Agent.read(from:))
        return value
    }
}

extension CreateAgentActionGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAgentActionGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAgentActionGroupOutput()
        value.agentActionGroup = try reader["agentActionGroup"].readIfPresent(with: BedrockAgentClientTypes.AgentActionGroup.read(from:))
        return value
    }
}

extension CreateAgentAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAgentAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAgentAliasOutput()
        value.agentAlias = try reader["agentAlias"].readIfPresent(with: BedrockAgentClientTypes.AgentAlias.read(from:))
        return value
    }
}

extension CreateDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataSourceOutput()
        value.dataSource = try reader["dataSource"].readIfPresent(with: BedrockAgentClientTypes.DataSource.read(from:))
        return value
    }
}

extension CreateFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFlowOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customerEncryptionKeyArn = try reader["customerEncryptionKeyArn"].readIfPresent()
        value.definition = try reader["definition"].readIfPresent(with: BedrockAgentClientTypes.FlowDefinition.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.executionRoleArn = try reader["executionRoleArn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension CreateFlowAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFlowAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFlowAliasOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.flowId = try reader["flowId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.routingConfiguration = try reader["routingConfiguration"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CreateFlowVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFlowVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFlowVersionOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customerEncryptionKeyArn = try reader["customerEncryptionKeyArn"].readIfPresent()
        value.definition = try reader["definition"].readIfPresent(with: BedrockAgentClientTypes.FlowDefinition.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.executionRoleArn = try reader["executionRoleArn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension CreateKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateKnowledgeBaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateKnowledgeBaseOutput()
        value.knowledgeBase = try reader["knowledgeBase"].readIfPresent(with: BedrockAgentClientTypes.KnowledgeBase.read(from:))
        return value
    }
}

extension CreatePromptOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePromptOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePromptOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customerEncryptionKeyArn = try reader["customerEncryptionKeyArn"].readIfPresent()
        value.defaultVariant = try reader["defaultVariant"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.variants = try reader["variants"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.PromptVariant.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension CreatePromptVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePromptVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePromptVersionOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customerEncryptionKeyArn = try reader["customerEncryptionKeyArn"].readIfPresent()
        value.defaultVariant = try reader["defaultVariant"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.variants = try reader["variants"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.PromptVariant.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteAgentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAgentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAgentOutput()
        value.agentId = try reader["agentId"].readIfPresent() ?? ""
        value.agentStatus = try reader["agentStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteAgentActionGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAgentActionGroupOutput {
        return DeleteAgentActionGroupOutput()
    }
}

extension DeleteAgentAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAgentAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAgentAliasOutput()
        value.agentAliasId = try reader["agentAliasId"].readIfPresent() ?? ""
        value.agentAliasStatus = try reader["agentAliasStatus"].readIfPresent() ?? .sdkUnknown("")
        value.agentId = try reader["agentId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteAgentVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAgentVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAgentVersionOutput()
        value.agentId = try reader["agentId"].readIfPresent() ?? ""
        value.agentStatus = try reader["agentStatus"].readIfPresent() ?? .sdkUnknown("")
        value.agentVersion = try reader["agentVersion"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDataSourceOutput()
        value.dataSourceId = try reader["dataSourceId"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteFlowOutput()
        value.id = try reader["id"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteFlowAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFlowAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteFlowAliasOutput()
        value.flowId = try reader["flowId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteFlowVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFlowVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteFlowVersionOutput()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteKnowledgeBaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteKnowledgeBaseOutput()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeletePromptOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePromptOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeletePromptOutput()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension DisassociateAgentKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateAgentKnowledgeBaseOutput {
        return DisassociateAgentKnowledgeBaseOutput()
    }
}

extension GetAgentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAgentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAgentOutput()
        value.agent = try reader["agent"].readIfPresent(with: BedrockAgentClientTypes.Agent.read(from:))
        return value
    }
}

extension GetAgentActionGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAgentActionGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAgentActionGroupOutput()
        value.agentActionGroup = try reader["agentActionGroup"].readIfPresent(with: BedrockAgentClientTypes.AgentActionGroup.read(from:))
        return value
    }
}

extension GetAgentAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAgentAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAgentAliasOutput()
        value.agentAlias = try reader["agentAlias"].readIfPresent(with: BedrockAgentClientTypes.AgentAlias.read(from:))
        return value
    }
}

extension GetAgentKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAgentKnowledgeBaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAgentKnowledgeBaseOutput()
        value.agentKnowledgeBase = try reader["agentKnowledgeBase"].readIfPresent(with: BedrockAgentClientTypes.AgentKnowledgeBase.read(from:))
        return value
    }
}

extension GetAgentVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAgentVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAgentVersionOutput()
        value.agentVersion = try reader["agentVersion"].readIfPresent(with: BedrockAgentClientTypes.AgentVersion.read(from:))
        return value
    }
}

extension GetDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataSourceOutput()
        value.dataSource = try reader["dataSource"].readIfPresent(with: BedrockAgentClientTypes.DataSource.read(from:))
        return value
    }
}

extension GetFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFlowOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customerEncryptionKeyArn = try reader["customerEncryptionKeyArn"].readIfPresent()
        value.definition = try reader["definition"].readIfPresent(with: BedrockAgentClientTypes.FlowDefinition.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.executionRoleArn = try reader["executionRoleArn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.validations = try reader["validations"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.FlowValidation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension GetFlowAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFlowAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFlowAliasOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.flowId = try reader["flowId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.routingConfiguration = try reader["routingConfiguration"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetFlowVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFlowVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFlowVersionOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customerEncryptionKeyArn = try reader["customerEncryptionKeyArn"].readIfPresent()
        value.definition = try reader["definition"].readIfPresent(with: BedrockAgentClientTypes.FlowDefinition.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.executionRoleArn = try reader["executionRoleArn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension GetIngestionJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIngestionJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIngestionJobOutput()
        value.ingestionJob = try reader["ingestionJob"].readIfPresent(with: BedrockAgentClientTypes.IngestionJob.read(from:))
        return value
    }
}

extension GetKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetKnowledgeBaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetKnowledgeBaseOutput()
        value.knowledgeBase = try reader["knowledgeBase"].readIfPresent(with: BedrockAgentClientTypes.KnowledgeBase.read(from:))
        return value
    }
}

extension GetPromptOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPromptOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPromptOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customerEncryptionKeyArn = try reader["customerEncryptionKeyArn"].readIfPresent()
        value.defaultVariant = try reader["defaultVariant"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.variants = try reader["variants"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.PromptVariant.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension ListAgentActionGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAgentActionGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAgentActionGroupsOutput()
        value.actionGroupSummaries = try reader["actionGroupSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.ActionGroupSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAgentAliasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAgentAliasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAgentAliasesOutput()
        value.agentAliasSummaries = try reader["agentAliasSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.AgentAliasSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAgentKnowledgeBasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAgentKnowledgeBasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAgentKnowledgeBasesOutput()
        value.agentKnowledgeBaseSummaries = try reader["agentKnowledgeBaseSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.AgentKnowledgeBaseSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAgentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAgentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAgentsOutput()
        value.agentSummaries = try reader["agentSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.AgentSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAgentVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAgentVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAgentVersionsOutput()
        value.agentVersionSummaries = try reader["agentVersionSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.AgentVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDataSourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataSourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataSourcesOutput()
        value.dataSourceSummaries = try reader["dataSourceSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.DataSourceSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFlowAliasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFlowAliasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFlowAliasesOutput()
        value.flowAliasSummaries = try reader["flowAliasSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.FlowAliasSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFlowsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFlowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFlowsOutput()
        value.flowSummaries = try reader["flowSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.FlowSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFlowVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFlowVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFlowVersionsOutput()
        value.flowVersionSummaries = try reader["flowVersionSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.FlowVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListIngestionJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIngestionJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIngestionJobsOutput()
        value.ingestionJobSummaries = try reader["ingestionJobSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.IngestionJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListKnowledgeBasesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListKnowledgeBasesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListKnowledgeBasesOutput()
        value.knowledgeBaseSummaries = try reader["knowledgeBaseSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.KnowledgeBaseSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListPromptsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPromptsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPromptsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.promptSummaries = try reader["promptSummaries"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.PromptSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PrepareAgentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PrepareAgentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PrepareAgentOutput()
        value.agentId = try reader["agentId"].readIfPresent() ?? ""
        value.agentStatus = try reader["agentStatus"].readIfPresent() ?? .sdkUnknown("")
        value.agentVersion = try reader["agentVersion"].readIfPresent() ?? ""
        value.preparedAt = try reader["preparedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension PrepareFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PrepareFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PrepareFlowOutput()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension StartIngestionJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartIngestionJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartIngestionJobOutput()
        value.ingestionJob = try reader["ingestionJob"].readIfPresent(with: BedrockAgentClientTypes.IngestionJob.read(from:))
        return value
    }
}

extension StopIngestionJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopIngestionJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopIngestionJobOutput()
        value.ingestionJob = try reader["ingestionJob"].readIfPresent(with: BedrockAgentClientTypes.IngestionJob.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAgentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAgentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAgentOutput()
        value.agent = try reader["agent"].readIfPresent(with: BedrockAgentClientTypes.Agent.read(from:))
        return value
    }
}

extension UpdateAgentActionGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAgentActionGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAgentActionGroupOutput()
        value.agentActionGroup = try reader["agentActionGroup"].readIfPresent(with: BedrockAgentClientTypes.AgentActionGroup.read(from:))
        return value
    }
}

extension UpdateAgentAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAgentAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAgentAliasOutput()
        value.agentAlias = try reader["agentAlias"].readIfPresent(with: BedrockAgentClientTypes.AgentAlias.read(from:))
        return value
    }
}

extension UpdateAgentKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAgentKnowledgeBaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAgentKnowledgeBaseOutput()
        value.agentKnowledgeBase = try reader["agentKnowledgeBase"].readIfPresent(with: BedrockAgentClientTypes.AgentKnowledgeBase.read(from:))
        return value
    }
}

extension UpdateDataSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDataSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDataSourceOutput()
        value.dataSource = try reader["dataSource"].readIfPresent(with: BedrockAgentClientTypes.DataSource.read(from:))
        return value
    }
}

extension UpdateFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFlowOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customerEncryptionKeyArn = try reader["customerEncryptionKeyArn"].readIfPresent()
        value.definition = try reader["definition"].readIfPresent(with: BedrockAgentClientTypes.FlowDefinition.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.executionRoleArn = try reader["executionRoleArn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateFlowAliasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFlowAliasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFlowAliasOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.flowId = try reader["flowId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.routingConfiguration = try reader["routingConfiguration"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension UpdateKnowledgeBaseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateKnowledgeBaseOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateKnowledgeBaseOutput()
        value.knowledgeBase = try reader["knowledgeBase"].readIfPresent(with: BedrockAgentClientTypes.KnowledgeBase.read(from:))
        return value
    }
}

extension UpdatePromptOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePromptOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePromptOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customerEncryptionKeyArn = try reader["customerEncryptionKeyArn"].readIfPresent()
        value.defaultVariant = try reader["defaultVariant"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.variants = try reader["variants"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.PromptVariant.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension ValidateFlowDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ValidateFlowDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ValidateFlowDefinitionOutput()
        value.validations = try reader["validations"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.FlowValidation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

enum AssociateAgentKnowledgeBaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAgentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAgentActionGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAgentAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFlowAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFlowVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateKnowledgeBaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePromptOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePromptVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAgentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAgentActionGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAgentAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAgentVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFlowAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFlowVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteKnowledgeBaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePromptOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateAgentKnowledgeBaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAgentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAgentActionGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAgentAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAgentKnowledgeBaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAgentVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFlowAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFlowVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIngestionJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetKnowledgeBaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPromptOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAgentActionGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAgentAliasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAgentKnowledgeBasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAgentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAgentVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataSourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFlowAliasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFlowsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFlowVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIngestionJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListKnowledgeBasesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPromptsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PrepareAgentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PrepareFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartIngestionJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopIngestionJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAgentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAgentActionGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAgentAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAgentKnowledgeBaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDataSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFlowAliasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateKnowledgeBaseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePromptOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ValidateFlowDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BedrockAgentClientTypes.AgentKnowledgeBase {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentKnowledgeBase {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentKnowledgeBase()
        value.agentId = try reader["agentId"].readIfPresent() ?? ""
        value.agentVersion = try reader["agentVersion"].readIfPresent() ?? ""
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.knowledgeBaseState = try reader["knowledgeBaseState"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockAgentClientTypes.Agent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.Agent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.Agent()
        value.agentId = try reader["agentId"].readIfPresent() ?? ""
        value.agentName = try reader["agentName"].readIfPresent() ?? ""
        value.agentArn = try reader["agentArn"].readIfPresent() ?? ""
        value.agentVersion = try reader["agentVersion"].readIfPresent() ?? ""
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.instruction = try reader["instruction"].readIfPresent()
        value.agentStatus = try reader["agentStatus"].readIfPresent() ?? .sdkUnknown("")
        value.foundationModel = try reader["foundationModel"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.idleSessionTTLInSeconds = try reader["idleSessionTTLInSeconds"].readIfPresent() ?? 0
        value.agentResourceRoleArn = try reader["agentResourceRoleArn"].readIfPresent() ?? ""
        value.customerEncryptionKeyArn = try reader["customerEncryptionKeyArn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.preparedAt = try reader["preparedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.recommendedActions = try reader["recommendedActions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.promptOverrideConfiguration = try reader["promptOverrideConfiguration"].readIfPresent(with: BedrockAgentClientTypes.PromptOverrideConfiguration.read(from:))
        value.guardrailConfiguration = try reader["guardrailConfiguration"].readIfPresent(with: BedrockAgentClientTypes.GuardrailConfiguration.read(from:))
        value.memoryConfiguration = try reader["memoryConfiguration"].readIfPresent(with: BedrockAgentClientTypes.MemoryConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.MemoryConfiguration {

    static func write(value: BedrockAgentClientTypes.MemoryConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabledMemoryTypes"].writeList(value.enabledMemoryTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockAgentClientTypes.MemoryType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["storageDays"].write(value.storageDays)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.MemoryConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.MemoryConfiguration()
        value.enabledMemoryTypes = try reader["enabledMemoryTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockAgentClientTypes.MemoryType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.storageDays = try reader["storageDays"].readIfPresent() ?? 30
        return value
    }
}

extension BedrockAgentClientTypes.GuardrailConfiguration {

    static func write(value: BedrockAgentClientTypes.GuardrailConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["guardrailIdentifier"].write(value.guardrailIdentifier)
        try writer["guardrailVersion"].write(value.guardrailVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.GuardrailConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.GuardrailConfiguration()
        value.guardrailIdentifier = try reader["guardrailIdentifier"].readIfPresent()
        value.guardrailVersion = try reader["guardrailVersion"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes.PromptOverrideConfiguration {

    static func write(value: BedrockAgentClientTypes.PromptOverrideConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["overrideLambda"].write(value.overrideLambda)
        try writer["promptConfigurations"].writeList(value.promptConfigurations, memberWritingClosure: BedrockAgentClientTypes.PromptConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PromptOverrideConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.PromptOverrideConfiguration()
        value.promptConfigurations = try reader["promptConfigurations"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.PromptConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.overrideLambda = try reader["overrideLambda"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes.PromptConfiguration {

    static func write(value: BedrockAgentClientTypes.PromptConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["basePromptTemplate"].write(value.basePromptTemplate)
        try writer["inferenceConfiguration"].write(value.inferenceConfiguration, with: BedrockAgentClientTypes.InferenceConfiguration.write(value:to:))
        try writer["parserMode"].write(value.parserMode)
        try writer["promptCreationMode"].write(value.promptCreationMode)
        try writer["promptState"].write(value.promptState)
        try writer["promptType"].write(value.promptType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PromptConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.PromptConfiguration()
        value.promptType = try reader["promptType"].readIfPresent()
        value.promptCreationMode = try reader["promptCreationMode"].readIfPresent()
        value.promptState = try reader["promptState"].readIfPresent()
        value.basePromptTemplate = try reader["basePromptTemplate"].readIfPresent()
        value.inferenceConfiguration = try reader["inferenceConfiguration"].readIfPresent(with: BedrockAgentClientTypes.InferenceConfiguration.read(from:))
        value.parserMode = try reader["parserMode"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes.InferenceConfiguration {

    static func write(value: BedrockAgentClientTypes.InferenceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maximumLength"].write(value.maximumLength)
        try writer["stopSequences"].writeList(value.stopSequences, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["temperature"].write(value.temperature)
        try writer["topK"].write(value.topk)
        try writer["topP"].write(value.topp)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.InferenceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.InferenceConfiguration()
        value.temperature = try reader["temperature"].readIfPresent()
        value.topp = try reader["topP"].readIfPresent()
        value.topk = try reader["topK"].readIfPresent()
        value.maximumLength = try reader["maximumLength"].readIfPresent()
        value.stopSequences = try reader["stopSequences"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentClientTypes.AgentActionGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentActionGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentActionGroup()
        value.agentId = try reader["agentId"].readIfPresent() ?? ""
        value.agentVersion = try reader["agentVersion"].readIfPresent() ?? ""
        value.actionGroupId = try reader["actionGroupId"].readIfPresent() ?? ""
        value.actionGroupName = try reader["actionGroupName"].readIfPresent() ?? ""
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.parentActionSignature = try reader["parentActionSignature"].readIfPresent()
        value.actionGroupExecutor = try reader["actionGroupExecutor"].readIfPresent(with: BedrockAgentClientTypes.ActionGroupExecutor.read(from:))
        value.apiSchema = try reader["apiSchema"].readIfPresent(with: BedrockAgentClientTypes.APISchema.read(from:))
        value.functionSchema = try reader["functionSchema"].readIfPresent(with: BedrockAgentClientTypes.FunctionSchema.read(from:))
        value.actionGroupState = try reader["actionGroupState"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockAgentClientTypes.FunctionSchema {

    static func write(value: BedrockAgentClientTypes.FunctionSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .functions(functions):
                try writer["functions"].writeList(functions, memberWritingClosure: BedrockAgentClientTypes.Function.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FunctionSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "functions":
                return .functions(try reader["functions"].readList(memberReadingClosure: BedrockAgentClientTypes.Function.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes.Function {

    static func write(value: BedrockAgentClientTypes.Function?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: BedrockAgentClientTypes.ParameterDetail.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["requireConfirmation"].write(value.requireConfirmation)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.Function {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.Function()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: BedrockAgentClientTypes.ParameterDetail.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.requireConfirmation = try reader["requireConfirmation"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes.ParameterDetail {

    static func write(value: BedrockAgentClientTypes.ParameterDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["required"].write(value.`required`)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ParameterDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.ParameterDetail()
        value.description = try reader["description"].readIfPresent()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.`required` = try reader["required"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes.APISchema {

    static func write(value: BedrockAgentClientTypes.APISchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .payload(payload):
                try writer["payload"].write(payload)
            case let .s3(s3):
                try writer["s3"].write(s3, with: BedrockAgentClientTypes.S3Identifier.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.APISchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3":
                return .s3(try reader["s3"].read(with: BedrockAgentClientTypes.S3Identifier.read(from:)))
            case "payload":
                return .payload(try reader["payload"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes.S3Identifier {

    static func write(value: BedrockAgentClientTypes.S3Identifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3BucketName"].write(value.s3BucketName)
        try writer["s3ObjectKey"].write(value.s3ObjectKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.S3Identifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.S3Identifier()
        value.s3BucketName = try reader["s3BucketName"].readIfPresent()
        value.s3ObjectKey = try reader["s3ObjectKey"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes.ActionGroupExecutor {

    static func write(value: BedrockAgentClientTypes.ActionGroupExecutor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .customcontrol(customcontrol):
                try writer["customControl"].write(customcontrol)
            case let .lambda(lambda):
                try writer["lambda"].write(lambda)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ActionGroupExecutor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "lambda":
                return .lambda(try reader["lambda"].read())
            case "customControl":
                return .customcontrol(try reader["customControl"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes.AgentAlias {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentAlias {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentAlias()
        value.agentId = try reader["agentId"].readIfPresent() ?? ""
        value.agentAliasId = try reader["agentAliasId"].readIfPresent() ?? ""
        value.agentAliasName = try reader["agentAliasName"].readIfPresent() ?? ""
        value.agentAliasArn = try reader["agentAliasArn"].readIfPresent() ?? ""
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.routingConfiguration = try reader["routingConfiguration"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.agentAliasHistoryEvents = try reader["agentAliasHistoryEvents"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.AgentAliasHistoryEvent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.agentAliasStatus = try reader["agentAliasStatus"].readIfPresent() ?? .sdkUnknown("")
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentClientTypes.AgentAliasHistoryEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentAliasHistoryEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentAliasHistoryEvent()
        value.routingConfiguration = try reader["routingConfiguration"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.endDate = try reader["endDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.startDate = try reader["startDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem {

    static func write(value: BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentVersion"].write(value.agentVersion)
        try writer["provisionedThroughput"].write(value.provisionedThroughput)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem()
        value.agentVersion = try reader["agentVersion"].readIfPresent()
        value.provisionedThroughput = try reader["provisionedThroughput"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes.DataSource {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.DataSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.DataSource()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.dataSourceId = try reader["dataSourceId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.description = try reader["description"].readIfPresent()
        value.dataSourceConfiguration = try reader["dataSourceConfiguration"].readIfPresent(with: BedrockAgentClientTypes.DataSourceConfiguration.read(from:))
        value.serverSideEncryptionConfiguration = try reader["serverSideEncryptionConfiguration"].readIfPresent(with: BedrockAgentClientTypes.ServerSideEncryptionConfiguration.read(from:))
        value.vectorIngestionConfiguration = try reader["vectorIngestionConfiguration"].readIfPresent(with: BedrockAgentClientTypes.VectorIngestionConfiguration.read(from:))
        value.dataDeletionPolicy = try reader["dataDeletionPolicy"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentClientTypes.VectorIngestionConfiguration {

    static func write(value: BedrockAgentClientTypes.VectorIngestionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["chunkingConfiguration"].write(value.chunkingConfiguration, with: BedrockAgentClientTypes.ChunkingConfiguration.write(value:to:))
        try writer["customTransformationConfiguration"].write(value.customTransformationConfiguration, with: BedrockAgentClientTypes.CustomTransformationConfiguration.write(value:to:))
        try writer["parsingConfiguration"].write(value.parsingConfiguration, with: BedrockAgentClientTypes.ParsingConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.VectorIngestionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.VectorIngestionConfiguration()
        value.chunkingConfiguration = try reader["chunkingConfiguration"].readIfPresent(with: BedrockAgentClientTypes.ChunkingConfiguration.read(from:))
        value.customTransformationConfiguration = try reader["customTransformationConfiguration"].readIfPresent(with: BedrockAgentClientTypes.CustomTransformationConfiguration.read(from:))
        value.parsingConfiguration = try reader["parsingConfiguration"].readIfPresent(with: BedrockAgentClientTypes.ParsingConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.ParsingConfiguration {

    static func write(value: BedrockAgentClientTypes.ParsingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bedrockFoundationModelConfiguration"].write(value.bedrockFoundationModelConfiguration, with: BedrockAgentClientTypes.BedrockFoundationModelConfiguration.write(value:to:))
        try writer["parsingStrategy"].write(value.parsingStrategy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ParsingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.ParsingConfiguration()
        value.parsingStrategy = try reader["parsingStrategy"].readIfPresent() ?? .sdkUnknown("")
        value.bedrockFoundationModelConfiguration = try reader["bedrockFoundationModelConfiguration"].readIfPresent(with: BedrockAgentClientTypes.BedrockFoundationModelConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.BedrockFoundationModelConfiguration {

    static func write(value: BedrockAgentClientTypes.BedrockFoundationModelConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelArn"].write(value.modelArn)
        try writer["parsingPrompt"].write(value.parsingPrompt, with: BedrockAgentClientTypes.ParsingPrompt.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.BedrockFoundationModelConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.BedrockFoundationModelConfiguration()
        value.modelArn = try reader["modelArn"].readIfPresent() ?? ""
        value.parsingPrompt = try reader["parsingPrompt"].readIfPresent(with: BedrockAgentClientTypes.ParsingPrompt.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.ParsingPrompt {

    static func write(value: BedrockAgentClientTypes.ParsingPrompt?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["parsingPromptText"].write(value.parsingPromptText)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ParsingPrompt {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.ParsingPrompt()
        value.parsingPromptText = try reader["parsingPromptText"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.CustomTransformationConfiguration {

    static func write(value: BedrockAgentClientTypes.CustomTransformationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["intermediateStorage"].write(value.intermediateStorage, with: BedrockAgentClientTypes.IntermediateStorage.write(value:to:))
        try writer["transformations"].writeList(value.transformations, memberWritingClosure: BedrockAgentClientTypes.Transformation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.CustomTransformationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.CustomTransformationConfiguration()
        value.intermediateStorage = try reader["intermediateStorage"].readIfPresent(with: BedrockAgentClientTypes.IntermediateStorage.read(from:))
        value.transformations = try reader["transformations"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.Transformation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockAgentClientTypes.Transformation {

    static func write(value: BedrockAgentClientTypes.Transformation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["stepToApply"].write(value.stepToApply)
        try writer["transformationFunction"].write(value.transformationFunction, with: BedrockAgentClientTypes.TransformationFunction.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.Transformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.Transformation()
        value.transformationFunction = try reader["transformationFunction"].readIfPresent(with: BedrockAgentClientTypes.TransformationFunction.read(from:))
        value.stepToApply = try reader["stepToApply"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockAgentClientTypes.TransformationFunction {

    static func write(value: BedrockAgentClientTypes.TransformationFunction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["transformationLambdaConfiguration"].write(value.transformationLambdaConfiguration, with: BedrockAgentClientTypes.TransformationLambdaConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.TransformationFunction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.TransformationFunction()
        value.transformationLambdaConfiguration = try reader["transformationLambdaConfiguration"].readIfPresent(with: BedrockAgentClientTypes.TransformationLambdaConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.TransformationLambdaConfiguration {

    static func write(value: BedrockAgentClientTypes.TransformationLambdaConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["lambdaArn"].write(value.lambdaArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.TransformationLambdaConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.TransformationLambdaConfiguration()
        value.lambdaArn = try reader["lambdaArn"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.IntermediateStorage {

    static func write(value: BedrockAgentClientTypes.IntermediateStorage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Location"].write(value.s3Location, with: BedrockAgentClientTypes.S3Location.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.IntermediateStorage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.IntermediateStorage()
        value.s3Location = try reader["s3Location"].readIfPresent(with: BedrockAgentClientTypes.S3Location.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.S3Location {

    static func write(value: BedrockAgentClientTypes.S3Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["uri"].write(value.uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.S3Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.S3Location()
        value.uri = try reader["uri"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.ChunkingConfiguration {

    static func write(value: BedrockAgentClientTypes.ChunkingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["chunkingStrategy"].write(value.chunkingStrategy)
        try writer["fixedSizeChunkingConfiguration"].write(value.fixedSizeChunkingConfiguration, with: BedrockAgentClientTypes.FixedSizeChunkingConfiguration.write(value:to:))
        try writer["hierarchicalChunkingConfiguration"].write(value.hierarchicalChunkingConfiguration, with: BedrockAgentClientTypes.HierarchicalChunkingConfiguration.write(value:to:))
        try writer["semanticChunkingConfiguration"].write(value.semanticChunkingConfiguration, with: BedrockAgentClientTypes.SemanticChunkingConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ChunkingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.ChunkingConfiguration()
        value.chunkingStrategy = try reader["chunkingStrategy"].readIfPresent() ?? .sdkUnknown("")
        value.fixedSizeChunkingConfiguration = try reader["fixedSizeChunkingConfiguration"].readIfPresent(with: BedrockAgentClientTypes.FixedSizeChunkingConfiguration.read(from:))
        value.hierarchicalChunkingConfiguration = try reader["hierarchicalChunkingConfiguration"].readIfPresent(with: BedrockAgentClientTypes.HierarchicalChunkingConfiguration.read(from:))
        value.semanticChunkingConfiguration = try reader["semanticChunkingConfiguration"].readIfPresent(with: BedrockAgentClientTypes.SemanticChunkingConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.SemanticChunkingConfiguration {

    static func write(value: BedrockAgentClientTypes.SemanticChunkingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["breakpointPercentileThreshold"].write(value.breakpointPercentileThreshold)
        try writer["bufferSize"].write(value.bufferSize)
        try writer["maxTokens"].write(value.maxTokens)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.SemanticChunkingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.SemanticChunkingConfiguration()
        value.maxTokens = try reader["maxTokens"].readIfPresent() ?? 0
        value.bufferSize = try reader["bufferSize"].readIfPresent() ?? 0
        value.breakpointPercentileThreshold = try reader["breakpointPercentileThreshold"].readIfPresent() ?? 0
        return value
    }
}

extension BedrockAgentClientTypes.HierarchicalChunkingConfiguration {

    static func write(value: BedrockAgentClientTypes.HierarchicalChunkingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["levelConfigurations"].writeList(value.levelConfigurations, memberWritingClosure: BedrockAgentClientTypes.HierarchicalChunkingLevelConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["overlapTokens"].write(value.overlapTokens)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.HierarchicalChunkingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.HierarchicalChunkingConfiguration()
        value.levelConfigurations = try reader["levelConfigurations"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.HierarchicalChunkingLevelConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.overlapTokens = try reader["overlapTokens"].readIfPresent() ?? 0
        return value
    }
}

extension BedrockAgentClientTypes.HierarchicalChunkingLevelConfiguration {

    static func write(value: BedrockAgentClientTypes.HierarchicalChunkingLevelConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxTokens"].write(value.maxTokens)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.HierarchicalChunkingLevelConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.HierarchicalChunkingLevelConfiguration()
        value.maxTokens = try reader["maxTokens"].readIfPresent() ?? 0
        return value
    }
}

extension BedrockAgentClientTypes.FixedSizeChunkingConfiguration {

    static func write(value: BedrockAgentClientTypes.FixedSizeChunkingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxTokens"].write(value.maxTokens)
        try writer["overlapPercentage"].write(value.overlapPercentage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FixedSizeChunkingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.FixedSizeChunkingConfiguration()
        value.maxTokens = try reader["maxTokens"].readIfPresent() ?? 0
        value.overlapPercentage = try reader["overlapPercentage"].readIfPresent() ?? 0
        return value
    }
}

extension BedrockAgentClientTypes.ServerSideEncryptionConfiguration {

    static func write(value: BedrockAgentClientTypes.ServerSideEncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ServerSideEncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.ServerSideEncryptionConfiguration()
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes.DataSourceConfiguration {

    static func write(value: BedrockAgentClientTypes.DataSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["confluenceConfiguration"].write(value.confluenceConfiguration, with: BedrockAgentClientTypes.ConfluenceDataSourceConfiguration.write(value:to:))
        try writer["s3Configuration"].write(value.s3Configuration, with: BedrockAgentClientTypes.S3DataSourceConfiguration.write(value:to:))
        try writer["salesforceConfiguration"].write(value.salesforceConfiguration, with: BedrockAgentClientTypes.SalesforceDataSourceConfiguration.write(value:to:))
        try writer["sharePointConfiguration"].write(value.sharePointConfiguration, with: BedrockAgentClientTypes.SharePointDataSourceConfiguration.write(value:to:))
        try writer["type"].write(value.type)
        try writer["webConfiguration"].write(value.webConfiguration, with: BedrockAgentClientTypes.WebDataSourceConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.DataSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.DataSourceConfiguration()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.s3Configuration = try reader["s3Configuration"].readIfPresent(with: BedrockAgentClientTypes.S3DataSourceConfiguration.read(from:))
        value.webConfiguration = try reader["webConfiguration"].readIfPresent(with: BedrockAgentClientTypes.WebDataSourceConfiguration.read(from:))
        value.confluenceConfiguration = try reader["confluenceConfiguration"].readIfPresent(with: BedrockAgentClientTypes.ConfluenceDataSourceConfiguration.read(from:))
        value.salesforceConfiguration = try reader["salesforceConfiguration"].readIfPresent(with: BedrockAgentClientTypes.SalesforceDataSourceConfiguration.read(from:))
        value.sharePointConfiguration = try reader["sharePointConfiguration"].readIfPresent(with: BedrockAgentClientTypes.SharePointDataSourceConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.SharePointDataSourceConfiguration {

    static func write(value: BedrockAgentClientTypes.SharePointDataSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["crawlerConfiguration"].write(value.crawlerConfiguration, with: BedrockAgentClientTypes.SharePointCrawlerConfiguration.write(value:to:))
        try writer["sourceConfiguration"].write(value.sourceConfiguration, with: BedrockAgentClientTypes.SharePointSourceConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.SharePointDataSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.SharePointDataSourceConfiguration()
        value.sourceConfiguration = try reader["sourceConfiguration"].readIfPresent(with: BedrockAgentClientTypes.SharePointSourceConfiguration.read(from:))
        value.crawlerConfiguration = try reader["crawlerConfiguration"].readIfPresent(with: BedrockAgentClientTypes.SharePointCrawlerConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.SharePointCrawlerConfiguration {

    static func write(value: BedrockAgentClientTypes.SharePointCrawlerConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterConfiguration"].write(value.filterConfiguration, with: BedrockAgentClientTypes.CrawlFilterConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.SharePointCrawlerConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.SharePointCrawlerConfiguration()
        value.filterConfiguration = try reader["filterConfiguration"].readIfPresent(with: BedrockAgentClientTypes.CrawlFilterConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.CrawlFilterConfiguration {

    static func write(value: BedrockAgentClientTypes.CrawlFilterConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["patternObjectFilter"].write(value.patternObjectFilter, with: BedrockAgentClientTypes.PatternObjectFilterConfiguration.write(value:to:))
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.CrawlFilterConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.CrawlFilterConfiguration()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.patternObjectFilter = try reader["patternObjectFilter"].readIfPresent(with: BedrockAgentClientTypes.PatternObjectFilterConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.PatternObjectFilterConfiguration {

    static func write(value: BedrockAgentClientTypes.PatternObjectFilterConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: BedrockAgentClientTypes.PatternObjectFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PatternObjectFilterConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.PatternObjectFilterConfiguration()
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.PatternObjectFilter.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockAgentClientTypes.PatternObjectFilter {

    static func write(value: BedrockAgentClientTypes.PatternObjectFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["exclusionFilters"].writeList(value.exclusionFilters, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["inclusionFilters"].writeList(value.inclusionFilters, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["objectType"].write(value.objectType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PatternObjectFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.PatternObjectFilter()
        value.objectType = try reader["objectType"].readIfPresent() ?? ""
        value.inclusionFilters = try reader["inclusionFilters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.exclusionFilters = try reader["exclusionFilters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentClientTypes.SharePointSourceConfiguration {

    static func write(value: BedrockAgentClientTypes.SharePointSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authType"].write(value.authType)
        try writer["credentialsSecretArn"].write(value.credentialsSecretArn)
        try writer["domain"].write(value.domain)
        try writer["hostType"].write(value.hostType)
        try writer["siteUrls"].writeList(value.siteUrls, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tenantId"].write(value.tenantId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.SharePointSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.SharePointSourceConfiguration()
        value.tenantId = try reader["tenantId"].readIfPresent()
        value.domain = try reader["domain"].readIfPresent() ?? ""
        value.siteUrls = try reader["siteUrls"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.hostType = try reader["hostType"].readIfPresent() ?? .sdkUnknown("")
        value.authType = try reader["authType"].readIfPresent() ?? .sdkUnknown("")
        value.credentialsSecretArn = try reader["credentialsSecretArn"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.SalesforceDataSourceConfiguration {

    static func write(value: BedrockAgentClientTypes.SalesforceDataSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["crawlerConfiguration"].write(value.crawlerConfiguration, with: BedrockAgentClientTypes.SalesforceCrawlerConfiguration.write(value:to:))
        try writer["sourceConfiguration"].write(value.sourceConfiguration, with: BedrockAgentClientTypes.SalesforceSourceConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.SalesforceDataSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.SalesforceDataSourceConfiguration()
        value.sourceConfiguration = try reader["sourceConfiguration"].readIfPresent(with: BedrockAgentClientTypes.SalesforceSourceConfiguration.read(from:))
        value.crawlerConfiguration = try reader["crawlerConfiguration"].readIfPresent(with: BedrockAgentClientTypes.SalesforceCrawlerConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.SalesforceCrawlerConfiguration {

    static func write(value: BedrockAgentClientTypes.SalesforceCrawlerConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterConfiguration"].write(value.filterConfiguration, with: BedrockAgentClientTypes.CrawlFilterConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.SalesforceCrawlerConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.SalesforceCrawlerConfiguration()
        value.filterConfiguration = try reader["filterConfiguration"].readIfPresent(with: BedrockAgentClientTypes.CrawlFilterConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.SalesforceSourceConfiguration {

    static func write(value: BedrockAgentClientTypes.SalesforceSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authType"].write(value.authType)
        try writer["credentialsSecretArn"].write(value.credentialsSecretArn)
        try writer["hostUrl"].write(value.hostUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.SalesforceSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.SalesforceSourceConfiguration()
        value.hostUrl = try reader["hostUrl"].readIfPresent() ?? ""
        value.authType = try reader["authType"].readIfPresent() ?? .sdkUnknown("")
        value.credentialsSecretArn = try reader["credentialsSecretArn"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.ConfluenceDataSourceConfiguration {

    static func write(value: BedrockAgentClientTypes.ConfluenceDataSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["crawlerConfiguration"].write(value.crawlerConfiguration, with: BedrockAgentClientTypes.ConfluenceCrawlerConfiguration.write(value:to:))
        try writer["sourceConfiguration"].write(value.sourceConfiguration, with: BedrockAgentClientTypes.ConfluenceSourceConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ConfluenceDataSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.ConfluenceDataSourceConfiguration()
        value.sourceConfiguration = try reader["sourceConfiguration"].readIfPresent(with: BedrockAgentClientTypes.ConfluenceSourceConfiguration.read(from:))
        value.crawlerConfiguration = try reader["crawlerConfiguration"].readIfPresent(with: BedrockAgentClientTypes.ConfluenceCrawlerConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.ConfluenceCrawlerConfiguration {

    static func write(value: BedrockAgentClientTypes.ConfluenceCrawlerConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterConfiguration"].write(value.filterConfiguration, with: BedrockAgentClientTypes.CrawlFilterConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ConfluenceCrawlerConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.ConfluenceCrawlerConfiguration()
        value.filterConfiguration = try reader["filterConfiguration"].readIfPresent(with: BedrockAgentClientTypes.CrawlFilterConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.ConfluenceSourceConfiguration {

    static func write(value: BedrockAgentClientTypes.ConfluenceSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authType"].write(value.authType)
        try writer["credentialsSecretArn"].write(value.credentialsSecretArn)
        try writer["hostType"].write(value.hostType)
        try writer["hostUrl"].write(value.hostUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ConfluenceSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.ConfluenceSourceConfiguration()
        value.hostUrl = try reader["hostUrl"].readIfPresent() ?? ""
        value.hostType = try reader["hostType"].readIfPresent() ?? .sdkUnknown("")
        value.authType = try reader["authType"].readIfPresent() ?? .sdkUnknown("")
        value.credentialsSecretArn = try reader["credentialsSecretArn"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.WebDataSourceConfiguration {

    static func write(value: BedrockAgentClientTypes.WebDataSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["crawlerConfiguration"].write(value.crawlerConfiguration, with: BedrockAgentClientTypes.WebCrawlerConfiguration.write(value:to:))
        try writer["sourceConfiguration"].write(value.sourceConfiguration, with: BedrockAgentClientTypes.WebSourceConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.WebDataSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.WebDataSourceConfiguration()
        value.sourceConfiguration = try reader["sourceConfiguration"].readIfPresent(with: BedrockAgentClientTypes.WebSourceConfiguration.read(from:))
        value.crawlerConfiguration = try reader["crawlerConfiguration"].readIfPresent(with: BedrockAgentClientTypes.WebCrawlerConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.WebCrawlerConfiguration {

    static func write(value: BedrockAgentClientTypes.WebCrawlerConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["crawlerLimits"].write(value.crawlerLimits, with: BedrockAgentClientTypes.WebCrawlerLimits.write(value:to:))
        try writer["exclusionFilters"].writeList(value.exclusionFilters, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["inclusionFilters"].writeList(value.inclusionFilters, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scope"].write(value.scope)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.WebCrawlerConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.WebCrawlerConfiguration()
        value.crawlerLimits = try reader["crawlerLimits"].readIfPresent(with: BedrockAgentClientTypes.WebCrawlerLimits.read(from:))
        value.inclusionFilters = try reader["inclusionFilters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.exclusionFilters = try reader["exclusionFilters"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.scope = try reader["scope"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes.WebCrawlerLimits {

    static func write(value: BedrockAgentClientTypes.WebCrawlerLimits?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["rateLimit"].write(value.rateLimit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.WebCrawlerLimits {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.WebCrawlerLimits()
        value.rateLimit = try reader["rateLimit"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes.WebSourceConfiguration {

    static func write(value: BedrockAgentClientTypes.WebSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["urlConfiguration"].write(value.urlConfiguration, with: BedrockAgentClientTypes.UrlConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.WebSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.WebSourceConfiguration()
        value.urlConfiguration = try reader["urlConfiguration"].readIfPresent(with: BedrockAgentClientTypes.UrlConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.UrlConfiguration {

    static func write(value: BedrockAgentClientTypes.UrlConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["seedUrls"].writeList(value.seedUrls, memberWritingClosure: BedrockAgentClientTypes.SeedUrl.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.UrlConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.UrlConfiguration()
        value.seedUrls = try reader["seedUrls"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.SeedUrl.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentClientTypes.SeedUrl {

    static func write(value: BedrockAgentClientTypes.SeedUrl?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["url"].write(value.url)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.SeedUrl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.SeedUrl()
        value.url = try reader["url"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes.S3DataSourceConfiguration {

    static func write(value: BedrockAgentClientTypes.S3DataSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketArn"].write(value.bucketArn)
        try writer["bucketOwnerAccountId"].write(value.bucketOwnerAccountId)
        try writer["inclusionPrefixes"].writeList(value.inclusionPrefixes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.S3DataSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.S3DataSourceConfiguration()
        value.bucketArn = try reader["bucketArn"].readIfPresent() ?? ""
        value.inclusionPrefixes = try reader["inclusionPrefixes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.bucketOwnerAccountId = try reader["bucketOwnerAccountId"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes.FlowDefinition {

    static func write(value: BedrockAgentClientTypes.FlowDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connections"].writeList(value.connections, memberWritingClosure: BedrockAgentClientTypes.FlowConnection.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["nodes"].writeList(value.nodes, memberWritingClosure: BedrockAgentClientTypes.FlowNode.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FlowDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.FlowDefinition()
        value.nodes = try reader["nodes"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.FlowNode.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.connections = try reader["connections"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.FlowConnection.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentClientTypes.FlowConnection {

    static func write(value: BedrockAgentClientTypes.FlowConnection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].write(value.configuration, with: BedrockAgentClientTypes.FlowConnectionConfiguration.write(value:to:))
        try writer["name"].write(value.name)
        try writer["source"].write(value.source)
        try writer["target"].write(value.target)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FlowConnection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.FlowConnection()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.source = try reader["source"].readIfPresent() ?? ""
        value.target = try reader["target"].readIfPresent() ?? ""
        value.configuration = try reader["configuration"].readIfPresent(with: BedrockAgentClientTypes.FlowConnectionConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.FlowConnectionConfiguration {

    static func write(value: BedrockAgentClientTypes.FlowConnectionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .conditional(conditional):
                try writer["conditional"].write(conditional, with: BedrockAgentClientTypes.FlowConditionalConnectionConfiguration.write(value:to:))
            case let .data(data):
                try writer["data"].write(data, with: BedrockAgentClientTypes.FlowDataConnectionConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FlowConnectionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "data":
                return .data(try reader["data"].read(with: BedrockAgentClientTypes.FlowDataConnectionConfiguration.read(from:)))
            case "conditional":
                return .conditional(try reader["conditional"].read(with: BedrockAgentClientTypes.FlowConditionalConnectionConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes.FlowConditionalConnectionConfiguration {

    static func write(value: BedrockAgentClientTypes.FlowConditionalConnectionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["condition"].write(value.condition)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FlowConditionalConnectionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.FlowConditionalConnectionConfiguration()
        value.condition = try reader["condition"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.FlowDataConnectionConfiguration {

    static func write(value: BedrockAgentClientTypes.FlowDataConnectionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sourceOutput"].write(value.sourceOutput)
        try writer["targetInput"].write(value.targetInput)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FlowDataConnectionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.FlowDataConnectionConfiguration()
        value.sourceOutput = try reader["sourceOutput"].readIfPresent() ?? ""
        value.targetInput = try reader["targetInput"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.FlowNode {

    static func write(value: BedrockAgentClientTypes.FlowNode?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].write(value.configuration, with: BedrockAgentClientTypes.FlowNodeConfiguration.write(value:to:))
        try writer["inputs"].writeList(value.inputs, memberWritingClosure: BedrockAgentClientTypes.FlowNodeInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["outputs"].writeList(value.outputs, memberWritingClosure: BedrockAgentClientTypes.FlowNodeOutput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FlowNode {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.FlowNode()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.configuration = try reader["configuration"].readIfPresent(with: BedrockAgentClientTypes.FlowNodeConfiguration.read(from:))
        value.inputs = try reader["inputs"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.FlowNodeInput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.outputs = try reader["outputs"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.FlowNodeOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentClientTypes.FlowNodeOutput {

    static func write(value: BedrockAgentClientTypes.FlowNodeOutput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FlowNodeOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.FlowNodeOutput()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockAgentClientTypes.FlowNodeInput {

    static func write(value: BedrockAgentClientTypes.FlowNodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["expression"].write(value.expression)
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FlowNodeInput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.FlowNodeInput()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.expression = try reader["expression"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.FlowNodeConfiguration {

    static func write(value: BedrockAgentClientTypes.FlowNodeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .agent(agent):
                try writer["agent"].write(agent, with: BedrockAgentClientTypes.AgentFlowNodeConfiguration.write(value:to:))
            case let .collector(collector):
                try writer["collector"].write(collector, with: BedrockAgentClientTypes.CollectorFlowNodeConfiguration.write(value:to:))
            case let .condition(condition):
                try writer["condition"].write(condition, with: BedrockAgentClientTypes.ConditionFlowNodeConfiguration.write(value:to:))
            case let .input(input):
                try writer["input"].write(input, with: BedrockAgentClientTypes.InputFlowNodeConfiguration.write(value:to:))
            case let .iterator(iterator):
                try writer["iterator"].write(iterator, with: BedrockAgentClientTypes.IteratorFlowNodeConfiguration.write(value:to:))
            case let .knowledgebase(knowledgebase):
                try writer["knowledgeBase"].write(knowledgebase, with: BedrockAgentClientTypes.KnowledgeBaseFlowNodeConfiguration.write(value:to:))
            case let .lambdafunction(lambdafunction):
                try writer["lambdaFunction"].write(lambdafunction, with: BedrockAgentClientTypes.LambdaFunctionFlowNodeConfiguration.write(value:to:))
            case let .lex(lex):
                try writer["lex"].write(lex, with: BedrockAgentClientTypes.LexFlowNodeConfiguration.write(value:to:))
            case let .output(output):
                try writer["output"].write(output, with: BedrockAgentClientTypes.OutputFlowNodeConfiguration.write(value:to:))
            case let .prompt(prompt):
                try writer["prompt"].write(prompt, with: BedrockAgentClientTypes.PromptFlowNodeConfiguration.write(value:to:))
            case let .retrieval(retrieval):
                try writer["retrieval"].write(retrieval, with: BedrockAgentClientTypes.RetrievalFlowNodeConfiguration.write(value:to:))
            case let .storage(storage):
                try writer["storage"].write(storage, with: BedrockAgentClientTypes.StorageFlowNodeConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FlowNodeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "input":
                return .input(try reader["input"].read(with: BedrockAgentClientTypes.InputFlowNodeConfiguration.read(from:)))
            case "output":
                return .output(try reader["output"].read(with: BedrockAgentClientTypes.OutputFlowNodeConfiguration.read(from:)))
            case "knowledgeBase":
                return .knowledgebase(try reader["knowledgeBase"].read(with: BedrockAgentClientTypes.KnowledgeBaseFlowNodeConfiguration.read(from:)))
            case "condition":
                return .condition(try reader["condition"].read(with: BedrockAgentClientTypes.ConditionFlowNodeConfiguration.read(from:)))
            case "lex":
                return .lex(try reader["lex"].read(with: BedrockAgentClientTypes.LexFlowNodeConfiguration.read(from:)))
            case "prompt":
                return .prompt(try reader["prompt"].read(with: BedrockAgentClientTypes.PromptFlowNodeConfiguration.read(from:)))
            case "lambdaFunction":
                return .lambdafunction(try reader["lambdaFunction"].read(with: BedrockAgentClientTypes.LambdaFunctionFlowNodeConfiguration.read(from:)))
            case "storage":
                return .storage(try reader["storage"].read(with: BedrockAgentClientTypes.StorageFlowNodeConfiguration.read(from:)))
            case "agent":
                return .agent(try reader["agent"].read(with: BedrockAgentClientTypes.AgentFlowNodeConfiguration.read(from:)))
            case "retrieval":
                return .retrieval(try reader["retrieval"].read(with: BedrockAgentClientTypes.RetrievalFlowNodeConfiguration.read(from:)))
            case "iterator":
                return .iterator(try reader["iterator"].read(with: BedrockAgentClientTypes.IteratorFlowNodeConfiguration.read(from:)))
            case "collector":
                return .collector(try reader["collector"].read(with: BedrockAgentClientTypes.CollectorFlowNodeConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes.CollectorFlowNodeConfiguration {

    static func write(value: BedrockAgentClientTypes.CollectorFlowNodeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.CollectorFlowNodeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return BedrockAgentClientTypes.CollectorFlowNodeConfiguration()
    }
}

extension BedrockAgentClientTypes.IteratorFlowNodeConfiguration {

    static func write(value: BedrockAgentClientTypes.IteratorFlowNodeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.IteratorFlowNodeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return BedrockAgentClientTypes.IteratorFlowNodeConfiguration()
    }
}

extension BedrockAgentClientTypes.RetrievalFlowNodeConfiguration {

    static func write(value: BedrockAgentClientTypes.RetrievalFlowNodeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["serviceConfiguration"].write(value.serviceConfiguration, with: BedrockAgentClientTypes.RetrievalFlowNodeServiceConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.RetrievalFlowNodeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.RetrievalFlowNodeConfiguration()
        value.serviceConfiguration = try reader["serviceConfiguration"].readIfPresent(with: BedrockAgentClientTypes.RetrievalFlowNodeServiceConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.RetrievalFlowNodeServiceConfiguration {

    static func write(value: BedrockAgentClientTypes.RetrievalFlowNodeServiceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3(s3):
                try writer["s3"].write(s3, with: BedrockAgentClientTypes.RetrievalFlowNodeS3Configuration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.RetrievalFlowNodeServiceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3":
                return .s3(try reader["s3"].read(with: BedrockAgentClientTypes.RetrievalFlowNodeS3Configuration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes.RetrievalFlowNodeS3Configuration {

    static func write(value: BedrockAgentClientTypes.RetrievalFlowNodeS3Configuration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.RetrievalFlowNodeS3Configuration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.RetrievalFlowNodeS3Configuration()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.AgentFlowNodeConfiguration {

    static func write(value: BedrockAgentClientTypes.AgentFlowNodeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentAliasArn"].write(value.agentAliasArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentFlowNodeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentFlowNodeConfiguration()
        value.agentAliasArn = try reader["agentAliasArn"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.StorageFlowNodeConfiguration {

    static func write(value: BedrockAgentClientTypes.StorageFlowNodeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["serviceConfiguration"].write(value.serviceConfiguration, with: BedrockAgentClientTypes.StorageFlowNodeServiceConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.StorageFlowNodeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.StorageFlowNodeConfiguration()
        value.serviceConfiguration = try reader["serviceConfiguration"].readIfPresent(with: BedrockAgentClientTypes.StorageFlowNodeServiceConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.StorageFlowNodeServiceConfiguration {

    static func write(value: BedrockAgentClientTypes.StorageFlowNodeServiceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3(s3):
                try writer["s3"].write(s3, with: BedrockAgentClientTypes.StorageFlowNodeS3Configuration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.StorageFlowNodeServiceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3":
                return .s3(try reader["s3"].read(with: BedrockAgentClientTypes.StorageFlowNodeS3Configuration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes.StorageFlowNodeS3Configuration {

    static func write(value: BedrockAgentClientTypes.StorageFlowNodeS3Configuration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.StorageFlowNodeS3Configuration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.StorageFlowNodeS3Configuration()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.LambdaFunctionFlowNodeConfiguration {

    static func write(value: BedrockAgentClientTypes.LambdaFunctionFlowNodeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["lambdaArn"].write(value.lambdaArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.LambdaFunctionFlowNodeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.LambdaFunctionFlowNodeConfiguration()
        value.lambdaArn = try reader["lambdaArn"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.PromptFlowNodeConfiguration {

    static func write(value: BedrockAgentClientTypes.PromptFlowNodeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["guardrailConfiguration"].write(value.guardrailConfiguration, with: BedrockAgentClientTypes.GuardrailConfiguration.write(value:to:))
        try writer["sourceConfiguration"].write(value.sourceConfiguration, with: BedrockAgentClientTypes.PromptFlowNodeSourceConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PromptFlowNodeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.PromptFlowNodeConfiguration()
        value.sourceConfiguration = try reader["sourceConfiguration"].readIfPresent(with: BedrockAgentClientTypes.PromptFlowNodeSourceConfiguration.read(from:))
        value.guardrailConfiguration = try reader["guardrailConfiguration"].readIfPresent(with: BedrockAgentClientTypes.GuardrailConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.PromptFlowNodeSourceConfiguration {

    static func write(value: BedrockAgentClientTypes.PromptFlowNodeSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .inline(inline):
                try writer["inline"].write(inline, with: BedrockAgentClientTypes.PromptFlowNodeInlineConfiguration.write(value:to:))
            case let .resource(resource):
                try writer["resource"].write(resource, with: BedrockAgentClientTypes.PromptFlowNodeResourceConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PromptFlowNodeSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "resource":
                return .resource(try reader["resource"].read(with: BedrockAgentClientTypes.PromptFlowNodeResourceConfiguration.read(from:)))
            case "inline":
                return .inline(try reader["inline"].read(with: BedrockAgentClientTypes.PromptFlowNodeInlineConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes.PromptFlowNodeInlineConfiguration {

    static func write(value: BedrockAgentClientTypes.PromptFlowNodeInlineConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalModelRequestFields"].write(value.additionalModelRequestFields)
        try writer["inferenceConfiguration"].write(value.inferenceConfiguration, with: BedrockAgentClientTypes.PromptInferenceConfiguration.write(value:to:))
        try writer["modelId"].write(value.modelId)
        try writer["templateConfiguration"].write(value.templateConfiguration, with: BedrockAgentClientTypes.PromptTemplateConfiguration.write(value:to:))
        try writer["templateType"].write(value.templateType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PromptFlowNodeInlineConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.PromptFlowNodeInlineConfiguration()
        value.templateType = try reader["templateType"].readIfPresent() ?? .sdkUnknown("")
        value.templateConfiguration = try reader["templateConfiguration"].readIfPresent(with: BedrockAgentClientTypes.PromptTemplateConfiguration.read(from:))
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.inferenceConfiguration = try reader["inferenceConfiguration"].readIfPresent(with: BedrockAgentClientTypes.PromptInferenceConfiguration.read(from:))
        value.additionalModelRequestFields = try reader["additionalModelRequestFields"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes.PromptInferenceConfiguration {

    static func write(value: BedrockAgentClientTypes.PromptInferenceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .text(text):
                try writer["text"].write(text, with: BedrockAgentClientTypes.PromptModelInferenceConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PromptInferenceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "text":
                return .text(try reader["text"].read(with: BedrockAgentClientTypes.PromptModelInferenceConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes.PromptModelInferenceConfiguration {

    static func write(value: BedrockAgentClientTypes.PromptModelInferenceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxTokens"].write(value.maxTokens)
        try writer["stopSequences"].writeList(value.stopSequences, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["temperature"].write(value.temperature)
        try writer["topP"].write(value.topp)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PromptModelInferenceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.PromptModelInferenceConfiguration()
        value.temperature = try reader["temperature"].readIfPresent()
        value.topp = try reader["topP"].readIfPresent()
        value.maxTokens = try reader["maxTokens"].readIfPresent()
        value.stopSequences = try reader["stopSequences"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentClientTypes.PromptTemplateConfiguration {

    static func write(value: BedrockAgentClientTypes.PromptTemplateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .chat(chat):
                try writer["chat"].write(chat, with: BedrockAgentClientTypes.ChatPromptTemplateConfiguration.write(value:to:))
            case let .text(text):
                try writer["text"].write(text, with: BedrockAgentClientTypes.TextPromptTemplateConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PromptTemplateConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "text":
                return .text(try reader["text"].read(with: BedrockAgentClientTypes.TextPromptTemplateConfiguration.read(from:)))
            case "chat":
                return .chat(try reader["chat"].read(with: BedrockAgentClientTypes.ChatPromptTemplateConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes.ChatPromptTemplateConfiguration {

    static func write(value: BedrockAgentClientTypes.ChatPromptTemplateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputVariables"].writeList(value.inputVariables, memberWritingClosure: BedrockAgentClientTypes.PromptInputVariable.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["messages"].writeList(value.messages, memberWritingClosure: BedrockAgentClientTypes.Message.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["system"].writeList(value.system, memberWritingClosure: BedrockAgentClientTypes.SystemContentBlock.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["toolConfiguration"].write(value.toolConfiguration, with: BedrockAgentClientTypes.ToolConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ChatPromptTemplateConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.ChatPromptTemplateConfiguration()
        value.messages = try reader["messages"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.Message.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.system = try reader["system"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.SystemContentBlock.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.inputVariables = try reader["inputVariables"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.PromptInputVariable.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.toolConfiguration = try reader["toolConfiguration"].readIfPresent(with: BedrockAgentClientTypes.ToolConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.ToolConfiguration {

    static func write(value: BedrockAgentClientTypes.ToolConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["toolChoice"].write(value.toolChoice, with: BedrockAgentClientTypes.ToolChoice.write(value:to:))
        try writer["tools"].writeList(value.tools, memberWritingClosure: BedrockAgentClientTypes.Tool.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ToolConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.ToolConfiguration()
        value.tools = try reader["tools"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.Tool.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.toolChoice = try reader["toolChoice"].readIfPresent(with: BedrockAgentClientTypes.ToolChoice.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.ToolChoice {

    static func write(value: BedrockAgentClientTypes.ToolChoice?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .any(any):
                try writer["any"].write(any, with: BedrockAgentClientTypes.AnyToolChoice.write(value:to:))
            case let .auto(auto):
                try writer["auto"].write(auto, with: BedrockAgentClientTypes.AutoToolChoice.write(value:to:))
            case let .tool(tool):
                try writer["tool"].write(tool, with: BedrockAgentClientTypes.SpecificToolChoice.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ToolChoice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "auto":
                return .auto(try reader["auto"].read(with: BedrockAgentClientTypes.AutoToolChoice.read(from:)))
            case "any":
                return .any(try reader["any"].read(with: BedrockAgentClientTypes.AnyToolChoice.read(from:)))
            case "tool":
                return .tool(try reader["tool"].read(with: BedrockAgentClientTypes.SpecificToolChoice.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes.SpecificToolChoice {

    static func write(value: BedrockAgentClientTypes.SpecificToolChoice?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.SpecificToolChoice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.SpecificToolChoice()
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.AnyToolChoice {

    static func write(value: BedrockAgentClientTypes.AnyToolChoice?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AnyToolChoice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return BedrockAgentClientTypes.AnyToolChoice()
    }
}

extension BedrockAgentClientTypes.AutoToolChoice {

    static func write(value: BedrockAgentClientTypes.AutoToolChoice?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AutoToolChoice {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return BedrockAgentClientTypes.AutoToolChoice()
    }
}

extension BedrockAgentClientTypes.Tool {

    static func write(value: BedrockAgentClientTypes.Tool?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .toolspec(toolspec):
                try writer["toolSpec"].write(toolspec, with: BedrockAgentClientTypes.ToolSpecification.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.Tool {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "toolSpec":
                return .toolspec(try reader["toolSpec"].read(with: BedrockAgentClientTypes.ToolSpecification.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes.ToolSpecification {

    static func write(value: BedrockAgentClientTypes.ToolSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["inputSchema"].write(value.inputSchema, with: BedrockAgentClientTypes.ToolInputSchema.write(value:to:))
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ToolSpecification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.ToolSpecification()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.inputSchema = try reader["inputSchema"].readIfPresent(with: BedrockAgentClientTypes.ToolInputSchema.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.ToolInputSchema {

    static func write(value: BedrockAgentClientTypes.ToolInputSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .json(json):
                try writer["json"].write(json)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ToolInputSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "json":
                return .json(try reader["json"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes.PromptInputVariable {

    static func write(value: BedrockAgentClientTypes.PromptInputVariable?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PromptInputVariable {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.PromptInputVariable()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes.SystemContentBlock {

    static func write(value: BedrockAgentClientTypes.SystemContentBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .text(text):
                try writer["text"].write(text)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.SystemContentBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "text":
                return .text(try reader["text"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes.Message {

    static func write(value: BedrockAgentClientTypes.Message?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["content"].writeList(value.content, memberWritingClosure: BedrockAgentClientTypes.ContentBlock.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["role"].write(value.role)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.Message {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.Message()
        value.role = try reader["role"].readIfPresent() ?? .sdkUnknown("")
        value.content = try reader["content"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.ContentBlock.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockAgentClientTypes.ContentBlock {

    static func write(value: BedrockAgentClientTypes.ContentBlock?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .text(text):
                try writer["text"].write(text)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ContentBlock {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "text":
                return .text(try reader["text"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes.TextPromptTemplateConfiguration {

    static func write(value: BedrockAgentClientTypes.TextPromptTemplateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputVariables"].writeList(value.inputVariables, memberWritingClosure: BedrockAgentClientTypes.PromptInputVariable.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["text"].write(value.text)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.TextPromptTemplateConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.TextPromptTemplateConfiguration()
        value.text = try reader["text"].readIfPresent() ?? ""
        value.inputVariables = try reader["inputVariables"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.PromptInputVariable.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentClientTypes.PromptFlowNodeResourceConfiguration {

    static func write(value: BedrockAgentClientTypes.PromptFlowNodeResourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["promptArn"].write(value.promptArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PromptFlowNodeResourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.PromptFlowNodeResourceConfiguration()
        value.promptArn = try reader["promptArn"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.LexFlowNodeConfiguration {

    static func write(value: BedrockAgentClientTypes.LexFlowNodeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["botAliasArn"].write(value.botAliasArn)
        try writer["localeId"].write(value.localeId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.LexFlowNodeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.LexFlowNodeConfiguration()
        value.botAliasArn = try reader["botAliasArn"].readIfPresent() ?? ""
        value.localeId = try reader["localeId"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.ConditionFlowNodeConfiguration {

    static func write(value: BedrockAgentClientTypes.ConditionFlowNodeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["conditions"].writeList(value.conditions, memberWritingClosure: BedrockAgentClientTypes.FlowCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ConditionFlowNodeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.ConditionFlowNodeConfiguration()
        value.conditions = try reader["conditions"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.FlowCondition.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BedrockAgentClientTypes.FlowCondition {

    static func write(value: BedrockAgentClientTypes.FlowCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["expression"].write(value.expression)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FlowCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.FlowCondition()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.expression = try reader["expression"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes.KnowledgeBaseFlowNodeConfiguration {

    static func write(value: BedrockAgentClientTypes.KnowledgeBaseFlowNodeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["guardrailConfiguration"].write(value.guardrailConfiguration, with: BedrockAgentClientTypes.GuardrailConfiguration.write(value:to:))
        try writer["knowledgeBaseId"].write(value.knowledgeBaseId)
        try writer["modelId"].write(value.modelId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.KnowledgeBaseFlowNodeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.KnowledgeBaseFlowNodeConfiguration()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.modelId = try reader["modelId"].readIfPresent()
        value.guardrailConfiguration = try reader["guardrailConfiguration"].readIfPresent(with: BedrockAgentClientTypes.GuardrailConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.OutputFlowNodeConfiguration {

    static func write(value: BedrockAgentClientTypes.OutputFlowNodeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.OutputFlowNodeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return BedrockAgentClientTypes.OutputFlowNodeConfiguration()
    }
}

extension BedrockAgentClientTypes.InputFlowNodeConfiguration {

    static func write(value: BedrockAgentClientTypes.InputFlowNodeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.InputFlowNodeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return BedrockAgentClientTypes.InputFlowNodeConfiguration()
    }
}

extension BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem {

    static func write(value: BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["flowVersion"].write(value.flowVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem()
        value.flowVersion = try reader["flowVersion"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes.KnowledgeBase {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.KnowledgeBase {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.KnowledgeBase()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.knowledgeBaseArn = try reader["knowledgeBaseArn"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.knowledgeBaseConfiguration = try reader["knowledgeBaseConfiguration"].readIfPresent(with: BedrockAgentClientTypes.KnowledgeBaseConfiguration.read(from:))
        value.storageConfiguration = try reader["storageConfiguration"].readIfPresent(with: BedrockAgentClientTypes.StorageConfiguration.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockAgentClientTypes.StorageConfiguration {

    static func write(value: BedrockAgentClientTypes.StorageConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mongoDbAtlasConfiguration"].write(value.mongoDbAtlasConfiguration, with: BedrockAgentClientTypes.MongoDbAtlasConfiguration.write(value:to:))
        try writer["opensearchServerlessConfiguration"].write(value.opensearchServerlessConfiguration, with: BedrockAgentClientTypes.OpenSearchServerlessConfiguration.write(value:to:))
        try writer["pineconeConfiguration"].write(value.pineconeConfiguration, with: BedrockAgentClientTypes.PineconeConfiguration.write(value:to:))
        try writer["rdsConfiguration"].write(value.rdsConfiguration, with: BedrockAgentClientTypes.RdsConfiguration.write(value:to:))
        try writer["redisEnterpriseCloudConfiguration"].write(value.redisEnterpriseCloudConfiguration, with: BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration.write(value:to:))
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.StorageConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.StorageConfiguration()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.opensearchServerlessConfiguration = try reader["opensearchServerlessConfiguration"].readIfPresent(with: BedrockAgentClientTypes.OpenSearchServerlessConfiguration.read(from:))
        value.pineconeConfiguration = try reader["pineconeConfiguration"].readIfPresent(with: BedrockAgentClientTypes.PineconeConfiguration.read(from:))
        value.redisEnterpriseCloudConfiguration = try reader["redisEnterpriseCloudConfiguration"].readIfPresent(with: BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration.read(from:))
        value.rdsConfiguration = try reader["rdsConfiguration"].readIfPresent(with: BedrockAgentClientTypes.RdsConfiguration.read(from:))
        value.mongoDbAtlasConfiguration = try reader["mongoDbAtlasConfiguration"].readIfPresent(with: BedrockAgentClientTypes.MongoDbAtlasConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.MongoDbAtlasConfiguration {

    static func write(value: BedrockAgentClientTypes.MongoDbAtlasConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["collectionName"].write(value.collectionName)
        try writer["credentialsSecretArn"].write(value.credentialsSecretArn)
        try writer["databaseName"].write(value.databaseName)
        try writer["endpoint"].write(value.endpoint)
        try writer["endpointServiceName"].write(value.endpointServiceName)
        try writer["fieldMapping"].write(value.fieldMapping, with: BedrockAgentClientTypes.MongoDbAtlasFieldMapping.write(value:to:))
        try writer["vectorIndexName"].write(value.vectorIndexName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.MongoDbAtlasConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.MongoDbAtlasConfiguration()
        value.endpoint = try reader["endpoint"].readIfPresent() ?? ""
        value.databaseName = try reader["databaseName"].readIfPresent() ?? ""
        value.collectionName = try reader["collectionName"].readIfPresent() ?? ""
        value.vectorIndexName = try reader["vectorIndexName"].readIfPresent() ?? ""
        value.credentialsSecretArn = try reader["credentialsSecretArn"].readIfPresent() ?? ""
        value.fieldMapping = try reader["fieldMapping"].readIfPresent(with: BedrockAgentClientTypes.MongoDbAtlasFieldMapping.read(from:))
        value.endpointServiceName = try reader["endpointServiceName"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes.MongoDbAtlasFieldMapping {

    static func write(value: BedrockAgentClientTypes.MongoDbAtlasFieldMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadataField"].write(value.metadataField)
        try writer["textField"].write(value.textField)
        try writer["vectorField"].write(value.vectorField)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.MongoDbAtlasFieldMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.MongoDbAtlasFieldMapping()
        value.vectorField = try reader["vectorField"].readIfPresent() ?? ""
        value.textField = try reader["textField"].readIfPresent() ?? ""
        value.metadataField = try reader["metadataField"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.RdsConfiguration {

    static func write(value: BedrockAgentClientTypes.RdsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["credentialsSecretArn"].write(value.credentialsSecretArn)
        try writer["databaseName"].write(value.databaseName)
        try writer["fieldMapping"].write(value.fieldMapping, with: BedrockAgentClientTypes.RdsFieldMapping.write(value:to:))
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tableName"].write(value.tableName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.RdsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.RdsConfiguration()
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.credentialsSecretArn = try reader["credentialsSecretArn"].readIfPresent() ?? ""
        value.databaseName = try reader["databaseName"].readIfPresent() ?? ""
        value.tableName = try reader["tableName"].readIfPresent() ?? ""
        value.fieldMapping = try reader["fieldMapping"].readIfPresent(with: BedrockAgentClientTypes.RdsFieldMapping.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.RdsFieldMapping {

    static func write(value: BedrockAgentClientTypes.RdsFieldMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadataField"].write(value.metadataField)
        try writer["primaryKeyField"].write(value.primaryKeyField)
        try writer["textField"].write(value.textField)
        try writer["vectorField"].write(value.vectorField)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.RdsFieldMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.RdsFieldMapping()
        value.primaryKeyField = try reader["primaryKeyField"].readIfPresent() ?? ""
        value.vectorField = try reader["vectorField"].readIfPresent() ?? ""
        value.textField = try reader["textField"].readIfPresent() ?? ""
        value.metadataField = try reader["metadataField"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration {

    static func write(value: BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["credentialsSecretArn"].write(value.credentialsSecretArn)
        try writer["endpoint"].write(value.endpoint)
        try writer["fieldMapping"].write(value.fieldMapping, with: BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping.write(value:to:))
        try writer["vectorIndexName"].write(value.vectorIndexName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.RedisEnterpriseCloudConfiguration()
        value.endpoint = try reader["endpoint"].readIfPresent() ?? ""
        value.vectorIndexName = try reader["vectorIndexName"].readIfPresent() ?? ""
        value.credentialsSecretArn = try reader["credentialsSecretArn"].readIfPresent() ?? ""
        value.fieldMapping = try reader["fieldMapping"].readIfPresent(with: BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping {

    static func write(value: BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadataField"].write(value.metadataField)
        try writer["textField"].write(value.textField)
        try writer["vectorField"].write(value.vectorField)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.RedisEnterpriseCloudFieldMapping()
        value.vectorField = try reader["vectorField"].readIfPresent() ?? ""
        value.textField = try reader["textField"].readIfPresent() ?? ""
        value.metadataField = try reader["metadataField"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.PineconeConfiguration {

    static func write(value: BedrockAgentClientTypes.PineconeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionString"].write(value.connectionString)
        try writer["credentialsSecretArn"].write(value.credentialsSecretArn)
        try writer["fieldMapping"].write(value.fieldMapping, with: BedrockAgentClientTypes.PineconeFieldMapping.write(value:to:))
        try writer["namespace"].write(value.namespace)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PineconeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.PineconeConfiguration()
        value.connectionString = try reader["connectionString"].readIfPresent() ?? ""
        value.credentialsSecretArn = try reader["credentialsSecretArn"].readIfPresent() ?? ""
        value.namespace = try reader["namespace"].readIfPresent()
        value.fieldMapping = try reader["fieldMapping"].readIfPresent(with: BedrockAgentClientTypes.PineconeFieldMapping.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.PineconeFieldMapping {

    static func write(value: BedrockAgentClientTypes.PineconeFieldMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadataField"].write(value.metadataField)
        try writer["textField"].write(value.textField)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PineconeFieldMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.PineconeFieldMapping()
        value.textField = try reader["textField"].readIfPresent() ?? ""
        value.metadataField = try reader["metadataField"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.OpenSearchServerlessConfiguration {

    static func write(value: BedrockAgentClientTypes.OpenSearchServerlessConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["collectionArn"].write(value.collectionArn)
        try writer["fieldMapping"].write(value.fieldMapping, with: BedrockAgentClientTypes.OpenSearchServerlessFieldMapping.write(value:to:))
        try writer["vectorIndexName"].write(value.vectorIndexName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.OpenSearchServerlessConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.OpenSearchServerlessConfiguration()
        value.collectionArn = try reader["collectionArn"].readIfPresent() ?? ""
        value.vectorIndexName = try reader["vectorIndexName"].readIfPresent() ?? ""
        value.fieldMapping = try reader["fieldMapping"].readIfPresent(with: BedrockAgentClientTypes.OpenSearchServerlessFieldMapping.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.OpenSearchServerlessFieldMapping {

    static func write(value: BedrockAgentClientTypes.OpenSearchServerlessFieldMapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadataField"].write(value.metadataField)
        try writer["textField"].write(value.textField)
        try writer["vectorField"].write(value.vectorField)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.OpenSearchServerlessFieldMapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.OpenSearchServerlessFieldMapping()
        value.vectorField = try reader["vectorField"].readIfPresent() ?? ""
        value.textField = try reader["textField"].readIfPresent() ?? ""
        value.metadataField = try reader["metadataField"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.KnowledgeBaseConfiguration {

    static func write(value: BedrockAgentClientTypes.KnowledgeBaseConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
        try writer["vectorKnowledgeBaseConfiguration"].write(value.vectorKnowledgeBaseConfiguration, with: BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.KnowledgeBaseConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.KnowledgeBaseConfiguration()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.vectorKnowledgeBaseConfiguration = try reader["vectorKnowledgeBaseConfiguration"].readIfPresent(with: BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration {

    static func write(value: BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["embeddingModelArn"].write(value.embeddingModelArn)
        try writer["embeddingModelConfiguration"].write(value.embeddingModelConfiguration, with: BedrockAgentClientTypes.EmbeddingModelConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.VectorKnowledgeBaseConfiguration()
        value.embeddingModelArn = try reader["embeddingModelArn"].readIfPresent() ?? ""
        value.embeddingModelConfiguration = try reader["embeddingModelConfiguration"].readIfPresent(with: BedrockAgentClientTypes.EmbeddingModelConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.EmbeddingModelConfiguration {

    static func write(value: BedrockAgentClientTypes.EmbeddingModelConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bedrockEmbeddingModelConfiguration"].write(value.bedrockEmbeddingModelConfiguration, with: BedrockAgentClientTypes.BedrockEmbeddingModelConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.EmbeddingModelConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.EmbeddingModelConfiguration()
        value.bedrockEmbeddingModelConfiguration = try reader["bedrockEmbeddingModelConfiguration"].readIfPresent(with: BedrockAgentClientTypes.BedrockEmbeddingModelConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.BedrockEmbeddingModelConfiguration {

    static func write(value: BedrockAgentClientTypes.BedrockEmbeddingModelConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dimensions"].write(value.dimensions)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.BedrockEmbeddingModelConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.BedrockEmbeddingModelConfiguration()
        value.dimensions = try reader["dimensions"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes.PromptVariant {

    static func write(value: BedrockAgentClientTypes.PromptVariant?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalModelRequestFields"].write(value.additionalModelRequestFields)
        try writer["genAiResource"].write(value.genAiResource, with: BedrockAgentClientTypes.PromptGenAiResource.write(value:to:))
        try writer["inferenceConfiguration"].write(value.inferenceConfiguration, with: BedrockAgentClientTypes.PromptInferenceConfiguration.write(value:to:))
        try writer["metadata"].writeList(value.metadata, memberWritingClosure: BedrockAgentClientTypes.PromptMetadataEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["modelId"].write(value.modelId)
        try writer["name"].write(value.name)
        try writer["templateConfiguration"].write(value.templateConfiguration, with: BedrockAgentClientTypes.PromptTemplateConfiguration.write(value:to:))
        try writer["templateType"].write(value.templateType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PromptVariant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.PromptVariant()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.templateType = try reader["templateType"].readIfPresent() ?? .sdkUnknown("")
        value.templateConfiguration = try reader["templateConfiguration"].readIfPresent(with: BedrockAgentClientTypes.PromptTemplateConfiguration.read(from:))
        value.modelId = try reader["modelId"].readIfPresent()
        value.inferenceConfiguration = try reader["inferenceConfiguration"].readIfPresent(with: BedrockAgentClientTypes.PromptInferenceConfiguration.read(from:))
        value.metadata = try reader["metadata"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.PromptMetadataEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.additionalModelRequestFields = try reader["additionalModelRequestFields"].readIfPresent()
        value.genAiResource = try reader["genAiResource"].readIfPresent(with: BedrockAgentClientTypes.PromptGenAiResource.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.PromptGenAiResource {

    static func write(value: BedrockAgentClientTypes.PromptGenAiResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .agent(agent):
                try writer["agent"].write(agent, with: BedrockAgentClientTypes.PromptAgentResource.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PromptGenAiResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "agent":
                return .agent(try reader["agent"].read(with: BedrockAgentClientTypes.PromptAgentResource.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes.PromptAgentResource {

    static func write(value: BedrockAgentClientTypes.PromptAgentResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agentIdentifier"].write(value.agentIdentifier)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PromptAgentResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.PromptAgentResource()
        value.agentIdentifier = try reader["agentIdentifier"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.PromptMetadataEntry {

    static func write(value: BedrockAgentClientTypes.PromptMetadataEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PromptMetadataEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.PromptMetadataEntry()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.AgentVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentVersion()
        value.agentId = try reader["agentId"].readIfPresent() ?? ""
        value.agentName = try reader["agentName"].readIfPresent() ?? ""
        value.agentArn = try reader["agentArn"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? ""
        value.instruction = try reader["instruction"].readIfPresent()
        value.agentStatus = try reader["agentStatus"].readIfPresent() ?? .sdkUnknown("")
        value.foundationModel = try reader["foundationModel"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.idleSessionTTLInSeconds = try reader["idleSessionTTLInSeconds"].readIfPresent() ?? 0
        value.agentResourceRoleArn = try reader["agentResourceRoleArn"].readIfPresent() ?? ""
        value.customerEncryptionKeyArn = try reader["customerEncryptionKeyArn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.recommendedActions = try reader["recommendedActions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.promptOverrideConfiguration = try reader["promptOverrideConfiguration"].readIfPresent(with: BedrockAgentClientTypes.PromptOverrideConfiguration.read(from:))
        value.guardrailConfiguration = try reader["guardrailConfiguration"].readIfPresent(with: BedrockAgentClientTypes.GuardrailConfiguration.read(from:))
        value.memoryConfiguration = try reader["memoryConfiguration"].readIfPresent(with: BedrockAgentClientTypes.MemoryConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.FlowValidation {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FlowValidation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.FlowValidation()
        value.message = try reader["message"].readIfPresent() ?? ""
        value.severity = try reader["severity"].readIfPresent() ?? .sdkUnknown("")
        value.details = try reader["details"].readIfPresent(with: BedrockAgentClientTypes.FlowValidationDetails.read(from:))
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension BedrockAgentClientTypes.FlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "cyclicConnection":
                return .cyclicconnection(try reader["cyclicConnection"].read(with: BedrockAgentClientTypes.CyclicConnectionFlowValidationDetails.read(from:)))
            case "duplicateConnections":
                return .duplicateconnections(try reader["duplicateConnections"].read(with: BedrockAgentClientTypes.DuplicateConnectionsFlowValidationDetails.read(from:)))
            case "duplicateConditionExpression":
                return .duplicateconditionexpression(try reader["duplicateConditionExpression"].read(with: BedrockAgentClientTypes.DuplicateConditionExpressionFlowValidationDetails.read(from:)))
            case "unreachableNode":
                return .unreachablenode(try reader["unreachableNode"].read(with: BedrockAgentClientTypes.UnreachableNodeFlowValidationDetails.read(from:)))
            case "unknownConnectionSource":
                return .unknownconnectionsource(try reader["unknownConnectionSource"].read(with: BedrockAgentClientTypes.UnknownConnectionSourceFlowValidationDetails.read(from:)))
            case "unknownConnectionSourceOutput":
                return .unknownconnectionsourceoutput(try reader["unknownConnectionSourceOutput"].read(with: BedrockAgentClientTypes.UnknownConnectionSourceOutputFlowValidationDetails.read(from:)))
            case "unknownConnectionTarget":
                return .unknownconnectiontarget(try reader["unknownConnectionTarget"].read(with: BedrockAgentClientTypes.UnknownConnectionTargetFlowValidationDetails.read(from:)))
            case "unknownConnectionTargetInput":
                return .unknownconnectiontargetinput(try reader["unknownConnectionTargetInput"].read(with: BedrockAgentClientTypes.UnknownConnectionTargetInputFlowValidationDetails.read(from:)))
            case "unknownConnectionCondition":
                return .unknownconnectioncondition(try reader["unknownConnectionCondition"].read(with: BedrockAgentClientTypes.UnknownConnectionConditionFlowValidationDetails.read(from:)))
            case "malformedConditionExpression":
                return .malformedconditionexpression(try reader["malformedConditionExpression"].read(with: BedrockAgentClientTypes.MalformedConditionExpressionFlowValidationDetails.read(from:)))
            case "malformedNodeInputExpression":
                return .malformednodeinputexpression(try reader["malformedNodeInputExpression"].read(with: BedrockAgentClientTypes.MalformedNodeInputExpressionFlowValidationDetails.read(from:)))
            case "mismatchedNodeInputType":
                return .mismatchednodeinputtype(try reader["mismatchedNodeInputType"].read(with: BedrockAgentClientTypes.MismatchedNodeInputTypeFlowValidationDetails.read(from:)))
            case "mismatchedNodeOutputType":
                return .mismatchednodeoutputtype(try reader["mismatchedNodeOutputType"].read(with: BedrockAgentClientTypes.MismatchedNodeOutputTypeFlowValidationDetails.read(from:)))
            case "incompatibleConnectionDataType":
                return .incompatibleconnectiondatatype(try reader["incompatibleConnectionDataType"].read(with: BedrockAgentClientTypes.IncompatibleConnectionDataTypeFlowValidationDetails.read(from:)))
            case "missingConnectionConfiguration":
                return .missingconnectionconfiguration(try reader["missingConnectionConfiguration"].read(with: BedrockAgentClientTypes.MissingConnectionConfigurationFlowValidationDetails.read(from:)))
            case "missingDefaultCondition":
                return .missingdefaultcondition(try reader["missingDefaultCondition"].read(with: BedrockAgentClientTypes.MissingDefaultConditionFlowValidationDetails.read(from:)))
            case "missingEndingNodes":
                return .missingendingnodes(try reader["missingEndingNodes"].read(with: BedrockAgentClientTypes.MissingEndingNodesFlowValidationDetails.read(from:)))
            case "missingNodeConfiguration":
                return .missingnodeconfiguration(try reader["missingNodeConfiguration"].read(with: BedrockAgentClientTypes.MissingNodeConfigurationFlowValidationDetails.read(from:)))
            case "missingNodeInput":
                return .missingnodeinput(try reader["missingNodeInput"].read(with: BedrockAgentClientTypes.MissingNodeInputFlowValidationDetails.read(from:)))
            case "missingNodeOutput":
                return .missingnodeoutput(try reader["missingNodeOutput"].read(with: BedrockAgentClientTypes.MissingNodeOutputFlowValidationDetails.read(from:)))
            case "missingStartingNodes":
                return .missingstartingnodes(try reader["missingStartingNodes"].read(with: BedrockAgentClientTypes.MissingStartingNodesFlowValidationDetails.read(from:)))
            case "multipleNodeInputConnections":
                return .multiplenodeinputconnections(try reader["multipleNodeInputConnections"].read(with: BedrockAgentClientTypes.MultipleNodeInputConnectionsFlowValidationDetails.read(from:)))
            case "unfulfilledNodeInput":
                return .unfulfillednodeinput(try reader["unfulfilledNodeInput"].read(with: BedrockAgentClientTypes.UnfulfilledNodeInputFlowValidationDetails.read(from:)))
            case "unsatisfiedConnectionConditions":
                return .unsatisfiedconnectionconditions(try reader["unsatisfiedConnectionConditions"].read(with: BedrockAgentClientTypes.UnsatisfiedConnectionConditionsFlowValidationDetails.read(from:)))
            case "unspecified":
                return .unspecified(try reader["unspecified"].read(with: BedrockAgentClientTypes.UnspecifiedFlowValidationDetails.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BedrockAgentClientTypes.UnspecifiedFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.UnspecifiedFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return BedrockAgentClientTypes.UnspecifiedFlowValidationDetails()
    }
}

extension BedrockAgentClientTypes.UnsatisfiedConnectionConditionsFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.UnsatisfiedConnectionConditionsFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.UnsatisfiedConnectionConditionsFlowValidationDetails()
        value.connection = try reader["connection"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.UnfulfilledNodeInputFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.UnfulfilledNodeInputFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.UnfulfilledNodeInputFlowValidationDetails()
        value.node = try reader["node"].readIfPresent() ?? ""
        value.input = try reader["input"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.MultipleNodeInputConnectionsFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.MultipleNodeInputConnectionsFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.MultipleNodeInputConnectionsFlowValidationDetails()
        value.node = try reader["node"].readIfPresent() ?? ""
        value.input = try reader["input"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.MissingStartingNodesFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.MissingStartingNodesFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return BedrockAgentClientTypes.MissingStartingNodesFlowValidationDetails()
    }
}

extension BedrockAgentClientTypes.MissingNodeOutputFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.MissingNodeOutputFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.MissingNodeOutputFlowValidationDetails()
        value.node = try reader["node"].readIfPresent() ?? ""
        value.output = try reader["output"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.MissingNodeInputFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.MissingNodeInputFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.MissingNodeInputFlowValidationDetails()
        value.node = try reader["node"].readIfPresent() ?? ""
        value.input = try reader["input"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.MissingNodeConfigurationFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.MissingNodeConfigurationFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.MissingNodeConfigurationFlowValidationDetails()
        value.node = try reader["node"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.MissingEndingNodesFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.MissingEndingNodesFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return BedrockAgentClientTypes.MissingEndingNodesFlowValidationDetails()
    }
}

extension BedrockAgentClientTypes.MissingDefaultConditionFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.MissingDefaultConditionFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.MissingDefaultConditionFlowValidationDetails()
        value.node = try reader["node"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.MissingConnectionConfigurationFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.MissingConnectionConfigurationFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.MissingConnectionConfigurationFlowValidationDetails()
        value.connection = try reader["connection"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.IncompatibleConnectionDataTypeFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.IncompatibleConnectionDataTypeFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.IncompatibleConnectionDataTypeFlowValidationDetails()
        value.connection = try reader["connection"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.MismatchedNodeOutputTypeFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.MismatchedNodeOutputTypeFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.MismatchedNodeOutputTypeFlowValidationDetails()
        value.node = try reader["node"].readIfPresent() ?? ""
        value.output = try reader["output"].readIfPresent() ?? ""
        value.expectedType = try reader["expectedType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockAgentClientTypes.MismatchedNodeInputTypeFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.MismatchedNodeInputTypeFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.MismatchedNodeInputTypeFlowValidationDetails()
        value.node = try reader["node"].readIfPresent() ?? ""
        value.input = try reader["input"].readIfPresent() ?? ""
        value.expectedType = try reader["expectedType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockAgentClientTypes.MalformedNodeInputExpressionFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.MalformedNodeInputExpressionFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.MalformedNodeInputExpressionFlowValidationDetails()
        value.node = try reader["node"].readIfPresent() ?? ""
        value.input = try reader["input"].readIfPresent() ?? ""
        value.cause = try reader["cause"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.MalformedConditionExpressionFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.MalformedConditionExpressionFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.MalformedConditionExpressionFlowValidationDetails()
        value.node = try reader["node"].readIfPresent() ?? ""
        value.condition = try reader["condition"].readIfPresent() ?? ""
        value.cause = try reader["cause"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.UnknownConnectionConditionFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.UnknownConnectionConditionFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.UnknownConnectionConditionFlowValidationDetails()
        value.connection = try reader["connection"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.UnknownConnectionTargetInputFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.UnknownConnectionTargetInputFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.UnknownConnectionTargetInputFlowValidationDetails()
        value.connection = try reader["connection"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.UnknownConnectionTargetFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.UnknownConnectionTargetFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.UnknownConnectionTargetFlowValidationDetails()
        value.connection = try reader["connection"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.UnknownConnectionSourceOutputFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.UnknownConnectionSourceOutputFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.UnknownConnectionSourceOutputFlowValidationDetails()
        value.connection = try reader["connection"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.UnknownConnectionSourceFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.UnknownConnectionSourceFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.UnknownConnectionSourceFlowValidationDetails()
        value.connection = try reader["connection"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.UnreachableNodeFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.UnreachableNodeFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.UnreachableNodeFlowValidationDetails()
        value.node = try reader["node"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.DuplicateConditionExpressionFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.DuplicateConditionExpressionFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.DuplicateConditionExpressionFlowValidationDetails()
        value.node = try reader["node"].readIfPresent() ?? ""
        value.expression = try reader["expression"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.DuplicateConnectionsFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.DuplicateConnectionsFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.DuplicateConnectionsFlowValidationDetails()
        value.source = try reader["source"].readIfPresent() ?? ""
        value.target = try reader["target"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.CyclicConnectionFlowValidationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.CyclicConnectionFlowValidationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.CyclicConnectionFlowValidationDetails()
        value.connection = try reader["connection"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.IngestionJob {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.IngestionJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.IngestionJob()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.dataSourceId = try reader["dataSourceId"].readIfPresent() ?? ""
        value.ingestionJobId = try reader["ingestionJobId"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statistics = try reader["statistics"].readIfPresent(with: BedrockAgentClientTypes.IngestionJobStatistics.read(from:))
        value.failureReasons = try reader["failureReasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockAgentClientTypes.IngestionJobStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.IngestionJobStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.IngestionJobStatistics()
        value.numberOfDocumentsScanned = try reader["numberOfDocumentsScanned"].readIfPresent() ?? 0
        value.numberOfMetadataDocumentsScanned = try reader["numberOfMetadataDocumentsScanned"].readIfPresent() ?? 0
        value.numberOfNewDocumentsIndexed = try reader["numberOfNewDocumentsIndexed"].readIfPresent() ?? 0
        value.numberOfModifiedDocumentsIndexed = try reader["numberOfModifiedDocumentsIndexed"].readIfPresent() ?? 0
        value.numberOfMetadataDocumentsModified = try reader["numberOfMetadataDocumentsModified"].readIfPresent() ?? 0
        value.numberOfDocumentsDeleted = try reader["numberOfDocumentsDeleted"].readIfPresent() ?? 0
        value.numberOfDocumentsFailed = try reader["numberOfDocumentsFailed"].readIfPresent() ?? 0
        return value
    }
}

extension BedrockAgentClientTypes.ActionGroupSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ActionGroupSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.ActionGroupSummary()
        value.actionGroupId = try reader["actionGroupId"].readIfPresent() ?? ""
        value.actionGroupName = try reader["actionGroupName"].readIfPresent() ?? ""
        value.actionGroupState = try reader["actionGroupState"].readIfPresent() ?? .sdkUnknown("")
        value.description = try reader["description"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockAgentClientTypes.AgentAliasSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentAliasSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentAliasSummary()
        value.agentAliasId = try reader["agentAliasId"].readIfPresent() ?? ""
        value.agentAliasName = try reader["agentAliasName"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.routingConfiguration = try reader["routingConfiguration"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.AgentAliasRoutingConfigurationListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.agentAliasStatus = try reader["agentAliasStatus"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockAgentClientTypes.AgentKnowledgeBaseSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentKnowledgeBaseSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentKnowledgeBaseSummary()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.knowledgeBaseState = try reader["knowledgeBaseState"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockAgentClientTypes.AgentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentSummary()
        value.agentId = try reader["agentId"].readIfPresent() ?? ""
        value.agentName = try reader["agentName"].readIfPresent() ?? ""
        value.agentStatus = try reader["agentStatus"].readIfPresent() ?? .sdkUnknown("")
        value.description = try reader["description"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.latestAgentVersion = try reader["latestAgentVersion"].readIfPresent()
        value.guardrailConfiguration = try reader["guardrailConfiguration"].readIfPresent(with: BedrockAgentClientTypes.GuardrailConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.AgentVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.AgentVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.AgentVersionSummary()
        value.agentName = try reader["agentName"].readIfPresent() ?? ""
        value.agentStatus = try reader["agentStatus"].readIfPresent() ?? .sdkUnknown("")
        value.agentVersion = try reader["agentVersion"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.guardrailConfiguration = try reader["guardrailConfiguration"].readIfPresent(with: BedrockAgentClientTypes.GuardrailConfiguration.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.DataSourceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.DataSourceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.DataSourceSummary()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.dataSourceId = try reader["dataSourceId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.description = try reader["description"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockAgentClientTypes.FlowAliasSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FlowAliasSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.FlowAliasSummary()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.routingConfiguration = try reader["routingConfiguration"].readListIfPresent(memberReadingClosure: BedrockAgentClientTypes.FlowAliasRoutingConfigurationListItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.flowId = try reader["flowId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockAgentClientTypes.FlowSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FlowSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.FlowSummary()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.FlowVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.FlowVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.FlowVersionSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.version = try reader["version"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.IngestionJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.IngestionJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.IngestionJobSummary()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.dataSourceId = try reader["dataSourceId"].readIfPresent() ?? ""
        value.ingestionJobId = try reader["ingestionJobId"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.statistics = try reader["statistics"].readIfPresent(with: BedrockAgentClientTypes.IngestionJobStatistics.read(from:))
        return value
    }
}

extension BedrockAgentClientTypes.KnowledgeBaseSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.KnowledgeBaseSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.KnowledgeBaseSummary()
        value.knowledgeBaseId = try reader["knowledgeBaseId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockAgentClientTypes.PromptSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.PromptSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.PromptSummary()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockAgentClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockAgentClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockAgentClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockAgentClientTypes.IngestionJobFilter {

    static func write(value: BedrockAgentClientTypes.IngestionJobFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attribute"].write(value.attribute)
        try writer["operator"].write(value.`operator`)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BedrockAgentClientTypes.IngestionJobSortBy {

    static func write(value: BedrockAgentClientTypes.IngestionJobSortBy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attribute"].write(value.attribute)
        try writer["order"].write(value.order)
    }
}

public enum BedrockAgentClientTypes {}
