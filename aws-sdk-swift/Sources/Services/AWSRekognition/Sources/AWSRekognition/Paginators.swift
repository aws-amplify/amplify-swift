//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension RekognitionClient {
    /// Paginate over `[DescribeProjectsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeProjectsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeProjectsOutput`
    public func describeProjectsPaginated(input: DescribeProjectsInput) -> ClientRuntime.PaginatorSequence<DescribeProjectsInput, DescribeProjectsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeProjectsInput, DescribeProjectsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeProjects(input:))
    }
}

extension DescribeProjectsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeProjectsInput {
        return DescribeProjectsInput(
            features: self.features,
            maxResults: self.maxResults,
            nextToken: token,
            projectNames: self.projectNames
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeProjectsInput, OperationStackOutput == DescribeProjectsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeProjectsPaginated`
    /// to access the nested member `[RekognitionClientTypes.ProjectDescription]`
    /// - Returns: `[RekognitionClientTypes.ProjectDescription]`
    public func projectDescriptions() async throws -> [RekognitionClientTypes.ProjectDescription] {
        return try await self.asyncCompactMap { item in item.projectDescriptions }
    }
}
extension RekognitionClient {
    /// Paginate over `[DescribeProjectVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeProjectVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeProjectVersionsOutput`
    public func describeProjectVersionsPaginated(input: DescribeProjectVersionsInput) -> ClientRuntime.PaginatorSequence<DescribeProjectVersionsInput, DescribeProjectVersionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeProjectVersionsInput, DescribeProjectVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeProjectVersions(input:))
    }
}

extension DescribeProjectVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeProjectVersionsInput {
        return DescribeProjectVersionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            projectArn: self.projectArn,
            versionNames: self.versionNames
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeProjectVersionsInput, OperationStackOutput == DescribeProjectVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeProjectVersionsPaginated`
    /// to access the nested member `[RekognitionClientTypes.ProjectVersionDescription]`
    /// - Returns: `[RekognitionClientTypes.ProjectVersionDescription]`
    public func projectVersionDescriptions() async throws -> [RekognitionClientTypes.ProjectVersionDescription] {
        return try await self.asyncCompactMap { item in item.projectVersionDescriptions }
    }
}
extension RekognitionClient {
    /// Paginate over `[GetCelebrityRecognitionOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetCelebrityRecognitionInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetCelebrityRecognitionOutput`
    public func getCelebrityRecognitionPaginated(input: GetCelebrityRecognitionInput) -> ClientRuntime.PaginatorSequence<GetCelebrityRecognitionInput, GetCelebrityRecognitionOutput> {
        return ClientRuntime.PaginatorSequence<GetCelebrityRecognitionInput, GetCelebrityRecognitionOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getCelebrityRecognition(input:))
    }
}

extension GetCelebrityRecognitionInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetCelebrityRecognitionInput {
        return GetCelebrityRecognitionInput(
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
extension RekognitionClient {
    /// Paginate over `[GetContentModerationOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetContentModerationInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetContentModerationOutput`
    public func getContentModerationPaginated(input: GetContentModerationInput) -> ClientRuntime.PaginatorSequence<GetContentModerationInput, GetContentModerationOutput> {
        return ClientRuntime.PaginatorSequence<GetContentModerationInput, GetContentModerationOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getContentModeration(input:))
    }
}

extension GetContentModerationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetContentModerationInput {
        return GetContentModerationInput(
            aggregateBy: self.aggregateBy,
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
extension RekognitionClient {
    /// Paginate over `[GetFaceDetectionOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetFaceDetectionInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetFaceDetectionOutput`
    public func getFaceDetectionPaginated(input: GetFaceDetectionInput) -> ClientRuntime.PaginatorSequence<GetFaceDetectionInput, GetFaceDetectionOutput> {
        return ClientRuntime.PaginatorSequence<GetFaceDetectionInput, GetFaceDetectionOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getFaceDetection(input:))
    }
}

extension GetFaceDetectionInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetFaceDetectionInput {
        return GetFaceDetectionInput(
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension RekognitionClient {
    /// Paginate over `[GetFaceSearchOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetFaceSearchInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetFaceSearchOutput`
    public func getFaceSearchPaginated(input: GetFaceSearchInput) -> ClientRuntime.PaginatorSequence<GetFaceSearchInput, GetFaceSearchOutput> {
        return ClientRuntime.PaginatorSequence<GetFaceSearchInput, GetFaceSearchOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getFaceSearch(input:))
    }
}

extension GetFaceSearchInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetFaceSearchInput {
        return GetFaceSearchInput(
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
extension RekognitionClient {
    /// Paginate over `[GetLabelDetectionOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetLabelDetectionInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetLabelDetectionOutput`
    public func getLabelDetectionPaginated(input: GetLabelDetectionInput) -> ClientRuntime.PaginatorSequence<GetLabelDetectionInput, GetLabelDetectionOutput> {
        return ClientRuntime.PaginatorSequence<GetLabelDetectionInput, GetLabelDetectionOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getLabelDetection(input:))
    }
}

extension GetLabelDetectionInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetLabelDetectionInput {
        return GetLabelDetectionInput(
            aggregateBy: self.aggregateBy,
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
extension RekognitionClient {
    /// Paginate over `[GetPersonTrackingOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetPersonTrackingInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetPersonTrackingOutput`
    public func getPersonTrackingPaginated(input: GetPersonTrackingInput) -> ClientRuntime.PaginatorSequence<GetPersonTrackingInput, GetPersonTrackingOutput> {
        return ClientRuntime.PaginatorSequence<GetPersonTrackingInput, GetPersonTrackingOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getPersonTracking(input:))
    }
}

extension GetPersonTrackingInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetPersonTrackingInput {
        return GetPersonTrackingInput(
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
extension RekognitionClient {
    /// Paginate over `[GetSegmentDetectionOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetSegmentDetectionInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetSegmentDetectionOutput`
    public func getSegmentDetectionPaginated(input: GetSegmentDetectionInput) -> ClientRuntime.PaginatorSequence<GetSegmentDetectionInput, GetSegmentDetectionOutput> {
        return ClientRuntime.PaginatorSequence<GetSegmentDetectionInput, GetSegmentDetectionOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getSegmentDetection(input:))
    }
}

extension GetSegmentDetectionInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetSegmentDetectionInput {
        return GetSegmentDetectionInput(
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension RekognitionClient {
    /// Paginate over `[GetTextDetectionOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetTextDetectionInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetTextDetectionOutput`
    public func getTextDetectionPaginated(input: GetTextDetectionInput) -> ClientRuntime.PaginatorSequence<GetTextDetectionInput, GetTextDetectionOutput> {
        return ClientRuntime.PaginatorSequence<GetTextDetectionInput, GetTextDetectionOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getTextDetection(input:))
    }
}

extension GetTextDetectionInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetTextDetectionInput {
        return GetTextDetectionInput(
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension RekognitionClient {
    /// Paginate over `[ListCollectionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCollectionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCollectionsOutput`
    public func listCollectionsPaginated(input: ListCollectionsInput) -> ClientRuntime.PaginatorSequence<ListCollectionsInput, ListCollectionsOutput> {
        return ClientRuntime.PaginatorSequence<ListCollectionsInput, ListCollectionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCollections(input:))
    }
}

extension ListCollectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCollectionsInput {
        return ListCollectionsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListCollectionsInput, OperationStackOutput == ListCollectionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCollectionsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func collectionIds() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.collectionIds }
    }
}
extension RekognitionClient {
    /// Paginate over `[ListDatasetEntriesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDatasetEntriesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDatasetEntriesOutput`
    public func listDatasetEntriesPaginated(input: ListDatasetEntriesInput) -> ClientRuntime.PaginatorSequence<ListDatasetEntriesInput, ListDatasetEntriesOutput> {
        return ClientRuntime.PaginatorSequence<ListDatasetEntriesInput, ListDatasetEntriesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDatasetEntries(input:))
    }
}

extension ListDatasetEntriesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDatasetEntriesInput {
        return ListDatasetEntriesInput(
            containsLabels: self.containsLabels,
            datasetArn: self.datasetArn,
            hasErrors: self.hasErrors,
            labeled: self.labeled,
            maxResults: self.maxResults,
            nextToken: token,
            sourceRefContains: self.sourceRefContains
        )}
}

extension PaginatorSequence where OperationStackInput == ListDatasetEntriesInput, OperationStackOutput == ListDatasetEntriesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDatasetEntriesPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func datasetEntries() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.datasetEntries }
    }
}
extension RekognitionClient {
    /// Paginate over `[ListDatasetLabelsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDatasetLabelsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDatasetLabelsOutput`
    public func listDatasetLabelsPaginated(input: ListDatasetLabelsInput) -> ClientRuntime.PaginatorSequence<ListDatasetLabelsInput, ListDatasetLabelsOutput> {
        return ClientRuntime.PaginatorSequence<ListDatasetLabelsInput, ListDatasetLabelsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDatasetLabels(input:))
    }
}

extension ListDatasetLabelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDatasetLabelsInput {
        return ListDatasetLabelsInput(
            datasetArn: self.datasetArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDatasetLabelsInput, OperationStackOutput == ListDatasetLabelsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDatasetLabelsPaginated`
    /// to access the nested member `[RekognitionClientTypes.DatasetLabelDescription]`
    /// - Returns: `[RekognitionClientTypes.DatasetLabelDescription]`
    public func datasetLabelDescriptions() async throws -> [RekognitionClientTypes.DatasetLabelDescription] {
        return try await self.asyncCompactMap { item in item.datasetLabelDescriptions }
    }
}
extension RekognitionClient {
    /// Paginate over `[ListFacesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFacesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFacesOutput`
    public func listFacesPaginated(input: ListFacesInput) -> ClientRuntime.PaginatorSequence<ListFacesInput, ListFacesOutput> {
        return ClientRuntime.PaginatorSequence<ListFacesInput, ListFacesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFaces(input:))
    }
}

extension ListFacesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFacesInput {
        return ListFacesInput(
            collectionId: self.collectionId,
            faceIds: self.faceIds,
            maxResults: self.maxResults,
            nextToken: token,
            userId: self.userId
        )}
}

extension PaginatorSequence where OperationStackInput == ListFacesInput, OperationStackOutput == ListFacesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFacesPaginated`
    /// to access the nested member `[RekognitionClientTypes.Face]`
    /// - Returns: `[RekognitionClientTypes.Face]`
    public func faces() async throws -> [RekognitionClientTypes.Face] {
        return try await self.asyncCompactMap { item in item.faces }
    }
}
extension RekognitionClient {
    /// Paginate over `[ListMediaAnalysisJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMediaAnalysisJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMediaAnalysisJobsOutput`
    public func listMediaAnalysisJobsPaginated(input: ListMediaAnalysisJobsInput) -> ClientRuntime.PaginatorSequence<ListMediaAnalysisJobsInput, ListMediaAnalysisJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListMediaAnalysisJobsInput, ListMediaAnalysisJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMediaAnalysisJobs(input:))
    }
}

extension ListMediaAnalysisJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMediaAnalysisJobsInput {
        return ListMediaAnalysisJobsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension RekognitionClient {
    /// Paginate over `[ListProjectPoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProjectPoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProjectPoliciesOutput`
    public func listProjectPoliciesPaginated(input: ListProjectPoliciesInput) -> ClientRuntime.PaginatorSequence<ListProjectPoliciesInput, ListProjectPoliciesOutput> {
        return ClientRuntime.PaginatorSequence<ListProjectPoliciesInput, ListProjectPoliciesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listProjectPolicies(input:))
    }
}

extension ListProjectPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProjectPoliciesInput {
        return ListProjectPoliciesInput(
            maxResults: self.maxResults,
            nextToken: token,
            projectArn: self.projectArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListProjectPoliciesInput, OperationStackOutput == ListProjectPoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listProjectPoliciesPaginated`
    /// to access the nested member `[RekognitionClientTypes.ProjectPolicy]`
    /// - Returns: `[RekognitionClientTypes.ProjectPolicy]`
    public func projectPolicies() async throws -> [RekognitionClientTypes.ProjectPolicy] {
        return try await self.asyncCompactMap { item in item.projectPolicies }
    }
}
extension RekognitionClient {
    /// Paginate over `[ListStreamProcessorsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListStreamProcessorsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListStreamProcessorsOutput`
    public func listStreamProcessorsPaginated(input: ListStreamProcessorsInput) -> ClientRuntime.PaginatorSequence<ListStreamProcessorsInput, ListStreamProcessorsOutput> {
        return ClientRuntime.PaginatorSequence<ListStreamProcessorsInput, ListStreamProcessorsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listStreamProcessors(input:))
    }
}

extension ListStreamProcessorsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListStreamProcessorsInput {
        return ListStreamProcessorsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension RekognitionClient {
    /// Paginate over `[ListUsersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUsersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUsersOutput`
    public func listUsersPaginated(input: ListUsersInput) -> ClientRuntime.PaginatorSequence<ListUsersInput, ListUsersOutput> {
        return ClientRuntime.PaginatorSequence<ListUsersInput, ListUsersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listUsers(input:))
    }
}

extension ListUsersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUsersInput {
        return ListUsersInput(
            collectionId: self.collectionId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListUsersInput, OperationStackOutput == ListUsersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listUsersPaginated`
    /// to access the nested member `[RekognitionClientTypes.User]`
    /// - Returns: `[RekognitionClientTypes.User]`
    public func users() async throws -> [RekognitionClientTypes.User] {
        return try await self.asyncCompactMap { item in item.users }
    }
}
