//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension AutoScalingClient {
    /// Paginate over `[DescribeAutoScalingGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeAutoScalingGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeAutoScalingGroupsOutput`
    public func describeAutoScalingGroupsPaginated(input: DescribeAutoScalingGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeAutoScalingGroupsInput, DescribeAutoScalingGroupsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeAutoScalingGroupsInput, DescribeAutoScalingGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeAutoScalingGroups(input:))
    }
}

extension DescribeAutoScalingGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAutoScalingGroupsInput {
        return DescribeAutoScalingGroupsInput(
            autoScalingGroupNames: self.autoScalingGroupNames,
            filters: self.filters,
            maxRecords: self.maxRecords,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeAutoScalingGroupsInput, OperationStackOutput == DescribeAutoScalingGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeAutoScalingGroupsPaginated`
    /// to access the nested member `[AutoScalingClientTypes.AutoScalingGroup]`
    /// - Returns: `[AutoScalingClientTypes.AutoScalingGroup]`
    public func autoScalingGroups() async throws -> [AutoScalingClientTypes.AutoScalingGroup] {
        return try await self.asyncCompactMap { item in item.autoScalingGroups }
    }
}
extension AutoScalingClient {
    /// Paginate over `[DescribeAutoScalingInstancesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeAutoScalingInstancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeAutoScalingInstancesOutput`
    public func describeAutoScalingInstancesPaginated(input: DescribeAutoScalingInstancesInput) -> ClientRuntime.PaginatorSequence<DescribeAutoScalingInstancesInput, DescribeAutoScalingInstancesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeAutoScalingInstancesInput, DescribeAutoScalingInstancesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeAutoScalingInstances(input:))
    }
}

extension DescribeAutoScalingInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAutoScalingInstancesInput {
        return DescribeAutoScalingInstancesInput(
            instanceIds: self.instanceIds,
            maxRecords: self.maxRecords,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeAutoScalingInstancesInput, OperationStackOutput == DescribeAutoScalingInstancesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeAutoScalingInstancesPaginated`
    /// to access the nested member `[AutoScalingClientTypes.AutoScalingInstanceDetails]`
    /// - Returns: `[AutoScalingClientTypes.AutoScalingInstanceDetails]`
    public func autoScalingInstances() async throws -> [AutoScalingClientTypes.AutoScalingInstanceDetails] {
        return try await self.asyncCompactMap { item in item.autoScalingInstances }
    }
}
extension AutoScalingClient {
    /// Paginate over `[DescribeInstanceRefreshesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeInstanceRefreshesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeInstanceRefreshesOutput`
    public func describeInstanceRefreshesPaginated(input: DescribeInstanceRefreshesInput) -> ClientRuntime.PaginatorSequence<DescribeInstanceRefreshesInput, DescribeInstanceRefreshesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeInstanceRefreshesInput, DescribeInstanceRefreshesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeInstanceRefreshes(input:))
    }
}

extension DescribeInstanceRefreshesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstanceRefreshesInput {
        return DescribeInstanceRefreshesInput(
            autoScalingGroupName: self.autoScalingGroupName,
            instanceRefreshIds: self.instanceRefreshIds,
            maxRecords: self.maxRecords,
            nextToken: token
        )}
}
extension AutoScalingClient {
    /// Paginate over `[DescribeLaunchConfigurationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeLaunchConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeLaunchConfigurationsOutput`
    public func describeLaunchConfigurationsPaginated(input: DescribeLaunchConfigurationsInput) -> ClientRuntime.PaginatorSequence<DescribeLaunchConfigurationsInput, DescribeLaunchConfigurationsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeLaunchConfigurationsInput, DescribeLaunchConfigurationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeLaunchConfigurations(input:))
    }
}

extension DescribeLaunchConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeLaunchConfigurationsInput {
        return DescribeLaunchConfigurationsInput(
            launchConfigurationNames: self.launchConfigurationNames,
            maxRecords: self.maxRecords,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeLaunchConfigurationsInput, OperationStackOutput == DescribeLaunchConfigurationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeLaunchConfigurationsPaginated`
    /// to access the nested member `[AutoScalingClientTypes.LaunchConfiguration]`
    /// - Returns: `[AutoScalingClientTypes.LaunchConfiguration]`
    public func launchConfigurations() async throws -> [AutoScalingClientTypes.LaunchConfiguration] {
        return try await self.asyncCompactMap { item in item.launchConfigurations }
    }
}
extension AutoScalingClient {
    /// Paginate over `[DescribeLoadBalancersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeLoadBalancersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeLoadBalancersOutput`
    public func describeLoadBalancersPaginated(input: DescribeLoadBalancersInput) -> ClientRuntime.PaginatorSequence<DescribeLoadBalancersInput, DescribeLoadBalancersOutput> {
        return ClientRuntime.PaginatorSequence<DescribeLoadBalancersInput, DescribeLoadBalancersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeLoadBalancers(input:))
    }
}

extension DescribeLoadBalancersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeLoadBalancersInput {
        return DescribeLoadBalancersInput(
            autoScalingGroupName: self.autoScalingGroupName,
            maxRecords: self.maxRecords,
            nextToken: token
        )}
}
extension AutoScalingClient {
    /// Paginate over `[DescribeLoadBalancerTargetGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeLoadBalancerTargetGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeLoadBalancerTargetGroupsOutput`
    public func describeLoadBalancerTargetGroupsPaginated(input: DescribeLoadBalancerTargetGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeLoadBalancerTargetGroupsInput, DescribeLoadBalancerTargetGroupsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeLoadBalancerTargetGroupsInput, DescribeLoadBalancerTargetGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeLoadBalancerTargetGroups(input:))
    }
}

extension DescribeLoadBalancerTargetGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeLoadBalancerTargetGroupsInput {
        return DescribeLoadBalancerTargetGroupsInput(
            autoScalingGroupName: self.autoScalingGroupName,
            maxRecords: self.maxRecords,
            nextToken: token
        )}
}
extension AutoScalingClient {
    /// Paginate over `[DescribeNotificationConfigurationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeNotificationConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeNotificationConfigurationsOutput`
    public func describeNotificationConfigurationsPaginated(input: DescribeNotificationConfigurationsInput) -> ClientRuntime.PaginatorSequence<DescribeNotificationConfigurationsInput, DescribeNotificationConfigurationsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeNotificationConfigurationsInput, DescribeNotificationConfigurationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeNotificationConfigurations(input:))
    }
}

extension DescribeNotificationConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeNotificationConfigurationsInput {
        return DescribeNotificationConfigurationsInput(
            autoScalingGroupNames: self.autoScalingGroupNames,
            maxRecords: self.maxRecords,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeNotificationConfigurationsInput, OperationStackOutput == DescribeNotificationConfigurationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeNotificationConfigurationsPaginated`
    /// to access the nested member `[AutoScalingClientTypes.NotificationConfiguration]`
    /// - Returns: `[AutoScalingClientTypes.NotificationConfiguration]`
    public func notificationConfigurations() async throws -> [AutoScalingClientTypes.NotificationConfiguration] {
        return try await self.asyncCompactMap { item in item.notificationConfigurations }
    }
}
extension AutoScalingClient {
    /// Paginate over `[DescribePoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribePoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribePoliciesOutput`
    public func describePoliciesPaginated(input: DescribePoliciesInput) -> ClientRuntime.PaginatorSequence<DescribePoliciesInput, DescribePoliciesOutput> {
        return ClientRuntime.PaginatorSequence<DescribePoliciesInput, DescribePoliciesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describePolicies(input:))
    }
}

extension DescribePoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePoliciesInput {
        return DescribePoliciesInput(
            autoScalingGroupName: self.autoScalingGroupName,
            maxRecords: self.maxRecords,
            nextToken: token,
            policyNames: self.policyNames,
            policyTypes: self.policyTypes
        )}
}

extension PaginatorSequence where OperationStackInput == DescribePoliciesInput, OperationStackOutput == DescribePoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describePoliciesPaginated`
    /// to access the nested member `[AutoScalingClientTypes.ScalingPolicy]`
    /// - Returns: `[AutoScalingClientTypes.ScalingPolicy]`
    public func scalingPolicies() async throws -> [AutoScalingClientTypes.ScalingPolicy] {
        return try await self.asyncCompactMap { item in item.scalingPolicies }
    }
}
extension AutoScalingClient {
    /// Paginate over `[DescribeScalingActivitiesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeScalingActivitiesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeScalingActivitiesOutput`
    public func describeScalingActivitiesPaginated(input: DescribeScalingActivitiesInput) -> ClientRuntime.PaginatorSequence<DescribeScalingActivitiesInput, DescribeScalingActivitiesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeScalingActivitiesInput, DescribeScalingActivitiesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeScalingActivities(input:))
    }
}

extension DescribeScalingActivitiesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeScalingActivitiesInput {
        return DescribeScalingActivitiesInput(
            activityIds: self.activityIds,
            autoScalingGroupName: self.autoScalingGroupName,
            includeDeletedGroups: self.includeDeletedGroups,
            maxRecords: self.maxRecords,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeScalingActivitiesInput, OperationStackOutput == DescribeScalingActivitiesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeScalingActivitiesPaginated`
    /// to access the nested member `[AutoScalingClientTypes.Activity]`
    /// - Returns: `[AutoScalingClientTypes.Activity]`
    public func activities() async throws -> [AutoScalingClientTypes.Activity] {
        return try await self.asyncCompactMap { item in item.activities }
    }
}
extension AutoScalingClient {
    /// Paginate over `[DescribeScheduledActionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeScheduledActionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeScheduledActionsOutput`
    public func describeScheduledActionsPaginated(input: DescribeScheduledActionsInput) -> ClientRuntime.PaginatorSequence<DescribeScheduledActionsInput, DescribeScheduledActionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeScheduledActionsInput, DescribeScheduledActionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeScheduledActions(input:))
    }
}

extension DescribeScheduledActionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeScheduledActionsInput {
        return DescribeScheduledActionsInput(
            autoScalingGroupName: self.autoScalingGroupName,
            endTime: self.endTime,
            maxRecords: self.maxRecords,
            nextToken: token,
            scheduledActionNames: self.scheduledActionNames,
            startTime: self.startTime
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeScheduledActionsInput, OperationStackOutput == DescribeScheduledActionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeScheduledActionsPaginated`
    /// to access the nested member `[AutoScalingClientTypes.ScheduledUpdateGroupAction]`
    /// - Returns: `[AutoScalingClientTypes.ScheduledUpdateGroupAction]`
    public func scheduledUpdateGroupActions() async throws -> [AutoScalingClientTypes.ScheduledUpdateGroupAction] {
        return try await self.asyncCompactMap { item in item.scheduledUpdateGroupActions }
    }
}
extension AutoScalingClient {
    /// Paginate over `[DescribeTagsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeTagsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeTagsOutput`
    public func describeTagsPaginated(input: DescribeTagsInput) -> ClientRuntime.PaginatorSequence<DescribeTagsInput, DescribeTagsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeTagsInput, DescribeTagsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeTags(input:))
    }
}

extension DescribeTagsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTagsInput {
        return DescribeTagsInput(
            filters: self.filters,
            maxRecords: self.maxRecords,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeTagsInput, OperationStackOutput == DescribeTagsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeTagsPaginated`
    /// to access the nested member `[AutoScalingClientTypes.TagDescription]`
    /// - Returns: `[AutoScalingClientTypes.TagDescription]`
    public func tags() async throws -> [AutoScalingClientTypes.TagDescription] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}
extension AutoScalingClient {
    /// Paginate over `[DescribeTrafficSourcesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeTrafficSourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeTrafficSourcesOutput`
    public func describeTrafficSourcesPaginated(input: DescribeTrafficSourcesInput) -> ClientRuntime.PaginatorSequence<DescribeTrafficSourcesInput, DescribeTrafficSourcesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeTrafficSourcesInput, DescribeTrafficSourcesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeTrafficSources(input:))
    }
}

extension DescribeTrafficSourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeTrafficSourcesInput {
        return DescribeTrafficSourcesInput(
            autoScalingGroupName: self.autoScalingGroupName,
            maxRecords: self.maxRecords,
            nextToken: token,
            trafficSourceType: self.trafficSourceType
        )}
}
extension AutoScalingClient {
    /// Paginate over `[DescribeWarmPoolOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeWarmPoolInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeWarmPoolOutput`
    public func describeWarmPoolPaginated(input: DescribeWarmPoolInput) -> ClientRuntime.PaginatorSequence<DescribeWarmPoolInput, DescribeWarmPoolOutput> {
        return ClientRuntime.PaginatorSequence<DescribeWarmPoolInput, DescribeWarmPoolOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeWarmPool(input:))
    }
}

extension DescribeWarmPoolInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeWarmPoolInput {
        return DescribeWarmPoolInput(
            autoScalingGroupName: self.autoScalingGroupName,
            maxRecords: self.maxRecords,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeWarmPoolInput, OperationStackOutput == DescribeWarmPoolOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeWarmPoolPaginated`
    /// to access the nested member `[AutoScalingClientTypes.Instance]`
    /// - Returns: `[AutoScalingClientTypes.Instance]`
    public func instances() async throws -> [AutoScalingClientTypes.Instance] {
        return try await self.asyncCompactMap { item in item.instances }
    }
}
