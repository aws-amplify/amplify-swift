//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError


public struct DescribeCustomerMetadataInput: Swift.Sendable {

    public init() { }
}

public struct DescribeLocationsInput: Swift.Sendable {

    public init() { }
}

public struct DescribeVirtualGatewaysInput: Swift.Sendable {

    public init() { }
}

/// One or more parameters are not valid.
public struct DirectConnectClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectConnectClientException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A server-side error occurred.
public struct DirectConnectServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DirectConnectServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DirectConnectClientTypes {

    /// Information about a route filter prefix that a customer can advertise through Border Gateway Protocol (BGP) over a public virtual interface.
    public struct RouteFilterPrefix: Swift.Sendable {
        /// The CIDR block for the advertised route. Separate multiple routes using commas. An IPv6 CIDR must use /64 or shorter.
        public var cidr: Swift.String?

        public init(
            cidr: Swift.String? = nil
        )
        {
            self.cidr = cidr
        }
    }
}

public struct AcceptDirectConnectGatewayAssociationProposalInput: Swift.Sendable {
    /// The ID of the Amazon Web Services account that owns the virtual private gateway or transit gateway.
    /// This member is required.
    public var associatedGatewayOwnerAccount: Swift.String?
    /// The ID of the Direct Connect gateway.
    /// This member is required.
    public var directConnectGatewayId: Swift.String?
    /// Overrides the Amazon VPC prefixes advertised to the Direct Connect gateway. For information about how to set the prefixes, see [Allowed Prefixes](https://docs.aws.amazon.com/directconnect/latest/UserGuide/multi-account-associate-vgw.html#allowed-prefixes) in the Direct Connect User Guide.
    public var overrideAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// The ID of the request proposal.
    /// This member is required.
    public var proposalId: Swift.String?

    public init(
        associatedGatewayOwnerAccount: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        overrideAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        proposalId: Swift.String? = nil
    )
    {
        self.associatedGatewayOwnerAccount = associatedGatewayOwnerAccount
        self.directConnectGatewayId = directConnectGatewayId
        self.overrideAllowedPrefixesToDirectConnectGateway = overrideAllowedPrefixesToDirectConnectGateway
        self.proposalId = proposalId
    }
}

extension DirectConnectClientTypes {

    public enum GatewayType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case transitgateway
        case virtualprivategateway
        case sdkUnknown(Swift.String)

        public static var allCases: [GatewayType] {
            return [
                .transitgateway,
                .virtualprivategateway
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .transitgateway: return "transitGateway"
            case .virtualprivategateway: return "virtualPrivateGateway"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DirectConnectClientTypes {

    /// Information about the associated gateway.
    public struct AssociatedGateway: Swift.Sendable {
        /// The ID of the associated gateway.
        public var id: Swift.String?
        /// The ID of the Amazon Web Services account that owns the associated virtual private gateway or transit gateway.
        public var ownerAccount: Swift.String?
        /// The Region where the associated gateway is located.
        public var region: Swift.String?
        /// The type of associated gateway.
        public var type: DirectConnectClientTypes.GatewayType?

        public init(
            id: Swift.String? = nil,
            ownerAccount: Swift.String? = nil,
            region: Swift.String? = nil,
            type: DirectConnectClientTypes.GatewayType? = nil
        )
        {
            self.id = id
            self.ownerAccount = ownerAccount
            self.region = region
            self.type = type
        }
    }
}

extension DirectConnectClientTypes {

    public enum DirectConnectGatewayAssociationState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case associated
        case associating
        case disassociated
        case disassociating
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectConnectGatewayAssociationState] {
            return [
                .associated,
                .associating,
                .disassociated,
                .disassociating,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .associated: return "associated"
            case .associating: return "associating"
            case .disassociated: return "disassociated"
            case .disassociating: return "disassociating"
            case .updating: return "updating"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DirectConnectClientTypes {

    /// Information about an association between a Direct Connect gateway and a virtual private gateway or transit gateway.
    public struct DirectConnectGatewayAssociation: Swift.Sendable {
        /// The Amazon VPC prefixes to advertise to the Direct Connect gateway.
        public var allowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?
        /// Information about the associated gateway.
        public var associatedGateway: DirectConnectClientTypes.AssociatedGateway?
        /// The ID of the Direct Connect gateway association.
        public var associationId: Swift.String?
        /// The state of the association. The following are the possible values:
        ///
        /// * associating: The initial state after calling [CreateDirectConnectGatewayAssociation].
        ///
        /// * associated: The Direct Connect gateway and virtual private gateway or transit gateway are successfully associated and ready to pass traffic.
        ///
        /// * disassociating: The initial state after calling [DeleteDirectConnectGatewayAssociation].
        ///
        /// * disassociated: The virtual private gateway or transit gateway is disassociated from the Direct Connect gateway. Traffic flow between the Direct Connect gateway and virtual private gateway or transit gateway is stopped.
        ///
        /// * updating: The CIDR blocks for the virtual private gateway or transit gateway are currently being updated. This could be new CIDR blocks added or current CIDR blocks removed.
        public var associationState: DirectConnectClientTypes.DirectConnectGatewayAssociationState?
        /// The ID of the Direct Connect gateway.
        public var directConnectGatewayId: Swift.String?
        /// The ID of the Amazon Web Services account that owns the associated gateway.
        public var directConnectGatewayOwnerAccount: Swift.String?
        /// The error message if the state of an object failed to advance.
        public var stateChangeError: Swift.String?
        /// The ID of the virtual private gateway. Applies only to private virtual interfaces.
        public var virtualGatewayId: Swift.String?
        /// The ID of the Amazon Web Services account that owns the virtual private gateway.
        public var virtualGatewayOwnerAccount: Swift.String?
        /// The Amazon Web Services Region where the virtual private gateway is located.
        @available(*, deprecated)
        public var virtualGatewayRegion: Swift.String?

        public init(
            allowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
            associatedGateway: DirectConnectClientTypes.AssociatedGateway? = nil,
            associationId: Swift.String? = nil,
            associationState: DirectConnectClientTypes.DirectConnectGatewayAssociationState? = nil,
            directConnectGatewayId: Swift.String? = nil,
            directConnectGatewayOwnerAccount: Swift.String? = nil,
            stateChangeError: Swift.String? = nil,
            virtualGatewayId: Swift.String? = nil,
            virtualGatewayOwnerAccount: Swift.String? = nil,
            virtualGatewayRegion: Swift.String? = nil
        )
        {
            self.allowedPrefixesToDirectConnectGateway = allowedPrefixesToDirectConnectGateway
            self.associatedGateway = associatedGateway
            self.associationId = associationId
            self.associationState = associationState
            self.directConnectGatewayId = directConnectGatewayId
            self.directConnectGatewayOwnerAccount = directConnectGatewayOwnerAccount
            self.stateChangeError = stateChangeError
            self.virtualGatewayId = virtualGatewayId
            self.virtualGatewayOwnerAccount = virtualGatewayOwnerAccount
            self.virtualGatewayRegion = virtualGatewayRegion
        }
    }
}

public struct AcceptDirectConnectGatewayAssociationProposalOutput: Swift.Sendable {
    /// Information about an association between a Direct Connect gateway and a virtual gateway or transit gateway.
    public var directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation?

    public init(
        directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation? = nil
    )
    {
        self.directConnectGatewayAssociation = directConnectGatewayAssociation
    }
}

extension DirectConnectClientTypes {

    public enum AddressFamily: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ipv4
        case ipv6
        case sdkUnknown(Swift.String)

        public static var allCases: [AddressFamily] {
            return [
                .ipv4,
                .ipv6
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ipv4: return "ipv4"
            case .ipv6: return "ipv6"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DirectConnectClientTypes {

    /// The name and status of a customer agreement.
    public struct CustomerAgreement: Swift.Sendable {
        /// The name of the agreement.
        public var agreementName: Swift.String?
        /// The status of the customer agreement. This will be either signed or unsigned
        public var status: Swift.String?

        public init(
            agreementName: Swift.String? = nil,
            status: Swift.String? = nil
        )
        {
            self.agreementName = agreementName
            self.status = status
        }
    }
}

public struct AllocateConnectionOnInterconnectInput: Swift.Sendable {
    /// The bandwidth of the connection. The possible values are 50Mbps, 100Mbps, 200Mbps, 300Mbps, 400Mbps, 500Mbps, 1Gbps, 2Gbps, 5Gbps, and 10Gbps. Note that only those Direct Connect Partners who have met specific requirements are allowed to create a 1Gbps, 2Gbps, 5Gbps or 10Gbps hosted connection.
    /// This member is required.
    public var bandwidth: Swift.String?
    /// The name of the provisioned connection.
    /// This member is required.
    public var connectionName: Swift.String?
    /// The ID of the interconnect on which the connection will be provisioned.
    /// This member is required.
    public var interconnectId: Swift.String?
    /// The ID of the Amazon Web Services account of the customer for whom the connection will be provisioned.
    /// This member is required.
    public var ownerAccount: Swift.String?
    /// The dedicated VLAN provisioned to the connection.
    /// This member is required.
    public var vlan: Swift.Int?

    public init(
        bandwidth: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        interconnectId: Swift.String? = nil,
        ownerAccount: Swift.String? = nil,
        vlan: Swift.Int? = 0
    )
    {
        self.bandwidth = bandwidth
        self.connectionName = connectionName
        self.interconnectId = interconnectId
        self.ownerAccount = ownerAccount
        self.vlan = vlan
    }
}

extension DirectConnectClientTypes {

    public enum ConnectionState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case down
        case ordering
        case pending
        case rejected
        case requested
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionState] {
            return [
                .available,
                .deleted,
                .deleting,
                .down,
                .ordering,
                .pending,
                .rejected,
                .requested,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .deleted: return "deleted"
            case .deleting: return "deleting"
            case .down: return "down"
            case .ordering: return "ordering"
            case .pending: return "pending"
            case .rejected: return "rejected"
            case .requested: return "requested"
            case .unknown: return "unknown"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DirectConnectClientTypes {

    public enum HasLogicalRedundancy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case no
        case unknown
        case yes
        case sdkUnknown(Swift.String)

        public static var allCases: [HasLogicalRedundancy] {
            return [
                .no,
                .unknown,
                .yes
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .no: return "no"
            case .unknown: return "unknown"
            case .yes: return "yes"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DirectConnectClientTypes {

    /// Information about the MAC Security (MACsec) secret key.
    public struct MacSecKey: Swift.Sendable {
        /// The Connection Key Name (CKN) for the MAC Security secret key.
        public var ckn: Swift.String?
        /// The Amazon Resource Name (ARN) of the MAC Security (MACsec) secret key.
        public var secretARN: Swift.String?
        /// The date that the MAC Security (MACsec) secret key takes effect. The value is displayed in UTC format.
        public var startOn: Swift.String?
        /// The state of the MAC Security (MACsec) secret key. The possible values are:
        ///
        /// * associating: The MAC Security (MACsec) secret key is being validated and not yet associated with the connection or LAG.
        ///
        /// * associated: The MAC Security (MACsec) secret key is validated and associated with the connection or LAG.
        ///
        /// * disassociating: The MAC Security (MACsec) secret key is being disassociated from the connection or LAG
        ///
        /// * disassociated: The MAC Security (MACsec) secret key is no longer associated with the connection or LAG.
        public var state: Swift.String?

        public init(
            ckn: Swift.String? = nil,
            secretARN: Swift.String? = nil,
            startOn: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.ckn = ckn
            self.secretARN = secretARN
            self.startOn = startOn
            self.state = state
        }
    }
}

extension DirectConnectClientTypes {

    /// Information about a tag.
    public struct Tag: Swift.Sendable {
        /// The key.
        /// This member is required.
        public var key: Swift.String?
        /// The value.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

/// Information about an Direct Connect connection.
public struct AllocateConnectionOnInterconnectOutput: Swift.Sendable {
    /// The Direct Connect endpoint on which the physical connection terminates.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The bandwidth of the connection.
    public var bandwidth: Swift.String?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The name of the connection.
    public var connectionName: Swift.String?
    /// The state of the connection. The following are the possible values:
    ///
    /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
    ///
    /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The connection has been approved and is being initialized.
    ///
    /// * available: The network link is up and the connection is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The connection is being deleted.
    ///
    /// * deleted: The connection has been deleted.
    ///
    /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
    ///
    /// * unknown: The state of the connection is not available.
    public var connectionState: DirectConnectClientTypes.ConnectionState?
    /// The MAC Security (MACsec) connection encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The time of the most recent call to [DescribeLoa] for this connection.
    public var loaIssueTime: Foundation.Date?
    /// The location of the connection.
    public var location: Swift.String?
    /// Indicates whether the connection supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The ID of the Amazon Web Services account that owns the connection.
    public var ownerAccount: Swift.String?
    /// The name of the Direct Connect service provider associated with the connection.
    public var partnerName: Swift.String?
    /// The MAC Security (MACsec) port link status of the connection. The valid values are Encryption Up, which means that there is an active Connection Key Name, or Encryption Down.
    public var portEncryptionStatus: Swift.String?
    /// The name of the service provider associated with the connection.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the connection.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init(
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bandwidth: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        connectionState: DirectConnectClientTypes.ConnectionState? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        loaIssueTime: Foundation.Date? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        ownerAccount: Swift.String? = nil,
        partnerName: Swift.String? = nil,
        portEncryptionStatus: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

/// A tag key was specified more than once.
public struct DuplicateTagKeysException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateTagKeysException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have reached the limit on the number of tags that can be assigned.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AllocateHostedConnectionInput: Swift.Sendable {
    /// The bandwidth of the connection. The possible values are 50Mbps, 100Mbps, 200Mbps, 300Mbps, 400Mbps, 500Mbps, 1Gbps, 2Gbps, 5Gbps, 10Gbps, and 25Gbps. Note that only those Direct Connect Partners who have met specific requirements are allowed to create a 1Gbps, 2Gbps, 5Gbps, 10Gbps, or 25Gbps hosted connection.
    /// This member is required.
    public var bandwidth: Swift.String?
    /// The ID of the interconnect or LAG.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The name of the hosted connection.
    /// This member is required.
    public var connectionName: Swift.String?
    /// The ID of the Amazon Web Services account ID of the customer for the connection.
    /// This member is required.
    public var ownerAccount: Swift.String?
    /// The tags associated with the connection.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The dedicated VLAN provisioned to the hosted connection.
    /// This member is required.
    public var vlan: Swift.Int?

    public init(
        bandwidth: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        ownerAccount: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        vlan: Swift.Int? = 0
    )
    {
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.ownerAccount = ownerAccount
        self.tags = tags
        self.vlan = vlan
    }
}

/// Information about an Direct Connect connection.
public struct AllocateHostedConnectionOutput: Swift.Sendable {
    /// The Direct Connect endpoint on which the physical connection terminates.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The bandwidth of the connection.
    public var bandwidth: Swift.String?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The name of the connection.
    public var connectionName: Swift.String?
    /// The state of the connection. The following are the possible values:
    ///
    /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
    ///
    /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The connection has been approved and is being initialized.
    ///
    /// * available: The network link is up and the connection is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The connection is being deleted.
    ///
    /// * deleted: The connection has been deleted.
    ///
    /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
    ///
    /// * unknown: The state of the connection is not available.
    public var connectionState: DirectConnectClientTypes.ConnectionState?
    /// The MAC Security (MACsec) connection encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The time of the most recent call to [DescribeLoa] for this connection.
    public var loaIssueTime: Foundation.Date?
    /// The location of the connection.
    public var location: Swift.String?
    /// Indicates whether the connection supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The ID of the Amazon Web Services account that owns the connection.
    public var ownerAccount: Swift.String?
    /// The name of the Direct Connect service provider associated with the connection.
    public var partnerName: Swift.String?
    /// The MAC Security (MACsec) port link status of the connection. The valid values are Encryption Up, which means that there is an active Connection Key Name, or Encryption Down.
    public var portEncryptionStatus: Swift.String?
    /// The name of the service provider associated with the connection.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the connection.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init(
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bandwidth: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        connectionState: DirectConnectClientTypes.ConnectionState? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        loaIssueTime: Foundation.Date? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        ownerAccount: Swift.String? = nil,
        partnerName: Swift.String? = nil,
        portEncryptionStatus: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

extension DirectConnectClientTypes {

    /// Information about a private virtual interface to be provisioned on a connection.
    public struct NewPrivateVirtualInterfaceAllocation: Swift.Sendable {
        /// The address family for the BGP peer.
        public var addressFamily: DirectConnectClientTypes.AddressFamily?
        /// The IP address assigned to the Amazon interface.
        public var amazonAddress: Swift.String?
        /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
        /// This member is required.
        public var asn: Swift.Int
        /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
        public var authKey: Swift.String?
        /// The IP address assigned to the customer interface.
        public var customerAddress: Swift.String?
        /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 8500. The default value is 1500.
        public var mtu: Swift.Int?
        /// The tags associated with the private virtual interface.
        public var tags: [DirectConnectClientTypes.Tag]?
        /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
        /// This member is required.
        public var virtualInterfaceName: Swift.String?
        /// The ID of the VLAN.
        /// This member is required.
        public var vlan: Swift.Int

        public init(
            addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
            amazonAddress: Swift.String? = nil,
            asn: Swift.Int = 0,
            authKey: Swift.String? = nil,
            customerAddress: Swift.String? = nil,
            mtu: Swift.Int? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil,
            virtualInterfaceName: Swift.String? = nil,
            vlan: Swift.Int = 0
        )
        {
            self.addressFamily = addressFamily
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.authKey = authKey
            self.customerAddress = customerAddress
            self.mtu = mtu
            self.tags = tags
            self.virtualInterfaceName = virtualInterfaceName
            self.vlan = vlan
        }
    }
}

public struct AllocatePrivateVirtualInterfaceInput: Swift.Sendable {
    /// The ID of the connection on which the private virtual interface is provisioned.
    /// This member is required.
    public var connectionId: Swift.String?
    /// Information about the private virtual interface.
    /// This member is required.
    public var newPrivateVirtualInterfaceAllocation: DirectConnectClientTypes.NewPrivateVirtualInterfaceAllocation?
    /// The ID of the Amazon Web Services account that owns the virtual private interface.
    /// This member is required.
    public var ownerAccount: Swift.String?

    public init(
        connectionId: Swift.String? = nil,
        newPrivateVirtualInterfaceAllocation: DirectConnectClientTypes.NewPrivateVirtualInterfaceAllocation? = nil,
        ownerAccount: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.newPrivateVirtualInterfaceAllocation = newPrivateVirtualInterfaceAllocation
        self.ownerAccount = ownerAccount
    }
}

extension DirectConnectClientTypes {

    public enum BGPPeerState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case pending
        case verifying
        case sdkUnknown(Swift.String)

        public static var allCases: [BGPPeerState] {
            return [
                .available,
                .deleted,
                .deleting,
                .pending,
                .verifying
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .deleted: return "deleted"
            case .deleting: return "deleting"
            case .pending: return "pending"
            case .verifying: return "verifying"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DirectConnectClientTypes {

    public enum BGPStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case down
        case unknown
        case up
        case sdkUnknown(Swift.String)

        public static var allCases: [BGPStatus] {
            return [
                .down,
                .unknown,
                .up
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .down: return "down"
            case .unknown: return "unknown"
            case .up: return "up"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DirectConnectClientTypes {

    /// Information about a BGP peer.
    public struct BGPPeer: Swift.Sendable {
        /// The address family for the BGP peer.
        public var addressFamily: DirectConnectClientTypes.AddressFamily?
        /// The IP address assigned to the Amazon interface.
        public var amazonAddress: Swift.String?
        /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
        public var asn: Swift.Int
        /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
        public var authKey: Swift.String?
        /// The Direct Connect endpoint that terminates the BGP peer.
        public var awsDeviceV2: Swift.String?
        /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
        public var awsLogicalDeviceId: Swift.String?
        /// The ID of the BGP peer.
        public var bgpPeerId: Swift.String?
        /// The state of the BGP peer. The following are the possible values:
        ///
        /// * verifying: The BGP peering addresses or ASN require validation before the BGP peer can be created. This state applies only to public virtual interfaces.
        ///
        /// * pending: The BGP peer is created, and remains in this state until it is ready to be established.
        ///
        /// * available: The BGP peer is ready to be established.
        ///
        /// * deleting: The BGP peer is being deleted.
        ///
        /// * deleted: The BGP peer is deleted and cannot be established.
        public var bgpPeerState: DirectConnectClientTypes.BGPPeerState?
        /// The status of the BGP peer. The following are the possible values:
        ///
        /// * up: The BGP peer is established. This state does not indicate the state of the routing function. Ensure that you are receiving routes over the BGP session.
        ///
        /// * down: The BGP peer is down.
        ///
        /// * unknown: The BGP peer status is not available.
        public var bgpStatus: DirectConnectClientTypes.BGPStatus?
        /// The IP address assigned to the customer interface.
        public var customerAddress: Swift.String?

        public init(
            addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
            amazonAddress: Swift.String? = nil,
            asn: Swift.Int = 0,
            authKey: Swift.String? = nil,
            awsDeviceV2: Swift.String? = nil,
            awsLogicalDeviceId: Swift.String? = nil,
            bgpPeerId: Swift.String? = nil,
            bgpPeerState: DirectConnectClientTypes.BGPPeerState? = nil,
            bgpStatus: DirectConnectClientTypes.BGPStatus? = nil,
            customerAddress: Swift.String? = nil
        )
        {
            self.addressFamily = addressFamily
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.authKey = authKey
            self.awsDeviceV2 = awsDeviceV2
            self.awsLogicalDeviceId = awsLogicalDeviceId
            self.bgpPeerId = bgpPeerId
            self.bgpPeerState = bgpPeerState
            self.bgpStatus = bgpStatus
            self.customerAddress = customerAddress
        }
    }
}

extension DirectConnectClientTypes {

    public enum VirtualInterfaceState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case confirming
        case deleted
        case deleting
        case down
        case pending
        case rejected
        case unknown
        case verifying
        case sdkUnknown(Swift.String)

        public static var allCases: [VirtualInterfaceState] {
            return [
                .available,
                .confirming,
                .deleted,
                .deleting,
                .down,
                .pending,
                .rejected,
                .unknown,
                .verifying
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .confirming: return "confirming"
            case .deleted: return "deleted"
            case .deleting: return "deleting"
            case .down: return "down"
            case .pending: return "pending"
            case .rejected: return "rejected"
            case .unknown: return "unknown"
            case .verifying: return "verifying"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Information about a virtual interface.
public struct AllocatePrivateVirtualInterfaceOutput: Swift.Sendable {
    /// The address family for the BGP peer.
    public var addressFamily: DirectConnectClientTypes.AddressFamily?
    /// The IP address assigned to the Amazon interface.
    public var amazonAddress: Swift.String?
    /// The autonomous system number (ASN) for the Amazon side of the connection.
    public var amazonSideAsn: Swift.Int?
    /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
    public var asn: Swift.Int
    /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
    public var authKey: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The BGP peers configured on this virtual interface.
    public var bgpPeers: [DirectConnectClientTypes.BGPPeer]?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The IP address assigned to the customer interface.
    public var customerAddress: Swift.String?
    /// The customer router configuration.
    public var customerRouterConfig: Swift.String?
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// Indicates whether jumbo frames are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The location of the connection.
    public var location: Swift.String?
    /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 8500. The default value is 1500
    public var mtu: Swift.Int?
    /// The ID of the Amazon Web Services account that owns the virtual interface.
    public var ownerAccount: Swift.String?
    /// The Amazon Web Services Region where the virtual interface is located.
    public var region: Swift.String?
    /// The routes to be advertised to the Amazon Web Services network in this Region. Applies to public virtual interfaces.
    public var routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// Indicates whether SiteLink is enabled.
    public var siteLinkEnabled: Swift.Bool?
    /// The tags associated with the virtual interface.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the virtual private gateway. Applies only to private virtual interfaces.
    public var virtualGatewayId: Swift.String?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?
    /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
    public var virtualInterfaceName: Swift.String?
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
    /// The type of virtual interface. The possible values are private, public and transit.
    public var virtualInterfaceType: Swift.String?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init(
        addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
        amazonAddress: Swift.String? = nil,
        amazonSideAsn: Swift.Int? = nil,
        asn: Swift.Int = 0,
        authKey: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bgpPeers: [DirectConnectClientTypes.BGPPeer]? = nil,
        connectionId: Swift.String? = nil,
        customerAddress: Swift.String? = nil,
        customerRouterConfig: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        location: Swift.String? = nil,
        mtu: Swift.Int? = nil,
        ownerAccount: Swift.String? = nil,
        region: Swift.String? = nil,
        routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        siteLinkEnabled: Swift.Bool? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        virtualGatewayId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil,
        virtualInterfaceName: Swift.String? = nil,
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil,
        virtualInterfaceType: Swift.String? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.amazonSideAsn = amazonSideAsn
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bgpPeers = bgpPeers
        self.connectionId = connectionId
        self.customerAddress = customerAddress
        self.customerRouterConfig = customerRouterConfig
        self.directConnectGatewayId = directConnectGatewayId
        self.jumboFrameCapable = jumboFrameCapable
        self.location = location
        self.mtu = mtu
        self.ownerAccount = ownerAccount
        self.region = region
        self.routeFilterPrefixes = routeFilterPrefixes
        self.siteLinkEnabled = siteLinkEnabled
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
        self.virtualInterfaceState = virtualInterfaceState
        self.virtualInterfaceType = virtualInterfaceType
        self.vlan = vlan
    }
}

extension DirectConnectClientTypes {

    /// Information about a public virtual interface to be provisioned on a connection.
    public struct NewPublicVirtualInterfaceAllocation: Swift.Sendable {
        /// The address family for the BGP peer.
        public var addressFamily: DirectConnectClientTypes.AddressFamily?
        /// The IP address assigned to the Amazon interface.
        public var amazonAddress: Swift.String?
        /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
        /// This member is required.
        public var asn: Swift.Int
        /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
        public var authKey: Swift.String?
        /// The IP address assigned to the customer interface.
        public var customerAddress: Swift.String?
        /// The routes to be advertised to the Amazon Web Services network in this Region. Applies to public virtual interfaces.
        public var routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
        /// The tags associated with the public virtual interface.
        public var tags: [DirectConnectClientTypes.Tag]?
        /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
        /// This member is required.
        public var virtualInterfaceName: Swift.String?
        /// The ID of the VLAN.
        /// This member is required.
        public var vlan: Swift.Int

        public init(
            addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
            amazonAddress: Swift.String? = nil,
            asn: Swift.Int = 0,
            authKey: Swift.String? = nil,
            customerAddress: Swift.String? = nil,
            routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil,
            virtualInterfaceName: Swift.String? = nil,
            vlan: Swift.Int = 0
        )
        {
            self.addressFamily = addressFamily
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.authKey = authKey
            self.customerAddress = customerAddress
            self.routeFilterPrefixes = routeFilterPrefixes
            self.tags = tags
            self.virtualInterfaceName = virtualInterfaceName
            self.vlan = vlan
        }
    }
}

public struct AllocatePublicVirtualInterfaceInput: Swift.Sendable {
    /// The ID of the connection on which the public virtual interface is provisioned.
    /// This member is required.
    public var connectionId: Swift.String?
    /// Information about the public virtual interface.
    /// This member is required.
    public var newPublicVirtualInterfaceAllocation: DirectConnectClientTypes.NewPublicVirtualInterfaceAllocation?
    /// The ID of the Amazon Web Services account that owns the public virtual interface.
    /// This member is required.
    public var ownerAccount: Swift.String?

    public init(
        connectionId: Swift.String? = nil,
        newPublicVirtualInterfaceAllocation: DirectConnectClientTypes.NewPublicVirtualInterfaceAllocation? = nil,
        ownerAccount: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.newPublicVirtualInterfaceAllocation = newPublicVirtualInterfaceAllocation
        self.ownerAccount = ownerAccount
    }
}

/// Information about a virtual interface.
public struct AllocatePublicVirtualInterfaceOutput: Swift.Sendable {
    /// The address family for the BGP peer.
    public var addressFamily: DirectConnectClientTypes.AddressFamily?
    /// The IP address assigned to the Amazon interface.
    public var amazonAddress: Swift.String?
    /// The autonomous system number (ASN) for the Amazon side of the connection.
    public var amazonSideAsn: Swift.Int?
    /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
    public var asn: Swift.Int
    /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
    public var authKey: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The BGP peers configured on this virtual interface.
    public var bgpPeers: [DirectConnectClientTypes.BGPPeer]?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The IP address assigned to the customer interface.
    public var customerAddress: Swift.String?
    /// The customer router configuration.
    public var customerRouterConfig: Swift.String?
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// Indicates whether jumbo frames are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The location of the connection.
    public var location: Swift.String?
    /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 8500. The default value is 1500
    public var mtu: Swift.Int?
    /// The ID of the Amazon Web Services account that owns the virtual interface.
    public var ownerAccount: Swift.String?
    /// The Amazon Web Services Region where the virtual interface is located.
    public var region: Swift.String?
    /// The routes to be advertised to the Amazon Web Services network in this Region. Applies to public virtual interfaces.
    public var routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// Indicates whether SiteLink is enabled.
    public var siteLinkEnabled: Swift.Bool?
    /// The tags associated with the virtual interface.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the virtual private gateway. Applies only to private virtual interfaces.
    public var virtualGatewayId: Swift.String?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?
    /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
    public var virtualInterfaceName: Swift.String?
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
    /// The type of virtual interface. The possible values are private, public and transit.
    public var virtualInterfaceType: Swift.String?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init(
        addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
        amazonAddress: Swift.String? = nil,
        amazonSideAsn: Swift.Int? = nil,
        asn: Swift.Int = 0,
        authKey: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bgpPeers: [DirectConnectClientTypes.BGPPeer]? = nil,
        connectionId: Swift.String? = nil,
        customerAddress: Swift.String? = nil,
        customerRouterConfig: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        location: Swift.String? = nil,
        mtu: Swift.Int? = nil,
        ownerAccount: Swift.String? = nil,
        region: Swift.String? = nil,
        routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        siteLinkEnabled: Swift.Bool? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        virtualGatewayId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil,
        virtualInterfaceName: Swift.String? = nil,
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil,
        virtualInterfaceType: Swift.String? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.amazonSideAsn = amazonSideAsn
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bgpPeers = bgpPeers
        self.connectionId = connectionId
        self.customerAddress = customerAddress
        self.customerRouterConfig = customerRouterConfig
        self.directConnectGatewayId = directConnectGatewayId
        self.jumboFrameCapable = jumboFrameCapable
        self.location = location
        self.mtu = mtu
        self.ownerAccount = ownerAccount
        self.region = region
        self.routeFilterPrefixes = routeFilterPrefixes
        self.siteLinkEnabled = siteLinkEnabled
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
        self.virtualInterfaceState = virtualInterfaceState
        self.virtualInterfaceType = virtualInterfaceType
        self.vlan = vlan
    }
}

extension DirectConnectClientTypes {

    /// Information about a transit virtual interface to be provisioned on a connection.
    public struct NewTransitVirtualInterfaceAllocation: Swift.Sendable {
        /// The address family for the BGP peer.
        public var addressFamily: DirectConnectClientTypes.AddressFamily?
        /// The IP address assigned to the Amazon interface.
        public var amazonAddress: Swift.String?
        /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
        public var asn: Swift.Int
        /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
        public var authKey: Swift.String?
        /// The IP address assigned to the customer interface.
        public var customerAddress: Swift.String?
        /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 8500. The default value is 1500
        public var mtu: Swift.Int?
        /// The tags associated with the transitive virtual interface.
        public var tags: [DirectConnectClientTypes.Tag]?
        /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
        public var virtualInterfaceName: Swift.String?
        /// The ID of the VLAN.
        public var vlan: Swift.Int

        public init(
            addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
            amazonAddress: Swift.String? = nil,
            asn: Swift.Int = 0,
            authKey: Swift.String? = nil,
            customerAddress: Swift.String? = nil,
            mtu: Swift.Int? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil,
            virtualInterfaceName: Swift.String? = nil,
            vlan: Swift.Int = 0
        )
        {
            self.addressFamily = addressFamily
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.authKey = authKey
            self.customerAddress = customerAddress
            self.mtu = mtu
            self.tags = tags
            self.virtualInterfaceName = virtualInterfaceName
            self.vlan = vlan
        }
    }
}

public struct AllocateTransitVirtualInterfaceInput: Swift.Sendable {
    /// The ID of the connection on which the transit virtual interface is provisioned.
    /// This member is required.
    public var connectionId: Swift.String?
    /// Information about the transit virtual interface.
    /// This member is required.
    public var newTransitVirtualInterfaceAllocation: DirectConnectClientTypes.NewTransitVirtualInterfaceAllocation?
    /// The ID of the Amazon Web Services account that owns the transit virtual interface.
    /// This member is required.
    public var ownerAccount: Swift.String?

    public init(
        connectionId: Swift.String? = nil,
        newTransitVirtualInterfaceAllocation: DirectConnectClientTypes.NewTransitVirtualInterfaceAllocation? = nil,
        ownerAccount: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.newTransitVirtualInterfaceAllocation = newTransitVirtualInterfaceAllocation
        self.ownerAccount = ownerAccount
    }
}

extension DirectConnectClientTypes {

    /// Information about a virtual interface.
    public struct VirtualInterface: Swift.Sendable {
        /// The address family for the BGP peer.
        public var addressFamily: DirectConnectClientTypes.AddressFamily?
        /// The IP address assigned to the Amazon interface.
        public var amazonAddress: Swift.String?
        /// The autonomous system number (ASN) for the Amazon side of the connection.
        public var amazonSideAsn: Swift.Int?
        /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
        public var asn: Swift.Int
        /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
        public var authKey: Swift.String?
        /// The Direct Connect endpoint that terminates the physical connection.
        public var awsDeviceV2: Swift.String?
        /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
        public var awsLogicalDeviceId: Swift.String?
        /// The BGP peers configured on this virtual interface.
        public var bgpPeers: [DirectConnectClientTypes.BGPPeer]?
        /// The ID of the connection.
        public var connectionId: Swift.String?
        /// The IP address assigned to the customer interface.
        public var customerAddress: Swift.String?
        /// The customer router configuration.
        public var customerRouterConfig: Swift.String?
        /// The ID of the Direct Connect gateway.
        public var directConnectGatewayId: Swift.String?
        /// Indicates whether jumbo frames are supported.
        public var jumboFrameCapable: Swift.Bool?
        /// The location of the connection.
        public var location: Swift.String?
        /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 8500. The default value is 1500
        public var mtu: Swift.Int?
        /// The ID of the Amazon Web Services account that owns the virtual interface.
        public var ownerAccount: Swift.String?
        /// The Amazon Web Services Region where the virtual interface is located.
        public var region: Swift.String?
        /// The routes to be advertised to the Amazon Web Services network in this Region. Applies to public virtual interfaces.
        public var routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
        /// Indicates whether SiteLink is enabled.
        public var siteLinkEnabled: Swift.Bool?
        /// The tags associated with the virtual interface.
        public var tags: [DirectConnectClientTypes.Tag]?
        /// The ID of the virtual private gateway. Applies only to private virtual interfaces.
        public var virtualGatewayId: Swift.String?
        /// The ID of the virtual interface.
        public var virtualInterfaceId: Swift.String?
        /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
        public var virtualInterfaceName: Swift.String?
        /// The state of the virtual interface. The following are the possible values:
        ///
        /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
        ///
        /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
        ///
        /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
        ///
        /// * available: A virtual interface that is able to forward traffic.
        ///
        /// * down: A virtual interface that is BGP down.
        ///
        /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
        ///
        /// * deleted: A virtual interface that cannot forward traffic.
        ///
        /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
        ///
        /// * unknown: The state of the virtual interface is not available.
        public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
        /// The type of virtual interface. The possible values are private, public and transit.
        public var virtualInterfaceType: Swift.String?
        /// The ID of the VLAN.
        public var vlan: Swift.Int

        public init(
            addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
            amazonAddress: Swift.String? = nil,
            amazonSideAsn: Swift.Int? = nil,
            asn: Swift.Int = 0,
            authKey: Swift.String? = nil,
            awsDeviceV2: Swift.String? = nil,
            awsLogicalDeviceId: Swift.String? = nil,
            bgpPeers: [DirectConnectClientTypes.BGPPeer]? = nil,
            connectionId: Swift.String? = nil,
            customerAddress: Swift.String? = nil,
            customerRouterConfig: Swift.String? = nil,
            directConnectGatewayId: Swift.String? = nil,
            jumboFrameCapable: Swift.Bool? = nil,
            location: Swift.String? = nil,
            mtu: Swift.Int? = nil,
            ownerAccount: Swift.String? = nil,
            region: Swift.String? = nil,
            routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
            siteLinkEnabled: Swift.Bool? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil,
            virtualGatewayId: Swift.String? = nil,
            virtualInterfaceId: Swift.String? = nil,
            virtualInterfaceName: Swift.String? = nil,
            virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil,
            virtualInterfaceType: Swift.String? = nil,
            vlan: Swift.Int = 0
        )
        {
            self.addressFamily = addressFamily
            self.amazonAddress = amazonAddress
            self.amazonSideAsn = amazonSideAsn
            self.asn = asn
            self.authKey = authKey
            self.awsDeviceV2 = awsDeviceV2
            self.awsLogicalDeviceId = awsLogicalDeviceId
            self.bgpPeers = bgpPeers
            self.connectionId = connectionId
            self.customerAddress = customerAddress
            self.customerRouterConfig = customerRouterConfig
            self.directConnectGatewayId = directConnectGatewayId
            self.jumboFrameCapable = jumboFrameCapable
            self.location = location
            self.mtu = mtu
            self.ownerAccount = ownerAccount
            self.region = region
            self.routeFilterPrefixes = routeFilterPrefixes
            self.siteLinkEnabled = siteLinkEnabled
            self.tags = tags
            self.virtualGatewayId = virtualGatewayId
            self.virtualInterfaceId = virtualInterfaceId
            self.virtualInterfaceName = virtualInterfaceName
            self.virtualInterfaceState = virtualInterfaceState
            self.virtualInterfaceType = virtualInterfaceType
            self.vlan = vlan
        }
    }
}

public struct AllocateTransitVirtualInterfaceOutput: Swift.Sendable {
    /// Information about the transit virtual interface.
    public var virtualInterface: DirectConnectClientTypes.VirtualInterface?

    public init(
        virtualInterface: DirectConnectClientTypes.VirtualInterface? = nil
    )
    {
        self.virtualInterface = virtualInterface
    }
}

public struct AssociateConnectionWithLagInput: Swift.Sendable {
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The ID of the LAG with which to associate the connection.
    /// This member is required.
    public var lagId: Swift.String?

    public init(
        connectionId: Swift.String? = nil,
        lagId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.lagId = lagId
    }
}

/// Information about an Direct Connect connection.
public struct AssociateConnectionWithLagOutput: Swift.Sendable {
    /// The Direct Connect endpoint on which the physical connection terminates.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The bandwidth of the connection.
    public var bandwidth: Swift.String?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The name of the connection.
    public var connectionName: Swift.String?
    /// The state of the connection. The following are the possible values:
    ///
    /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
    ///
    /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The connection has been approved and is being initialized.
    ///
    /// * available: The network link is up and the connection is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The connection is being deleted.
    ///
    /// * deleted: The connection has been deleted.
    ///
    /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
    ///
    /// * unknown: The state of the connection is not available.
    public var connectionState: DirectConnectClientTypes.ConnectionState?
    /// The MAC Security (MACsec) connection encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The time of the most recent call to [DescribeLoa] for this connection.
    public var loaIssueTime: Foundation.Date?
    /// The location of the connection.
    public var location: Swift.String?
    /// Indicates whether the connection supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The ID of the Amazon Web Services account that owns the connection.
    public var ownerAccount: Swift.String?
    /// The name of the Direct Connect service provider associated with the connection.
    public var partnerName: Swift.String?
    /// The MAC Security (MACsec) port link status of the connection. The valid values are Encryption Up, which means that there is an active Connection Key Name, or Encryption Down.
    public var portEncryptionStatus: Swift.String?
    /// The name of the service provider associated with the connection.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the connection.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init(
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bandwidth: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        connectionState: DirectConnectClientTypes.ConnectionState? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        loaIssueTime: Foundation.Date? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        ownerAccount: Swift.String? = nil,
        partnerName: Swift.String? = nil,
        portEncryptionStatus: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

public struct AssociateHostedConnectionInput: Swift.Sendable {
    /// The ID of the hosted connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The ID of the interconnect or the LAG.
    /// This member is required.
    public var parentConnectionId: Swift.String?

    public init(
        connectionId: Swift.String? = nil,
        parentConnectionId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.parentConnectionId = parentConnectionId
    }
}

/// Information about an Direct Connect connection.
public struct AssociateHostedConnectionOutput: Swift.Sendable {
    /// The Direct Connect endpoint on which the physical connection terminates.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The bandwidth of the connection.
    public var bandwidth: Swift.String?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The name of the connection.
    public var connectionName: Swift.String?
    /// The state of the connection. The following are the possible values:
    ///
    /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
    ///
    /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The connection has been approved and is being initialized.
    ///
    /// * available: The network link is up and the connection is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The connection is being deleted.
    ///
    /// * deleted: The connection has been deleted.
    ///
    /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
    ///
    /// * unknown: The state of the connection is not available.
    public var connectionState: DirectConnectClientTypes.ConnectionState?
    /// The MAC Security (MACsec) connection encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The time of the most recent call to [DescribeLoa] for this connection.
    public var loaIssueTime: Foundation.Date?
    /// The location of the connection.
    public var location: Swift.String?
    /// Indicates whether the connection supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The ID of the Amazon Web Services account that owns the connection.
    public var ownerAccount: Swift.String?
    /// The name of the Direct Connect service provider associated with the connection.
    public var partnerName: Swift.String?
    /// The MAC Security (MACsec) port link status of the connection. The valid values are Encryption Up, which means that there is an active Connection Key Name, or Encryption Down.
    public var portEncryptionStatus: Swift.String?
    /// The name of the service provider associated with the connection.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the connection.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init(
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bandwidth: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        connectionState: DirectConnectClientTypes.ConnectionState? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        loaIssueTime: Foundation.Date? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        ownerAccount: Swift.String? = nil,
        partnerName: Swift.String? = nil,
        portEncryptionStatus: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

public struct AssociateMacSecKeyInput: Swift.Sendable {
    /// The MAC Security (MACsec) CAK to associate with the dedicated connection. You can create the CKN/CAK pair using an industry standard tool. The valid values are 64 hexadecimal characters (0-9, A-E). If you use this request parameter, you must use the ckn request parameter and not use the secretARN request parameter.
    public var cak: Swift.String?
    /// The MAC Security (MACsec) CKN to associate with the dedicated connection. You can create the CKN/CAK pair using an industry standard tool. The valid values are 64 hexadecimal characters (0-9, A-E). If you use this request parameter, you must use the cak request parameter and not use the secretARN request parameter.
    public var ckn: Swift.String?
    /// The ID of the dedicated connection (dxcon-xxxx), or the ID of the LAG (dxlag-xxxx). You can use [DescribeConnections] or [DescribeLags] to retrieve connection ID.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the MAC Security (MACsec) secret key to associate with the dedicated connection. You can use [DescribeConnections] or [DescribeLags] to retrieve the MAC Security (MACsec) secret key. If you use this request parameter, you do not use the ckn and cak request parameters.
    public var secretARN: Swift.String?

    public init(
        cak: Swift.String? = nil,
        ckn: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        secretARN: Swift.String? = nil
    )
    {
        self.cak = cak
        self.ckn = ckn
        self.connectionId = connectionId
        self.secretARN = secretARN
    }
}

public struct AssociateMacSecKeyOutput: Swift.Sendable {
    /// The ID of the dedicated connection (dxcon-xxxx), or the ID of the LAG (dxlag-xxxx).
    public var connectionId: Swift.String?
    /// The MAC Security (MACsec) security keys associated with the dedicated connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?

    public init(
        connectionId: Swift.String? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil
    )
    {
        self.connectionId = connectionId
        self.macSecKeys = macSecKeys
    }
}

public struct AssociateVirtualInterfaceInput: Swift.Sendable {
    /// The ID of the LAG or connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The ID of the virtual interface.
    /// This member is required.
    public var virtualInterfaceId: Swift.String?

    public init(
        connectionId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.virtualInterfaceId = virtualInterfaceId
    }
}

/// Information about a virtual interface.
public struct AssociateVirtualInterfaceOutput: Swift.Sendable {
    /// The address family for the BGP peer.
    public var addressFamily: DirectConnectClientTypes.AddressFamily?
    /// The IP address assigned to the Amazon interface.
    public var amazonAddress: Swift.String?
    /// The autonomous system number (ASN) for the Amazon side of the connection.
    public var amazonSideAsn: Swift.Int?
    /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
    public var asn: Swift.Int
    /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
    public var authKey: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The BGP peers configured on this virtual interface.
    public var bgpPeers: [DirectConnectClientTypes.BGPPeer]?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The IP address assigned to the customer interface.
    public var customerAddress: Swift.String?
    /// The customer router configuration.
    public var customerRouterConfig: Swift.String?
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// Indicates whether jumbo frames are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The location of the connection.
    public var location: Swift.String?
    /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 8500. The default value is 1500
    public var mtu: Swift.Int?
    /// The ID of the Amazon Web Services account that owns the virtual interface.
    public var ownerAccount: Swift.String?
    /// The Amazon Web Services Region where the virtual interface is located.
    public var region: Swift.String?
    /// The routes to be advertised to the Amazon Web Services network in this Region. Applies to public virtual interfaces.
    public var routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// Indicates whether SiteLink is enabled.
    public var siteLinkEnabled: Swift.Bool?
    /// The tags associated with the virtual interface.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the virtual private gateway. Applies only to private virtual interfaces.
    public var virtualGatewayId: Swift.String?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?
    /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
    public var virtualInterfaceName: Swift.String?
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
    /// The type of virtual interface. The possible values are private, public and transit.
    public var virtualInterfaceType: Swift.String?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init(
        addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
        amazonAddress: Swift.String? = nil,
        amazonSideAsn: Swift.Int? = nil,
        asn: Swift.Int = 0,
        authKey: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bgpPeers: [DirectConnectClientTypes.BGPPeer]? = nil,
        connectionId: Swift.String? = nil,
        customerAddress: Swift.String? = nil,
        customerRouterConfig: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        location: Swift.String? = nil,
        mtu: Swift.Int? = nil,
        ownerAccount: Swift.String? = nil,
        region: Swift.String? = nil,
        routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        siteLinkEnabled: Swift.Bool? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        virtualGatewayId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil,
        virtualInterfaceName: Swift.String? = nil,
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil,
        virtualInterfaceType: Swift.String? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.amazonSideAsn = amazonSideAsn
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bgpPeers = bgpPeers
        self.connectionId = connectionId
        self.customerAddress = customerAddress
        self.customerRouterConfig = customerRouterConfig
        self.directConnectGatewayId = directConnectGatewayId
        self.jumboFrameCapable = jumboFrameCapable
        self.location = location
        self.mtu = mtu
        self.ownerAccount = ownerAccount
        self.region = region
        self.routeFilterPrefixes = routeFilterPrefixes
        self.siteLinkEnabled = siteLinkEnabled
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
        self.virtualInterfaceState = virtualInterfaceState
        self.virtualInterfaceType = virtualInterfaceType
        self.vlan = vlan
    }
}

public struct ConfirmConnectionInput: Swift.Sendable {
    /// The ID of the hosted connection.
    /// This member is required.
    public var connectionId: Swift.String?

    public init(
        connectionId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

public struct ConfirmConnectionOutput: Swift.Sendable {
    /// The state of the connection. The following are the possible values:
    ///
    /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
    ///
    /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The connection has been approved and is being initialized.
    ///
    /// * available: The network link is up and the connection is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The connection is being deleted.
    ///
    /// * deleted: The connection has been deleted.
    ///
    /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
    ///
    /// * unknown: The state of the connection is not available.
    public var connectionState: DirectConnectClientTypes.ConnectionState?

    public init(
        connectionState: DirectConnectClientTypes.ConnectionState? = nil
    )
    {
        self.connectionState = connectionState
    }
}

public struct ConfirmCustomerAgreementInput: Swift.Sendable {
    /// The name of the customer agreement.
    public var agreementName: Swift.String?

    public init(
        agreementName: Swift.String? = nil
    )
    {
        self.agreementName = agreementName
    }
}

public struct ConfirmCustomerAgreementOutput: Swift.Sendable {
    /// The status of the customer agreement when the connection was created. This will be either signed or unsigned.
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

public struct ConfirmPrivateVirtualInterfaceInput: Swift.Sendable {
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// The ID of the virtual private gateway.
    public var virtualGatewayId: Swift.String?
    /// The ID of the virtual interface.
    /// This member is required.
    public var virtualInterfaceId: Swift.String?

    public init(
        directConnectGatewayId: Swift.String? = nil,
        virtualGatewayId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.directConnectGatewayId = directConnectGatewayId
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
    }
}

public struct ConfirmPrivateVirtualInterfaceOutput: Swift.Sendable {
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?

    public init(
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil
    )
    {
        self.virtualInterfaceState = virtualInterfaceState
    }
}

public struct ConfirmPublicVirtualInterfaceInput: Swift.Sendable {
    /// The ID of the virtual interface.
    /// This member is required.
    public var virtualInterfaceId: Swift.String?

    public init(
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.virtualInterfaceId = virtualInterfaceId
    }
}

public struct ConfirmPublicVirtualInterfaceOutput: Swift.Sendable {
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?

    public init(
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil
    )
    {
        self.virtualInterfaceState = virtualInterfaceState
    }
}

public struct ConfirmTransitVirtualInterfaceInput: Swift.Sendable {
    /// The ID of the Direct Connect gateway.
    /// This member is required.
    public var directConnectGatewayId: Swift.String?
    /// The ID of the virtual interface.
    /// This member is required.
    public var virtualInterfaceId: Swift.String?

    public init(
        directConnectGatewayId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.directConnectGatewayId = directConnectGatewayId
        self.virtualInterfaceId = virtualInterfaceId
    }
}

public struct ConfirmTransitVirtualInterfaceOutput: Swift.Sendable {
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?

    public init(
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil
    )
    {
        self.virtualInterfaceState = virtualInterfaceState
    }
}

extension DirectConnectClientTypes {

    /// Information about an Direct Connect connection.
    public struct Connection: Swift.Sendable {
        /// The Direct Connect endpoint on which the physical connection terminates.
        @available(*, deprecated)
        public var awsDevice: Swift.String?
        /// The Direct Connect endpoint that terminates the physical connection.
        public var awsDeviceV2: Swift.String?
        /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
        public var awsLogicalDeviceId: Swift.String?
        /// The bandwidth of the connection.
        public var bandwidth: Swift.String?
        /// The ID of the connection.
        public var connectionId: Swift.String?
        /// The name of the connection.
        public var connectionName: Swift.String?
        /// The state of the connection. The following are the possible values:
        ///
        /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
        ///
        /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
        ///
        /// * pending: The connection has been approved and is being initialized.
        ///
        /// * available: The network link is up and the connection is ready for use.
        ///
        /// * down: The network link is down.
        ///
        /// * deleting: The connection is being deleted.
        ///
        /// * deleted: The connection has been deleted.
        ///
        /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
        ///
        /// * unknown: The state of the connection is not available.
        public var connectionState: DirectConnectClientTypes.ConnectionState?
        /// The MAC Security (MACsec) connection encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
        public var encryptionMode: Swift.String?
        /// Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).
        public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
        /// Indicates whether jumbo frames are supported.
        public var jumboFrameCapable: Swift.Bool?
        /// The ID of the LAG.
        public var lagId: Swift.String?
        /// The time of the most recent call to [DescribeLoa] for this connection.
        public var loaIssueTime: Foundation.Date?
        /// The location of the connection.
        public var location: Swift.String?
        /// Indicates whether the connection supports MAC Security (MACsec).
        public var macSecCapable: Swift.Bool?
        /// The MAC Security (MACsec) security keys associated with the connection.
        public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
        /// The ID of the Amazon Web Services account that owns the connection.
        public var ownerAccount: Swift.String?
        /// The name of the Direct Connect service provider associated with the connection.
        public var partnerName: Swift.String?
        /// The MAC Security (MACsec) port link status of the connection. The valid values are Encryption Up, which means that there is an active Connection Key Name, or Encryption Down.
        public var portEncryptionStatus: Swift.String?
        /// The name of the service provider associated with the connection.
        public var providerName: Swift.String?
        /// The Amazon Web Services Region where the connection is located.
        public var region: Swift.String?
        /// The tags associated with the connection.
        public var tags: [DirectConnectClientTypes.Tag]?
        /// The ID of the VLAN.
        public var vlan: Swift.Int

        public init(
            awsDevice: Swift.String? = nil,
            awsDeviceV2: Swift.String? = nil,
            awsLogicalDeviceId: Swift.String? = nil,
            bandwidth: Swift.String? = nil,
            connectionId: Swift.String? = nil,
            connectionName: Swift.String? = nil,
            connectionState: DirectConnectClientTypes.ConnectionState? = nil,
            encryptionMode: Swift.String? = nil,
            hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
            jumboFrameCapable: Swift.Bool? = nil,
            lagId: Swift.String? = nil,
            loaIssueTime: Foundation.Date? = nil,
            location: Swift.String? = nil,
            macSecCapable: Swift.Bool? = nil,
            macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
            ownerAccount: Swift.String? = nil,
            partnerName: Swift.String? = nil,
            portEncryptionStatus: Swift.String? = nil,
            providerName: Swift.String? = nil,
            region: Swift.String? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil,
            vlan: Swift.Int = 0
        )
        {
            self.awsDevice = awsDevice
            self.awsDeviceV2 = awsDeviceV2
            self.awsLogicalDeviceId = awsLogicalDeviceId
            self.bandwidth = bandwidth
            self.connectionId = connectionId
            self.connectionName = connectionName
            self.connectionState = connectionState
            self.encryptionMode = encryptionMode
            self.hasLogicalRedundancy = hasLogicalRedundancy
            self.jumboFrameCapable = jumboFrameCapable
            self.lagId = lagId
            self.loaIssueTime = loaIssueTime
            self.location = location
            self.macSecCapable = macSecCapable
            self.macSecKeys = macSecKeys
            self.ownerAccount = ownerAccount
            self.partnerName = partnerName
            self.portEncryptionStatus = portEncryptionStatus
            self.providerName = providerName
            self.region = region
            self.tags = tags
            self.vlan = vlan
        }
    }
}

extension DirectConnectClientTypes {

    /// Information about a new BGP peer.
    public struct NewBGPPeer: Swift.Sendable {
        /// The address family for the BGP peer.
        public var addressFamily: DirectConnectClientTypes.AddressFamily?
        /// The IP address assigned to the Amazon interface.
        public var amazonAddress: Swift.String?
        /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
        public var asn: Swift.Int
        /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
        public var authKey: Swift.String?
        /// The IP address assigned to the customer interface.
        public var customerAddress: Swift.String?

        public init(
            addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
            amazonAddress: Swift.String? = nil,
            asn: Swift.Int = 0,
            authKey: Swift.String? = nil,
            customerAddress: Swift.String? = nil
        )
        {
            self.addressFamily = addressFamily
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.authKey = authKey
            self.customerAddress = customerAddress
        }
    }
}

public struct CreateBGPPeerInput: Swift.Sendable {
    /// Information about the BGP peer.
    public var newBGPPeer: DirectConnectClientTypes.NewBGPPeer?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?

    public init(
        newBGPPeer: DirectConnectClientTypes.NewBGPPeer? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.newBGPPeer = newBGPPeer
        self.virtualInterfaceId = virtualInterfaceId
    }
}

public struct CreateBGPPeerOutput: Swift.Sendable {
    /// The virtual interface.
    public var virtualInterface: DirectConnectClientTypes.VirtualInterface?

    public init(
        virtualInterface: DirectConnectClientTypes.VirtualInterface? = nil
    )
    {
        self.virtualInterface = virtualInterface
    }
}

public struct CreateConnectionInput: Swift.Sendable {
    /// The bandwidth of the connection.
    /// This member is required.
    public var bandwidth: Swift.String?
    /// The name of the connection.
    /// This member is required.
    public var connectionName: Swift.String?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The location of the connection.
    /// This member is required.
    public var location: Swift.String?
    /// The name of the service provider associated with the requested connection.
    public var providerName: Swift.String?
    /// Indicates whether you want the connection to support MAC Security (MACsec). MAC Security (MACsec) is only available on dedicated connections. For information about MAC Security (MACsec) prerequisties, see [MACsec prerequisties](https://docs.aws.amazon.com/directconnect/latest/UserGuide/direct-connect-mac-sec-getting-started.html#mac-sec-prerequisites) in the Direct Connect User Guide.
    public var requestMACSec: Swift.Bool?
    /// The tags to associate with the lag.
    public var tags: [DirectConnectClientTypes.Tag]?

    public init(
        bandwidth: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        lagId: Swift.String? = nil,
        location: Swift.String? = nil,
        providerName: Swift.String? = nil,
        requestMACSec: Swift.Bool? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil
    )
    {
        self.bandwidth = bandwidth
        self.connectionName = connectionName
        self.lagId = lagId
        self.location = location
        self.providerName = providerName
        self.requestMACSec = requestMACSec
        self.tags = tags
    }
}

/// Information about an Direct Connect connection.
public struct CreateConnectionOutput: Swift.Sendable {
    /// The Direct Connect endpoint on which the physical connection terminates.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The bandwidth of the connection.
    public var bandwidth: Swift.String?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The name of the connection.
    public var connectionName: Swift.String?
    /// The state of the connection. The following are the possible values:
    ///
    /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
    ///
    /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The connection has been approved and is being initialized.
    ///
    /// * available: The network link is up and the connection is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The connection is being deleted.
    ///
    /// * deleted: The connection has been deleted.
    ///
    /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
    ///
    /// * unknown: The state of the connection is not available.
    public var connectionState: DirectConnectClientTypes.ConnectionState?
    /// The MAC Security (MACsec) connection encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The time of the most recent call to [DescribeLoa] for this connection.
    public var loaIssueTime: Foundation.Date?
    /// The location of the connection.
    public var location: Swift.String?
    /// Indicates whether the connection supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The ID of the Amazon Web Services account that owns the connection.
    public var ownerAccount: Swift.String?
    /// The name of the Direct Connect service provider associated with the connection.
    public var partnerName: Swift.String?
    /// The MAC Security (MACsec) port link status of the connection. The valid values are Encryption Up, which means that there is an active Connection Key Name, or Encryption Down.
    public var portEncryptionStatus: Swift.String?
    /// The name of the service provider associated with the connection.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the connection.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init(
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bandwidth: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        connectionState: DirectConnectClientTypes.ConnectionState? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        loaIssueTime: Foundation.Date? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        ownerAccount: Swift.String? = nil,
        partnerName: Swift.String? = nil,
        portEncryptionStatus: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

public struct CreateDirectConnectGatewayInput: Swift.Sendable {
    /// The autonomous system number (ASN) for Border Gateway Protocol (BGP) to be configured on the Amazon side of the connection. The ASN must be in the private range of 64,512 to 65,534 or 4,200,000,000 to 4,294,967,294. The default is 64512.
    public var amazonSideAsn: Swift.Int?
    /// The name of the Direct Connect gateway.
    /// This member is required.
    public var directConnectGatewayName: Swift.String?

    public init(
        amazonSideAsn: Swift.Int? = nil,
        directConnectGatewayName: Swift.String? = nil
    )
    {
        self.amazonSideAsn = amazonSideAsn
        self.directConnectGatewayName = directConnectGatewayName
    }
}

extension DirectConnectClientTypes {

    public enum DirectConnectGatewayState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectConnectGatewayState] {
            return [
                .available,
                .deleted,
                .deleting,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .deleted: return "deleted"
            case .deleting: return "deleting"
            case .pending: return "pending"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DirectConnectClientTypes {

    /// Information about a Direct Connect gateway, which enables you to connect virtual interfaces and virtual private gateway or transit gateways.
    public struct DirectConnectGateway: Swift.Sendable {
        /// The autonomous system number (ASN) for the Amazon side of the connection.
        public var amazonSideAsn: Swift.Int?
        /// The ID of the Direct Connect gateway.
        public var directConnectGatewayId: Swift.String?
        /// The name of the Direct Connect gateway.
        public var directConnectGatewayName: Swift.String?
        /// The state of the Direct Connect gateway. The following are the possible values:
        ///
        /// * pending: The initial state after calling [CreateDirectConnectGateway].
        ///
        /// * available: The Direct Connect gateway is ready for use.
        ///
        /// * deleting: The initial state after calling [DeleteDirectConnectGateway].
        ///
        /// * deleted: The Direct Connect gateway is deleted and cannot pass traffic.
        public var directConnectGatewayState: DirectConnectClientTypes.DirectConnectGatewayState?
        /// The ID of the Amazon Web Services account that owns the Direct Connect gateway.
        public var ownerAccount: Swift.String?
        /// The error message if the state of an object failed to advance.
        public var stateChangeError: Swift.String?

        public init(
            amazonSideAsn: Swift.Int? = nil,
            directConnectGatewayId: Swift.String? = nil,
            directConnectGatewayName: Swift.String? = nil,
            directConnectGatewayState: DirectConnectClientTypes.DirectConnectGatewayState? = nil,
            ownerAccount: Swift.String? = nil,
            stateChangeError: Swift.String? = nil
        )
        {
            self.amazonSideAsn = amazonSideAsn
            self.directConnectGatewayId = directConnectGatewayId
            self.directConnectGatewayName = directConnectGatewayName
            self.directConnectGatewayState = directConnectGatewayState
            self.ownerAccount = ownerAccount
            self.stateChangeError = stateChangeError
        }
    }
}

public struct CreateDirectConnectGatewayOutput: Swift.Sendable {
    /// The Direct Connect gateway.
    public var directConnectGateway: DirectConnectClientTypes.DirectConnectGateway?

    public init(
        directConnectGateway: DirectConnectClientTypes.DirectConnectGateway? = nil
    )
    {
        self.directConnectGateway = directConnectGateway
    }
}

public struct CreateDirectConnectGatewayAssociationInput: Swift.Sendable {
    /// The Amazon VPC prefixes to advertise to the Direct Connect gateway This parameter is required when you create an association to a transit gateway. For information about how to set the prefixes, see [Allowed Prefixes](https://docs.aws.amazon.com/directconnect/latest/UserGuide/multi-account-associate-vgw.html#allowed-prefixes) in the Direct Connect User Guide.
    public var addAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// The ID of the Direct Connect gateway.
    /// This member is required.
    public var directConnectGatewayId: Swift.String?
    /// The ID of the virtual private gateway or transit gateway.
    public var gatewayId: Swift.String?
    /// The ID of the virtual private gateway.
    public var virtualGatewayId: Swift.String?

    public init(
        addAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        directConnectGatewayId: Swift.String? = nil,
        gatewayId: Swift.String? = nil,
        virtualGatewayId: Swift.String? = nil
    )
    {
        self.addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGateway
        self.directConnectGatewayId = directConnectGatewayId
        self.gatewayId = gatewayId
        self.virtualGatewayId = virtualGatewayId
    }
}

public struct CreateDirectConnectGatewayAssociationOutput: Swift.Sendable {
    /// The association to be created.
    public var directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation?

    public init(
        directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation? = nil
    )
    {
        self.directConnectGatewayAssociation = directConnectGatewayAssociation
    }
}

public struct CreateDirectConnectGatewayAssociationProposalInput: Swift.Sendable {
    /// The Amazon VPC prefixes to advertise to the Direct Connect gateway.
    public var addAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// The ID of the Direct Connect gateway.
    /// This member is required.
    public var directConnectGatewayId: Swift.String?
    /// The ID of the Amazon Web Services account that owns the Direct Connect gateway.
    /// This member is required.
    public var directConnectGatewayOwnerAccount: Swift.String?
    /// The ID of the virtual private gateway or transit gateway.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The Amazon VPC prefixes to no longer advertise to the Direct Connect gateway.
    public var removeAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?

    public init(
        addAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        directConnectGatewayId: Swift.String? = nil,
        directConnectGatewayOwnerAccount: Swift.String? = nil,
        gatewayId: Swift.String? = nil,
        removeAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]? = nil
    )
    {
        self.addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGateway
        self.directConnectGatewayId = directConnectGatewayId
        self.directConnectGatewayOwnerAccount = directConnectGatewayOwnerAccount
        self.gatewayId = gatewayId
        self.removeAllowedPrefixesToDirectConnectGateway = removeAllowedPrefixesToDirectConnectGateway
    }
}

extension DirectConnectClientTypes {

    public enum DirectConnectGatewayAssociationProposalState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accepted
        case deleted
        case requested
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectConnectGatewayAssociationProposalState] {
            return [
                .accepted,
                .deleted,
                .requested
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "accepted"
            case .deleted: return "deleted"
            case .requested: return "requested"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DirectConnectClientTypes {

    /// Information about the proposal request to attach a virtual private gateway to a Direct Connect gateway.
    public struct DirectConnectGatewayAssociationProposal: Swift.Sendable {
        /// Information about the associated gateway.
        public var associatedGateway: DirectConnectClientTypes.AssociatedGateway?
        /// The ID of the Direct Connect gateway.
        public var directConnectGatewayId: Swift.String?
        /// The ID of the Amazon Web Services account that owns the Direct Connect gateway.
        public var directConnectGatewayOwnerAccount: Swift.String?
        /// The existing Amazon VPC prefixes advertised to the Direct Connect gateway.
        public var existingAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?
        /// The ID of the association proposal.
        public var proposalId: Swift.String?
        /// The state of the proposal. The following are possible values:
        ///
        /// * accepted: The proposal has been accepted. The Direct Connect gateway association is available to use in this state.
        ///
        /// * deleted: The proposal has been deleted by the owner that made the proposal. The Direct Connect gateway association cannot be used in this state.
        ///
        /// * requested: The proposal has been requested. The Direct Connect gateway association cannot be used in this state.
        public var proposalState: DirectConnectClientTypes.DirectConnectGatewayAssociationProposalState?
        /// The Amazon VPC prefixes to advertise to the Direct Connect gateway.
        public var requestedAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?

        public init(
            associatedGateway: DirectConnectClientTypes.AssociatedGateway? = nil,
            directConnectGatewayId: Swift.String? = nil,
            directConnectGatewayOwnerAccount: Swift.String? = nil,
            existingAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
            proposalId: Swift.String? = nil,
            proposalState: DirectConnectClientTypes.DirectConnectGatewayAssociationProposalState? = nil,
            requestedAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]? = nil
        )
        {
            self.associatedGateway = associatedGateway
            self.directConnectGatewayId = directConnectGatewayId
            self.directConnectGatewayOwnerAccount = directConnectGatewayOwnerAccount
            self.existingAllowedPrefixesToDirectConnectGateway = existingAllowedPrefixesToDirectConnectGateway
            self.proposalId = proposalId
            self.proposalState = proposalState
            self.requestedAllowedPrefixesToDirectConnectGateway = requestedAllowedPrefixesToDirectConnectGateway
        }
    }
}

public struct CreateDirectConnectGatewayAssociationProposalOutput: Swift.Sendable {
    /// Information about the Direct Connect gateway proposal.
    public var directConnectGatewayAssociationProposal: DirectConnectClientTypes.DirectConnectGatewayAssociationProposal?

    public init(
        directConnectGatewayAssociationProposal: DirectConnectClientTypes.DirectConnectGatewayAssociationProposal? = nil
    )
    {
        self.directConnectGatewayAssociationProposal = directConnectGatewayAssociationProposal
    }
}

public struct CreateInterconnectInput: Swift.Sendable {
    /// The port bandwidth, in Gbps. The possible values are 1, 10, and 100.
    /// This member is required.
    public var bandwidth: Swift.String?
    /// The name of the interconnect.
    /// This member is required.
    public var interconnectName: Swift.String?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The location of the interconnect.
    /// This member is required.
    public var location: Swift.String?
    /// The name of the service provider associated with the interconnect.
    public var providerName: Swift.String?
    /// The tags to associate with the interconnect.
    public var tags: [DirectConnectClientTypes.Tag]?

    public init(
        bandwidth: Swift.String? = nil,
        interconnectName: Swift.String? = nil,
        lagId: Swift.String? = nil,
        location: Swift.String? = nil,
        providerName: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil
    )
    {
        self.bandwidth = bandwidth
        self.interconnectName = interconnectName
        self.lagId = lagId
        self.location = location
        self.providerName = providerName
        self.tags = tags
    }
}

extension DirectConnectClientTypes {

    public enum InterconnectState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case down
        case pending
        case requested
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [InterconnectState] {
            return [
                .available,
                .deleted,
                .deleting,
                .down,
                .pending,
                .requested,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .deleted: return "deleted"
            case .deleting: return "deleting"
            case .down: return "down"
            case .pending: return "pending"
            case .requested: return "requested"
            case .unknown: return "unknown"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Information about an interconnect.
public struct CreateInterconnectOutput: Swift.Sendable {
    /// The Direct Connect endpoint on which the physical connection terminates.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The bandwidth of the connection.
    public var bandwidth: Swift.String?
    /// Indicates whether the interconnect supports a secondary BGP in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// The ID of the interconnect.
    public var interconnectId: Swift.String?
    /// The name of the interconnect.
    public var interconnectName: Swift.String?
    /// The state of the interconnect. The following are the possible values:
    ///
    /// * requested: The initial state of an interconnect. The interconnect stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The interconnect is approved, and is being initialized.
    ///
    /// * available: The network link is up, and the interconnect is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The interconnect is being deleted.
    ///
    /// * deleted: The interconnect is deleted.
    ///
    /// * unknown: The state of the interconnect is not available.
    public var interconnectState: DirectConnectClientTypes.InterconnectState?
    /// Indicates whether jumbo frames are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The time of the most recent call to [DescribeLoa] for this connection.
    public var loaIssueTime: Foundation.Date?
    /// The location of the connection.
    public var location: Swift.String?
    /// The name of the service provider associated with the interconnect.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the interconnect.
    public var tags: [DirectConnectClientTypes.Tag]?

    public init(
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bandwidth: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        interconnectId: Swift.String? = nil,
        interconnectName: Swift.String? = nil,
        interconnectState: DirectConnectClientTypes.InterconnectState? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        loaIssueTime: Foundation.Date? = nil,
        location: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bandwidth = bandwidth
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.interconnectId = interconnectId
        self.interconnectName = interconnectName
        self.interconnectState = interconnectState
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.providerName = providerName
        self.region = region
        self.tags = tags
    }
}

public struct CreateLagInput: Swift.Sendable {
    /// The tags to associate with the automtically created LAGs.
    public var childConnectionTags: [DirectConnectClientTypes.Tag]?
    /// The ID of an existing dedicated connection to migrate to the LAG.
    public var connectionId: Swift.String?
    /// The bandwidth of the individual physical dedicated connections bundled by the LAG. The possible values are 1Gbps,10Gbps, 100Gbps, and 400Gbps.
    /// This member is required.
    public var connectionsBandwidth: Swift.String?
    /// The name of the LAG.
    /// This member is required.
    public var lagName: Swift.String?
    /// The location for the LAG.
    /// This member is required.
    public var location: Swift.String?
    /// The number of physical dedicated connections initially provisioned and bundled by the LAG. You can have a maximum of four connections when the port speed is 1Gbps or 10Gbps, or two when the port speed is 100Gbps or 400Gbps.
    /// This member is required.
    public var numberOfConnections: Swift.Int?
    /// The name of the service provider associated with the LAG.
    public var providerName: Swift.String?
    /// Indicates whether the connection will support MAC Security (MACsec). All connections in the LAG must be capable of supporting MAC Security (MACsec). For information about MAC Security (MACsec) prerequisties, see [MACsec prerequisties](https://docs.aws.amazon.com/directconnect/latest/UserGuide/direct-connect-mac-sec-getting-started.html#mac-sec-prerequisites) in the Direct Connect User Guide.
    public var requestMACSec: Swift.Bool?
    /// The tags to associate with the LAG.
    public var tags: [DirectConnectClientTypes.Tag]?

    public init(
        childConnectionTags: [DirectConnectClientTypes.Tag]? = nil,
        connectionId: Swift.String? = nil,
        connectionsBandwidth: Swift.String? = nil,
        lagName: Swift.String? = nil,
        location: Swift.String? = nil,
        numberOfConnections: Swift.Int? = 0,
        providerName: Swift.String? = nil,
        requestMACSec: Swift.Bool? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil
    )
    {
        self.childConnectionTags = childConnectionTags
        self.connectionId = connectionId
        self.connectionsBandwidth = connectionsBandwidth
        self.lagName = lagName
        self.location = location
        self.numberOfConnections = numberOfConnections
        self.providerName = providerName
        self.requestMACSec = requestMACSec
        self.tags = tags
    }
}

extension DirectConnectClientTypes {

    public enum LagState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleted
        case deleting
        case down
        case pending
        case requested
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [LagState] {
            return [
                .available,
                .deleted,
                .deleting,
                .down,
                .pending,
                .requested,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .deleted: return "deleted"
            case .deleting: return "deleting"
            case .down: return "down"
            case .pending: return "pending"
            case .requested: return "requested"
            case .unknown: return "unknown"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Information about a link aggregation group (LAG).
public struct CreateLagOutput: Swift.Sendable {
    /// Indicates whether the LAG can host other connections.
    public var allowsHostedConnections: Swift.Bool
    /// The Direct Connect endpoint that hosts the LAG.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that hosts the LAG.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The connections bundled by the LAG.
    public var connections: [DirectConnectClientTypes.Connection]?
    /// The individual bandwidth of the physical connections bundled by the LAG. The possible values are 1Gbps, 10Gbps, 100Gbps, or 400 Gbps..
    public var connectionsBandwidth: Swift.String?
    /// The LAG MAC Security (MACsec) encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the LAG supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The name of the LAG.
    public var lagName: Swift.String?
    /// The state of the LAG. The following are the possible values:
    ///
    /// * requested: The initial state of a LAG. The LAG stays in the requested state until the Letter of Authorization (LOA) is available.
    ///
    /// * pending: The LAG has been approved and is being initialized.
    ///
    /// * available: The network link is established and the LAG is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The LAG is being deleted.
    ///
    /// * deleted: The LAG is deleted.
    ///
    /// * unknown: The state of the LAG is not available.
    public var lagState: DirectConnectClientTypes.LagState?
    /// The location of the LAG.
    public var location: Swift.String?
    /// Indicates whether the LAG supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the LAG.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The minimum number of physical dedicated connections that must be operational for the LAG itself to be operational.
    public var minimumLinks: Swift.Int
    /// The number of physical dedicated connections initially provisioned and bundled by the LAG. You can have a maximum of four connections when the port speed is 1 Gbps or 10 Gbps, or two when the port speed is 100 Gbps or 400 Gbps.
    public var numberOfConnections: Swift.Int
    /// The ID of the Amazon Web Services account that owns the LAG.
    public var ownerAccount: Swift.String?
    /// The name of the service provider associated with the LAG.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the LAG.
    public var tags: [DirectConnectClientTypes.Tag]?

    public init(
        allowsHostedConnections: Swift.Bool = false,
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        connections: [DirectConnectClientTypes.Connection]? = nil,
        connectionsBandwidth: Swift.String? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        lagName: Swift.String? = nil,
        lagState: DirectConnectClientTypes.LagState? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        minimumLinks: Swift.Int = 0,
        numberOfConnections: Swift.Int = 0,
        ownerAccount: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil
    )
    {
        self.allowsHostedConnections = allowsHostedConnections
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.connections = connections
        self.connectionsBandwidth = connectionsBandwidth
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.lagName = lagName
        self.lagState = lagState
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.minimumLinks = minimumLinks
        self.numberOfConnections = numberOfConnections
        self.ownerAccount = ownerAccount
        self.providerName = providerName
        self.region = region
        self.tags = tags
    }
}

extension DirectConnectClientTypes {

    /// Information about a private virtual interface.
    public struct NewPrivateVirtualInterface: Swift.Sendable {
        /// The address family for the BGP peer.
        public var addressFamily: DirectConnectClientTypes.AddressFamily?
        /// The IP address assigned to the Amazon interface.
        public var amazonAddress: Swift.String?
        /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
        /// This member is required.
        public var asn: Swift.Int
        /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
        public var authKey: Swift.String?
        /// The IP address assigned to the customer interface.
        public var customerAddress: Swift.String?
        /// The ID of the Direct Connect gateway.
        public var directConnectGatewayId: Swift.String?
        /// Indicates whether to enable or disable SiteLink.
        public var enableSiteLink: Swift.Bool?
        /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 8500. The default value is 1500.
        public var mtu: Swift.Int?
        /// The tags associated with the private virtual interface.
        public var tags: [DirectConnectClientTypes.Tag]?
        /// The ID of the virtual private gateway.
        public var virtualGatewayId: Swift.String?
        /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
        /// This member is required.
        public var virtualInterfaceName: Swift.String?
        /// The ID of the VLAN.
        /// This member is required.
        public var vlan: Swift.Int

        public init(
            addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
            amazonAddress: Swift.String? = nil,
            asn: Swift.Int = 0,
            authKey: Swift.String? = nil,
            customerAddress: Swift.String? = nil,
            directConnectGatewayId: Swift.String? = nil,
            enableSiteLink: Swift.Bool? = nil,
            mtu: Swift.Int? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil,
            virtualGatewayId: Swift.String? = nil,
            virtualInterfaceName: Swift.String? = nil,
            vlan: Swift.Int = 0
        )
        {
            self.addressFamily = addressFamily
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.authKey = authKey
            self.customerAddress = customerAddress
            self.directConnectGatewayId = directConnectGatewayId
            self.enableSiteLink = enableSiteLink
            self.mtu = mtu
            self.tags = tags
            self.virtualGatewayId = virtualGatewayId
            self.virtualInterfaceName = virtualInterfaceName
            self.vlan = vlan
        }
    }
}

public struct CreatePrivateVirtualInterfaceInput: Swift.Sendable {
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// Information about the private virtual interface.
    /// This member is required.
    public var newPrivateVirtualInterface: DirectConnectClientTypes.NewPrivateVirtualInterface?

    public init(
        connectionId: Swift.String? = nil,
        newPrivateVirtualInterface: DirectConnectClientTypes.NewPrivateVirtualInterface? = nil
    )
    {
        self.connectionId = connectionId
        self.newPrivateVirtualInterface = newPrivateVirtualInterface
    }
}

/// Information about a virtual interface.
public struct CreatePrivateVirtualInterfaceOutput: Swift.Sendable {
    /// The address family for the BGP peer.
    public var addressFamily: DirectConnectClientTypes.AddressFamily?
    /// The IP address assigned to the Amazon interface.
    public var amazonAddress: Swift.String?
    /// The autonomous system number (ASN) for the Amazon side of the connection.
    public var amazonSideAsn: Swift.Int?
    /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
    public var asn: Swift.Int
    /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
    public var authKey: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The BGP peers configured on this virtual interface.
    public var bgpPeers: [DirectConnectClientTypes.BGPPeer]?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The IP address assigned to the customer interface.
    public var customerAddress: Swift.String?
    /// The customer router configuration.
    public var customerRouterConfig: Swift.String?
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// Indicates whether jumbo frames are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The location of the connection.
    public var location: Swift.String?
    /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 8500. The default value is 1500
    public var mtu: Swift.Int?
    /// The ID of the Amazon Web Services account that owns the virtual interface.
    public var ownerAccount: Swift.String?
    /// The Amazon Web Services Region where the virtual interface is located.
    public var region: Swift.String?
    /// The routes to be advertised to the Amazon Web Services network in this Region. Applies to public virtual interfaces.
    public var routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// Indicates whether SiteLink is enabled.
    public var siteLinkEnabled: Swift.Bool?
    /// The tags associated with the virtual interface.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the virtual private gateway. Applies only to private virtual interfaces.
    public var virtualGatewayId: Swift.String?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?
    /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
    public var virtualInterfaceName: Swift.String?
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
    /// The type of virtual interface. The possible values are private, public and transit.
    public var virtualInterfaceType: Swift.String?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init(
        addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
        amazonAddress: Swift.String? = nil,
        amazonSideAsn: Swift.Int? = nil,
        asn: Swift.Int = 0,
        authKey: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bgpPeers: [DirectConnectClientTypes.BGPPeer]? = nil,
        connectionId: Swift.String? = nil,
        customerAddress: Swift.String? = nil,
        customerRouterConfig: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        location: Swift.String? = nil,
        mtu: Swift.Int? = nil,
        ownerAccount: Swift.String? = nil,
        region: Swift.String? = nil,
        routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        siteLinkEnabled: Swift.Bool? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        virtualGatewayId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil,
        virtualInterfaceName: Swift.String? = nil,
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil,
        virtualInterfaceType: Swift.String? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.amazonSideAsn = amazonSideAsn
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bgpPeers = bgpPeers
        self.connectionId = connectionId
        self.customerAddress = customerAddress
        self.customerRouterConfig = customerRouterConfig
        self.directConnectGatewayId = directConnectGatewayId
        self.jumboFrameCapable = jumboFrameCapable
        self.location = location
        self.mtu = mtu
        self.ownerAccount = ownerAccount
        self.region = region
        self.routeFilterPrefixes = routeFilterPrefixes
        self.siteLinkEnabled = siteLinkEnabled
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
        self.virtualInterfaceState = virtualInterfaceState
        self.virtualInterfaceType = virtualInterfaceType
        self.vlan = vlan
    }
}

extension DirectConnectClientTypes {

    /// Information about a public virtual interface.
    public struct NewPublicVirtualInterface: Swift.Sendable {
        /// The address family for the BGP peer.
        public var addressFamily: DirectConnectClientTypes.AddressFamily?
        /// The IP address assigned to the Amazon interface.
        public var amazonAddress: Swift.String?
        /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
        /// This member is required.
        public var asn: Swift.Int
        /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
        public var authKey: Swift.String?
        /// The IP address assigned to the customer interface.
        public var customerAddress: Swift.String?
        /// The routes to be advertised to the Amazon Web Services network in this Region. Applies to public virtual interfaces.
        public var routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
        /// The tags associated with the public virtual interface.
        public var tags: [DirectConnectClientTypes.Tag]?
        /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
        /// This member is required.
        public var virtualInterfaceName: Swift.String?
        /// The ID of the VLAN.
        /// This member is required.
        public var vlan: Swift.Int

        public init(
            addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
            amazonAddress: Swift.String? = nil,
            asn: Swift.Int = 0,
            authKey: Swift.String? = nil,
            customerAddress: Swift.String? = nil,
            routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil,
            virtualInterfaceName: Swift.String? = nil,
            vlan: Swift.Int = 0
        )
        {
            self.addressFamily = addressFamily
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.authKey = authKey
            self.customerAddress = customerAddress
            self.routeFilterPrefixes = routeFilterPrefixes
            self.tags = tags
            self.virtualInterfaceName = virtualInterfaceName
            self.vlan = vlan
        }
    }
}

public struct CreatePublicVirtualInterfaceInput: Swift.Sendable {
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// Information about the public virtual interface.
    /// This member is required.
    public var newPublicVirtualInterface: DirectConnectClientTypes.NewPublicVirtualInterface?

    public init(
        connectionId: Swift.String? = nil,
        newPublicVirtualInterface: DirectConnectClientTypes.NewPublicVirtualInterface? = nil
    )
    {
        self.connectionId = connectionId
        self.newPublicVirtualInterface = newPublicVirtualInterface
    }
}

/// Information about a virtual interface.
public struct CreatePublicVirtualInterfaceOutput: Swift.Sendable {
    /// The address family for the BGP peer.
    public var addressFamily: DirectConnectClientTypes.AddressFamily?
    /// The IP address assigned to the Amazon interface.
    public var amazonAddress: Swift.String?
    /// The autonomous system number (ASN) for the Amazon side of the connection.
    public var amazonSideAsn: Swift.Int?
    /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
    public var asn: Swift.Int
    /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
    public var authKey: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The BGP peers configured on this virtual interface.
    public var bgpPeers: [DirectConnectClientTypes.BGPPeer]?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The IP address assigned to the customer interface.
    public var customerAddress: Swift.String?
    /// The customer router configuration.
    public var customerRouterConfig: Swift.String?
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// Indicates whether jumbo frames are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The location of the connection.
    public var location: Swift.String?
    /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 8500. The default value is 1500
    public var mtu: Swift.Int?
    /// The ID of the Amazon Web Services account that owns the virtual interface.
    public var ownerAccount: Swift.String?
    /// The Amazon Web Services Region where the virtual interface is located.
    public var region: Swift.String?
    /// The routes to be advertised to the Amazon Web Services network in this Region. Applies to public virtual interfaces.
    public var routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// Indicates whether SiteLink is enabled.
    public var siteLinkEnabled: Swift.Bool?
    /// The tags associated with the virtual interface.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the virtual private gateway. Applies only to private virtual interfaces.
    public var virtualGatewayId: Swift.String?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?
    /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
    public var virtualInterfaceName: Swift.String?
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
    /// The type of virtual interface. The possible values are private, public and transit.
    public var virtualInterfaceType: Swift.String?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init(
        addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
        amazonAddress: Swift.String? = nil,
        amazonSideAsn: Swift.Int? = nil,
        asn: Swift.Int = 0,
        authKey: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bgpPeers: [DirectConnectClientTypes.BGPPeer]? = nil,
        connectionId: Swift.String? = nil,
        customerAddress: Swift.String? = nil,
        customerRouterConfig: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        location: Swift.String? = nil,
        mtu: Swift.Int? = nil,
        ownerAccount: Swift.String? = nil,
        region: Swift.String? = nil,
        routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        siteLinkEnabled: Swift.Bool? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        virtualGatewayId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil,
        virtualInterfaceName: Swift.String? = nil,
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil,
        virtualInterfaceType: Swift.String? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.amazonSideAsn = amazonSideAsn
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bgpPeers = bgpPeers
        self.connectionId = connectionId
        self.customerAddress = customerAddress
        self.customerRouterConfig = customerRouterConfig
        self.directConnectGatewayId = directConnectGatewayId
        self.jumboFrameCapable = jumboFrameCapable
        self.location = location
        self.mtu = mtu
        self.ownerAccount = ownerAccount
        self.region = region
        self.routeFilterPrefixes = routeFilterPrefixes
        self.siteLinkEnabled = siteLinkEnabled
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
        self.virtualInterfaceState = virtualInterfaceState
        self.virtualInterfaceType = virtualInterfaceType
        self.vlan = vlan
    }
}

extension DirectConnectClientTypes {

    /// Information about a transit virtual interface.
    public struct NewTransitVirtualInterface: Swift.Sendable {
        /// The address family for the BGP peer.
        public var addressFamily: DirectConnectClientTypes.AddressFamily?
        /// The IP address assigned to the Amazon interface.
        public var amazonAddress: Swift.String?
        /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
        public var asn: Swift.Int
        /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
        public var authKey: Swift.String?
        /// The IP address assigned to the customer interface.
        public var customerAddress: Swift.String?
        /// The ID of the Direct Connect gateway.
        public var directConnectGatewayId: Swift.String?
        /// Indicates whether to enable or disable SiteLink.
        public var enableSiteLink: Swift.Bool?
        /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 8500. The default value is 1500.
        public var mtu: Swift.Int?
        /// The tags associated with the transitive virtual interface.
        public var tags: [DirectConnectClientTypes.Tag]?
        /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
        public var virtualInterfaceName: Swift.String?
        /// The ID of the VLAN.
        public var vlan: Swift.Int

        public init(
            addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
            amazonAddress: Swift.String? = nil,
            asn: Swift.Int = 0,
            authKey: Swift.String? = nil,
            customerAddress: Swift.String? = nil,
            directConnectGatewayId: Swift.String? = nil,
            enableSiteLink: Swift.Bool? = nil,
            mtu: Swift.Int? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil,
            virtualInterfaceName: Swift.String? = nil,
            vlan: Swift.Int = 0
        )
        {
            self.addressFamily = addressFamily
            self.amazonAddress = amazonAddress
            self.asn = asn
            self.authKey = authKey
            self.customerAddress = customerAddress
            self.directConnectGatewayId = directConnectGatewayId
            self.enableSiteLink = enableSiteLink
            self.mtu = mtu
            self.tags = tags
            self.virtualInterfaceName = virtualInterfaceName
            self.vlan = vlan
        }
    }
}

public struct CreateTransitVirtualInterfaceInput: Swift.Sendable {
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// Information about the transit virtual interface.
    /// This member is required.
    public var newTransitVirtualInterface: DirectConnectClientTypes.NewTransitVirtualInterface?

    public init(
        connectionId: Swift.String? = nil,
        newTransitVirtualInterface: DirectConnectClientTypes.NewTransitVirtualInterface? = nil
    )
    {
        self.connectionId = connectionId
        self.newTransitVirtualInterface = newTransitVirtualInterface
    }
}

public struct CreateTransitVirtualInterfaceOutput: Swift.Sendable {
    /// Information about a virtual interface.
    public var virtualInterface: DirectConnectClientTypes.VirtualInterface?

    public init(
        virtualInterface: DirectConnectClientTypes.VirtualInterface? = nil
    )
    {
        self.virtualInterface = virtualInterface
    }
}

public struct DeleteBGPPeerInput: Swift.Sendable {
    /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration.
    public var asn: Swift.Int?
    /// The ID of the BGP peer.
    public var bgpPeerId: Swift.String?
    /// The IP address assigned to the customer interface.
    public var customerAddress: Swift.String?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?

    public init(
        asn: Swift.Int? = 0,
        bgpPeerId: Swift.String? = nil,
        customerAddress: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.asn = asn
        self.bgpPeerId = bgpPeerId
        self.customerAddress = customerAddress
        self.virtualInterfaceId = virtualInterfaceId
    }
}

public struct DeleteBGPPeerOutput: Swift.Sendable {
    /// The virtual interface.
    public var virtualInterface: DirectConnectClientTypes.VirtualInterface?

    public init(
        virtualInterface: DirectConnectClientTypes.VirtualInterface? = nil
    )
    {
        self.virtualInterface = virtualInterface
    }
}

public struct DeleteConnectionInput: Swift.Sendable {
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?

    public init(
        connectionId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

/// Information about an Direct Connect connection.
public struct DeleteConnectionOutput: Swift.Sendable {
    /// The Direct Connect endpoint on which the physical connection terminates.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The bandwidth of the connection.
    public var bandwidth: Swift.String?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The name of the connection.
    public var connectionName: Swift.String?
    /// The state of the connection. The following are the possible values:
    ///
    /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
    ///
    /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The connection has been approved and is being initialized.
    ///
    /// * available: The network link is up and the connection is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The connection is being deleted.
    ///
    /// * deleted: The connection has been deleted.
    ///
    /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
    ///
    /// * unknown: The state of the connection is not available.
    public var connectionState: DirectConnectClientTypes.ConnectionState?
    /// The MAC Security (MACsec) connection encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The time of the most recent call to [DescribeLoa] for this connection.
    public var loaIssueTime: Foundation.Date?
    /// The location of the connection.
    public var location: Swift.String?
    /// Indicates whether the connection supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The ID of the Amazon Web Services account that owns the connection.
    public var ownerAccount: Swift.String?
    /// The name of the Direct Connect service provider associated with the connection.
    public var partnerName: Swift.String?
    /// The MAC Security (MACsec) port link status of the connection. The valid values are Encryption Up, which means that there is an active Connection Key Name, or Encryption Down.
    public var portEncryptionStatus: Swift.String?
    /// The name of the service provider associated with the connection.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the connection.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init(
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bandwidth: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        connectionState: DirectConnectClientTypes.ConnectionState? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        loaIssueTime: Foundation.Date? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        ownerAccount: Swift.String? = nil,
        partnerName: Swift.String? = nil,
        portEncryptionStatus: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

public struct DeleteDirectConnectGatewayInput: Swift.Sendable {
    /// The ID of the Direct Connect gateway.
    /// This member is required.
    public var directConnectGatewayId: Swift.String?

    public init(
        directConnectGatewayId: Swift.String? = nil
    )
    {
        self.directConnectGatewayId = directConnectGatewayId
    }
}

public struct DeleteDirectConnectGatewayOutput: Swift.Sendable {
    /// The Direct Connect gateway.
    public var directConnectGateway: DirectConnectClientTypes.DirectConnectGateway?

    public init(
        directConnectGateway: DirectConnectClientTypes.DirectConnectGateway? = nil
    )
    {
        self.directConnectGateway = directConnectGateway
    }
}

public struct DeleteDirectConnectGatewayAssociationInput: Swift.Sendable {
    /// The ID of the Direct Connect gateway association.
    public var associationId: Swift.String?
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// The ID of the virtual private gateway.
    public var virtualGatewayId: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        virtualGatewayId: Swift.String? = nil
    )
    {
        self.associationId = associationId
        self.directConnectGatewayId = directConnectGatewayId
        self.virtualGatewayId = virtualGatewayId
    }
}

public struct DeleteDirectConnectGatewayAssociationOutput: Swift.Sendable {
    /// Information about the deleted association.
    public var directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation?

    public init(
        directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation? = nil
    )
    {
        self.directConnectGatewayAssociation = directConnectGatewayAssociation
    }
}

public struct DeleteDirectConnectGatewayAssociationProposalInput: Swift.Sendable {
    /// The ID of the proposal.
    /// This member is required.
    public var proposalId: Swift.String?

    public init(
        proposalId: Swift.String? = nil
    )
    {
        self.proposalId = proposalId
    }
}

public struct DeleteDirectConnectGatewayAssociationProposalOutput: Swift.Sendable {
    /// The ID of the associated gateway.
    public var directConnectGatewayAssociationProposal: DirectConnectClientTypes.DirectConnectGatewayAssociationProposal?

    public init(
        directConnectGatewayAssociationProposal: DirectConnectClientTypes.DirectConnectGatewayAssociationProposal? = nil
    )
    {
        self.directConnectGatewayAssociationProposal = directConnectGatewayAssociationProposal
    }
}

public struct DeleteInterconnectInput: Swift.Sendable {
    /// The ID of the interconnect.
    /// This member is required.
    public var interconnectId: Swift.String?

    public init(
        interconnectId: Swift.String? = nil
    )
    {
        self.interconnectId = interconnectId
    }
}

public struct DeleteInterconnectOutput: Swift.Sendable {
    /// The state of the interconnect. The following are the possible values:
    ///
    /// * requested: The initial state of an interconnect. The interconnect stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The interconnect is approved, and is being initialized.
    ///
    /// * available: The network link is up, and the interconnect is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The interconnect is being deleted.
    ///
    /// * deleted: The interconnect is deleted.
    ///
    /// * unknown: The state of the interconnect is not available.
    public var interconnectState: DirectConnectClientTypes.InterconnectState?

    public init(
        interconnectState: DirectConnectClientTypes.InterconnectState? = nil
    )
    {
        self.interconnectState = interconnectState
    }
}

public struct DeleteLagInput: Swift.Sendable {
    /// The ID of the LAG.
    /// This member is required.
    public var lagId: Swift.String?

    public init(
        lagId: Swift.String? = nil
    )
    {
        self.lagId = lagId
    }
}

/// Information about a link aggregation group (LAG).
public struct DeleteLagOutput: Swift.Sendable {
    /// Indicates whether the LAG can host other connections.
    public var allowsHostedConnections: Swift.Bool
    /// The Direct Connect endpoint that hosts the LAG.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that hosts the LAG.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The connections bundled by the LAG.
    public var connections: [DirectConnectClientTypes.Connection]?
    /// The individual bandwidth of the physical connections bundled by the LAG. The possible values are 1Gbps, 10Gbps, 100Gbps, or 400 Gbps..
    public var connectionsBandwidth: Swift.String?
    /// The LAG MAC Security (MACsec) encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the LAG supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The name of the LAG.
    public var lagName: Swift.String?
    /// The state of the LAG. The following are the possible values:
    ///
    /// * requested: The initial state of a LAG. The LAG stays in the requested state until the Letter of Authorization (LOA) is available.
    ///
    /// * pending: The LAG has been approved and is being initialized.
    ///
    /// * available: The network link is established and the LAG is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The LAG is being deleted.
    ///
    /// * deleted: The LAG is deleted.
    ///
    /// * unknown: The state of the LAG is not available.
    public var lagState: DirectConnectClientTypes.LagState?
    /// The location of the LAG.
    public var location: Swift.String?
    /// Indicates whether the LAG supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the LAG.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The minimum number of physical dedicated connections that must be operational for the LAG itself to be operational.
    public var minimumLinks: Swift.Int
    /// The number of physical dedicated connections initially provisioned and bundled by the LAG. You can have a maximum of four connections when the port speed is 1 Gbps or 10 Gbps, or two when the port speed is 100 Gbps or 400 Gbps.
    public var numberOfConnections: Swift.Int
    /// The ID of the Amazon Web Services account that owns the LAG.
    public var ownerAccount: Swift.String?
    /// The name of the service provider associated with the LAG.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the LAG.
    public var tags: [DirectConnectClientTypes.Tag]?

    public init(
        allowsHostedConnections: Swift.Bool = false,
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        connections: [DirectConnectClientTypes.Connection]? = nil,
        connectionsBandwidth: Swift.String? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        lagName: Swift.String? = nil,
        lagState: DirectConnectClientTypes.LagState? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        minimumLinks: Swift.Int = 0,
        numberOfConnections: Swift.Int = 0,
        ownerAccount: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil
    )
    {
        self.allowsHostedConnections = allowsHostedConnections
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.connections = connections
        self.connectionsBandwidth = connectionsBandwidth
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.lagName = lagName
        self.lagState = lagState
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.minimumLinks = minimumLinks
        self.numberOfConnections = numberOfConnections
        self.ownerAccount = ownerAccount
        self.providerName = providerName
        self.region = region
        self.tags = tags
    }
}

public struct DeleteVirtualInterfaceInput: Swift.Sendable {
    /// The ID of the virtual interface.
    /// This member is required.
    public var virtualInterfaceId: Swift.String?

    public init(
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.virtualInterfaceId = virtualInterfaceId
    }
}

public struct DeleteVirtualInterfaceOutput: Swift.Sendable {
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?

    public init(
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil
    )
    {
        self.virtualInterfaceState = virtualInterfaceState
    }
}

extension DirectConnectClientTypes {

    public enum LoaContentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pdf
        case sdkUnknown(Swift.String)

        public static var allCases: [LoaContentType] {
            return [
                .pdf
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pdf: return "application/pdf"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeConnectionLoaInput: Swift.Sendable {
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The standard media type for the LOA-CFA document. The only supported value is application/pdf.
    public var loaContentType: DirectConnectClientTypes.LoaContentType?
    /// The name of the APN partner or service provider who establishes connectivity on your behalf. If you specify this parameter, the LOA-CFA lists the provider name alongside your company name as the requester of the cross connect.
    public var providerName: Swift.String?

    public init(
        connectionId: Swift.String? = nil,
        loaContentType: DirectConnectClientTypes.LoaContentType? = nil,
        providerName: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.loaContentType = loaContentType
        self.providerName = providerName
    }
}

extension DirectConnectClientTypes {

    /// Information about a Letter of Authorization - Connecting Facility Assignment (LOA-CFA) for a connection.
    public struct Loa: Swift.Sendable {
        /// The binary contents of the LOA-CFA document.
        public var loaContent: Foundation.Data?
        /// The standard media type for the LOA-CFA document. The only supported value is application/pdf.
        public var loaContentType: DirectConnectClientTypes.LoaContentType?

        public init(
            loaContent: Foundation.Data? = nil,
            loaContentType: DirectConnectClientTypes.LoaContentType? = nil
        )
        {
            self.loaContent = loaContent
            self.loaContentType = loaContentType
        }
    }
}

public struct DescribeConnectionLoaOutput: Swift.Sendable {
    /// The Letter of Authorization - Connecting Facility Assignment (LOA-CFA).
    public var loa: DirectConnectClientTypes.Loa?

    public init(
        loa: DirectConnectClientTypes.Loa? = nil
    )
    {
        self.loa = loa
    }
}

public struct DescribeConnectionsInput: Swift.Sendable {
    /// The ID of the connection.
    public var connectionId: Swift.String?

    public init(
        connectionId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

public struct DescribeConnectionsOutput: Swift.Sendable {
    /// The connections.
    public var connections: [DirectConnectClientTypes.Connection]?

    public init(
        connections: [DirectConnectClientTypes.Connection]? = nil
    )
    {
        self.connections = connections
    }
}

public struct DescribeConnectionsOnInterconnectInput: Swift.Sendable {
    /// The ID of the interconnect.
    /// This member is required.
    public var interconnectId: Swift.String?

    public init(
        interconnectId: Swift.String? = nil
    )
    {
        self.interconnectId = interconnectId
    }
}

public struct DescribeConnectionsOnInterconnectOutput: Swift.Sendable {
    /// The connections.
    public var connections: [DirectConnectClientTypes.Connection]?

    public init(
        connections: [DirectConnectClientTypes.Connection]? = nil
    )
    {
        self.connections = connections
    }
}

extension DirectConnectClientTypes {

    public enum NniPartnerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case nonpartner
        case v1
        case v2
        case sdkUnknown(Swift.String)

        public static var allCases: [NniPartnerType] {
            return [
                .nonpartner,
                .v1,
                .v2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .nonpartner: return "nonPartner"
            case .v1: return "v1"
            case .v2: return "v2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeCustomerMetadataOutput: Swift.Sendable {
    /// The list of customer agreements.
    public var agreements: [DirectConnectClientTypes.CustomerAgreement]?
    /// The type of network-to-network interface (NNI) partner. The partner type will be one of the following:
    ///
    /// * V1: This partner can only allocate 50Mbps, 100Mbps, 200Mbps, 300Mbps, 400Mbps, or 500Mbps subgigabit connections.
    ///
    /// * V2: This partner can only allocate 1GB, 2GB, 5GB, or 10GB hosted connections.
    ///
    /// * nonPartner: The customer is not a partner.
    public var nniPartnerType: DirectConnectClientTypes.NniPartnerType?

    public init(
        agreements: [DirectConnectClientTypes.CustomerAgreement]? = nil,
        nniPartnerType: DirectConnectClientTypes.NniPartnerType? = nil
    )
    {
        self.agreements = agreements
        self.nniPartnerType = nniPartnerType
    }
}

public struct DescribeDirectConnectGatewayAssociationProposalsInput: Swift.Sendable {
    /// The ID of the associated gateway.
    public var associatedGatewayId: Swift.String?
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value. If MaxResults is given a value larger than 100, only 100 results are returned.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the proposal.
    public var proposalId: Swift.String?

    public init(
        associatedGatewayId: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        proposalId: Swift.String? = nil
    )
    {
        self.associatedGatewayId = associatedGatewayId
        self.directConnectGatewayId = directConnectGatewayId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.proposalId = proposalId
    }
}

public struct DescribeDirectConnectGatewayAssociationProposalsOutput: Swift.Sendable {
    /// Describes the Direct Connect gateway association proposals.
    public var directConnectGatewayAssociationProposals: [DirectConnectClientTypes.DirectConnectGatewayAssociationProposal]?
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        directConnectGatewayAssociationProposals: [DirectConnectClientTypes.DirectConnectGatewayAssociationProposal]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directConnectGatewayAssociationProposals = directConnectGatewayAssociationProposals
        self.nextToken = nextToken
    }
}

public struct DescribeDirectConnectGatewayAssociationsInput: Swift.Sendable {
    /// The ID of the associated gateway.
    public var associatedGatewayId: Swift.String?
    /// The ID of the Direct Connect gateway association.
    public var associationId: Swift.String?
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value. If MaxResults is given a value larger than 100, only 100 results are returned.
    public var maxResults: Swift.Int?
    /// The token provided in the previous call to retrieve the next page.
    public var nextToken: Swift.String?
    /// The ID of the virtual private gateway or transit gateway.
    public var virtualGatewayId: Swift.String?

    public init(
        associatedGatewayId: Swift.String? = nil,
        associationId: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        virtualGatewayId: Swift.String? = nil
    )
    {
        self.associatedGatewayId = associatedGatewayId
        self.associationId = associationId
        self.directConnectGatewayId = directConnectGatewayId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.virtualGatewayId = virtualGatewayId
    }
}

public struct DescribeDirectConnectGatewayAssociationsOutput: Swift.Sendable {
    /// Information about the associations.
    public var directConnectGatewayAssociations: [DirectConnectClientTypes.DirectConnectGatewayAssociation]?
    /// The token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        directConnectGatewayAssociations: [DirectConnectClientTypes.DirectConnectGatewayAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directConnectGatewayAssociations = directConnectGatewayAssociations
        self.nextToken = nextToken
    }
}

public struct DescribeDirectConnectGatewayAttachmentsInput: Swift.Sendable {
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value. If MaxResults is given a value larger than 100, only 100 results are returned.
    public var maxResults: Swift.Int?
    /// The token provided in the previous call to retrieve the next page.
    public var nextToken: Swift.String?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?

    public init(
        directConnectGatewayId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.directConnectGatewayId = directConnectGatewayId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.virtualInterfaceId = virtualInterfaceId
    }
}

extension DirectConnectClientTypes {

    public enum DirectConnectGatewayAttachmentState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case attached
        case attaching
        case detached
        case detaching
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectConnectGatewayAttachmentState] {
            return [
                .attached,
                .attaching,
                .detached,
                .detaching
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .attached: return "attached"
            case .attaching: return "attaching"
            case .detached: return "detached"
            case .detaching: return "detaching"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DirectConnectClientTypes {

    public enum DirectConnectGatewayAttachmentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case privatevirtualinterface
        case transitvirtualinterface
        case sdkUnknown(Swift.String)

        public static var allCases: [DirectConnectGatewayAttachmentType] {
            return [
                .privatevirtualinterface,
                .transitvirtualinterface
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .privatevirtualinterface: return "PrivateVirtualInterface"
            case .transitvirtualinterface: return "TransitVirtualInterface"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DirectConnectClientTypes {

    /// Information about an attachment between a Direct Connect gateway and a virtual interface.
    public struct DirectConnectGatewayAttachment: Swift.Sendable {
        /// The state of the attachment. The following are the possible values:
        ///
        /// * attaching: The initial state after a virtual interface is created using the Direct Connect gateway.
        ///
        /// * attached: The Direct Connect gateway and virtual interface are attached and ready to pass traffic.
        ///
        /// * detaching: The initial state after calling [DeleteVirtualInterface].
        ///
        /// * detached: The virtual interface is detached from the Direct Connect gateway. Traffic flow between the Direct Connect gateway and virtual interface is stopped.
        public var attachmentState: DirectConnectClientTypes.DirectConnectGatewayAttachmentState?
        /// The type of attachment.
        public var attachmentType: DirectConnectClientTypes.DirectConnectGatewayAttachmentType?
        /// The ID of the Direct Connect gateway.
        public var directConnectGatewayId: Swift.String?
        /// The error message if the state of an object failed to advance.
        public var stateChangeError: Swift.String?
        /// The ID of the virtual interface.
        public var virtualInterfaceId: Swift.String?
        /// The ID of the Amazon Web Services account that owns the virtual interface.
        public var virtualInterfaceOwnerAccount: Swift.String?
        /// The Amazon Web Services Region where the virtual interface is located.
        public var virtualInterfaceRegion: Swift.String?

        public init(
            attachmentState: DirectConnectClientTypes.DirectConnectGatewayAttachmentState? = nil,
            attachmentType: DirectConnectClientTypes.DirectConnectGatewayAttachmentType? = nil,
            directConnectGatewayId: Swift.String? = nil,
            stateChangeError: Swift.String? = nil,
            virtualInterfaceId: Swift.String? = nil,
            virtualInterfaceOwnerAccount: Swift.String? = nil,
            virtualInterfaceRegion: Swift.String? = nil
        )
        {
            self.attachmentState = attachmentState
            self.attachmentType = attachmentType
            self.directConnectGatewayId = directConnectGatewayId
            self.stateChangeError = stateChangeError
            self.virtualInterfaceId = virtualInterfaceId
            self.virtualInterfaceOwnerAccount = virtualInterfaceOwnerAccount
            self.virtualInterfaceRegion = virtualInterfaceRegion
        }
    }
}

public struct DescribeDirectConnectGatewayAttachmentsOutput: Swift.Sendable {
    /// The attachments.
    public var directConnectGatewayAttachments: [DirectConnectClientTypes.DirectConnectGatewayAttachment]?
    /// The token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        directConnectGatewayAttachments: [DirectConnectClientTypes.DirectConnectGatewayAttachment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directConnectGatewayAttachments = directConnectGatewayAttachments
        self.nextToken = nextToken
    }
}

public struct DescribeDirectConnectGatewaysInput: Swift.Sendable {
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value. If MaxResults is given a value larger than 100, only 100 results are returned.
    public var maxResults: Swift.Int?
    /// The token provided in the previous call to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        directConnectGatewayId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directConnectGatewayId = directConnectGatewayId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeDirectConnectGatewaysOutput: Swift.Sendable {
    /// The Direct Connect gateways.
    public var directConnectGateways: [DirectConnectClientTypes.DirectConnectGateway]?
    /// The token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        directConnectGateways: [DirectConnectClientTypes.DirectConnectGateway]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directConnectGateways = directConnectGateways
        self.nextToken = nextToken
    }
}

public struct DescribeHostedConnectionsInput: Swift.Sendable {
    /// The ID of the interconnect or LAG.
    /// This member is required.
    public var connectionId: Swift.String?

    public init(
        connectionId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
    }
}

public struct DescribeHostedConnectionsOutput: Swift.Sendable {
    /// The connections.
    public var connections: [DirectConnectClientTypes.Connection]?

    public init(
        connections: [DirectConnectClientTypes.Connection]? = nil
    )
    {
        self.connections = connections
    }
}

public struct DescribeInterconnectLoaInput: Swift.Sendable {
    /// The ID of the interconnect.
    /// This member is required.
    public var interconnectId: Swift.String?
    /// The standard media type for the LOA-CFA document. The only supported value is application/pdf.
    public var loaContentType: DirectConnectClientTypes.LoaContentType?
    /// The name of the service provider who establishes connectivity on your behalf. If you supply this parameter, the LOA-CFA lists the provider name alongside your company name as the requester of the cross connect.
    public var providerName: Swift.String?

    public init(
        interconnectId: Swift.String? = nil,
        loaContentType: DirectConnectClientTypes.LoaContentType? = nil,
        providerName: Swift.String? = nil
    )
    {
        self.interconnectId = interconnectId
        self.loaContentType = loaContentType
        self.providerName = providerName
    }
}

public struct DescribeInterconnectLoaOutput: Swift.Sendable {
    /// The Letter of Authorization - Connecting Facility Assignment (LOA-CFA).
    public var loa: DirectConnectClientTypes.Loa?

    public init(
        loa: DirectConnectClientTypes.Loa? = nil
    )
    {
        self.loa = loa
    }
}

public struct DescribeInterconnectsInput: Swift.Sendable {
    /// The ID of the interconnect.
    public var interconnectId: Swift.String?

    public init(
        interconnectId: Swift.String? = nil
    )
    {
        self.interconnectId = interconnectId
    }
}

extension DirectConnectClientTypes {

    /// Information about an interconnect.
    public struct Interconnect: Swift.Sendable {
        /// The Direct Connect endpoint on which the physical connection terminates.
        @available(*, deprecated)
        public var awsDevice: Swift.String?
        /// The Direct Connect endpoint that terminates the physical connection.
        public var awsDeviceV2: Swift.String?
        /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
        public var awsLogicalDeviceId: Swift.String?
        /// The bandwidth of the connection.
        public var bandwidth: Swift.String?
        /// Indicates whether the interconnect supports a secondary BGP in the same address family (IPv4/IPv6).
        public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
        /// The ID of the interconnect.
        public var interconnectId: Swift.String?
        /// The name of the interconnect.
        public var interconnectName: Swift.String?
        /// The state of the interconnect. The following are the possible values:
        ///
        /// * requested: The initial state of an interconnect. The interconnect stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
        ///
        /// * pending: The interconnect is approved, and is being initialized.
        ///
        /// * available: The network link is up, and the interconnect is ready for use.
        ///
        /// * down: The network link is down.
        ///
        /// * deleting: The interconnect is being deleted.
        ///
        /// * deleted: The interconnect is deleted.
        ///
        /// * unknown: The state of the interconnect is not available.
        public var interconnectState: DirectConnectClientTypes.InterconnectState?
        /// Indicates whether jumbo frames are supported.
        public var jumboFrameCapable: Swift.Bool?
        /// The ID of the LAG.
        public var lagId: Swift.String?
        /// The time of the most recent call to [DescribeLoa] for this connection.
        public var loaIssueTime: Foundation.Date?
        /// The location of the connection.
        public var location: Swift.String?
        /// The name of the service provider associated with the interconnect.
        public var providerName: Swift.String?
        /// The Amazon Web Services Region where the connection is located.
        public var region: Swift.String?
        /// The tags associated with the interconnect.
        public var tags: [DirectConnectClientTypes.Tag]?

        public init(
            awsDevice: Swift.String? = nil,
            awsDeviceV2: Swift.String? = nil,
            awsLogicalDeviceId: Swift.String? = nil,
            bandwidth: Swift.String? = nil,
            hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
            interconnectId: Swift.String? = nil,
            interconnectName: Swift.String? = nil,
            interconnectState: DirectConnectClientTypes.InterconnectState? = nil,
            jumboFrameCapable: Swift.Bool? = nil,
            lagId: Swift.String? = nil,
            loaIssueTime: Foundation.Date? = nil,
            location: Swift.String? = nil,
            providerName: Swift.String? = nil,
            region: Swift.String? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil
        )
        {
            self.awsDevice = awsDevice
            self.awsDeviceV2 = awsDeviceV2
            self.awsLogicalDeviceId = awsLogicalDeviceId
            self.bandwidth = bandwidth
            self.hasLogicalRedundancy = hasLogicalRedundancy
            self.interconnectId = interconnectId
            self.interconnectName = interconnectName
            self.interconnectState = interconnectState
            self.jumboFrameCapable = jumboFrameCapable
            self.lagId = lagId
            self.loaIssueTime = loaIssueTime
            self.location = location
            self.providerName = providerName
            self.region = region
            self.tags = tags
        }
    }
}

public struct DescribeInterconnectsOutput: Swift.Sendable {
    /// The interconnects.
    public var interconnects: [DirectConnectClientTypes.Interconnect]?

    public init(
        interconnects: [DirectConnectClientTypes.Interconnect]? = nil
    )
    {
        self.interconnects = interconnects
    }
}

public struct DescribeLagsInput: Swift.Sendable {
    /// The ID of the LAG.
    public var lagId: Swift.String?

    public init(
        lagId: Swift.String? = nil
    )
    {
        self.lagId = lagId
    }
}

extension DirectConnectClientTypes {

    /// Information about a link aggregation group (LAG).
    public struct Lag: Swift.Sendable {
        /// Indicates whether the LAG can host other connections.
        public var allowsHostedConnections: Swift.Bool
        /// The Direct Connect endpoint that hosts the LAG.
        @available(*, deprecated)
        public var awsDevice: Swift.String?
        /// The Direct Connect endpoint that hosts the LAG.
        public var awsDeviceV2: Swift.String?
        /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
        public var awsLogicalDeviceId: Swift.String?
        /// The connections bundled by the LAG.
        public var connections: [DirectConnectClientTypes.Connection]?
        /// The individual bandwidth of the physical connections bundled by the LAG. The possible values are 1Gbps, 10Gbps, 100Gbps, or 400 Gbps..
        public var connectionsBandwidth: Swift.String?
        /// The LAG MAC Security (MACsec) encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
        public var encryptionMode: Swift.String?
        /// Indicates whether the LAG supports a secondary BGP peer in the same address family (IPv4/IPv6).
        public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
        /// Indicates whether jumbo frames are supported.
        public var jumboFrameCapable: Swift.Bool?
        /// The ID of the LAG.
        public var lagId: Swift.String?
        /// The name of the LAG.
        public var lagName: Swift.String?
        /// The state of the LAG. The following are the possible values:
        ///
        /// * requested: The initial state of a LAG. The LAG stays in the requested state until the Letter of Authorization (LOA) is available.
        ///
        /// * pending: The LAG has been approved and is being initialized.
        ///
        /// * available: The network link is established and the LAG is ready for use.
        ///
        /// * down: The network link is down.
        ///
        /// * deleting: The LAG is being deleted.
        ///
        /// * deleted: The LAG is deleted.
        ///
        /// * unknown: The state of the LAG is not available.
        public var lagState: DirectConnectClientTypes.LagState?
        /// The location of the LAG.
        public var location: Swift.String?
        /// Indicates whether the LAG supports MAC Security (MACsec).
        public var macSecCapable: Swift.Bool?
        /// The MAC Security (MACsec) security keys associated with the LAG.
        public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
        /// The minimum number of physical dedicated connections that must be operational for the LAG itself to be operational.
        public var minimumLinks: Swift.Int
        /// The number of physical dedicated connections initially provisioned and bundled by the LAG. You can have a maximum of four connections when the port speed is 1 Gbps or 10 Gbps, or two when the port speed is 100 Gbps or 400 Gbps.
        public var numberOfConnections: Swift.Int
        /// The ID of the Amazon Web Services account that owns the LAG.
        public var ownerAccount: Swift.String?
        /// The name of the service provider associated with the LAG.
        public var providerName: Swift.String?
        /// The Amazon Web Services Region where the connection is located.
        public var region: Swift.String?
        /// The tags associated with the LAG.
        public var tags: [DirectConnectClientTypes.Tag]?

        public init(
            allowsHostedConnections: Swift.Bool = false,
            awsDevice: Swift.String? = nil,
            awsDeviceV2: Swift.String? = nil,
            awsLogicalDeviceId: Swift.String? = nil,
            connections: [DirectConnectClientTypes.Connection]? = nil,
            connectionsBandwidth: Swift.String? = nil,
            encryptionMode: Swift.String? = nil,
            hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
            jumboFrameCapable: Swift.Bool? = nil,
            lagId: Swift.String? = nil,
            lagName: Swift.String? = nil,
            lagState: DirectConnectClientTypes.LagState? = nil,
            location: Swift.String? = nil,
            macSecCapable: Swift.Bool? = nil,
            macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
            minimumLinks: Swift.Int = 0,
            numberOfConnections: Swift.Int = 0,
            ownerAccount: Swift.String? = nil,
            providerName: Swift.String? = nil,
            region: Swift.String? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil
        )
        {
            self.allowsHostedConnections = allowsHostedConnections
            self.awsDevice = awsDevice
            self.awsDeviceV2 = awsDeviceV2
            self.awsLogicalDeviceId = awsLogicalDeviceId
            self.connections = connections
            self.connectionsBandwidth = connectionsBandwidth
            self.encryptionMode = encryptionMode
            self.hasLogicalRedundancy = hasLogicalRedundancy
            self.jumboFrameCapable = jumboFrameCapable
            self.lagId = lagId
            self.lagName = lagName
            self.lagState = lagState
            self.location = location
            self.macSecCapable = macSecCapable
            self.macSecKeys = macSecKeys
            self.minimumLinks = minimumLinks
            self.numberOfConnections = numberOfConnections
            self.ownerAccount = ownerAccount
            self.providerName = providerName
            self.region = region
            self.tags = tags
        }
    }
}

public struct DescribeLagsOutput: Swift.Sendable {
    /// The LAGs.
    public var lags: [DirectConnectClientTypes.Lag]?

    public init(
        lags: [DirectConnectClientTypes.Lag]? = nil
    )
    {
        self.lags = lags
    }
}

public struct DescribeLoaInput: Swift.Sendable {
    /// The ID of a connection, LAG, or interconnect.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The standard media type for the LOA-CFA document. The only supported value is application/pdf.
    public var loaContentType: DirectConnectClientTypes.LoaContentType?
    /// The name of the service provider who establishes connectivity on your behalf. If you specify this parameter, the LOA-CFA lists the provider name alongside your company name as the requester of the cross connect.
    public var providerName: Swift.String?

    public init(
        connectionId: Swift.String? = nil,
        loaContentType: DirectConnectClientTypes.LoaContentType? = nil,
        providerName: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.loaContentType = loaContentType
        self.providerName = providerName
    }
}

/// Information about a Letter of Authorization - Connecting Facility Assignment (LOA-CFA) for a connection.
public struct DescribeLoaOutput: Swift.Sendable {
    /// The binary contents of the LOA-CFA document.
    public var loaContent: Foundation.Data?
    /// The standard media type for the LOA-CFA document. The only supported value is application/pdf.
    public var loaContentType: DirectConnectClientTypes.LoaContentType?

    public init(
        loaContent: Foundation.Data? = nil,
        loaContentType: DirectConnectClientTypes.LoaContentType? = nil
    )
    {
        self.loaContent = loaContent
        self.loaContentType = loaContentType
    }
}

extension DirectConnectClientTypes {

    /// Information about an Direct Connect location.
    public struct Location: Swift.Sendable {
        /// The available MAC Security (MACsec) port speeds for the location.
        public var availableMacSecPortSpeeds: [Swift.String]?
        /// The available port speeds for the location.
        public var availablePortSpeeds: [Swift.String]?
        /// The name of the service provider for the location.
        public var availableProviders: [Swift.String]?
        /// The code for the location.
        public var locationCode: Swift.String?
        /// The name of the location. This includes the name of the colocation partner and the physical site of the building.
        public var locationName: Swift.String?
        /// The Amazon Web Services Region for the location.
        public var region: Swift.String?

        public init(
            availableMacSecPortSpeeds: [Swift.String]? = nil,
            availablePortSpeeds: [Swift.String]? = nil,
            availableProviders: [Swift.String]? = nil,
            locationCode: Swift.String? = nil,
            locationName: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.availableMacSecPortSpeeds = availableMacSecPortSpeeds
            self.availablePortSpeeds = availablePortSpeeds
            self.availableProviders = availableProviders
            self.locationCode = locationCode
            self.locationName = locationName
            self.region = region
        }
    }
}

public struct DescribeLocationsOutput: Swift.Sendable {
    /// The locations.
    public var locations: [DirectConnectClientTypes.Location]?

    public init(
        locations: [DirectConnectClientTypes.Location]? = nil
    )
    {
        self.locations = locations
    }
}

/// Provides the details about a virtual interface's router.
public struct DescribeRouterConfigurationInput: Swift.Sendable {
    /// Identifies the router by a combination of vendor, platform, and software version. For example, CiscoSystemsInc-2900SeriesRouters-IOS124.
    public var routerTypeIdentifier: Swift.String?
    /// The ID of the virtual interface.
    /// This member is required.
    public var virtualInterfaceId: Swift.String?

    public init(
        routerTypeIdentifier: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.routerTypeIdentifier = routerTypeIdentifier
        self.virtualInterfaceId = virtualInterfaceId
    }
}

extension DirectConnectClientTypes {

    /// Information about the virtual router.
    public struct RouterType: Swift.Sendable {
        /// The virtual interface router platform.
        public var platform: Swift.String?
        /// Identifies the router by a combination of vendor, platform, and software version. For example, CiscoSystemsInc-2900SeriesRouters-IOS124.
        public var routerTypeIdentifier: Swift.String?
        /// The router software.
        public var software: Swift.String?
        /// The vendor for the virtual interface's router.
        public var vendor: Swift.String?
        /// The template for the virtual interface's router.
        public var xsltTemplateName: Swift.String?
        /// The MAC Security (MACsec) template for the virtual interface's router.
        public var xsltTemplateNameForMacSec: Swift.String?

        public init(
            platform: Swift.String? = nil,
            routerTypeIdentifier: Swift.String? = nil,
            software: Swift.String? = nil,
            vendor: Swift.String? = nil,
            xsltTemplateName: Swift.String? = nil,
            xsltTemplateNameForMacSec: Swift.String? = nil
        )
        {
            self.platform = platform
            self.routerTypeIdentifier = routerTypeIdentifier
            self.software = software
            self.vendor = vendor
            self.xsltTemplateName = xsltTemplateName
            self.xsltTemplateNameForMacSec = xsltTemplateNameForMacSec
        }
    }
}

public struct DescribeRouterConfigurationOutput: Swift.Sendable {
    /// The customer router configuration.
    public var customerRouterConfig: Swift.String?
    /// The details about the router.
    public var router: DirectConnectClientTypes.RouterType?
    /// The ID assigned to the virtual interface.
    public var virtualInterfaceId: Swift.String?
    /// Provides the details about a virtual interface's router.
    public var virtualInterfaceName: Swift.String?

    public init(
        customerRouterConfig: Swift.String? = nil,
        router: DirectConnectClientTypes.RouterType? = nil,
        virtualInterfaceId: Swift.String? = nil,
        virtualInterfaceName: Swift.String? = nil
    )
    {
        self.customerRouterConfig = customerRouterConfig
        self.router = router
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
    }
}

public struct DescribeTagsInput: Swift.Sendable {
    /// The Amazon Resource Names (ARNs) of the resources.
    /// This member is required.
    public var resourceArns: [Swift.String]?

    public init(
        resourceArns: [Swift.String]? = nil
    )
    {
        self.resourceArns = resourceArns
    }
}

extension DirectConnectClientTypes {

    /// Information about a tag associated with an Direct Connect resource.
    public struct ResourceTag: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var resourceArn: Swift.String?
        /// The tags.
        public var tags: [DirectConnectClientTypes.Tag]?

        public init(
            resourceArn: Swift.String? = nil,
            tags: [DirectConnectClientTypes.Tag]? = nil
        )
        {
            self.resourceArn = resourceArn
            self.tags = tags
        }
    }
}

public struct DescribeTagsOutput: Swift.Sendable {
    /// Information about the tags.
    public var resourceTags: [DirectConnectClientTypes.ResourceTag]?

    public init(
        resourceTags: [DirectConnectClientTypes.ResourceTag]? = nil
    )
    {
        self.resourceTags = resourceTags
    }
}

extension DirectConnectClientTypes {

    /// Information about a virtual private gateway for a private virtual interface.
    public struct VirtualGateway: Swift.Sendable {
        /// The ID of the virtual private gateway.
        public var virtualGatewayId: Swift.String?
        /// The state of the virtual private gateway. The following are the possible values:
        ///
        /// * pending: Initial state after creating the virtual private gateway.
        ///
        /// * available: Ready for use by a private virtual interface.
        ///
        /// * deleting: Initial state after deleting the virtual private gateway.
        ///
        /// * deleted: The virtual private gateway is deleted. The private virtual interface is unable to send traffic over this gateway.
        public var virtualGatewayState: Swift.String?

        public init(
            virtualGatewayId: Swift.String? = nil,
            virtualGatewayState: Swift.String? = nil
        )
        {
            self.virtualGatewayId = virtualGatewayId
            self.virtualGatewayState = virtualGatewayState
        }
    }
}

public struct DescribeVirtualGatewaysOutput: Swift.Sendable {
    /// The virtual private gateways.
    public var virtualGateways: [DirectConnectClientTypes.VirtualGateway]?

    public init(
        virtualGateways: [DirectConnectClientTypes.VirtualGateway]? = nil
    )
    {
        self.virtualGateways = virtualGateways
    }
}

public struct DescribeVirtualInterfacesInput: Swift.Sendable {
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?

    public init(
        connectionId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.virtualInterfaceId = virtualInterfaceId
    }
}

public struct DescribeVirtualInterfacesOutput: Swift.Sendable {
    /// The virtual interfaces
    public var virtualInterfaces: [DirectConnectClientTypes.VirtualInterface]?

    public init(
        virtualInterfaces: [DirectConnectClientTypes.VirtualInterface]? = nil
    )
    {
        self.virtualInterfaces = virtualInterfaces
    }
}

public struct DisassociateConnectionFromLagInput: Swift.Sendable {
    /// The ID of the connection.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The ID of the LAG.
    /// This member is required.
    public var lagId: Swift.String?

    public init(
        connectionId: Swift.String? = nil,
        lagId: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.lagId = lagId
    }
}

/// Information about an Direct Connect connection.
public struct DisassociateConnectionFromLagOutput: Swift.Sendable {
    /// The Direct Connect endpoint on which the physical connection terminates.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The bandwidth of the connection.
    public var bandwidth: Swift.String?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The name of the connection.
    public var connectionName: Swift.String?
    /// The state of the connection. The following are the possible values:
    ///
    /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
    ///
    /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The connection has been approved and is being initialized.
    ///
    /// * available: The network link is up and the connection is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The connection is being deleted.
    ///
    /// * deleted: The connection has been deleted.
    ///
    /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
    ///
    /// * unknown: The state of the connection is not available.
    public var connectionState: DirectConnectClientTypes.ConnectionState?
    /// The MAC Security (MACsec) connection encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The time of the most recent call to [DescribeLoa] for this connection.
    public var loaIssueTime: Foundation.Date?
    /// The location of the connection.
    public var location: Swift.String?
    /// Indicates whether the connection supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The ID of the Amazon Web Services account that owns the connection.
    public var ownerAccount: Swift.String?
    /// The name of the Direct Connect service provider associated with the connection.
    public var partnerName: Swift.String?
    /// The MAC Security (MACsec) port link status of the connection. The valid values are Encryption Up, which means that there is an active Connection Key Name, or Encryption Down.
    public var portEncryptionStatus: Swift.String?
    /// The name of the service provider associated with the connection.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the connection.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init(
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bandwidth: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        connectionState: DirectConnectClientTypes.ConnectionState? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        loaIssueTime: Foundation.Date? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        ownerAccount: Swift.String? = nil,
        partnerName: Swift.String? = nil,
        portEncryptionStatus: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

public struct DisassociateMacSecKeyInput: Swift.Sendable {
    /// The ID of the dedicated connection (dxcon-xxxx), or the ID of the LAG (dxlag-xxxx). You can use [DescribeConnections] or [DescribeLags] to retrieve connection ID.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the MAC Security (MACsec) secret key. You can use [DescribeConnections] to retrieve the ARN of the MAC Security (MACsec) secret key.
    /// This member is required.
    public var secretARN: Swift.String?

    public init(
        connectionId: Swift.String? = nil,
        secretARN: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.secretARN = secretARN
    }
}

public struct DisassociateMacSecKeyOutput: Swift.Sendable {
    /// The ID of the dedicated connection (dxcon-xxxx), or the ID of the LAG (dxlag-xxxx).
    public var connectionId: Swift.String?
    /// The MAC Security (MACsec) security keys no longer associated with the dedicated connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?

    public init(
        connectionId: Swift.String? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil
    )
    {
        self.connectionId = connectionId
        self.macSecKeys = macSecKeys
    }
}

public struct ListVirtualInterfaceTestHistoryInput: Swift.Sendable {
    /// The BGP peers that were placed in the DOWN state during the virtual interface failover test.
    public var bgpPeers: [Swift.String]?
    /// The maximum number of results to return with a single call. To retrieve the remaining results, make another call with the returned nextToken value. If MaxResults is given a value larger than 100, only 100 results are returned.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The status of the virtual interface failover test.
    public var status: Swift.String?
    /// The ID of the virtual interface failover test.
    public var testId: Swift.String?
    /// The ID of the virtual interface that was tested.
    public var virtualInterfaceId: Swift.String?

    public init(
        bgpPeers: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: Swift.String? = nil,
        testId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.bgpPeers = bgpPeers
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
        self.testId = testId
        self.virtualInterfaceId = virtualInterfaceId
    }
}

extension DirectConnectClientTypes {

    /// Information about the virtual interface failover test.
    public struct VirtualInterfaceTestHistory: Swift.Sendable {
        /// The BGP peers that were put in the DOWN state as part of the virtual interface failover test.
        public var bgpPeers: [Swift.String]?
        /// The time that the virtual interface moves out of the DOWN state.
        public var endTime: Foundation.Date?
        /// The owner ID of the tested virtual interface.
        public var ownerAccount: Swift.String?
        /// The time that the virtual interface moves to the DOWN state.
        public var startTime: Foundation.Date?
        /// The status of the virtual interface failover test.
        public var status: Swift.String?
        /// The time that the virtual interface failover test ran in minutes.
        public var testDurationInMinutes: Swift.Int?
        /// The ID of the virtual interface failover test.
        public var testId: Swift.String?
        /// The ID of the tested virtual interface.
        public var virtualInterfaceId: Swift.String?

        public init(
            bgpPeers: [Swift.String]? = nil,
            endTime: Foundation.Date? = nil,
            ownerAccount: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            status: Swift.String? = nil,
            testDurationInMinutes: Swift.Int? = nil,
            testId: Swift.String? = nil,
            virtualInterfaceId: Swift.String? = nil
        )
        {
            self.bgpPeers = bgpPeers
            self.endTime = endTime
            self.ownerAccount = ownerAccount
            self.startTime = startTime
            self.status = status
            self.testDurationInMinutes = testDurationInMinutes
            self.testId = testId
            self.virtualInterfaceId = virtualInterfaceId
        }
    }
}

public struct ListVirtualInterfaceTestHistoryOutput: Swift.Sendable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The ID of the tested virtual interface.
    public var virtualInterfaceTestHistory: [DirectConnectClientTypes.VirtualInterfaceTestHistory]?

    public init(
        nextToken: Swift.String? = nil,
        virtualInterfaceTestHistory: [DirectConnectClientTypes.VirtualInterfaceTestHistory]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualInterfaceTestHistory = virtualInterfaceTestHistory
    }
}

public struct StartBgpFailoverTestInput: Swift.Sendable {
    /// The BGP peers to place in the DOWN state.
    public var bgpPeers: [Swift.String]?
    /// The time in minutes that the virtual interface failover test will last. Maximum value: 4,320 minutes (72 hours). Default: 180 minutes (3 hours).
    public var testDurationInMinutes: Swift.Int?
    /// The ID of the virtual interface you want to test.
    /// This member is required.
    public var virtualInterfaceId: Swift.String?

    public init(
        bgpPeers: [Swift.String]? = nil,
        testDurationInMinutes: Swift.Int? = nil,
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.bgpPeers = bgpPeers
        self.testDurationInMinutes = testDurationInMinutes
        self.virtualInterfaceId = virtualInterfaceId
    }
}

public struct StartBgpFailoverTestOutput: Swift.Sendable {
    /// Information about the virtual interface failover test.
    public var virtualInterfaceTest: DirectConnectClientTypes.VirtualInterfaceTestHistory?

    public init(
        virtualInterfaceTest: DirectConnectClientTypes.VirtualInterfaceTestHistory? = nil
    )
    {
        self.virtualInterfaceTest = virtualInterfaceTest
    }
}

public struct StopBgpFailoverTestInput: Swift.Sendable {
    /// The ID of the virtual interface you no longer want to test.
    /// This member is required.
    public var virtualInterfaceId: Swift.String?

    public init(
        virtualInterfaceId: Swift.String? = nil
    )
    {
        self.virtualInterfaceId = virtualInterfaceId
    }
}

public struct StopBgpFailoverTestOutput: Swift.Sendable {
    /// Information about the virtual interface failover test.
    public var virtualInterfaceTest: DirectConnectClientTypes.VirtualInterfaceTestHistory?

    public init(
        virtualInterfaceTest: DirectConnectClientTypes.VirtualInterfaceTestHistory? = nil
    )
    {
        self.virtualInterfaceTest = virtualInterfaceTest
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add.
    /// This member is required.
    public var tags: [DirectConnectClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateConnectionInput: Swift.Sendable {
    /// The ID of the dedicated connection. You can use [DescribeConnections] to retrieve the connection ID.
    /// This member is required.
    public var connectionId: Swift.String?
    /// The name of the connection.
    public var connectionName: Swift.String?
    /// The connection MAC Security (MACsec) encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?

    public init(
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        encryptionMode: Swift.String? = nil
    )
    {
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.encryptionMode = encryptionMode
    }
}

/// Information about an Direct Connect connection.
public struct UpdateConnectionOutput: Swift.Sendable {
    /// The Direct Connect endpoint on which the physical connection terminates.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The bandwidth of the connection.
    public var bandwidth: Swift.String?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The name of the connection.
    public var connectionName: Swift.String?
    /// The state of the connection. The following are the possible values:
    ///
    /// * ordering: The initial state of a hosted connection provisioned on an interconnect. The connection stays in the ordering state until the owner of the hosted connection confirms or declines the connection order.
    ///
    /// * requested: The initial state of a standard connection. The connection stays in the requested state until the Letter of Authorization (LOA) is sent to the customer.
    ///
    /// * pending: The connection has been approved and is being initialized.
    ///
    /// * available: The network link is up and the connection is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The connection is being deleted.
    ///
    /// * deleted: The connection has been deleted.
    ///
    /// * rejected: A hosted connection in the ordering state enters the rejected state if it is deleted by the customer.
    ///
    /// * unknown: The state of the connection is not available.
    public var connectionState: DirectConnectClientTypes.ConnectionState?
    /// The MAC Security (MACsec) connection encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the connection supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The time of the most recent call to [DescribeLoa] for this connection.
    public var loaIssueTime: Foundation.Date?
    /// The location of the connection.
    public var location: Swift.String?
    /// Indicates whether the connection supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the connection.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The ID of the Amazon Web Services account that owns the connection.
    public var ownerAccount: Swift.String?
    /// The name of the Direct Connect service provider associated with the connection.
    public var partnerName: Swift.String?
    /// The MAC Security (MACsec) port link status of the connection. The valid values are Encryption Up, which means that there is an active Connection Key Name, or Encryption Down.
    public var portEncryptionStatus: Swift.String?
    /// The name of the service provider associated with the connection.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the connection.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init(
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bandwidth: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionName: Swift.String? = nil,
        connectionState: DirectConnectClientTypes.ConnectionState? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        loaIssueTime: Foundation.Date? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        ownerAccount: Swift.String? = nil,
        partnerName: Swift.String? = nil,
        portEncryptionStatus: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bandwidth = bandwidth
        self.connectionId = connectionId
        self.connectionName = connectionName
        self.connectionState = connectionState
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.loaIssueTime = loaIssueTime
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.ownerAccount = ownerAccount
        self.partnerName = partnerName
        self.portEncryptionStatus = portEncryptionStatus
        self.providerName = providerName
        self.region = region
        self.tags = tags
        self.vlan = vlan
    }
}

public struct UpdateDirectConnectGatewayInput: Swift.Sendable {
    /// The ID of the Direct Connect gateway to update.
    /// This member is required.
    public var directConnectGatewayId: Swift.String?
    /// The new name for the Direct Connect gateway.
    /// This member is required.
    public var newDirectConnectGatewayName: Swift.String?

    public init(
        directConnectGatewayId: Swift.String? = nil,
        newDirectConnectGatewayName: Swift.String? = nil
    )
    {
        self.directConnectGatewayId = directConnectGatewayId
        self.newDirectConnectGatewayName = newDirectConnectGatewayName
    }
}

public struct UpdateDirectConnectGatewayOutput: Swift.Sendable {
    /// Informaiton about a Direct Connect gateway, which enables you to connect virtual interfaces and virtual private gateways or transit gateways.
    public var directConnectGateway: DirectConnectClientTypes.DirectConnectGateway?

    public init(
        directConnectGateway: DirectConnectClientTypes.DirectConnectGateway? = nil
    )
    {
        self.directConnectGateway = directConnectGateway
    }
}

public struct UpdateDirectConnectGatewayAssociationInput: Swift.Sendable {
    /// The Amazon VPC prefixes to advertise to the Direct Connect gateway.
    public var addAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// The ID of the Direct Connect gateway association.
    public var associationId: Swift.String?
    /// The Amazon VPC prefixes to no longer advertise to the Direct Connect gateway.
    public var removeAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]?

    public init(
        addAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        associationId: Swift.String? = nil,
        removeAllowedPrefixesToDirectConnectGateway: [DirectConnectClientTypes.RouteFilterPrefix]? = nil
    )
    {
        self.addAllowedPrefixesToDirectConnectGateway = addAllowedPrefixesToDirectConnectGateway
        self.associationId = associationId
        self.removeAllowedPrefixesToDirectConnectGateway = removeAllowedPrefixesToDirectConnectGateway
    }
}

public struct UpdateDirectConnectGatewayAssociationOutput: Swift.Sendable {
    /// Information about an association between a Direct Connect gateway and a virtual private gateway or transit gateway.
    public var directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation?

    public init(
        directConnectGatewayAssociation: DirectConnectClientTypes.DirectConnectGatewayAssociation? = nil
    )
    {
        self.directConnectGatewayAssociation = directConnectGatewayAssociation
    }
}

public struct UpdateLagInput: Swift.Sendable {
    /// The LAG MAC Security (MACsec) encryption mode. Amazon Web Services applies the value to all connections which are part of the LAG.
    public var encryptionMode: Swift.String?
    /// The ID of the LAG.
    /// This member is required.
    public var lagId: Swift.String?
    /// The name of the LAG.
    public var lagName: Swift.String?
    /// The minimum number of physical connections that must be operational for the LAG itself to be operational.
    public var minimumLinks: Swift.Int?

    public init(
        encryptionMode: Swift.String? = nil,
        lagId: Swift.String? = nil,
        lagName: Swift.String? = nil,
        minimumLinks: Swift.Int? = 0
    )
    {
        self.encryptionMode = encryptionMode
        self.lagId = lagId
        self.lagName = lagName
        self.minimumLinks = minimumLinks
    }
}

/// Information about a link aggregation group (LAG).
public struct UpdateLagOutput: Swift.Sendable {
    /// Indicates whether the LAG can host other connections.
    public var allowsHostedConnections: Swift.Bool
    /// The Direct Connect endpoint that hosts the LAG.
    @available(*, deprecated)
    public var awsDevice: Swift.String?
    /// The Direct Connect endpoint that hosts the LAG.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The connections bundled by the LAG.
    public var connections: [DirectConnectClientTypes.Connection]?
    /// The individual bandwidth of the physical connections bundled by the LAG. The possible values are 1Gbps, 10Gbps, 100Gbps, or 400 Gbps..
    public var connectionsBandwidth: Swift.String?
    /// The LAG MAC Security (MACsec) encryption mode. The valid values are no_encrypt, should_encrypt, and must_encrypt.
    public var encryptionMode: Swift.String?
    /// Indicates whether the LAG supports a secondary BGP peer in the same address family (IPv4/IPv6).
    public var hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy?
    /// Indicates whether jumbo frames are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The ID of the LAG.
    public var lagId: Swift.String?
    /// The name of the LAG.
    public var lagName: Swift.String?
    /// The state of the LAG. The following are the possible values:
    ///
    /// * requested: The initial state of a LAG. The LAG stays in the requested state until the Letter of Authorization (LOA) is available.
    ///
    /// * pending: The LAG has been approved and is being initialized.
    ///
    /// * available: The network link is established and the LAG is ready for use.
    ///
    /// * down: The network link is down.
    ///
    /// * deleting: The LAG is being deleted.
    ///
    /// * deleted: The LAG is deleted.
    ///
    /// * unknown: The state of the LAG is not available.
    public var lagState: DirectConnectClientTypes.LagState?
    /// The location of the LAG.
    public var location: Swift.String?
    /// Indicates whether the LAG supports MAC Security (MACsec).
    public var macSecCapable: Swift.Bool?
    /// The MAC Security (MACsec) security keys associated with the LAG.
    public var macSecKeys: [DirectConnectClientTypes.MacSecKey]?
    /// The minimum number of physical dedicated connections that must be operational for the LAG itself to be operational.
    public var minimumLinks: Swift.Int
    /// The number of physical dedicated connections initially provisioned and bundled by the LAG. You can have a maximum of four connections when the port speed is 1 Gbps or 10 Gbps, or two when the port speed is 100 Gbps or 400 Gbps.
    public var numberOfConnections: Swift.Int
    /// The ID of the Amazon Web Services account that owns the LAG.
    public var ownerAccount: Swift.String?
    /// The name of the service provider associated with the LAG.
    public var providerName: Swift.String?
    /// The Amazon Web Services Region where the connection is located.
    public var region: Swift.String?
    /// The tags associated with the LAG.
    public var tags: [DirectConnectClientTypes.Tag]?

    public init(
        allowsHostedConnections: Swift.Bool = false,
        awsDevice: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        connections: [DirectConnectClientTypes.Connection]? = nil,
        connectionsBandwidth: Swift.String? = nil,
        encryptionMode: Swift.String? = nil,
        hasLogicalRedundancy: DirectConnectClientTypes.HasLogicalRedundancy? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        lagId: Swift.String? = nil,
        lagName: Swift.String? = nil,
        lagState: DirectConnectClientTypes.LagState? = nil,
        location: Swift.String? = nil,
        macSecCapable: Swift.Bool? = nil,
        macSecKeys: [DirectConnectClientTypes.MacSecKey]? = nil,
        minimumLinks: Swift.Int = 0,
        numberOfConnections: Swift.Int = 0,
        ownerAccount: Swift.String? = nil,
        providerName: Swift.String? = nil,
        region: Swift.String? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil
    )
    {
        self.allowsHostedConnections = allowsHostedConnections
        self.awsDevice = awsDevice
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.connections = connections
        self.connectionsBandwidth = connectionsBandwidth
        self.encryptionMode = encryptionMode
        self.hasLogicalRedundancy = hasLogicalRedundancy
        self.jumboFrameCapable = jumboFrameCapable
        self.lagId = lagId
        self.lagName = lagName
        self.lagState = lagState
        self.location = location
        self.macSecCapable = macSecCapable
        self.macSecKeys = macSecKeys
        self.minimumLinks = minimumLinks
        self.numberOfConnections = numberOfConnections
        self.ownerAccount = ownerAccount
        self.providerName = providerName
        self.region = region
        self.tags = tags
    }
}

public struct UpdateVirtualInterfaceAttributesInput: Swift.Sendable {
    /// Indicates whether to enable or disable SiteLink.
    public var enableSiteLink: Swift.Bool?
    /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 8500. The default value is 1500.
    public var mtu: Swift.Int?
    /// The ID of the virtual private interface.
    /// This member is required.
    public var virtualInterfaceId: Swift.String?
    /// The name of the virtual private interface.
    public var virtualInterfaceName: Swift.String?

    public init(
        enableSiteLink: Swift.Bool? = nil,
        mtu: Swift.Int? = nil,
        virtualInterfaceId: Swift.String? = nil,
        virtualInterfaceName: Swift.String? = nil
    )
    {
        self.enableSiteLink = enableSiteLink
        self.mtu = mtu
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
    }
}

/// Information about a virtual interface.
public struct UpdateVirtualInterfaceAttributesOutput: Swift.Sendable {
    /// The address family for the BGP peer.
    public var addressFamily: DirectConnectClientTypes.AddressFamily?
    /// The IP address assigned to the Amazon interface.
    public var amazonAddress: Swift.String?
    /// The autonomous system number (ASN) for the Amazon side of the connection.
    public var amazonSideAsn: Swift.Int?
    /// The autonomous system (AS) number for Border Gateway Protocol (BGP) configuration. The valid values are 1-2147483647.
    public var asn: Swift.Int
    /// The authentication key for BGP configuration. This string has a minimum length of 6 characters and and a maximun lenth of 80 characters.
    public var authKey: Swift.String?
    /// The Direct Connect endpoint that terminates the physical connection.
    public var awsDeviceV2: Swift.String?
    /// The Direct Connect endpoint that terminates the logical connection. This device might be different than the device that terminates the physical connection.
    public var awsLogicalDeviceId: Swift.String?
    /// The BGP peers configured on this virtual interface.
    public var bgpPeers: [DirectConnectClientTypes.BGPPeer]?
    /// The ID of the connection.
    public var connectionId: Swift.String?
    /// The IP address assigned to the customer interface.
    public var customerAddress: Swift.String?
    /// The customer router configuration.
    public var customerRouterConfig: Swift.String?
    /// The ID of the Direct Connect gateway.
    public var directConnectGatewayId: Swift.String?
    /// Indicates whether jumbo frames are supported.
    public var jumboFrameCapable: Swift.Bool?
    /// The location of the connection.
    public var location: Swift.String?
    /// The maximum transmission unit (MTU), in bytes. The supported values are 1500 and 8500. The default value is 1500
    public var mtu: Swift.Int?
    /// The ID of the Amazon Web Services account that owns the virtual interface.
    public var ownerAccount: Swift.String?
    /// The Amazon Web Services Region where the virtual interface is located.
    public var region: Swift.String?
    /// The routes to be advertised to the Amazon Web Services network in this Region. Applies to public virtual interfaces.
    public var routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]?
    /// Indicates whether SiteLink is enabled.
    public var siteLinkEnabled: Swift.Bool?
    /// The tags associated with the virtual interface.
    public var tags: [DirectConnectClientTypes.Tag]?
    /// The ID of the virtual private gateway. Applies only to private virtual interfaces.
    public var virtualGatewayId: Swift.String?
    /// The ID of the virtual interface.
    public var virtualInterfaceId: Swift.String?
    /// The name of the virtual interface assigned by the customer network. The name has a maximum of 100 characters. The following are valid characters: a-z, 0-9 and a hyphen (-).
    public var virtualInterfaceName: Swift.String?
    /// The state of the virtual interface. The following are the possible values:
    ///
    /// * confirming: The creation of the virtual interface is pending confirmation from the virtual interface owner. If the owner of the virtual interface is different from the owner of the connection on which it is provisioned, then the virtual interface will remain in this state until it is confirmed by the virtual interface owner.
    ///
    /// * verifying: This state only applies to public virtual interfaces. Each public virtual interface needs validation before the virtual interface can be created.
    ///
    /// * pending: A virtual interface is in this state from the time that it is created until the virtual interface is ready to forward traffic.
    ///
    /// * available: A virtual interface that is able to forward traffic.
    ///
    /// * down: A virtual interface that is BGP down.
    ///
    /// * deleting: A virtual interface is in this state immediately after calling [DeleteVirtualInterface] until it can no longer forward traffic.
    ///
    /// * deleted: A virtual interface that cannot forward traffic.
    ///
    /// * rejected: The virtual interface owner has declined creation of the virtual interface. If a virtual interface in the Confirming state is deleted by the virtual interface owner, the virtual interface enters the Rejected state.
    ///
    /// * unknown: The state of the virtual interface is not available.
    public var virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState?
    /// The type of virtual interface. The possible values are private, public and transit.
    public var virtualInterfaceType: Swift.String?
    /// The ID of the VLAN.
    public var vlan: Swift.Int

    public init(
        addressFamily: DirectConnectClientTypes.AddressFamily? = nil,
        amazonAddress: Swift.String? = nil,
        amazonSideAsn: Swift.Int? = nil,
        asn: Swift.Int = 0,
        authKey: Swift.String? = nil,
        awsDeviceV2: Swift.String? = nil,
        awsLogicalDeviceId: Swift.String? = nil,
        bgpPeers: [DirectConnectClientTypes.BGPPeer]? = nil,
        connectionId: Swift.String? = nil,
        customerAddress: Swift.String? = nil,
        customerRouterConfig: Swift.String? = nil,
        directConnectGatewayId: Swift.String? = nil,
        jumboFrameCapable: Swift.Bool? = nil,
        location: Swift.String? = nil,
        mtu: Swift.Int? = nil,
        ownerAccount: Swift.String? = nil,
        region: Swift.String? = nil,
        routeFilterPrefixes: [DirectConnectClientTypes.RouteFilterPrefix]? = nil,
        siteLinkEnabled: Swift.Bool? = nil,
        tags: [DirectConnectClientTypes.Tag]? = nil,
        virtualGatewayId: Swift.String? = nil,
        virtualInterfaceId: Swift.String? = nil,
        virtualInterfaceName: Swift.String? = nil,
        virtualInterfaceState: DirectConnectClientTypes.VirtualInterfaceState? = nil,
        virtualInterfaceType: Swift.String? = nil,
        vlan: Swift.Int = 0
    )
    {
        self.addressFamily = addressFamily
        self.amazonAddress = amazonAddress
        self.amazonSideAsn = amazonSideAsn
        self.asn = asn
        self.authKey = authKey
        self.awsDeviceV2 = awsDeviceV2
        self.awsLogicalDeviceId = awsLogicalDeviceId
        self.bgpPeers = bgpPeers
        self.connectionId = connectionId
        self.customerAddress = customerAddress
        self.customerRouterConfig = customerRouterConfig
        self.directConnectGatewayId = directConnectGatewayId
        self.jumboFrameCapable = jumboFrameCapable
        self.location = location
        self.mtu = mtu
        self.ownerAccount = ownerAccount
        self.region = region
        self.routeFilterPrefixes = routeFilterPrefixes
        self.siteLinkEnabled = siteLinkEnabled
        self.tags = tags
        self.virtualGatewayId = virtualGatewayId
        self.virtualInterfaceId = virtualInterfaceId
        self.virtualInterfaceName = virtualInterfaceName
        self.virtualInterfaceState = virtualInterfaceState
        self.virtualInterfaceType = virtualInterfaceType
        self.vlan = vlan
    }
}

extension AcceptDirectConnectGatewayAssociationProposalInput {

    static func urlPathProvider(_ value: AcceptDirectConnectGatewayAssociationProposalInput) -> Swift.String? {
        return "/"
    }
}

extension AllocateConnectionOnInterconnectInput {

    static func urlPathProvider(_ value: AllocateConnectionOnInterconnectInput) -> Swift.String? {
        return "/"
    }
}

extension AllocateHostedConnectionInput {

    static func urlPathProvider(_ value: AllocateHostedConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension AllocatePrivateVirtualInterfaceInput {

    static func urlPathProvider(_ value: AllocatePrivateVirtualInterfaceInput) -> Swift.String? {
        return "/"
    }
}

extension AllocatePublicVirtualInterfaceInput {

    static func urlPathProvider(_ value: AllocatePublicVirtualInterfaceInput) -> Swift.String? {
        return "/"
    }
}

extension AllocateTransitVirtualInterfaceInput {

    static func urlPathProvider(_ value: AllocateTransitVirtualInterfaceInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateConnectionWithLagInput {

    static func urlPathProvider(_ value: AssociateConnectionWithLagInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateHostedConnectionInput {

    static func urlPathProvider(_ value: AssociateHostedConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateMacSecKeyInput {

    static func urlPathProvider(_ value: AssociateMacSecKeyInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateVirtualInterfaceInput {

    static func urlPathProvider(_ value: AssociateVirtualInterfaceInput) -> Swift.String? {
        return "/"
    }
}

extension ConfirmConnectionInput {

    static func urlPathProvider(_ value: ConfirmConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension ConfirmCustomerAgreementInput {

    static func urlPathProvider(_ value: ConfirmCustomerAgreementInput) -> Swift.String? {
        return "/"
    }
}

extension ConfirmPrivateVirtualInterfaceInput {

    static func urlPathProvider(_ value: ConfirmPrivateVirtualInterfaceInput) -> Swift.String? {
        return "/"
    }
}

extension ConfirmPublicVirtualInterfaceInput {

    static func urlPathProvider(_ value: ConfirmPublicVirtualInterfaceInput) -> Swift.String? {
        return "/"
    }
}

extension ConfirmTransitVirtualInterfaceInput {

    static func urlPathProvider(_ value: ConfirmTransitVirtualInterfaceInput) -> Swift.String? {
        return "/"
    }
}

extension CreateBGPPeerInput {

    static func urlPathProvider(_ value: CreateBGPPeerInput) -> Swift.String? {
        return "/"
    }
}

extension CreateConnectionInput {

    static func urlPathProvider(_ value: CreateConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDirectConnectGatewayInput {

    static func urlPathProvider(_ value: CreateDirectConnectGatewayInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDirectConnectGatewayAssociationInput {

    static func urlPathProvider(_ value: CreateDirectConnectGatewayAssociationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDirectConnectGatewayAssociationProposalInput {

    static func urlPathProvider(_ value: CreateDirectConnectGatewayAssociationProposalInput) -> Swift.String? {
        return "/"
    }
}

extension CreateInterconnectInput {

    static func urlPathProvider(_ value: CreateInterconnectInput) -> Swift.String? {
        return "/"
    }
}

extension CreateLagInput {

    static func urlPathProvider(_ value: CreateLagInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePrivateVirtualInterfaceInput {

    static func urlPathProvider(_ value: CreatePrivateVirtualInterfaceInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePublicVirtualInterfaceInput {

    static func urlPathProvider(_ value: CreatePublicVirtualInterfaceInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTransitVirtualInterfaceInput {

    static func urlPathProvider(_ value: CreateTransitVirtualInterfaceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteBGPPeerInput {

    static func urlPathProvider(_ value: DeleteBGPPeerInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteConnectionInput {

    static func urlPathProvider(_ value: DeleteConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDirectConnectGatewayInput {

    static func urlPathProvider(_ value: DeleteDirectConnectGatewayInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDirectConnectGatewayAssociationInput {

    static func urlPathProvider(_ value: DeleteDirectConnectGatewayAssociationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDirectConnectGatewayAssociationProposalInput {

    static func urlPathProvider(_ value: DeleteDirectConnectGatewayAssociationProposalInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteInterconnectInput {

    static func urlPathProvider(_ value: DeleteInterconnectInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteLagInput {

    static func urlPathProvider(_ value: DeleteLagInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteVirtualInterfaceInput {

    static func urlPathProvider(_ value: DeleteVirtualInterfaceInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConnectionLoaInput {

    static func urlPathProvider(_ value: DescribeConnectionLoaInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConnectionsInput {

    static func urlPathProvider(_ value: DescribeConnectionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConnectionsOnInterconnectInput {

    static func urlPathProvider(_ value: DescribeConnectionsOnInterconnectInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeCustomerMetadataInput {

    static func urlPathProvider(_ value: DescribeCustomerMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDirectConnectGatewayAssociationProposalsInput {

    static func urlPathProvider(_ value: DescribeDirectConnectGatewayAssociationProposalsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDirectConnectGatewayAssociationsInput {

    static func urlPathProvider(_ value: DescribeDirectConnectGatewayAssociationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDirectConnectGatewayAttachmentsInput {

    static func urlPathProvider(_ value: DescribeDirectConnectGatewayAttachmentsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDirectConnectGatewaysInput {

    static func urlPathProvider(_ value: DescribeDirectConnectGatewaysInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeHostedConnectionsInput {

    static func urlPathProvider(_ value: DescribeHostedConnectionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeInterconnectLoaInput {

    static func urlPathProvider(_ value: DescribeInterconnectLoaInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeInterconnectsInput {

    static func urlPathProvider(_ value: DescribeInterconnectsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeLagsInput {

    static func urlPathProvider(_ value: DescribeLagsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeLoaInput {

    static func urlPathProvider(_ value: DescribeLoaInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeLocationsInput {

    static func urlPathProvider(_ value: DescribeLocationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRouterConfigurationInput {

    static func urlPathProvider(_ value: DescribeRouterConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeTagsInput {

    static func urlPathProvider(_ value: DescribeTagsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeVirtualGatewaysInput {

    static func urlPathProvider(_ value: DescribeVirtualGatewaysInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeVirtualInterfacesInput {

    static func urlPathProvider(_ value: DescribeVirtualInterfacesInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateConnectionFromLagInput {

    static func urlPathProvider(_ value: DisassociateConnectionFromLagInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateMacSecKeyInput {

    static func urlPathProvider(_ value: DisassociateMacSecKeyInput) -> Swift.String? {
        return "/"
    }
}

extension ListVirtualInterfaceTestHistoryInput {

    static func urlPathProvider(_ value: ListVirtualInterfaceTestHistoryInput) -> Swift.String? {
        return "/"
    }
}

extension StartBgpFailoverTestInput {

    static func urlPathProvider(_ value: StartBgpFailoverTestInput) -> Swift.String? {
        return "/"
    }
}

extension StopBgpFailoverTestInput {

    static func urlPathProvider(_ value: StopBgpFailoverTestInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateConnectionInput {

    static func urlPathProvider(_ value: UpdateConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDirectConnectGatewayInput {

    static func urlPathProvider(_ value: UpdateDirectConnectGatewayInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDirectConnectGatewayAssociationInput {

    static func urlPathProvider(_ value: UpdateDirectConnectGatewayAssociationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateLagInput {

    static func urlPathProvider(_ value: UpdateLagInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateVirtualInterfaceAttributesInput {

    static func urlPathProvider(_ value: UpdateVirtualInterfaceAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension AcceptDirectConnectGatewayAssociationProposalInput {

    static func write(value: AcceptDirectConnectGatewayAssociationProposalInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["associatedGatewayOwnerAccount"].write(value.associatedGatewayOwnerAccount)
        try writer["directConnectGatewayId"].write(value.directConnectGatewayId)
        try writer["overrideAllowedPrefixesToDirectConnectGateway"].writeList(value.overrideAllowedPrefixesToDirectConnectGateway, memberWritingClosure: DirectConnectClientTypes.RouteFilterPrefix.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["proposalId"].write(value.proposalId)
    }
}

extension AllocateConnectionOnInterconnectInput {

    static func write(value: AllocateConnectionOnInterconnectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bandwidth"].write(value.bandwidth)
        try writer["connectionName"].write(value.connectionName)
        try writer["interconnectId"].write(value.interconnectId)
        try writer["ownerAccount"].write(value.ownerAccount)
        try writer["vlan"].write(value.vlan)
    }
}

extension AllocateHostedConnectionInput {

    static func write(value: AllocateHostedConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bandwidth"].write(value.bandwidth)
        try writer["connectionId"].write(value.connectionId)
        try writer["connectionName"].write(value.connectionName)
        try writer["ownerAccount"].write(value.ownerAccount)
        try writer["tags"].writeList(value.tags, memberWritingClosure: DirectConnectClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vlan"].write(value.vlan)
    }
}

extension AllocatePrivateVirtualInterfaceInput {

    static func write(value: AllocatePrivateVirtualInterfaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
        try writer["newPrivateVirtualInterfaceAllocation"].write(value.newPrivateVirtualInterfaceAllocation, with: DirectConnectClientTypes.NewPrivateVirtualInterfaceAllocation.write(value:to:))
        try writer["ownerAccount"].write(value.ownerAccount)
    }
}

extension AllocatePublicVirtualInterfaceInput {

    static func write(value: AllocatePublicVirtualInterfaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
        try writer["newPublicVirtualInterfaceAllocation"].write(value.newPublicVirtualInterfaceAllocation, with: DirectConnectClientTypes.NewPublicVirtualInterfaceAllocation.write(value:to:))
        try writer["ownerAccount"].write(value.ownerAccount)
    }
}

extension AllocateTransitVirtualInterfaceInput {

    static func write(value: AllocateTransitVirtualInterfaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
        try writer["newTransitVirtualInterfaceAllocation"].write(value.newTransitVirtualInterfaceAllocation, with: DirectConnectClientTypes.NewTransitVirtualInterfaceAllocation.write(value:to:))
        try writer["ownerAccount"].write(value.ownerAccount)
    }
}

extension AssociateConnectionWithLagInput {

    static func write(value: AssociateConnectionWithLagInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
        try writer["lagId"].write(value.lagId)
    }
}

extension AssociateHostedConnectionInput {

    static func write(value: AssociateHostedConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
        try writer["parentConnectionId"].write(value.parentConnectionId)
    }
}

extension AssociateMacSecKeyInput {

    static func write(value: AssociateMacSecKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cak"].write(value.cak)
        try writer["ckn"].write(value.ckn)
        try writer["connectionId"].write(value.connectionId)
        try writer["secretARN"].write(value.secretARN)
    }
}

extension AssociateVirtualInterfaceInput {

    static func write(value: AssociateVirtualInterfaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
        try writer["virtualInterfaceId"].write(value.virtualInterfaceId)
    }
}

extension ConfirmConnectionInput {

    static func write(value: ConfirmConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
    }
}

extension ConfirmCustomerAgreementInput {

    static func write(value: ConfirmCustomerAgreementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["agreementName"].write(value.agreementName)
    }
}

extension ConfirmPrivateVirtualInterfaceInput {

    static func write(value: ConfirmPrivateVirtualInterfaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["directConnectGatewayId"].write(value.directConnectGatewayId)
        try writer["virtualGatewayId"].write(value.virtualGatewayId)
        try writer["virtualInterfaceId"].write(value.virtualInterfaceId)
    }
}

extension ConfirmPublicVirtualInterfaceInput {

    static func write(value: ConfirmPublicVirtualInterfaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["virtualInterfaceId"].write(value.virtualInterfaceId)
    }
}

extension ConfirmTransitVirtualInterfaceInput {

    static func write(value: ConfirmTransitVirtualInterfaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["directConnectGatewayId"].write(value.directConnectGatewayId)
        try writer["virtualInterfaceId"].write(value.virtualInterfaceId)
    }
}

extension CreateBGPPeerInput {

    static func write(value: CreateBGPPeerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["newBGPPeer"].write(value.newBGPPeer, with: DirectConnectClientTypes.NewBGPPeer.write(value:to:))
        try writer["virtualInterfaceId"].write(value.virtualInterfaceId)
    }
}

extension CreateConnectionInput {

    static func write(value: CreateConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bandwidth"].write(value.bandwidth)
        try writer["connectionName"].write(value.connectionName)
        try writer["lagId"].write(value.lagId)
        try writer["location"].write(value.location)
        try writer["providerName"].write(value.providerName)
        try writer["requestMACSec"].write(value.requestMACSec)
        try writer["tags"].writeList(value.tags, memberWritingClosure: DirectConnectClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateDirectConnectGatewayInput {

    static func write(value: CreateDirectConnectGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["amazonSideAsn"].write(value.amazonSideAsn)
        try writer["directConnectGatewayName"].write(value.directConnectGatewayName)
    }
}

extension CreateDirectConnectGatewayAssociationInput {

    static func write(value: CreateDirectConnectGatewayAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addAllowedPrefixesToDirectConnectGateway"].writeList(value.addAllowedPrefixesToDirectConnectGateway, memberWritingClosure: DirectConnectClientTypes.RouteFilterPrefix.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["directConnectGatewayId"].write(value.directConnectGatewayId)
        try writer["gatewayId"].write(value.gatewayId)
        try writer["virtualGatewayId"].write(value.virtualGatewayId)
    }
}

extension CreateDirectConnectGatewayAssociationProposalInput {

    static func write(value: CreateDirectConnectGatewayAssociationProposalInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addAllowedPrefixesToDirectConnectGateway"].writeList(value.addAllowedPrefixesToDirectConnectGateway, memberWritingClosure: DirectConnectClientTypes.RouteFilterPrefix.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["directConnectGatewayId"].write(value.directConnectGatewayId)
        try writer["directConnectGatewayOwnerAccount"].write(value.directConnectGatewayOwnerAccount)
        try writer["gatewayId"].write(value.gatewayId)
        try writer["removeAllowedPrefixesToDirectConnectGateway"].writeList(value.removeAllowedPrefixesToDirectConnectGateway, memberWritingClosure: DirectConnectClientTypes.RouteFilterPrefix.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateInterconnectInput {

    static func write(value: CreateInterconnectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bandwidth"].write(value.bandwidth)
        try writer["interconnectName"].write(value.interconnectName)
        try writer["lagId"].write(value.lagId)
        try writer["location"].write(value.location)
        try writer["providerName"].write(value.providerName)
        try writer["tags"].writeList(value.tags, memberWritingClosure: DirectConnectClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateLagInput {

    static func write(value: CreateLagInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["childConnectionTags"].writeList(value.childConnectionTags, memberWritingClosure: DirectConnectClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["connectionId"].write(value.connectionId)
        try writer["connectionsBandwidth"].write(value.connectionsBandwidth)
        try writer["lagName"].write(value.lagName)
        try writer["location"].write(value.location)
        try writer["numberOfConnections"].write(value.numberOfConnections)
        try writer["providerName"].write(value.providerName)
        try writer["requestMACSec"].write(value.requestMACSec)
        try writer["tags"].writeList(value.tags, memberWritingClosure: DirectConnectClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreatePrivateVirtualInterfaceInput {

    static func write(value: CreatePrivateVirtualInterfaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
        try writer["newPrivateVirtualInterface"].write(value.newPrivateVirtualInterface, with: DirectConnectClientTypes.NewPrivateVirtualInterface.write(value:to:))
    }
}

extension CreatePublicVirtualInterfaceInput {

    static func write(value: CreatePublicVirtualInterfaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
        try writer["newPublicVirtualInterface"].write(value.newPublicVirtualInterface, with: DirectConnectClientTypes.NewPublicVirtualInterface.write(value:to:))
    }
}

extension CreateTransitVirtualInterfaceInput {

    static func write(value: CreateTransitVirtualInterfaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
        try writer["newTransitVirtualInterface"].write(value.newTransitVirtualInterface, with: DirectConnectClientTypes.NewTransitVirtualInterface.write(value:to:))
    }
}

extension DeleteBGPPeerInput {

    static func write(value: DeleteBGPPeerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["asn"].write(value.asn)
        try writer["bgpPeerId"].write(value.bgpPeerId)
        try writer["customerAddress"].write(value.customerAddress)
        try writer["virtualInterfaceId"].write(value.virtualInterfaceId)
    }
}

extension DeleteConnectionInput {

    static func write(value: DeleteConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
    }
}

extension DeleteDirectConnectGatewayInput {

    static func write(value: DeleteDirectConnectGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["directConnectGatewayId"].write(value.directConnectGatewayId)
    }
}

extension DeleteDirectConnectGatewayAssociationInput {

    static func write(value: DeleteDirectConnectGatewayAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["associationId"].write(value.associationId)
        try writer["directConnectGatewayId"].write(value.directConnectGatewayId)
        try writer["virtualGatewayId"].write(value.virtualGatewayId)
    }
}

extension DeleteDirectConnectGatewayAssociationProposalInput {

    static func write(value: DeleteDirectConnectGatewayAssociationProposalInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["proposalId"].write(value.proposalId)
    }
}

extension DeleteInterconnectInput {

    static func write(value: DeleteInterconnectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["interconnectId"].write(value.interconnectId)
    }
}

extension DeleteLagInput {

    static func write(value: DeleteLagInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["lagId"].write(value.lagId)
    }
}

extension DeleteVirtualInterfaceInput {

    static func write(value: DeleteVirtualInterfaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["virtualInterfaceId"].write(value.virtualInterfaceId)
    }
}

extension DescribeConnectionLoaInput {

    static func write(value: DescribeConnectionLoaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
        try writer["loaContentType"].write(value.loaContentType)
        try writer["providerName"].write(value.providerName)
    }
}

extension DescribeConnectionsInput {

    static func write(value: DescribeConnectionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
    }
}

extension DescribeConnectionsOnInterconnectInput {

    static func write(value: DescribeConnectionsOnInterconnectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["interconnectId"].write(value.interconnectId)
    }
}

extension DescribeCustomerMetadataInput {

    static func write(value: DescribeCustomerMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribeDirectConnectGatewayAssociationProposalsInput {

    static func write(value: DescribeDirectConnectGatewayAssociationProposalsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["associatedGatewayId"].write(value.associatedGatewayId)
        try writer["directConnectGatewayId"].write(value.directConnectGatewayId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["proposalId"].write(value.proposalId)
    }
}

extension DescribeDirectConnectGatewayAssociationsInput {

    static func write(value: DescribeDirectConnectGatewayAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["associatedGatewayId"].write(value.associatedGatewayId)
        try writer["associationId"].write(value.associationId)
        try writer["directConnectGatewayId"].write(value.directConnectGatewayId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["virtualGatewayId"].write(value.virtualGatewayId)
    }
}

extension DescribeDirectConnectGatewayAttachmentsInput {

    static func write(value: DescribeDirectConnectGatewayAttachmentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["directConnectGatewayId"].write(value.directConnectGatewayId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["virtualInterfaceId"].write(value.virtualInterfaceId)
    }
}

extension DescribeDirectConnectGatewaysInput {

    static func write(value: DescribeDirectConnectGatewaysInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["directConnectGatewayId"].write(value.directConnectGatewayId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeHostedConnectionsInput {

    static func write(value: DescribeHostedConnectionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
    }
}

extension DescribeInterconnectLoaInput {

    static func write(value: DescribeInterconnectLoaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["interconnectId"].write(value.interconnectId)
        try writer["loaContentType"].write(value.loaContentType)
        try writer["providerName"].write(value.providerName)
    }
}

extension DescribeInterconnectsInput {

    static func write(value: DescribeInterconnectsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["interconnectId"].write(value.interconnectId)
    }
}

extension DescribeLagsInput {

    static func write(value: DescribeLagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["lagId"].write(value.lagId)
    }
}

extension DescribeLoaInput {

    static func write(value: DescribeLoaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
        try writer["loaContentType"].write(value.loaContentType)
        try writer["providerName"].write(value.providerName)
    }
}

extension DescribeLocationsInput {

    static func write(value: DescribeLocationsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribeRouterConfigurationInput {

    static func write(value: DescribeRouterConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["routerTypeIdentifier"].write(value.routerTypeIdentifier)
        try writer["virtualInterfaceId"].write(value.virtualInterfaceId)
    }
}

extension DescribeTagsInput {

    static func write(value: DescribeTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArns"].writeList(value.resourceArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeVirtualGatewaysInput {

    static func write(value: DescribeVirtualGatewaysInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribeVirtualInterfacesInput {

    static func write(value: DescribeVirtualInterfacesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
        try writer["virtualInterfaceId"].write(value.virtualInterfaceId)
    }
}

extension DisassociateConnectionFromLagInput {

    static func write(value: DisassociateConnectionFromLagInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
        try writer["lagId"].write(value.lagId)
    }
}

extension DisassociateMacSecKeyInput {

    static func write(value: DisassociateMacSecKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
        try writer["secretARN"].write(value.secretARN)
    }
}

extension ListVirtualInterfaceTestHistoryInput {

    static func write(value: ListVirtualInterfaceTestHistoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bgpPeers"].writeList(value.bgpPeers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["status"].write(value.status)
        try writer["testId"].write(value.testId)
        try writer["virtualInterfaceId"].write(value.virtualInterfaceId)
    }
}

extension StartBgpFailoverTestInput {

    static func write(value: StartBgpFailoverTestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bgpPeers"].writeList(value.bgpPeers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["testDurationInMinutes"].write(value.testDurationInMinutes)
        try writer["virtualInterfaceId"].write(value.virtualInterfaceId)
    }
}

extension StopBgpFailoverTestInput {

    static func write(value: StopBgpFailoverTestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["virtualInterfaceId"].write(value.virtualInterfaceId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: DirectConnectClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateConnectionInput {

    static func write(value: UpdateConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectionId"].write(value.connectionId)
        try writer["connectionName"].write(value.connectionName)
        try writer["encryptionMode"].write(value.encryptionMode)
    }
}

extension UpdateDirectConnectGatewayInput {

    static func write(value: UpdateDirectConnectGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["directConnectGatewayId"].write(value.directConnectGatewayId)
        try writer["newDirectConnectGatewayName"].write(value.newDirectConnectGatewayName)
    }
}

extension UpdateDirectConnectGatewayAssociationInput {

    static func write(value: UpdateDirectConnectGatewayAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addAllowedPrefixesToDirectConnectGateway"].writeList(value.addAllowedPrefixesToDirectConnectGateway, memberWritingClosure: DirectConnectClientTypes.RouteFilterPrefix.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["associationId"].write(value.associationId)
        try writer["removeAllowedPrefixesToDirectConnectGateway"].writeList(value.removeAllowedPrefixesToDirectConnectGateway, memberWritingClosure: DirectConnectClientTypes.RouteFilterPrefix.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateLagInput {

    static func write(value: UpdateLagInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionMode"].write(value.encryptionMode)
        try writer["lagId"].write(value.lagId)
        try writer["lagName"].write(value.lagName)
        try writer["minimumLinks"].write(value.minimumLinks)
    }
}

extension UpdateVirtualInterfaceAttributesInput {

    static func write(value: UpdateVirtualInterfaceAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enableSiteLink"].write(value.enableSiteLink)
        try writer["mtu"].write(value.mtu)
        try writer["virtualInterfaceId"].write(value.virtualInterfaceId)
        try writer["virtualInterfaceName"].write(value.virtualInterfaceName)
    }
}

extension AcceptDirectConnectGatewayAssociationProposalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcceptDirectConnectGatewayAssociationProposalOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AcceptDirectConnectGatewayAssociationProposalOutput()
        value.directConnectGatewayAssociation = try reader["directConnectGatewayAssociation"].readIfPresent(with: DirectConnectClientTypes.DirectConnectGatewayAssociation.read(from:))
        return value
    }
}

extension AllocateConnectionOnInterconnectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AllocateConnectionOnInterconnectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AllocateConnectionOnInterconnectOutput()
        value.awsDevice = try reader["awsDevice"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.bandwidth = try reader["bandwidth"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionName = try reader["connectionName"].readIfPresent()
        value.connectionState = try reader["connectionState"].readIfPresent()
        value.encryptionMode = try reader["encryptionMode"].readIfPresent()
        value.hasLogicalRedundancy = try reader["hasLogicalRedundancy"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.lagId = try reader["lagId"].readIfPresent()
        value.loaIssueTime = try reader["loaIssueTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.location = try reader["location"].readIfPresent()
        value.macSecCapable = try reader["macSecCapable"].readIfPresent()
        value.macSecKeys = try reader["macSecKeys"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.MacSecKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.partnerName = try reader["partnerName"].readIfPresent()
        value.portEncryptionStatus = try reader["portEncryptionStatus"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vlan = try reader["vlan"].readIfPresent() ?? 0
        return value
    }
}

extension AllocateHostedConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AllocateHostedConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AllocateHostedConnectionOutput()
        value.awsDevice = try reader["awsDevice"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.bandwidth = try reader["bandwidth"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionName = try reader["connectionName"].readIfPresent()
        value.connectionState = try reader["connectionState"].readIfPresent()
        value.encryptionMode = try reader["encryptionMode"].readIfPresent()
        value.hasLogicalRedundancy = try reader["hasLogicalRedundancy"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.lagId = try reader["lagId"].readIfPresent()
        value.loaIssueTime = try reader["loaIssueTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.location = try reader["location"].readIfPresent()
        value.macSecCapable = try reader["macSecCapable"].readIfPresent()
        value.macSecKeys = try reader["macSecKeys"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.MacSecKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.partnerName = try reader["partnerName"].readIfPresent()
        value.portEncryptionStatus = try reader["portEncryptionStatus"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vlan = try reader["vlan"].readIfPresent() ?? 0
        return value
    }
}

extension AllocatePrivateVirtualInterfaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AllocatePrivateVirtualInterfaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AllocatePrivateVirtualInterfaceOutput()
        value.addressFamily = try reader["addressFamily"].readIfPresent()
        value.amazonAddress = try reader["amazonAddress"].readIfPresent()
        value.amazonSideAsn = try reader["amazonSideAsn"].readIfPresent()
        value.asn = try reader["asn"].readIfPresent() ?? 0
        value.authKey = try reader["authKey"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.bgpPeers = try reader["bgpPeers"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.BGPPeer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.customerAddress = try reader["customerAddress"].readIfPresent()
        value.customerRouterConfig = try reader["customerRouterConfig"].readIfPresent()
        value.directConnectGatewayId = try reader["directConnectGatewayId"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.location = try reader["location"].readIfPresent()
        value.mtu = try reader["mtu"].readIfPresent()
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.routeFilterPrefixes = try reader["routeFilterPrefixes"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.RouteFilterPrefix.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.siteLinkEnabled = try reader["siteLinkEnabled"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.virtualGatewayId = try reader["virtualGatewayId"].readIfPresent()
        value.virtualInterfaceId = try reader["virtualInterfaceId"].readIfPresent()
        value.virtualInterfaceName = try reader["virtualInterfaceName"].readIfPresent()
        value.virtualInterfaceState = try reader["virtualInterfaceState"].readIfPresent()
        value.virtualInterfaceType = try reader["virtualInterfaceType"].readIfPresent()
        value.vlan = try reader["vlan"].readIfPresent() ?? 0
        return value
    }
}

extension AllocatePublicVirtualInterfaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AllocatePublicVirtualInterfaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AllocatePublicVirtualInterfaceOutput()
        value.addressFamily = try reader["addressFamily"].readIfPresent()
        value.amazonAddress = try reader["amazonAddress"].readIfPresent()
        value.amazonSideAsn = try reader["amazonSideAsn"].readIfPresent()
        value.asn = try reader["asn"].readIfPresent() ?? 0
        value.authKey = try reader["authKey"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.bgpPeers = try reader["bgpPeers"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.BGPPeer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.customerAddress = try reader["customerAddress"].readIfPresent()
        value.customerRouterConfig = try reader["customerRouterConfig"].readIfPresent()
        value.directConnectGatewayId = try reader["directConnectGatewayId"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.location = try reader["location"].readIfPresent()
        value.mtu = try reader["mtu"].readIfPresent()
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.routeFilterPrefixes = try reader["routeFilterPrefixes"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.RouteFilterPrefix.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.siteLinkEnabled = try reader["siteLinkEnabled"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.virtualGatewayId = try reader["virtualGatewayId"].readIfPresent()
        value.virtualInterfaceId = try reader["virtualInterfaceId"].readIfPresent()
        value.virtualInterfaceName = try reader["virtualInterfaceName"].readIfPresent()
        value.virtualInterfaceState = try reader["virtualInterfaceState"].readIfPresent()
        value.virtualInterfaceType = try reader["virtualInterfaceType"].readIfPresent()
        value.vlan = try reader["vlan"].readIfPresent() ?? 0
        return value
    }
}

extension AllocateTransitVirtualInterfaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AllocateTransitVirtualInterfaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AllocateTransitVirtualInterfaceOutput()
        value.virtualInterface = try reader["virtualInterface"].readIfPresent(with: DirectConnectClientTypes.VirtualInterface.read(from:))
        return value
    }
}

extension AssociateConnectionWithLagOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateConnectionWithLagOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateConnectionWithLagOutput()
        value.awsDevice = try reader["awsDevice"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.bandwidth = try reader["bandwidth"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionName = try reader["connectionName"].readIfPresent()
        value.connectionState = try reader["connectionState"].readIfPresent()
        value.encryptionMode = try reader["encryptionMode"].readIfPresent()
        value.hasLogicalRedundancy = try reader["hasLogicalRedundancy"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.lagId = try reader["lagId"].readIfPresent()
        value.loaIssueTime = try reader["loaIssueTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.location = try reader["location"].readIfPresent()
        value.macSecCapable = try reader["macSecCapable"].readIfPresent()
        value.macSecKeys = try reader["macSecKeys"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.MacSecKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.partnerName = try reader["partnerName"].readIfPresent()
        value.portEncryptionStatus = try reader["portEncryptionStatus"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vlan = try reader["vlan"].readIfPresent() ?? 0
        return value
    }
}

extension AssociateHostedConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateHostedConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateHostedConnectionOutput()
        value.awsDevice = try reader["awsDevice"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.bandwidth = try reader["bandwidth"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionName = try reader["connectionName"].readIfPresent()
        value.connectionState = try reader["connectionState"].readIfPresent()
        value.encryptionMode = try reader["encryptionMode"].readIfPresent()
        value.hasLogicalRedundancy = try reader["hasLogicalRedundancy"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.lagId = try reader["lagId"].readIfPresent()
        value.loaIssueTime = try reader["loaIssueTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.location = try reader["location"].readIfPresent()
        value.macSecCapable = try reader["macSecCapable"].readIfPresent()
        value.macSecKeys = try reader["macSecKeys"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.MacSecKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.partnerName = try reader["partnerName"].readIfPresent()
        value.portEncryptionStatus = try reader["portEncryptionStatus"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vlan = try reader["vlan"].readIfPresent() ?? 0
        return value
    }
}

extension AssociateMacSecKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateMacSecKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateMacSecKeyOutput()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.macSecKeys = try reader["macSecKeys"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.MacSecKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension AssociateVirtualInterfaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateVirtualInterfaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateVirtualInterfaceOutput()
        value.addressFamily = try reader["addressFamily"].readIfPresent()
        value.amazonAddress = try reader["amazonAddress"].readIfPresent()
        value.amazonSideAsn = try reader["amazonSideAsn"].readIfPresent()
        value.asn = try reader["asn"].readIfPresent() ?? 0
        value.authKey = try reader["authKey"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.bgpPeers = try reader["bgpPeers"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.BGPPeer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.customerAddress = try reader["customerAddress"].readIfPresent()
        value.customerRouterConfig = try reader["customerRouterConfig"].readIfPresent()
        value.directConnectGatewayId = try reader["directConnectGatewayId"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.location = try reader["location"].readIfPresent()
        value.mtu = try reader["mtu"].readIfPresent()
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.routeFilterPrefixes = try reader["routeFilterPrefixes"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.RouteFilterPrefix.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.siteLinkEnabled = try reader["siteLinkEnabled"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.virtualGatewayId = try reader["virtualGatewayId"].readIfPresent()
        value.virtualInterfaceId = try reader["virtualInterfaceId"].readIfPresent()
        value.virtualInterfaceName = try reader["virtualInterfaceName"].readIfPresent()
        value.virtualInterfaceState = try reader["virtualInterfaceState"].readIfPresent()
        value.virtualInterfaceType = try reader["virtualInterfaceType"].readIfPresent()
        value.vlan = try reader["vlan"].readIfPresent() ?? 0
        return value
    }
}

extension ConfirmConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ConfirmConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ConfirmConnectionOutput()
        value.connectionState = try reader["connectionState"].readIfPresent()
        return value
    }
}

extension ConfirmCustomerAgreementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ConfirmCustomerAgreementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ConfirmCustomerAgreementOutput()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension ConfirmPrivateVirtualInterfaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ConfirmPrivateVirtualInterfaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ConfirmPrivateVirtualInterfaceOutput()
        value.virtualInterfaceState = try reader["virtualInterfaceState"].readIfPresent()
        return value
    }
}

extension ConfirmPublicVirtualInterfaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ConfirmPublicVirtualInterfaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ConfirmPublicVirtualInterfaceOutput()
        value.virtualInterfaceState = try reader["virtualInterfaceState"].readIfPresent()
        return value
    }
}

extension ConfirmTransitVirtualInterfaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ConfirmTransitVirtualInterfaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ConfirmTransitVirtualInterfaceOutput()
        value.virtualInterfaceState = try reader["virtualInterfaceState"].readIfPresent()
        return value
    }
}

extension CreateBGPPeerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBGPPeerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBGPPeerOutput()
        value.virtualInterface = try reader["virtualInterface"].readIfPresent(with: DirectConnectClientTypes.VirtualInterface.read(from:))
        return value
    }
}

extension CreateConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConnectionOutput()
        value.awsDevice = try reader["awsDevice"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.bandwidth = try reader["bandwidth"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionName = try reader["connectionName"].readIfPresent()
        value.connectionState = try reader["connectionState"].readIfPresent()
        value.encryptionMode = try reader["encryptionMode"].readIfPresent()
        value.hasLogicalRedundancy = try reader["hasLogicalRedundancy"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.lagId = try reader["lagId"].readIfPresent()
        value.loaIssueTime = try reader["loaIssueTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.location = try reader["location"].readIfPresent()
        value.macSecCapable = try reader["macSecCapable"].readIfPresent()
        value.macSecKeys = try reader["macSecKeys"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.MacSecKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.partnerName = try reader["partnerName"].readIfPresent()
        value.portEncryptionStatus = try reader["portEncryptionStatus"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vlan = try reader["vlan"].readIfPresent() ?? 0
        return value
    }
}

extension CreateDirectConnectGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDirectConnectGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDirectConnectGatewayOutput()
        value.directConnectGateway = try reader["directConnectGateway"].readIfPresent(with: DirectConnectClientTypes.DirectConnectGateway.read(from:))
        return value
    }
}

extension CreateDirectConnectGatewayAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDirectConnectGatewayAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDirectConnectGatewayAssociationOutput()
        value.directConnectGatewayAssociation = try reader["directConnectGatewayAssociation"].readIfPresent(with: DirectConnectClientTypes.DirectConnectGatewayAssociation.read(from:))
        return value
    }
}

extension CreateDirectConnectGatewayAssociationProposalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDirectConnectGatewayAssociationProposalOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDirectConnectGatewayAssociationProposalOutput()
        value.directConnectGatewayAssociationProposal = try reader["directConnectGatewayAssociationProposal"].readIfPresent(with: DirectConnectClientTypes.DirectConnectGatewayAssociationProposal.read(from:))
        return value
    }
}

extension CreateInterconnectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInterconnectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInterconnectOutput()
        value.awsDevice = try reader["awsDevice"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.bandwidth = try reader["bandwidth"].readIfPresent()
        value.hasLogicalRedundancy = try reader["hasLogicalRedundancy"].readIfPresent()
        value.interconnectId = try reader["interconnectId"].readIfPresent()
        value.interconnectName = try reader["interconnectName"].readIfPresent()
        value.interconnectState = try reader["interconnectState"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.lagId = try reader["lagId"].readIfPresent()
        value.loaIssueTime = try reader["loaIssueTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.location = try reader["location"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateLagOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLagOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLagOutput()
        value.allowsHostedConnections = try reader["allowsHostedConnections"].readIfPresent() ?? false
        value.awsDevice = try reader["awsDevice"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.connections = try reader["connections"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Connection.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectionsBandwidth = try reader["connectionsBandwidth"].readIfPresent()
        value.encryptionMode = try reader["encryptionMode"].readIfPresent()
        value.hasLogicalRedundancy = try reader["hasLogicalRedundancy"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.lagId = try reader["lagId"].readIfPresent()
        value.lagName = try reader["lagName"].readIfPresent()
        value.lagState = try reader["lagState"].readIfPresent()
        value.location = try reader["location"].readIfPresent()
        value.macSecCapable = try reader["macSecCapable"].readIfPresent()
        value.macSecKeys = try reader["macSecKeys"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.MacSecKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.minimumLinks = try reader["minimumLinks"].readIfPresent() ?? 0
        value.numberOfConnections = try reader["numberOfConnections"].readIfPresent() ?? 0
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreatePrivateVirtualInterfaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePrivateVirtualInterfaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePrivateVirtualInterfaceOutput()
        value.addressFamily = try reader["addressFamily"].readIfPresent()
        value.amazonAddress = try reader["amazonAddress"].readIfPresent()
        value.amazonSideAsn = try reader["amazonSideAsn"].readIfPresent()
        value.asn = try reader["asn"].readIfPresent() ?? 0
        value.authKey = try reader["authKey"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.bgpPeers = try reader["bgpPeers"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.BGPPeer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.customerAddress = try reader["customerAddress"].readIfPresent()
        value.customerRouterConfig = try reader["customerRouterConfig"].readIfPresent()
        value.directConnectGatewayId = try reader["directConnectGatewayId"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.location = try reader["location"].readIfPresent()
        value.mtu = try reader["mtu"].readIfPresent()
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.routeFilterPrefixes = try reader["routeFilterPrefixes"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.RouteFilterPrefix.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.siteLinkEnabled = try reader["siteLinkEnabled"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.virtualGatewayId = try reader["virtualGatewayId"].readIfPresent()
        value.virtualInterfaceId = try reader["virtualInterfaceId"].readIfPresent()
        value.virtualInterfaceName = try reader["virtualInterfaceName"].readIfPresent()
        value.virtualInterfaceState = try reader["virtualInterfaceState"].readIfPresent()
        value.virtualInterfaceType = try reader["virtualInterfaceType"].readIfPresent()
        value.vlan = try reader["vlan"].readIfPresent() ?? 0
        return value
    }
}

extension CreatePublicVirtualInterfaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePublicVirtualInterfaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePublicVirtualInterfaceOutput()
        value.addressFamily = try reader["addressFamily"].readIfPresent()
        value.amazonAddress = try reader["amazonAddress"].readIfPresent()
        value.amazonSideAsn = try reader["amazonSideAsn"].readIfPresent()
        value.asn = try reader["asn"].readIfPresent() ?? 0
        value.authKey = try reader["authKey"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.bgpPeers = try reader["bgpPeers"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.BGPPeer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.customerAddress = try reader["customerAddress"].readIfPresent()
        value.customerRouterConfig = try reader["customerRouterConfig"].readIfPresent()
        value.directConnectGatewayId = try reader["directConnectGatewayId"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.location = try reader["location"].readIfPresent()
        value.mtu = try reader["mtu"].readIfPresent()
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.routeFilterPrefixes = try reader["routeFilterPrefixes"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.RouteFilterPrefix.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.siteLinkEnabled = try reader["siteLinkEnabled"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.virtualGatewayId = try reader["virtualGatewayId"].readIfPresent()
        value.virtualInterfaceId = try reader["virtualInterfaceId"].readIfPresent()
        value.virtualInterfaceName = try reader["virtualInterfaceName"].readIfPresent()
        value.virtualInterfaceState = try reader["virtualInterfaceState"].readIfPresent()
        value.virtualInterfaceType = try reader["virtualInterfaceType"].readIfPresent()
        value.vlan = try reader["vlan"].readIfPresent() ?? 0
        return value
    }
}

extension CreateTransitVirtualInterfaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTransitVirtualInterfaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTransitVirtualInterfaceOutput()
        value.virtualInterface = try reader["virtualInterface"].readIfPresent(with: DirectConnectClientTypes.VirtualInterface.read(from:))
        return value
    }
}

extension DeleteBGPPeerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBGPPeerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteBGPPeerOutput()
        value.virtualInterface = try reader["virtualInterface"].readIfPresent(with: DirectConnectClientTypes.VirtualInterface.read(from:))
        return value
    }
}

extension DeleteConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteConnectionOutput()
        value.awsDevice = try reader["awsDevice"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.bandwidth = try reader["bandwidth"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionName = try reader["connectionName"].readIfPresent()
        value.connectionState = try reader["connectionState"].readIfPresent()
        value.encryptionMode = try reader["encryptionMode"].readIfPresent()
        value.hasLogicalRedundancy = try reader["hasLogicalRedundancy"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.lagId = try reader["lagId"].readIfPresent()
        value.loaIssueTime = try reader["loaIssueTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.location = try reader["location"].readIfPresent()
        value.macSecCapable = try reader["macSecCapable"].readIfPresent()
        value.macSecKeys = try reader["macSecKeys"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.MacSecKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.partnerName = try reader["partnerName"].readIfPresent()
        value.portEncryptionStatus = try reader["portEncryptionStatus"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vlan = try reader["vlan"].readIfPresent() ?? 0
        return value
    }
}

extension DeleteDirectConnectGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDirectConnectGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDirectConnectGatewayOutput()
        value.directConnectGateway = try reader["directConnectGateway"].readIfPresent(with: DirectConnectClientTypes.DirectConnectGateway.read(from:))
        return value
    }
}

extension DeleteDirectConnectGatewayAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDirectConnectGatewayAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDirectConnectGatewayAssociationOutput()
        value.directConnectGatewayAssociation = try reader["directConnectGatewayAssociation"].readIfPresent(with: DirectConnectClientTypes.DirectConnectGatewayAssociation.read(from:))
        return value
    }
}

extension DeleteDirectConnectGatewayAssociationProposalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDirectConnectGatewayAssociationProposalOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDirectConnectGatewayAssociationProposalOutput()
        value.directConnectGatewayAssociationProposal = try reader["directConnectGatewayAssociationProposal"].readIfPresent(with: DirectConnectClientTypes.DirectConnectGatewayAssociationProposal.read(from:))
        return value
    }
}

extension DeleteInterconnectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInterconnectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteInterconnectOutput()
        value.interconnectState = try reader["interconnectState"].readIfPresent()
        return value
    }
}

extension DeleteLagOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLagOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteLagOutput()
        value.allowsHostedConnections = try reader["allowsHostedConnections"].readIfPresent() ?? false
        value.awsDevice = try reader["awsDevice"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.connections = try reader["connections"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Connection.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectionsBandwidth = try reader["connectionsBandwidth"].readIfPresent()
        value.encryptionMode = try reader["encryptionMode"].readIfPresent()
        value.hasLogicalRedundancy = try reader["hasLogicalRedundancy"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.lagId = try reader["lagId"].readIfPresent()
        value.lagName = try reader["lagName"].readIfPresent()
        value.lagState = try reader["lagState"].readIfPresent()
        value.location = try reader["location"].readIfPresent()
        value.macSecCapable = try reader["macSecCapable"].readIfPresent()
        value.macSecKeys = try reader["macSecKeys"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.MacSecKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.minimumLinks = try reader["minimumLinks"].readIfPresent() ?? 0
        value.numberOfConnections = try reader["numberOfConnections"].readIfPresent() ?? 0
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeleteVirtualInterfaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVirtualInterfaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteVirtualInterfaceOutput()
        value.virtualInterfaceState = try reader["virtualInterfaceState"].readIfPresent()
        return value
    }
}

extension DescribeConnectionLoaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConnectionLoaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConnectionLoaOutput()
        value.loa = try reader["loa"].readIfPresent(with: DirectConnectClientTypes.Loa.read(from:))
        return value
    }
}

extension DescribeConnectionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConnectionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConnectionsOutput()
        value.connections = try reader["connections"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Connection.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeConnectionsOnInterconnectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConnectionsOnInterconnectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConnectionsOnInterconnectOutput()
        value.connections = try reader["connections"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Connection.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeCustomerMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCustomerMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCustomerMetadataOutput()
        value.agreements = try reader["agreements"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.CustomerAgreement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nniPartnerType = try reader["nniPartnerType"].readIfPresent()
        return value
    }
}

extension DescribeDirectConnectGatewayAssociationProposalsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDirectConnectGatewayAssociationProposalsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDirectConnectGatewayAssociationProposalsOutput()
        value.directConnectGatewayAssociationProposals = try reader["directConnectGatewayAssociationProposals"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.DirectConnectGatewayAssociationProposal.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeDirectConnectGatewayAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDirectConnectGatewayAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDirectConnectGatewayAssociationsOutput()
        value.directConnectGatewayAssociations = try reader["directConnectGatewayAssociations"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.DirectConnectGatewayAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeDirectConnectGatewayAttachmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDirectConnectGatewayAttachmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDirectConnectGatewayAttachmentsOutput()
        value.directConnectGatewayAttachments = try reader["directConnectGatewayAttachments"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.DirectConnectGatewayAttachment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeDirectConnectGatewaysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDirectConnectGatewaysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDirectConnectGatewaysOutput()
        value.directConnectGateways = try reader["directConnectGateways"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.DirectConnectGateway.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeHostedConnectionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeHostedConnectionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeHostedConnectionsOutput()
        value.connections = try reader["connections"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Connection.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeInterconnectLoaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInterconnectLoaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInterconnectLoaOutput()
        value.loa = try reader["loa"].readIfPresent(with: DirectConnectClientTypes.Loa.read(from:))
        return value
    }
}

extension DescribeInterconnectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInterconnectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInterconnectsOutput()
        value.interconnects = try reader["interconnects"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Interconnect.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeLagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeLagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeLagsOutput()
        value.lags = try reader["lags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Lag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeLoaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeLoaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeLoaOutput()
        value.loaContent = try reader["loaContent"].readIfPresent()
        value.loaContentType = try reader["loaContentType"].readIfPresent()
        return value
    }
}

extension DescribeLocationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeLocationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeLocationsOutput()
        value.locations = try reader["locations"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Location.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeRouterConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRouterConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRouterConfigurationOutput()
        value.customerRouterConfig = try reader["customerRouterConfig"].readIfPresent()
        value.router = try reader["router"].readIfPresent(with: DirectConnectClientTypes.RouterType.read(from:))
        value.virtualInterfaceId = try reader["virtualInterfaceId"].readIfPresent()
        value.virtualInterfaceName = try reader["virtualInterfaceName"].readIfPresent()
        return value
    }
}

extension DescribeTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTagsOutput()
        value.resourceTags = try reader["resourceTags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.ResourceTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeVirtualGatewaysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeVirtualGatewaysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeVirtualGatewaysOutput()
        value.virtualGateways = try reader["virtualGateways"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.VirtualGateway.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeVirtualInterfacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeVirtualInterfacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeVirtualInterfacesOutput()
        value.virtualInterfaces = try reader["virtualInterfaces"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.VirtualInterface.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DisassociateConnectionFromLagOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateConnectionFromLagOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateConnectionFromLagOutput()
        value.awsDevice = try reader["awsDevice"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.bandwidth = try reader["bandwidth"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionName = try reader["connectionName"].readIfPresent()
        value.connectionState = try reader["connectionState"].readIfPresent()
        value.encryptionMode = try reader["encryptionMode"].readIfPresent()
        value.hasLogicalRedundancy = try reader["hasLogicalRedundancy"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.lagId = try reader["lagId"].readIfPresent()
        value.loaIssueTime = try reader["loaIssueTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.location = try reader["location"].readIfPresent()
        value.macSecCapable = try reader["macSecCapable"].readIfPresent()
        value.macSecKeys = try reader["macSecKeys"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.MacSecKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.partnerName = try reader["partnerName"].readIfPresent()
        value.portEncryptionStatus = try reader["portEncryptionStatus"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vlan = try reader["vlan"].readIfPresent() ?? 0
        return value
    }
}

extension DisassociateMacSecKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateMacSecKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateMacSecKeyOutput()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.macSecKeys = try reader["macSecKeys"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.MacSecKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListVirtualInterfaceTestHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVirtualInterfaceTestHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVirtualInterfaceTestHistoryOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.virtualInterfaceTestHistory = try reader["virtualInterfaceTestHistory"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.VirtualInterfaceTestHistory.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartBgpFailoverTestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartBgpFailoverTestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartBgpFailoverTestOutput()
        value.virtualInterfaceTest = try reader["virtualInterfaceTest"].readIfPresent(with: DirectConnectClientTypes.VirtualInterfaceTestHistory.read(from:))
        return value
    }
}

extension StopBgpFailoverTestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopBgpFailoverTestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopBgpFailoverTestOutput()
        value.virtualInterfaceTest = try reader["virtualInterfaceTest"].readIfPresent(with: DirectConnectClientTypes.VirtualInterfaceTestHistory.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConnectionOutput()
        value.awsDevice = try reader["awsDevice"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.bandwidth = try reader["bandwidth"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionName = try reader["connectionName"].readIfPresent()
        value.connectionState = try reader["connectionState"].readIfPresent()
        value.encryptionMode = try reader["encryptionMode"].readIfPresent()
        value.hasLogicalRedundancy = try reader["hasLogicalRedundancy"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.lagId = try reader["lagId"].readIfPresent()
        value.loaIssueTime = try reader["loaIssueTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.location = try reader["location"].readIfPresent()
        value.macSecCapable = try reader["macSecCapable"].readIfPresent()
        value.macSecKeys = try reader["macSecKeys"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.MacSecKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.partnerName = try reader["partnerName"].readIfPresent()
        value.portEncryptionStatus = try reader["portEncryptionStatus"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vlan = try reader["vlan"].readIfPresent() ?? 0
        return value
    }
}

extension UpdateDirectConnectGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDirectConnectGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDirectConnectGatewayOutput()
        value.directConnectGateway = try reader["directConnectGateway"].readIfPresent(with: DirectConnectClientTypes.DirectConnectGateway.read(from:))
        return value
    }
}

extension UpdateDirectConnectGatewayAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDirectConnectGatewayAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDirectConnectGatewayAssociationOutput()
        value.directConnectGatewayAssociation = try reader["directConnectGatewayAssociation"].readIfPresent(with: DirectConnectClientTypes.DirectConnectGatewayAssociation.read(from:))
        return value
    }
}

extension UpdateLagOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLagOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLagOutput()
        value.allowsHostedConnections = try reader["allowsHostedConnections"].readIfPresent() ?? false
        value.awsDevice = try reader["awsDevice"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.connections = try reader["connections"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Connection.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectionsBandwidth = try reader["connectionsBandwidth"].readIfPresent()
        value.encryptionMode = try reader["encryptionMode"].readIfPresent()
        value.hasLogicalRedundancy = try reader["hasLogicalRedundancy"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.lagId = try reader["lagId"].readIfPresent()
        value.lagName = try reader["lagName"].readIfPresent()
        value.lagState = try reader["lagState"].readIfPresent()
        value.location = try reader["location"].readIfPresent()
        value.macSecCapable = try reader["macSecCapable"].readIfPresent()
        value.macSecKeys = try reader["macSecKeys"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.MacSecKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.minimumLinks = try reader["minimumLinks"].readIfPresent() ?? 0
        value.numberOfConnections = try reader["numberOfConnections"].readIfPresent() ?? 0
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.providerName = try reader["providerName"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateVirtualInterfaceAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVirtualInterfaceAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVirtualInterfaceAttributesOutput()
        value.addressFamily = try reader["addressFamily"].readIfPresent()
        value.amazonAddress = try reader["amazonAddress"].readIfPresent()
        value.amazonSideAsn = try reader["amazonSideAsn"].readIfPresent()
        value.asn = try reader["asn"].readIfPresent() ?? 0
        value.authKey = try reader["authKey"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.bgpPeers = try reader["bgpPeers"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.BGPPeer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.customerAddress = try reader["customerAddress"].readIfPresent()
        value.customerRouterConfig = try reader["customerRouterConfig"].readIfPresent()
        value.directConnectGatewayId = try reader["directConnectGatewayId"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.location = try reader["location"].readIfPresent()
        value.mtu = try reader["mtu"].readIfPresent()
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.routeFilterPrefixes = try reader["routeFilterPrefixes"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.RouteFilterPrefix.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.siteLinkEnabled = try reader["siteLinkEnabled"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.virtualGatewayId = try reader["virtualGatewayId"].readIfPresent()
        value.virtualInterfaceId = try reader["virtualInterfaceId"].readIfPresent()
        value.virtualInterfaceName = try reader["virtualInterfaceName"].readIfPresent()
        value.virtualInterfaceState = try reader["virtualInterfaceState"].readIfPresent()
        value.virtualInterfaceType = try reader["virtualInterfaceType"].readIfPresent()
        value.vlan = try reader["vlan"].readIfPresent() ?? 0
        return value
    }
}

enum AcceptDirectConnectGatewayAssociationProposalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AllocateConnectionOnInterconnectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AllocateHostedConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            case "DuplicateTagKeysException": return try DuplicateTagKeysException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AllocatePrivateVirtualInterfaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            case "DuplicateTagKeysException": return try DuplicateTagKeysException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AllocatePublicVirtualInterfaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            case "DuplicateTagKeysException": return try DuplicateTagKeysException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AllocateTransitVirtualInterfaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            case "DuplicateTagKeysException": return try DuplicateTagKeysException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateConnectionWithLagOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateHostedConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateMacSecKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateVirtualInterfaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ConfirmConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ConfirmCustomerAgreementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ConfirmPrivateVirtualInterfaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ConfirmPublicVirtualInterfaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ConfirmTransitVirtualInterfaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBGPPeerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            case "DuplicateTagKeysException": return try DuplicateTagKeysException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDirectConnectGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDirectConnectGatewayAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDirectConnectGatewayAssociationProposalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInterconnectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            case "DuplicateTagKeysException": return try DuplicateTagKeysException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLagOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            case "DuplicateTagKeysException": return try DuplicateTagKeysException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePrivateVirtualInterfaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            case "DuplicateTagKeysException": return try DuplicateTagKeysException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePublicVirtualInterfaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            case "DuplicateTagKeysException": return try DuplicateTagKeysException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTransitVirtualInterfaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            case "DuplicateTagKeysException": return try DuplicateTagKeysException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBGPPeerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDirectConnectGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDirectConnectGatewayAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDirectConnectGatewayAssociationProposalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInterconnectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLagOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVirtualInterfaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConnectionLoaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConnectionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConnectionsOnInterconnectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCustomerMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDirectConnectGatewayAssociationProposalsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDirectConnectGatewayAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDirectConnectGatewayAttachmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDirectConnectGatewaysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeHostedConnectionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInterconnectLoaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInterconnectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeLagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeLoaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeLocationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRouterConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeVirtualGatewaysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeVirtualInterfacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateConnectionFromLagOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateMacSecKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVirtualInterfaceTestHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartBgpFailoverTestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopBgpFailoverTestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            case "DuplicateTagKeysException": return try DuplicateTagKeysException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDirectConnectGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDirectConnectGatewayAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLagOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVirtualInterfaceAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DirectConnectClientException": return try DirectConnectClientException.makeError(baseError: baseError)
            case "DirectConnectServerException": return try DirectConnectServerException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DirectConnectServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DirectConnectServerException {
        let reader = baseError.errorBodyReader
        var value = DirectConnectServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DirectConnectClientException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DirectConnectClientException {
        let reader = baseError.errorBodyReader
        var value = DirectConnectClientException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DuplicateTagKeysException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DuplicateTagKeysException {
        let reader = baseError.errorBodyReader
        var value = DuplicateTagKeysException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DirectConnectClientTypes.DirectConnectGatewayAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.DirectConnectGatewayAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.DirectConnectGatewayAssociation()
        value.directConnectGatewayId = try reader["directConnectGatewayId"].readIfPresent()
        value.directConnectGatewayOwnerAccount = try reader["directConnectGatewayOwnerAccount"].readIfPresent()
        value.associationState = try reader["associationState"].readIfPresent()
        value.stateChangeError = try reader["stateChangeError"].readIfPresent()
        value.associatedGateway = try reader["associatedGateway"].readIfPresent(with: DirectConnectClientTypes.AssociatedGateway.read(from:))
        value.associationId = try reader["associationId"].readIfPresent()
        value.allowedPrefixesToDirectConnectGateway = try reader["allowedPrefixesToDirectConnectGateway"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.RouteFilterPrefix.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.virtualGatewayId = try reader["virtualGatewayId"].readIfPresent()
        value.virtualGatewayRegion = try reader["virtualGatewayRegion"].readIfPresent()
        value.virtualGatewayOwnerAccount = try reader["virtualGatewayOwnerAccount"].readIfPresent()
        return value
    }
}

extension DirectConnectClientTypes.RouteFilterPrefix {

    static func write(value: DirectConnectClientTypes.RouteFilterPrefix?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cidr"].write(value.cidr)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.RouteFilterPrefix {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.RouteFilterPrefix()
        value.cidr = try reader["cidr"].readIfPresent()
        return value
    }
}

extension DirectConnectClientTypes.AssociatedGateway {

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.AssociatedGateway {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.AssociatedGateway()
        value.id = try reader["id"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        return value
    }
}

extension DirectConnectClientTypes.Tag {

    static func write(value: DirectConnectClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension DirectConnectClientTypes.MacSecKey {

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.MacSecKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.MacSecKey()
        value.secretARN = try reader["secretARN"].readIfPresent()
        value.ckn = try reader["ckn"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.startOn = try reader["startOn"].readIfPresent()
        return value
    }
}

extension DirectConnectClientTypes.BGPPeer {

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.BGPPeer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.BGPPeer()
        value.bgpPeerId = try reader["bgpPeerId"].readIfPresent()
        value.asn = try reader["asn"].readIfPresent() ?? 0
        value.authKey = try reader["authKey"].readIfPresent()
        value.addressFamily = try reader["addressFamily"].readIfPresent()
        value.amazonAddress = try reader["amazonAddress"].readIfPresent()
        value.customerAddress = try reader["customerAddress"].readIfPresent()
        value.bgpPeerState = try reader["bgpPeerState"].readIfPresent()
        value.bgpStatus = try reader["bgpStatus"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        return value
    }
}

extension DirectConnectClientTypes.VirtualInterface {

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.VirtualInterface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.VirtualInterface()
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.virtualInterfaceId = try reader["virtualInterfaceId"].readIfPresent()
        value.location = try reader["location"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.virtualInterfaceType = try reader["virtualInterfaceType"].readIfPresent()
        value.virtualInterfaceName = try reader["virtualInterfaceName"].readIfPresent()
        value.vlan = try reader["vlan"].readIfPresent() ?? 0
        value.asn = try reader["asn"].readIfPresent() ?? 0
        value.amazonSideAsn = try reader["amazonSideAsn"].readIfPresent()
        value.authKey = try reader["authKey"].readIfPresent()
        value.amazonAddress = try reader["amazonAddress"].readIfPresent()
        value.customerAddress = try reader["customerAddress"].readIfPresent()
        value.addressFamily = try reader["addressFamily"].readIfPresent()
        value.virtualInterfaceState = try reader["virtualInterfaceState"].readIfPresent()
        value.customerRouterConfig = try reader["customerRouterConfig"].readIfPresent()
        value.mtu = try reader["mtu"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.virtualGatewayId = try reader["virtualGatewayId"].readIfPresent()
        value.directConnectGatewayId = try reader["directConnectGatewayId"].readIfPresent()
        value.routeFilterPrefixes = try reader["routeFilterPrefixes"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.RouteFilterPrefix.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.bgpPeers = try reader["bgpPeers"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.BGPPeer.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.region = try reader["region"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.siteLinkEnabled = try reader["siteLinkEnabled"].readIfPresent()
        return value
    }
}

extension DirectConnectClientTypes.DirectConnectGateway {

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.DirectConnectGateway {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.DirectConnectGateway()
        value.directConnectGatewayId = try reader["directConnectGatewayId"].readIfPresent()
        value.directConnectGatewayName = try reader["directConnectGatewayName"].readIfPresent()
        value.amazonSideAsn = try reader["amazonSideAsn"].readIfPresent()
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.directConnectGatewayState = try reader["directConnectGatewayState"].readIfPresent()
        value.stateChangeError = try reader["stateChangeError"].readIfPresent()
        return value
    }
}

extension DirectConnectClientTypes.DirectConnectGatewayAssociationProposal {

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.DirectConnectGatewayAssociationProposal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.DirectConnectGatewayAssociationProposal()
        value.proposalId = try reader["proposalId"].readIfPresent()
        value.directConnectGatewayId = try reader["directConnectGatewayId"].readIfPresent()
        value.directConnectGatewayOwnerAccount = try reader["directConnectGatewayOwnerAccount"].readIfPresent()
        value.proposalState = try reader["proposalState"].readIfPresent()
        value.associatedGateway = try reader["associatedGateway"].readIfPresent(with: DirectConnectClientTypes.AssociatedGateway.read(from:))
        value.existingAllowedPrefixesToDirectConnectGateway = try reader["existingAllowedPrefixesToDirectConnectGateway"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.RouteFilterPrefix.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requestedAllowedPrefixesToDirectConnectGateway = try reader["requestedAllowedPrefixesToDirectConnectGateway"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.RouteFilterPrefix.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DirectConnectClientTypes.Connection {

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.Connection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.Connection()
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.connectionId = try reader["connectionId"].readIfPresent()
        value.connectionName = try reader["connectionName"].readIfPresent()
        value.connectionState = try reader["connectionState"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.location = try reader["location"].readIfPresent()
        value.bandwidth = try reader["bandwidth"].readIfPresent()
        value.vlan = try reader["vlan"].readIfPresent() ?? 0
        value.partnerName = try reader["partnerName"].readIfPresent()
        value.loaIssueTime = try reader["loaIssueTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lagId = try reader["lagId"].readIfPresent()
        value.awsDevice = try reader["awsDevice"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.hasLogicalRedundancy = try reader["hasLogicalRedundancy"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.providerName = try reader["providerName"].readIfPresent()
        value.macSecCapable = try reader["macSecCapable"].readIfPresent()
        value.portEncryptionStatus = try reader["portEncryptionStatus"].readIfPresent()
        value.encryptionMode = try reader["encryptionMode"].readIfPresent()
        value.macSecKeys = try reader["macSecKeys"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.MacSecKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DirectConnectClientTypes.Loa {

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.Loa {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.Loa()
        value.loaContent = try reader["loaContent"].readIfPresent()
        value.loaContentType = try reader["loaContentType"].readIfPresent()
        return value
    }
}

extension DirectConnectClientTypes.CustomerAgreement {

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.CustomerAgreement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.CustomerAgreement()
        value.agreementName = try reader["agreementName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DirectConnectClientTypes.DirectConnectGatewayAttachment {

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.DirectConnectGatewayAttachment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.DirectConnectGatewayAttachment()
        value.directConnectGatewayId = try reader["directConnectGatewayId"].readIfPresent()
        value.virtualInterfaceId = try reader["virtualInterfaceId"].readIfPresent()
        value.virtualInterfaceRegion = try reader["virtualInterfaceRegion"].readIfPresent()
        value.virtualInterfaceOwnerAccount = try reader["virtualInterfaceOwnerAccount"].readIfPresent()
        value.attachmentState = try reader["attachmentState"].readIfPresent()
        value.attachmentType = try reader["attachmentType"].readIfPresent()
        value.stateChangeError = try reader["stateChangeError"].readIfPresent()
        return value
    }
}

extension DirectConnectClientTypes.Interconnect {

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.Interconnect {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.Interconnect()
        value.interconnectId = try reader["interconnectId"].readIfPresent()
        value.interconnectName = try reader["interconnectName"].readIfPresent()
        value.interconnectState = try reader["interconnectState"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.location = try reader["location"].readIfPresent()
        value.bandwidth = try reader["bandwidth"].readIfPresent()
        value.loaIssueTime = try reader["loaIssueTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lagId = try reader["lagId"].readIfPresent()
        value.awsDevice = try reader["awsDevice"].readIfPresent()
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.hasLogicalRedundancy = try reader["hasLogicalRedundancy"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.providerName = try reader["providerName"].readIfPresent()
        return value
    }
}

extension DirectConnectClientTypes.Lag {

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.Lag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.Lag()
        value.connectionsBandwidth = try reader["connectionsBandwidth"].readIfPresent()
        value.numberOfConnections = try reader["numberOfConnections"].readIfPresent() ?? 0
        value.lagId = try reader["lagId"].readIfPresent()
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.lagName = try reader["lagName"].readIfPresent()
        value.lagState = try reader["lagState"].readIfPresent()
        value.location = try reader["location"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.minimumLinks = try reader["minimumLinks"].readIfPresent() ?? 0
        value.awsDevice = try reader["awsDevice"].readIfPresent()
        value.awsDeviceV2 = try reader["awsDeviceV2"].readIfPresent()
        value.awsLogicalDeviceId = try reader["awsLogicalDeviceId"].readIfPresent()
        value.connections = try reader["connections"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Connection.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowsHostedConnections = try reader["allowsHostedConnections"].readIfPresent() ?? false
        value.jumboFrameCapable = try reader["jumboFrameCapable"].readIfPresent()
        value.hasLogicalRedundancy = try reader["hasLogicalRedundancy"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.providerName = try reader["providerName"].readIfPresent()
        value.macSecCapable = try reader["macSecCapable"].readIfPresent()
        value.encryptionMode = try reader["encryptionMode"].readIfPresent()
        value.macSecKeys = try reader["macSecKeys"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.MacSecKey.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DirectConnectClientTypes.Location {

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.Location()
        value.locationCode = try reader["locationCode"].readIfPresent()
        value.locationName = try reader["locationName"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.availablePortSpeeds = try reader["availablePortSpeeds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.availableProviders = try reader["availableProviders"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.availableMacSecPortSpeeds = try reader["availableMacSecPortSpeeds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DirectConnectClientTypes.RouterType {

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.RouterType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.RouterType()
        value.vendor = try reader["vendor"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.software = try reader["software"].readIfPresent()
        value.xsltTemplateName = try reader["xsltTemplateName"].readIfPresent()
        value.xsltTemplateNameForMacSec = try reader["xsltTemplateNameForMacSec"].readIfPresent()
        value.routerTypeIdentifier = try reader["routerTypeIdentifier"].readIfPresent()
        return value
    }
}

extension DirectConnectClientTypes.ResourceTag {

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.ResourceTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.ResourceTag()
        value.resourceArn = try reader["resourceArn"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: DirectConnectClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DirectConnectClientTypes.VirtualGateway {

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.VirtualGateway {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.VirtualGateway()
        value.virtualGatewayId = try reader["virtualGatewayId"].readIfPresent()
        value.virtualGatewayState = try reader["virtualGatewayState"].readIfPresent()
        return value
    }
}

extension DirectConnectClientTypes.VirtualInterfaceTestHistory {

    static func read(from reader: SmithyJSON.Reader) throws -> DirectConnectClientTypes.VirtualInterfaceTestHistory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DirectConnectClientTypes.VirtualInterfaceTestHistory()
        value.testId = try reader["testId"].readIfPresent()
        value.virtualInterfaceId = try reader["virtualInterfaceId"].readIfPresent()
        value.bgpPeers = try reader["bgpPeers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.ownerAccount = try reader["ownerAccount"].readIfPresent()
        value.testDurationInMinutes = try reader["testDurationInMinutes"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DirectConnectClientTypes.NewPrivateVirtualInterfaceAllocation {

    static func write(value: DirectConnectClientTypes.NewPrivateVirtualInterfaceAllocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addressFamily"].write(value.addressFamily)
        try writer["amazonAddress"].write(value.amazonAddress)
        try writer["asn"].write(value.asn)
        try writer["authKey"].write(value.authKey)
        try writer["customerAddress"].write(value.customerAddress)
        try writer["mtu"].write(value.mtu)
        try writer["tags"].writeList(value.tags, memberWritingClosure: DirectConnectClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["virtualInterfaceName"].write(value.virtualInterfaceName)
        try writer["vlan"].write(value.vlan)
    }
}

extension DirectConnectClientTypes.NewPublicVirtualInterfaceAllocation {

    static func write(value: DirectConnectClientTypes.NewPublicVirtualInterfaceAllocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addressFamily"].write(value.addressFamily)
        try writer["amazonAddress"].write(value.amazonAddress)
        try writer["asn"].write(value.asn)
        try writer["authKey"].write(value.authKey)
        try writer["customerAddress"].write(value.customerAddress)
        try writer["routeFilterPrefixes"].writeList(value.routeFilterPrefixes, memberWritingClosure: DirectConnectClientTypes.RouteFilterPrefix.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeList(value.tags, memberWritingClosure: DirectConnectClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["virtualInterfaceName"].write(value.virtualInterfaceName)
        try writer["vlan"].write(value.vlan)
    }
}

extension DirectConnectClientTypes.NewTransitVirtualInterfaceAllocation {

    static func write(value: DirectConnectClientTypes.NewTransitVirtualInterfaceAllocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addressFamily"].write(value.addressFamily)
        try writer["amazonAddress"].write(value.amazonAddress)
        try writer["asn"].write(value.asn)
        try writer["authKey"].write(value.authKey)
        try writer["customerAddress"].write(value.customerAddress)
        try writer["mtu"].write(value.mtu)
        try writer["tags"].writeList(value.tags, memberWritingClosure: DirectConnectClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["virtualInterfaceName"].write(value.virtualInterfaceName)
        try writer["vlan"].write(value.vlan)
    }
}

extension DirectConnectClientTypes.NewBGPPeer {

    static func write(value: DirectConnectClientTypes.NewBGPPeer?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addressFamily"].write(value.addressFamily)
        try writer["amazonAddress"].write(value.amazonAddress)
        try writer["asn"].write(value.asn)
        try writer["authKey"].write(value.authKey)
        try writer["customerAddress"].write(value.customerAddress)
    }
}

extension DirectConnectClientTypes.NewPrivateVirtualInterface {

    static func write(value: DirectConnectClientTypes.NewPrivateVirtualInterface?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addressFamily"].write(value.addressFamily)
        try writer["amazonAddress"].write(value.amazonAddress)
        try writer["asn"].write(value.asn)
        try writer["authKey"].write(value.authKey)
        try writer["customerAddress"].write(value.customerAddress)
        try writer["directConnectGatewayId"].write(value.directConnectGatewayId)
        try writer["enableSiteLink"].write(value.enableSiteLink)
        try writer["mtu"].write(value.mtu)
        try writer["tags"].writeList(value.tags, memberWritingClosure: DirectConnectClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["virtualGatewayId"].write(value.virtualGatewayId)
        try writer["virtualInterfaceName"].write(value.virtualInterfaceName)
        try writer["vlan"].write(value.vlan)
    }
}

extension DirectConnectClientTypes.NewPublicVirtualInterface {

    static func write(value: DirectConnectClientTypes.NewPublicVirtualInterface?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addressFamily"].write(value.addressFamily)
        try writer["amazonAddress"].write(value.amazonAddress)
        try writer["asn"].write(value.asn)
        try writer["authKey"].write(value.authKey)
        try writer["customerAddress"].write(value.customerAddress)
        try writer["routeFilterPrefixes"].writeList(value.routeFilterPrefixes, memberWritingClosure: DirectConnectClientTypes.RouteFilterPrefix.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeList(value.tags, memberWritingClosure: DirectConnectClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["virtualInterfaceName"].write(value.virtualInterfaceName)
        try writer["vlan"].write(value.vlan)
    }
}

extension DirectConnectClientTypes.NewTransitVirtualInterface {

    static func write(value: DirectConnectClientTypes.NewTransitVirtualInterface?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addressFamily"].write(value.addressFamily)
        try writer["amazonAddress"].write(value.amazonAddress)
        try writer["asn"].write(value.asn)
        try writer["authKey"].write(value.authKey)
        try writer["customerAddress"].write(value.customerAddress)
        try writer["directConnectGatewayId"].write(value.directConnectGatewayId)
        try writer["enableSiteLink"].write(value.enableSiteLink)
        try writer["mtu"].write(value.mtu)
        try writer["tags"].writeList(value.tags, memberWritingClosure: DirectConnectClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["virtualInterfaceName"].write(value.virtualInterfaceName)
        try writer["vlan"].write(value.vlan)
    }
}

public enum DirectConnectClientTypes {}
