//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// One or more parameters provided to the operation are not valid.
public struct InvalidParametersException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParametersException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The current limits of the service would have been exceeded by this operation. Decrease your resource use or increase your service limits and retry the operation.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ServiceCatalogClientTypes {

    public enum PortfolioShareType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsOrganizations
        case awsServicecatalog
        case imported
        case sdkUnknown(Swift.String)

        public static var allCases: [PortfolioShareType] {
            return [
                .awsOrganizations,
                .awsServicecatalog,
                .imported
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsOrganizations: return "AWS_ORGANIZATIONS"
            case .awsServicecatalog: return "AWS_SERVICECATALOG"
            case .imported: return "IMPORTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AcceptPortfolioShareInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The type of shared portfolios to accept. The default is to accept imported portfolios.
    ///
    /// * AWS_ORGANIZATIONS - Accept portfolios shared by the management account of your organization.
    ///
    /// * IMPORTED - Accept imported portfolios.
    ///
    /// * AWS_SERVICECATALOG - Not supported. (Throws ResourceNotFoundException.)
    ///
    ///
    /// For example, aws servicecatalog accept-portfolio-share --portfolio-id "port-2qwzkwxt3y5fk" --portfolio-share-type AWS_ORGANIZATIONS
    public var portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType?

    public init(
        acceptLanguage: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.portfolioShareType = portfolioShareType
    }
}

public struct AcceptPortfolioShareOutput: Swift.Sendable {

    public init() { }
}

extension ServiceCatalogClientTypes {

    public enum AccessLevelFilterKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case role
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessLevelFilterKey] {
            return [
                .account,
                .role,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "Account"
            case .role: return "Role"
            case .user: return "User"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    /// The access level to use to filter results.
    public struct AccessLevelFilter: Swift.Sendable {
        /// The access level.
        ///
        /// * Account - Filter results based on the account.
        ///
        /// * Role - Filter results based on the federated role of the specified user.
        ///
        /// * User - Filter results based on the specified user.
        public var key: ServiceCatalogClientTypes.AccessLevelFilterKey?
        /// The user to which the access level applies. The only supported value is self.
        public var value: Swift.String?

        public init(
            key: ServiceCatalogClientTypes.AccessLevelFilterKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension ServiceCatalogClientTypes {

    public enum AccessStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case underChange
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessStatus] {
            return [
                .disabled,
                .enabled,
                .underChange
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .underChange: return "UNDER_CHANGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a tag. A tag is a key-value pair. Tags are propagated to the resources created when provisioning a product.
    public struct Tag: Swift.Sendable {
        /// The tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The value for this key.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

/// The specified resource is a duplicate.
public struct DuplicateResourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateResourceException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateBudgetWithResourceInput: Swift.Sendable {
    /// The name of the budget you want to associate.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The resource identifier. Either a portfolio-id or a product-id.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        budgetName: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.budgetName = budgetName
        self.resourceId = resourceId
    }
}

public struct AssociateBudgetWithResourceOutput: Swift.Sendable {

    public init() { }
}

extension ServiceCatalogClientTypes {

    public enum PrincipalType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iam
        case iamPattern
        case sdkUnknown(Swift.String)

        public static var allCases: [PrincipalType] {
            return [
                .iam,
                .iamPattern
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iam: return "IAM"
            case .iamPattern: return "IAM_PATTERN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AssociatePrincipalWithPortfolioInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The ARN of the principal (user, role, or group). If the PrincipalType is IAM, the supported value is a fully defined [IAM Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns). If the PrincipalType is IAM_PATTERN, the supported value is an IAM ARN without an AccountID in the following format: arn:partition:iam:::resource-type/resource-id The ARN resource-id can be either:
    ///
    /// * A fully formed resource-id. For example, arn:aws:iam:::role/resource-name or arn:aws:iam:::role/resource-path/resource-name
    ///
    /// * A wildcard ARN. The wildcard ARN accepts IAM_PATTERN values with a "*" or "?" in the resource-id segment of the ARN. For example arn:partition:service:::resource-type/resource-path/resource-name. The new symbols are exclusive to the resource-path and resource-name and cannot replace the resource-type or other ARN values. The ARN path and principal name allow unlimited wildcard characters.
    ///
    ///
    /// Examples of an acceptable wildcard ARN:
    ///
    /// * arn:aws:iam:::role/ResourceName_*
    ///
    /// * arn:aws:iam:::role/*/ResourceName_?
    ///
    ///
    /// Examples of an unacceptable wildcard ARN:
    ///
    /// * arn:aws:iam:::*/ResourceName
    ///
    ///
    /// You can associate multiple IAM_PATTERNs even if the account has no principal with that name. The "?" wildcard character matches zero or one of any character. This is similar to ".?" in regular regex context. The "*" wildcard character matches any number of any characters. This is similar to ".*" in regular regex context. In the IAM Principal ARN format (arn:partition:iam:::resource-type/resource-path/resource-name), valid resource-type values include user/, group/, or role/. The "?" and "*" characters are allowed only after the resource-type in the resource-id segment. You can use special characters anywhere within the resource-id. The "*" character also matches the "/" character, allowing paths to be formed within the resource-id. For example, arn:aws:iam:::role/*/ResourceName_? matches both arn:aws:iam:::role/pathA/pathB/ResourceName_1 and arn:aws:iam:::role/pathA/ResourceName_1.
    /// This member is required.
    public var principalARN: Swift.String?
    /// The principal type. The supported value is IAM if you use a fully defined Amazon Resource Name (ARN), or IAM_PATTERN if you use an ARN with no accountID, with or without wildcard characters.
    /// This member is required.
    public var principalType: ServiceCatalogClientTypes.PrincipalType?

    public init(
        acceptLanguage: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        principalARN: Swift.String? = nil,
        principalType: ServiceCatalogClientTypes.PrincipalType? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.principalARN = principalARN
        self.principalType = principalType
    }
}

public struct AssociatePrincipalWithPortfolioOutput: Swift.Sendable {

    public init() { }
}

public struct AssociateProductWithPortfolioInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?
    /// The identifier of the source portfolio.
    public var sourcePortfolioId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        productId: Swift.String? = nil,
        sourcePortfolioId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.productId = productId
        self.sourcePortfolioId = sourcePortfolioId
    }
}

public struct AssociateProductWithPortfolioOutput: Swift.Sendable {

    public init() { }
}

public struct AssociateServiceActionWithProvisioningArtifactInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests from the same Amazon Web Services account use the same idempotency token, the same response is returned for each repeated request.
    public var idempotencyToken: Swift.String?
    /// The product identifier. For example, prod-abcdzk7xy33qa.
    /// This member is required.
    public var productId: Swift.String?
    /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?
    /// The self-service action identifier. For example, act-fs7abcd89wxyz.
    /// This member is required.
    public var serviceActionId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        productId: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        serviceActionId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
        self.serviceActionId = serviceActionId
    }
}

public struct AssociateServiceActionWithProvisioningArtifactOutput: Swift.Sendable {

    public init() { }
}

/// An attempt was made to modify a resource that is in a state that is not valid. Check your resources to ensure that they are in valid states before retrying the operation.
public struct InvalidStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An operation requiring TagOptions failed because the TagOptions migration process has not been performed for this account. Use the Amazon Web Services Management Console to perform the migration process before retrying the operation.
public struct TagOptionNotMigratedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagOptionNotMigratedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateTagOptionWithResourceInput: Swift.Sendable {
    /// The resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The TagOption identifier.
    /// This member is required.
    public var tagOptionId: Swift.String?

    public init(
        resourceId: Swift.String? = nil,
        tagOptionId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
        self.tagOptionId = tagOptionId
    }
}

public struct AssociateTagOptionWithResourceOutput: Swift.Sendable {

    public init() { }
}

extension ServiceCatalogClientTypes {

    /// A self-service action association consisting of the Action ID, the Product ID, and the Provisioning Artifact ID.
    public struct ServiceActionAssociation: Swift.Sendable {
        /// The product identifier. For example, prod-abcdzk7xy33qa.
        /// This member is required.
        public var productId: Swift.String?
        /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
        /// This member is required.
        public var provisioningArtifactId: Swift.String?
        /// The self-service action identifier. For example, act-fs7abcd89wxyz.
        /// This member is required.
        public var serviceActionId: Swift.String?

        public init(
            productId: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil,
            serviceActionId: Swift.String? = nil
        )
        {
            self.productId = productId
            self.provisioningArtifactId = provisioningArtifactId
            self.serviceActionId = serviceActionId
        }
    }
}

public struct BatchAssociateServiceActionWithProvisioningArtifactInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// One or more associations, each consisting of the Action ID, the Product ID, and the Provisioning Artifact ID.
    /// This member is required.
    public var serviceActionAssociations: [ServiceCatalogClientTypes.ServiceActionAssociation]?

    public init(
        acceptLanguage: Swift.String? = nil,
        serviceActionAssociations: [ServiceCatalogClientTypes.ServiceActionAssociation]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.serviceActionAssociations = serviceActionAssociations
    }
}

extension ServiceCatalogClientTypes {

    public enum ServiceActionAssociationErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case duplicateresourceexception
        case internalfailure
        case invalidparameterexception
        case limitexceededexception
        case resourcenotfoundexception
        case throttlingexception
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceActionAssociationErrorCode] {
            return [
                .duplicateresourceexception,
                .internalfailure,
                .invalidparameterexception,
                .limitexceededexception,
                .resourcenotfoundexception,
                .throttlingexception
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .duplicateresourceexception: return "DUPLICATE_RESOURCE"
            case .internalfailure: return "INTERNAL_FAILURE"
            case .invalidparameterexception: return "INVALID_PARAMETER"
            case .limitexceededexception: return "LIMIT_EXCEEDED"
            case .resourcenotfoundexception: return "RESOURCE_NOT_FOUND"
            case .throttlingexception: return "THROTTLING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    /// An object containing information about the error, along with identifying information about the self-service action and its associations.
    public struct FailedServiceActionAssociation: Swift.Sendable {
        /// The error code. Valid values are listed below.
        public var errorCode: ServiceCatalogClientTypes.ServiceActionAssociationErrorCode?
        /// A text description of the error.
        public var errorMessage: Swift.String?
        /// The product identifier. For example, prod-abcdzk7xy33qa.
        public var productId: Swift.String?
        /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
        public var provisioningArtifactId: Swift.String?
        /// The self-service action identifier. For example, act-fs7abcd89wxyz.
        public var serviceActionId: Swift.String?

        public init(
            errorCode: ServiceCatalogClientTypes.ServiceActionAssociationErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            productId: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil,
            serviceActionId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.productId = productId
            self.provisioningArtifactId = provisioningArtifactId
            self.serviceActionId = serviceActionId
        }
    }
}

public struct BatchAssociateServiceActionWithProvisioningArtifactOutput: Swift.Sendable {
    /// An object that contains a list of errors, along with information to help you identify the self-service action.
    public var failedServiceActionAssociations: [ServiceCatalogClientTypes.FailedServiceActionAssociation]?

    public init(
        failedServiceActionAssociations: [ServiceCatalogClientTypes.FailedServiceActionAssociation]? = nil
    )
    {
        self.failedServiceActionAssociations = failedServiceActionAssociations
    }
}

public struct BatchDisassociateServiceActionFromProvisioningArtifactInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// One or more associations, each consisting of the Action ID, the Product ID, and the Provisioning Artifact ID.
    /// This member is required.
    public var serviceActionAssociations: [ServiceCatalogClientTypes.ServiceActionAssociation]?

    public init(
        acceptLanguage: Swift.String? = nil,
        serviceActionAssociations: [ServiceCatalogClientTypes.ServiceActionAssociation]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.serviceActionAssociations = serviceActionAssociations
    }
}

public struct BatchDisassociateServiceActionFromProvisioningArtifactOutput: Swift.Sendable {
    /// An object that contains a list of errors, along with information to help you identify the self-service action.
    public var failedServiceActionAssociations: [ServiceCatalogClientTypes.FailedServiceActionAssociation]?

    public init(
        failedServiceActionAssociations: [ServiceCatalogClientTypes.FailedServiceActionAssociation]? = nil
    )
    {
        self.failedServiceActionAssociations = failedServiceActionAssociations
    }
}

extension ServiceCatalogClientTypes {

    public enum CopyOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case copytags
        case sdkUnknown(Swift.String)

        public static var allCases: [CopyOption] {
            return [
                .copytags
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .copytags: return "CopyTags"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    public enum ProvisioningArtifactPropertyName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case id
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisioningArtifactPropertyName] {
            return [
                .id
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .id: return "Id"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CopyProductInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The copy options. If the value is CopyTags, the tags from the source product are copied to the target product.
    public var copyOptions: [ServiceCatalogClientTypes.CopyOption]?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the source product.
    /// This member is required.
    public var sourceProductArn: Swift.String?
    /// The identifiers of the provisioning artifacts (also known as versions) of the product to copy. By default, all provisioning artifacts are copied.
    public var sourceProvisioningArtifactIdentifiers: [[Swift.String: Swift.String]]?
    /// The identifier of the target product. By default, a new product is created.
    public var targetProductId: Swift.String?
    /// A name for the target product. The default is the name of the source product.
    public var targetProductName: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        copyOptions: [ServiceCatalogClientTypes.CopyOption]? = nil,
        idempotencyToken: Swift.String? = nil,
        sourceProductArn: Swift.String? = nil,
        sourceProvisioningArtifactIdentifiers: [[Swift.String: Swift.String]]? = nil,
        targetProductId: Swift.String? = nil,
        targetProductName: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.copyOptions = copyOptions
        self.idempotencyToken = idempotencyToken
        self.sourceProductArn = sourceProductArn
        self.sourceProvisioningArtifactIdentifiers = sourceProvisioningArtifactIdentifiers
        self.targetProductId = targetProductId
        self.targetProductName = targetProductName
    }
}

public struct CopyProductOutput: Swift.Sendable {
    /// The token to use to track the progress of the operation.
    public var copyProductToken: Swift.String?

    public init(
        copyProductToken: Swift.String? = nil
    )
    {
        self.copyProductToken = copyProductToken
    }
}

public struct CreateConstraintInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The description of the constraint.
    public var description: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The constraint parameters, in JSON format. The syntax depends on the constraint type as follows: LAUNCH You are required to specify either the RoleArn or the LocalRoleName but can't use both. Specify the RoleArn property as follows: {"RoleArn" : "arn:aws:iam::123456789012:role/LaunchRole"} Specify the LocalRoleName property as follows: {"LocalRoleName": "SCBasicLaunchRole"} If you specify the LocalRoleName property, when an account uses the launch constraint, the IAM role with that name in the account will be used. This allows launch-role constraints to be account-agnostic so the administrator can create fewer resources per shared account. The given role name must exist in the account used to create the launch constraint and the account of the user who launches a product with this launch constraint. You cannot have both a LAUNCH and a STACKSET constraint. You also cannot have more than one LAUNCH constraint on a product and portfolio. NOTIFICATION Specify the NotificationArns property as follows: {"NotificationArns" : ["arn:aws:sns:us-east-1:123456789012:Topic"]} RESOURCE_UPDATE Specify the TagUpdatesOnProvisionedProduct property as follows: {"Version":"2.0","Properties":{"TagUpdateOnProvisionedProduct":"String"}} The TagUpdatesOnProvisionedProduct property accepts a string value of ALLOWED or NOT_ALLOWED. STACKSET Specify the Parameters property as follows: {"Version": "String", "Properties": {"AccountList": [ "String" ], "RegionList": [ "String" ], "AdminRole": "String", "ExecutionRole": "String"}} You cannot have both a LAUNCH and a STACKSET constraint. You also cannot have more than one STACKSET constraint on a product and portfolio. Products with a STACKSET constraint will launch an CloudFormation stack set. TEMPLATE Specify the Rules property. For more information, see [Template Constraint Rules](http://docs.aws.amazon.com/servicecatalog/latest/adminguide/reference-template_constraint_rules.html).
    /// This member is required.
    public var parameters: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?
    /// The type of constraint.
    ///
    /// * LAUNCH
    ///
    /// * NOTIFICATION
    ///
    /// * RESOURCE_UPDATE
    ///
    /// * STACKSET
    ///
    /// * TEMPLATE
    /// This member is required.
    public var type: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        description: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        parameters: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        productId: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.description = description
        self.idempotencyToken = idempotencyToken
        self.parameters = parameters
        self.portfolioId = portfolioId
        self.productId = productId
        self.type = type
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a constraint.
    public struct ConstraintDetail: Swift.Sendable {
        /// The identifier of the constraint.
        public var constraintId: Swift.String?
        /// The description of the constraint.
        public var description: Swift.String?
        /// The owner of the constraint.
        public var owner: Swift.String?
        /// The identifier of the portfolio the product resides in. The constraint applies only to the instance of the product that lives within this portfolio.
        public var portfolioId: Swift.String?
        /// The identifier of the product the constraint applies to. Note that a constraint applies to a specific instance of a product within a certain portfolio.
        public var productId: Swift.String?
        /// The type of constraint.
        ///
        /// * LAUNCH
        ///
        /// * NOTIFICATION
        ///
        /// * STACKSET
        ///
        /// * TEMPLATE
        public var type: Swift.String?

        public init(
            constraintId: Swift.String? = nil,
            description: Swift.String? = nil,
            owner: Swift.String? = nil,
            portfolioId: Swift.String? = nil,
            productId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.constraintId = constraintId
            self.description = description
            self.owner = owner
            self.portfolioId = portfolioId
            self.productId = productId
            self.type = type
        }
    }
}

extension ServiceCatalogClientTypes {

    public enum Status: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case creating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .available,
                .creating,
                .failed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateConstraintOutput: Swift.Sendable {
    /// Information about the constraint.
    public var constraintDetail: ServiceCatalogClientTypes.ConstraintDetail?
    /// The constraint parameters.
    public var constraintParameters: Swift.String?
    /// The status of the current request.
    public var status: ServiceCatalogClientTypes.Status?

    public init(
        constraintDetail: ServiceCatalogClientTypes.ConstraintDetail? = nil,
        constraintParameters: Swift.String? = nil,
        status: ServiceCatalogClientTypes.Status? = nil
    )
    {
        self.constraintDetail = constraintDetail
        self.constraintParameters = constraintParameters
        self.status = status
    }
}

public struct CreatePortfolioInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The description of the portfolio.
    public var description: Swift.String?
    /// The name to use for display purposes.
    /// This member is required.
    public var displayName: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The name of the portfolio provider.
    /// This member is required.
    public var providerName: Swift.String?
    /// One or more tags.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        acceptLanguage: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        providerName: Swift.String? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.description = description
        self.displayName = displayName
        self.idempotencyToken = idempotencyToken
        self.providerName = providerName
        self.tags = tags
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a portfolio.
    public struct PortfolioDetail: Swift.Sendable {
        /// The ARN assigned to the portfolio.
        public var arn: Swift.String?
        /// The UTC time stamp of the creation time.
        public var createdTime: Foundation.Date?
        /// The description of the portfolio.
        public var description: Swift.String?
        /// The name to use for display purposes.
        public var displayName: Swift.String?
        /// The portfolio identifier.
        public var id: Swift.String?
        /// The name of the portfolio provider.
        public var providerName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            id: Swift.String? = nil,
            providerName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.id = id
            self.providerName = providerName
        }
    }
}

public struct CreatePortfolioOutput: Swift.Sendable {
    /// Information about the portfolio.
    public var portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail?
    /// Information about the tags associated with the portfolio.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.portfolioDetail = portfolioDetail
        self.tags = tags
    }
}

/// The operation is not supported.
public struct OperationNotSupportedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationNotSupportedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ServiceCatalogClientTypes {

    public enum OrganizationNodeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case organization
        case organizationalUnit
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationNodeType] {
            return [
                .account,
                .organization,
                .organizationalUnit
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .organization: return "ORGANIZATION"
            case .organizationalUnit: return "ORGANIZATIONAL_UNIT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Information about the organization node.
    public struct OrganizationNode: Swift.Sendable {
        /// The organization node type.
        public var type: ServiceCatalogClientTypes.OrganizationNodeType?
        /// The identifier of the organization node.
        public var value: Swift.String?

        public init(
            type: ServiceCatalogClientTypes.OrganizationNodeType? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }
}

public struct CreatePortfolioShareInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The Amazon Web Services account ID. For example, 123456789012.
    public var accountId: Swift.String?
    /// The organization node to whom you are going to share. When you pass OrganizationNode, it creates PortfolioShare for all of the Amazon Web Services accounts that are associated to the OrganizationNode. The output returns a PortfolioShareToken, which enables the administrator to monitor the status of the PortfolioShare creation process.
    public var organizationNode: ServiceCatalogClientTypes.OrganizationNode?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// This parameter is only supported for portfolios with an OrganizationalNode Type of ORGANIZATION or ORGANIZATIONAL_UNIT. Enables or disables Principal sharing when creating the portfolio share. If you do not provide this flag, principal sharing is disabled. When you enable Principal Name Sharing for a portfolio share, the share recipient account end users with a principal that matches any of the associated IAM patterns can provision products from the portfolio. Once shared, the share recipient can view associations of PrincipalType: IAM_PATTERN on their portfolio. You can create the principals in the recipient account before or after creating the share.
    public var sharePrincipals: Swift.Bool?
    /// Enables or disables TagOptions  sharing when creating the portfolio share. If this flag is not provided, TagOptions sharing is disabled.
    public var shareTagOptions: Swift.Bool?

    public init(
        acceptLanguage: Swift.String? = nil,
        accountId: Swift.String? = nil,
        organizationNode: ServiceCatalogClientTypes.OrganizationNode? = nil,
        portfolioId: Swift.String? = nil,
        sharePrincipals: Swift.Bool? = false,
        shareTagOptions: Swift.Bool? = false
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accountId = accountId
        self.organizationNode = organizationNode
        self.portfolioId = portfolioId
        self.sharePrincipals = sharePrincipals
        self.shareTagOptions = shareTagOptions
    }
}

public struct CreatePortfolioShareOutput: Swift.Sendable {
    /// The portfolio shares a unique identifier that only returns if the portfolio is shared to an organization node.
    public var portfolioShareToken: Swift.String?

    public init(
        portfolioShareToken: Swift.String? = nil
    )
    {
        self.portfolioShareToken = portfolioShareToken
    }
}

extension ServiceCatalogClientTypes {

    public enum ProductType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cloudFormationTemplate
        case external
        case marketplace
        case terraformCloud
        case terraformOpenSource
        case sdkUnknown(Swift.String)

        public static var allCases: [ProductType] {
            return [
                .cloudFormationTemplate,
                .external,
                .marketplace,
                .terraformCloud,
                .terraformOpenSource
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cloudFormationTemplate: return "CLOUD_FORMATION_TEMPLATE"
            case .external: return "EXTERNAL"
            case .marketplace: return "MARKETPLACE"
            case .terraformCloud: return "TERRAFORM_CLOUD"
            case .terraformOpenSource: return "TERRAFORM_OPEN_SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    public enum ProvisioningArtifactType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cloudFormationTemplate
        case external
        case marketplaceAmi
        case marketplaceCar
        case terraformCloud
        case terraformOpenSource
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisioningArtifactType] {
            return [
                .cloudFormationTemplate,
                .external,
                .marketplaceAmi,
                .marketplaceCar,
                .terraformCloud,
                .terraformOpenSource
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cloudFormationTemplate: return "CLOUD_FORMATION_TEMPLATE"
            case .external: return "EXTERNAL"
            case .marketplaceAmi: return "MARKETPLACE_AMI"
            case .marketplaceCar: return "MARKETPLACE_CAR"
            case .terraformCloud: return "TERRAFORM_CLOUD"
            case .terraformOpenSource: return "TERRAFORM_OPEN_SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a provisioning artifact (also known as a version) for a product.
    public struct ProvisioningArtifactProperties: Swift.Sendable {
        /// The description of the provisioning artifact, including how it differs from the previous provisioning artifact.
        public var description: Swift.String?
        /// If set to true, Service Catalog stops validating the specified provisioning artifact even if it is invalid. Service Catalog does not support template validation for the TERRAFORM_OS product type.
        public var disableTemplateValidation: Swift.Bool
        /// Specify the template source with one of the following options, but not both. Keys accepted: [ LoadTemplateFromURL, ImportFromPhysicalId ] The URL of the CloudFormation template in Amazon S3 or GitHub in JSON format. Specify the URL in JSON format as follows: "LoadTemplateFromURL": "https://s3.amazonaws.com/cf-templates-ozkq9d3hgiq2-us-east-1/..."ImportFromPhysicalId: The physical id of the resource that contains the template. Currently only supports CloudFormation stack arn. Specify the physical id in JSON format as follows: ImportFromPhysicalId: arn:aws:cloudformation:[us-east-1]:[accountId]:stack/[StackName]/[resourceId]
        public var info: [Swift.String: Swift.String]?
        /// The name of the provisioning artifact (for example, v1 v2beta). No spaces are allowed.
        public var name: Swift.String?
        /// The type of provisioning artifact.
        ///
        /// * CLOUD_FORMATION_TEMPLATE - CloudFormation template
        ///
        /// * TERRAFORM_OPEN_SOURCE - Terraform Open Source configuration file
        ///
        /// * TERRAFORM_CLOUD - Terraform Cloud configuration file
        ///
        /// * EXTERNAL - External configuration file
        public var type: ServiceCatalogClientTypes.ProvisioningArtifactType?

        public init(
            description: Swift.String? = nil,
            disableTemplateValidation: Swift.Bool = false,
            info: [Swift.String: Swift.String]? = nil,
            name: Swift.String? = nil,
            type: ServiceCatalogClientTypes.ProvisioningArtifactType? = nil
        )
        {
            self.description = description
            self.disableTemplateValidation = disableTemplateValidation
            self.info = info
            self.name = name
            self.type = type
        }
    }
}

extension ServiceCatalogClientTypes {

    /// The subtype containing details about the Codestar connection Type.
    public struct CodeStarParameters: Swift.Sendable {
        /// The absolute path wehre the artifact resides within the repo and branch, formatted as "folder/file.json."
        /// This member is required.
        public var artifactPath: Swift.String?
        /// The specific branch where the artifact resides.
        /// This member is required.
        public var branch: Swift.String?
        /// The CodeStar ARN, which is the connection between Service Catalog and the external repository.
        /// This member is required.
        public var connectionArn: Swift.String?
        /// The specific repository where the products artifact-to-be-synced resides, formatted as "Account/Repo."
        /// This member is required.
        public var repository: Swift.String?

        public init(
            artifactPath: Swift.String? = nil,
            branch: Swift.String? = nil,
            connectionArn: Swift.String? = nil,
            repository: Swift.String? = nil
        )
        {
            self.artifactPath = artifactPath
            self.branch = branch
            self.connectionArn = connectionArn
            self.repository = repository
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Provides connection details.
    public struct SourceConnectionParameters: Swift.Sendable {
        /// Provides ConnectionType details.
        public var codeStar: ServiceCatalogClientTypes.CodeStarParameters?

        public init(
            codeStar: ServiceCatalogClientTypes.CodeStarParameters? = nil
        )
        {
            self.codeStar = codeStar
        }
    }
}

extension ServiceCatalogClientTypes {

    public enum SourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case codestar
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .codestar
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .codestar: return "CODESTAR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    /// A top level ProductViewDetail response containing details about the products connection. Service Catalog returns this field for the CreateProduct, UpdateProduct, DescribeProductAsAdmin, and SearchProductAsAdmin APIs. This response contains the same fields as the ConnectionParameters request, with the addition of the LastSync response.
    public struct SourceConnection: Swift.Sendable {
        /// The connection details based on the connection Type.
        /// This member is required.
        public var connectionParameters: ServiceCatalogClientTypes.SourceConnectionParameters?
        /// The only supported SourceConnection type is Codestar.
        public var type: ServiceCatalogClientTypes.SourceType?

        public init(
            connectionParameters: ServiceCatalogClientTypes.SourceConnectionParameters? = nil,
            type: ServiceCatalogClientTypes.SourceType? = nil
        )
        {
            self.connectionParameters = connectionParameters
            self.type = type
        }
    }
}

public struct CreateProductInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The description of the product.
    public var description: Swift.String?
    /// The distributor of the product.
    public var distributor: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The name of the product.
    /// This member is required.
    public var name: Swift.String?
    /// The owner of the product.
    /// This member is required.
    public var owner: Swift.String?
    /// The type of product.
    /// This member is required.
    public var productType: ServiceCatalogClientTypes.ProductType?
    /// The configuration of the provisioning artifact.
    public var provisioningArtifactParameters: ServiceCatalogClientTypes.ProvisioningArtifactProperties?
    /// Specifies connection details for the created product and syncs the product to the connection source artifact. This automatically manages the product's artifacts based on changes to the source. The SourceConnection parameter consists of the following sub-fields.
    ///
    /// * Type
    ///
    /// * ConnectionParamters
    public var sourceConnection: ServiceCatalogClientTypes.SourceConnection?
    /// The support information about the product.
    public var supportDescription: Swift.String?
    /// The contact email for product support.
    public var supportEmail: Swift.String?
    /// The contact URL for product support. ^https?:\/\// / is the pattern used to validate SupportUrl.
    public var supportUrl: Swift.String?
    /// One or more tags.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        acceptLanguage: Swift.String? = nil,
        description: Swift.String? = nil,
        distributor: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        name: Swift.String? = nil,
        owner: Swift.String? = nil,
        productType: ServiceCatalogClientTypes.ProductType? = nil,
        provisioningArtifactParameters: ServiceCatalogClientTypes.ProvisioningArtifactProperties? = nil,
        sourceConnection: ServiceCatalogClientTypes.SourceConnection? = nil,
        supportDescription: Swift.String? = nil,
        supportEmail: Swift.String? = nil,
        supportUrl: Swift.String? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.description = description
        self.distributor = distributor
        self.idempotencyToken = idempotencyToken
        self.name = name
        self.owner = owner
        self.productType = productType
        self.provisioningArtifactParameters = provisioningArtifactParameters
        self.sourceConnection = sourceConnection
        self.supportDescription = supportDescription
        self.supportEmail = supportEmail
        self.supportUrl = supportUrl
        self.tags = tags
    }
}

extension ServiceCatalogClientTypes {

    /// Summary information about a product view.
    public struct ProductViewSummary: Swift.Sendable {
        /// The distributor of the product. Contact the product administrator for the significance of this value.
        public var distributor: Swift.String?
        /// Indicates whether the product has a default path. If the product does not have a default path, call [ListLaunchPaths] to disambiguate between paths. Otherwise, [ListLaunchPaths] is not required, and the output of [ProductViewSummary] can be used directly with [DescribeProvisioningParameters].
        public var hasDefaultPath: Swift.Bool
        /// The product view identifier.
        public var id: Swift.String?
        /// The name of the product.
        public var name: Swift.String?
        /// The owner of the product. Contact the product administrator for the significance of this value.
        public var owner: Swift.String?
        /// The product identifier.
        public var productId: Swift.String?
        /// Short description of the product.
        public var shortDescription: Swift.String?
        /// The description of the support for this Product.
        public var supportDescription: Swift.String?
        /// The email contact information to obtain support for this Product.
        public var supportEmail: Swift.String?
        /// The URL information to obtain support for this Product.
        public var supportUrl: Swift.String?
        /// The product type. Contact the product administrator for the significance of this value. If this value is MARKETPLACE, the product was created by Amazon Web Services Marketplace.
        public var type: ServiceCatalogClientTypes.ProductType?

        public init(
            distributor: Swift.String? = nil,
            hasDefaultPath: Swift.Bool = false,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            productId: Swift.String? = nil,
            shortDescription: Swift.String? = nil,
            supportDescription: Swift.String? = nil,
            supportEmail: Swift.String? = nil,
            supportUrl: Swift.String? = nil,
            type: ServiceCatalogClientTypes.ProductType? = nil
        )
        {
            self.distributor = distributor
            self.hasDefaultPath = hasDefaultPath
            self.id = id
            self.name = name
            self.owner = owner
            self.productId = productId
            self.shortDescription = shortDescription
            self.supportDescription = supportDescription
            self.supportEmail = supportEmail
            self.supportUrl = supportUrl
            self.type = type
        }
    }
}

extension ServiceCatalogClientTypes {

    public enum LastSyncStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [LastSyncStatus] {
            return [
                .failed,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Provides details about the product's connection sync and contains the following sub-fields.
    ///
    /// * LastSyncTime
    ///
    /// * LastSyncStatus
    ///
    /// * LastSyncStatusMessage
    ///
    /// * LastSuccessfulSyncTime
    ///
    /// * LastSuccessfulSyncProvisioningArtifactID
    public struct LastSync: Swift.Sendable {
        /// The ProvisioningArtifactID of the ProvisioningArtifact created from the latest successful sync.
        public var lastSuccessfulSyncProvisioningArtifactId: Swift.String?
        /// The time of the latest successful sync from the source repo artifact to the Service Catalog product.
        public var lastSuccessfulSyncTime: Foundation.Date?
        /// The current status of the sync. Responses include SUCCEEDED or FAILED.
        public var lastSyncStatus: ServiceCatalogClientTypes.LastSyncStatus?
        /// The sync's status message.
        public var lastSyncStatusMessage: Swift.String?
        /// The time of the last attempted sync from the repository to the Service Catalog product.
        public var lastSyncTime: Foundation.Date?

        public init(
            lastSuccessfulSyncProvisioningArtifactId: Swift.String? = nil,
            lastSuccessfulSyncTime: Foundation.Date? = nil,
            lastSyncStatus: ServiceCatalogClientTypes.LastSyncStatus? = nil,
            lastSyncStatusMessage: Swift.String? = nil,
            lastSyncTime: Foundation.Date? = nil
        )
        {
            self.lastSuccessfulSyncProvisioningArtifactId = lastSuccessfulSyncProvisioningArtifactId
            self.lastSuccessfulSyncTime = lastSuccessfulSyncTime
            self.lastSyncStatus = lastSyncStatus
            self.lastSyncStatusMessage = lastSyncStatusMessage
            self.lastSyncTime = lastSyncTime
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Provides details about the configured SourceConnection.
    public struct SourceConnectionDetail: Swift.Sendable {
        /// The connection details based on the connection Type.
        public var connectionParameters: ServiceCatalogClientTypes.SourceConnectionParameters?
        /// Provides details about the product's connection sync and contains the following sub-fields.
        ///
        /// * LastSyncTime
        ///
        /// * LastSyncStatus
        ///
        /// * LastSyncStatusMessage
        ///
        /// * LastSuccessfulSyncTime
        ///
        /// * LastSuccessfulSyncProvisioningArtifactID
        public var lastSync: ServiceCatalogClientTypes.LastSync?
        /// The only supported SourceConnection type is Codestar.
        public var type: ServiceCatalogClientTypes.SourceType?

        public init(
            connectionParameters: ServiceCatalogClientTypes.SourceConnectionParameters? = nil,
            lastSync: ServiceCatalogClientTypes.LastSync? = nil,
            type: ServiceCatalogClientTypes.SourceType? = nil
        )
        {
            self.connectionParameters = connectionParameters
            self.lastSync = lastSync
            self.type = type
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a product view.
    public struct ProductViewDetail: Swift.Sendable {
        /// The UTC time stamp of the creation time.
        public var createdTime: Foundation.Date?
        /// The ARN of the product.
        public var productARN: Swift.String?
        /// Summary information about the product view.
        public var productViewSummary: ServiceCatalogClientTypes.ProductViewSummary?
        /// A top level ProductViewDetail response containing details about the products connection. Service Catalog returns this field for the CreateProduct, UpdateProduct, DescribeProductAsAdmin, and SearchProductAsAdmin APIs. This response contains the same fields as the ConnectionParameters request, with the addition of the LastSync response.
        public var sourceConnection: ServiceCatalogClientTypes.SourceConnectionDetail?
        /// The status of the product.
        ///
        /// * AVAILABLE - The product is ready for use.
        ///
        /// * CREATING - Product creation has started; the product is not ready for use.
        ///
        /// * FAILED - An action failed.
        public var status: ServiceCatalogClientTypes.Status?

        public init(
            createdTime: Foundation.Date? = nil,
            productARN: Swift.String? = nil,
            productViewSummary: ServiceCatalogClientTypes.ProductViewSummary? = nil,
            sourceConnection: ServiceCatalogClientTypes.SourceConnectionDetail? = nil,
            status: ServiceCatalogClientTypes.Status? = nil
        )
        {
            self.createdTime = createdTime
            self.productARN = productARN
            self.productViewSummary = productViewSummary
            self.sourceConnection = sourceConnection
            self.status = status
        }
    }
}

extension ServiceCatalogClientTypes {

    public enum ProvisioningArtifactGuidance: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case deprecated
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisioningArtifactGuidance] {
            return [
                .default,
                .deprecated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .deprecated: return "DEPRECATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a provisioning artifact (also known as a version) for a product.
    public struct ProvisioningArtifactDetail: Swift.Sendable {
        /// Indicates whether the product version is active.
        public var active: Swift.Bool?
        /// The UTC time stamp of the creation time.
        public var createdTime: Foundation.Date?
        /// The description of the provisioning artifact.
        public var description: Swift.String?
        /// Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.
        public var guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance?
        /// The identifier of the provisioning artifact.
        public var id: Swift.String?
        /// The name of the provisioning artifact.
        public var name: Swift.String?
        /// Specifies the revision of the external artifact that was used to automatically sync the Service Catalog product and create the provisioning artifact. Service Catalog includes this response parameter as a high level field to the existing ProvisioningArtifactDetail type, which is returned as part of the response for CreateProduct, UpdateProduct, DescribeProductAsAdmin, DescribeProvisioningArtifact, ListProvisioningArtifact, and UpdateProvisioningArticat APIs. This field only exists for Repo-Synced products.
        public var sourceRevision: Swift.String?
        /// The type of provisioning artifact.
        ///
        /// * CLOUD_FORMATION_TEMPLATE - CloudFormation template
        ///
        /// * TERRAFORM_OPEN_SOURCE - Terraform Open Source configuration file
        ///
        /// * TERRAFORM_CLOUD - Terraform Cloud configuration file
        ///
        /// * EXTERNAL - External configuration file
        public var type: ServiceCatalogClientTypes.ProvisioningArtifactType?

        public init(
            active: Swift.Bool? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            sourceRevision: Swift.String? = nil,
            type: ServiceCatalogClientTypes.ProvisioningArtifactType? = nil
        )
        {
            self.active = active
            self.createdTime = createdTime
            self.description = description
            self.guidance = guidance
            self.id = id
            self.name = name
            self.sourceRevision = sourceRevision
            self.type = type
        }
    }
}

public struct CreateProductOutput: Swift.Sendable {
    /// Information about the product view.
    public var productViewDetail: ServiceCatalogClientTypes.ProductViewDetail?
    /// Information about the provisioning artifact.
    public var provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    /// Information about the tags associated with the product.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        productViewDetail: ServiceCatalogClientTypes.ProductViewDetail? = nil,
        provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.productViewDetail = productViewDetail
        self.provisioningArtifactDetail = provisioningArtifactDetail
        self.tags = tags
    }
}

extension ServiceCatalogClientTypes {

    public enum ProvisionedProductPlanType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cloudformation
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedProductPlanType] {
            return [
                .cloudformation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cloudformation: return "CLOUDFORMATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    /// The parameter key-value pair used to update a provisioned product.
    public struct UpdateProvisioningParameter: Swift.Sendable {
        /// The parameter key.
        public var key: Swift.String?
        /// If set to true, Value is ignored and the previous parameter value is kept.
        public var usePreviousValue: Swift.Bool
        /// The parameter value.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            usePreviousValue: Swift.Bool = false,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.usePreviousValue = usePreviousValue
            self.value = value
        }
    }
}

public struct CreateProvisionedProductPlanInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// Passed to CloudFormation. The SNS topic ARNs to which to publish stack-related events.
    public var notificationArns: [Swift.String]?
    /// The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use [ListLaunchPaths].
    public var pathId: Swift.String?
    /// The name of the plan.
    /// This member is required.
    public var planName: Swift.String?
    /// The plan type.
    /// This member is required.
    public var planType: ServiceCatalogClientTypes.ProvisionedProductPlanType?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?
    /// A user-friendly name for the provisioned product. This value must be unique for the Amazon Web Services account and cannot be updated after the product is provisioned.
    /// This member is required.
    public var provisionedProductName: Swift.String?
    /// The identifier of the provisioning artifact.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?
    /// Parameters specified by the administrator that are required for provisioning the product.
    public var provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]?
    /// One or more tags. If the plan is for an existing provisioned product, the product must have a RESOURCE_UPDATE constraint with TagUpdatesOnProvisionedProduct set to ALLOWED to allow tag updates.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        acceptLanguage: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        notificationArns: [Swift.String]? = nil,
        pathId: Swift.String? = nil,
        planName: Swift.String? = nil,
        planType: ServiceCatalogClientTypes.ProvisionedProductPlanType? = nil,
        productId: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.notificationArns = notificationArns
        self.pathId = pathId
        self.planName = planName
        self.planType = planType
        self.productId = productId
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningParameters = provisioningParameters
        self.tags = tags
    }
}

public struct CreateProvisionedProductPlanOutput: Swift.Sendable {
    /// The plan identifier.
    public var planId: Swift.String?
    /// The name of the plan.
    public var planName: Swift.String?
    /// The product identifier.
    public var provisionProductId: Swift.String?
    /// The user-friendly name of the provisioned product.
    public var provisionedProductName: Swift.String?
    /// The identifier of the provisioning artifact.
    public var provisioningArtifactId: Swift.String?

    public init(
        planId: Swift.String? = nil,
        planName: Swift.String? = nil,
        provisionProductId: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil
    )
    {
        self.planId = planId
        self.planName = planName
        self.provisionProductId = provisionProductId
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
    }
}

public struct CreateProvisioningArtifactInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The configuration for the provisioning artifact.
    /// This member is required.
    public var parameters: ServiceCatalogClientTypes.ProvisioningArtifactProperties?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        parameters: ServiceCatalogClientTypes.ProvisioningArtifactProperties? = nil,
        productId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.parameters = parameters
        self.productId = productId
    }
}

public struct CreateProvisioningArtifactOutput: Swift.Sendable {
    /// Specify the template source with one of the following options, but not both. Keys accepted: [ LoadTemplateFromURL, ImportFromPhysicalId ]. Use the URL of the CloudFormation template in Amazon S3 or GitHub in JSON format. LoadTemplateFromURL Use the URL of the CloudFormation template in Amazon S3 or GitHub in JSON format. ImportFromPhysicalId Use the physical id of the resource that contains the template; currently supports CloudFormation stack ARN.
    public var info: [Swift.String: Swift.String]?
    /// Information about the provisioning artifact.
    public var provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    /// The status of the current request.
    public var status: ServiceCatalogClientTypes.Status?

    public init(
        info: [Swift.String: Swift.String]? = nil,
        provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail? = nil,
        status: ServiceCatalogClientTypes.Status? = nil
    )
    {
        self.info = info
        self.provisioningArtifactDetail = provisioningArtifactDetail
        self.status = status
    }
}

extension ServiceCatalogClientTypes {

    public enum ServiceActionDefinitionKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assumerole
        case name
        case parameters
        case version
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceActionDefinitionKey] {
            return [
                .assumerole,
                .name,
                .parameters,
                .version
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assumerole: return "AssumeRole"
            case .name: return "Name"
            case .parameters: return "Parameters"
            case .version: return "Version"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    public enum ServiceActionDefinitionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ssmautomation
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceActionDefinitionType] {
            return [
                .ssmautomation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ssmautomation: return "SSM_AUTOMATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateServiceActionInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The self-service action definition. Can be one of the following: Name The name of the Amazon Web Services Systems Manager document (SSM document). For example, AWS-RestartEC2Instance. If you are using a shared SSM document, you must provide the ARN instead of the name. Version The Amazon Web Services Systems Manager automation document version. For example, "Version": "1" AssumeRole The Amazon Resource Name (ARN) of the role that performs the self-service actions on your behalf. For example, "AssumeRole": "arn:aws:iam::12345678910:role/ActionRole". To reuse the provisioned product launch role, set to "AssumeRole": "LAUNCH_ROLE". Parameters The list of parameters in JSON format. For example: [{\"Name\":\"InstanceId\",\"Type\":\"TARGET\"}] or [{\"Name\":\"InstanceId\",\"Type\":\"TEXT_VALUE\"}].
    /// This member is required.
    public var definition: [Swift.String: Swift.String]?
    /// The service action definition type. For example, SSM_AUTOMATION.
    /// This member is required.
    public var definitionType: ServiceCatalogClientTypes.ServiceActionDefinitionType?
    /// The self-service action description.
    public var description: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The self-service action name.
    /// This member is required.
    public var name: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        definition: [Swift.String: Swift.String]? = nil,
        definitionType: ServiceCatalogClientTypes.ServiceActionDefinitionType? = nil,
        description: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.definition = definition
        self.definitionType = definitionType
        self.description = description
        self.idempotencyToken = idempotencyToken
        self.name = name
    }
}

extension ServiceCatalogClientTypes {

    /// Detailed information about the self-service action.
    public struct ServiceActionSummary: Swift.Sendable {
        /// The self-service action definition type. For example, SSM_AUTOMATION.
        public var definitionType: ServiceCatalogClientTypes.ServiceActionDefinitionType?
        /// The self-service action description.
        public var description: Swift.String?
        /// The self-service action identifier.
        public var id: Swift.String?
        /// The self-service action name.
        public var name: Swift.String?

        public init(
            definitionType: ServiceCatalogClientTypes.ServiceActionDefinitionType? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.definitionType = definitionType
            self.description = description
            self.id = id
            self.name = name
        }
    }
}

extension ServiceCatalogClientTypes {

    /// An object containing detailed information about the self-service action.
    public struct ServiceActionDetail: Swift.Sendable {
        /// A map that defines the self-service action.
        public var definition: [Swift.String: Swift.String]?
        /// Summary information about the self-service action.
        public var serviceActionSummary: ServiceCatalogClientTypes.ServiceActionSummary?

        public init(
            definition: [Swift.String: Swift.String]? = nil,
            serviceActionSummary: ServiceCatalogClientTypes.ServiceActionSummary? = nil
        )
        {
            self.definition = definition
            self.serviceActionSummary = serviceActionSummary
        }
    }
}

public struct CreateServiceActionOutput: Swift.Sendable {
    /// An object containing information about the self-service action.
    public var serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail?

    public init(
        serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail? = nil
    )
    {
        self.serviceActionDetail = serviceActionDetail
    }
}

public struct CreateTagOptionInput: Swift.Sendable {
    /// The TagOption key.
    /// This member is required.
    public var key: Swift.String?
    /// The TagOption value.
    /// This member is required.
    public var value: Swift.String?

    public init(
        key: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a TagOption.
    public struct TagOptionDetail: Swift.Sendable {
        /// The TagOption active state.
        public var active: Swift.Bool?
        /// The TagOption identifier.
        public var id: Swift.String?
        /// The TagOption key.
        public var key: Swift.String?
        /// The Amazon Web Services account Id of the owner account that created the TagOption.
        public var owner: Swift.String?
        /// The TagOption value.
        public var value: Swift.String?

        public init(
            active: Swift.Bool? = nil,
            id: Swift.String? = nil,
            key: Swift.String? = nil,
            owner: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.active = active
            self.id = id
            self.key = key
            self.owner = owner
            self.value = value
        }
    }
}

public struct CreateTagOptionOutput: Swift.Sendable {
    /// Information about the TagOption.
    public var tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail?

    public init(
        tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail? = nil
    )
    {
        self.tagOptionDetail = tagOptionDetail
    }
}

public struct DeleteConstraintInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The identifier of the constraint.
    /// This member is required.
    public var id: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

public struct DeleteConstraintOutput: Swift.Sendable {

    public init() { }
}

/// A resource that is currently in use. Ensure that the resource is not in use and retry the operation.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeletePortfolioInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var id: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

public struct DeletePortfolioOutput: Swift.Sendable {

    public init() { }
}

public struct DeletePortfolioShareInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The Amazon Web Services account ID.
    public var accountId: Swift.String?
    /// The organization node to whom you are going to stop sharing.
    public var organizationNode: ServiceCatalogClientTypes.OrganizationNode?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        accountId: Swift.String? = nil,
        organizationNode: ServiceCatalogClientTypes.OrganizationNode? = nil,
        portfolioId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accountId = accountId
        self.organizationNode = organizationNode
        self.portfolioId = portfolioId
    }
}

public struct DeletePortfolioShareOutput: Swift.Sendable {
    /// The portfolio share unique identifier. This will only be returned if delete is made to an organization node.
    public var portfolioShareToken: Swift.String?

    public init(
        portfolioShareToken: Swift.String? = nil
    )
    {
        self.portfolioShareToken = portfolioShareToken
    }
}

public struct DeleteProductInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var id: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

public struct DeleteProductOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteProvisionedProductPlanInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// If set to true, Service Catalog stops managing the specified provisioned product even if it cannot delete the underlying resources.
    public var ignoreErrors: Swift.Bool?
    /// The plan identifier.
    /// This member is required.
    public var planId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        ignoreErrors: Swift.Bool? = false,
        planId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.ignoreErrors = ignoreErrors
        self.planId = planId
    }
}

public struct DeleteProvisionedProductPlanOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteProvisioningArtifactInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?
    /// The identifier of the provisioning artifact.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        productId: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
    }
}

public struct DeleteProvisioningArtifactOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteServiceActionInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The self-service action identifier. For example, act-fs7abcd89wxyz.
    /// This member is required.
    public var id: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests from the same Amazon Web Services account use the same idempotency token, the same response is returned for each repeated request.
    public var idempotencyToken: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
        self.idempotencyToken = idempotencyToken
    }
}

public struct DeleteServiceActionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTagOptionInput: Swift.Sendable {
    /// The TagOption identifier.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteTagOptionOutput: Swift.Sendable {

    public init() { }
}

public struct DescribeConstraintInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The identifier of the constraint.
    /// This member is required.
    public var id: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

public struct DescribeConstraintOutput: Swift.Sendable {
    /// Information about the constraint.
    public var constraintDetail: ServiceCatalogClientTypes.ConstraintDetail?
    /// The constraint parameters.
    public var constraintParameters: Swift.String?
    /// The status of the current request.
    public var status: ServiceCatalogClientTypes.Status?

    public init(
        constraintDetail: ServiceCatalogClientTypes.ConstraintDetail? = nil,
        constraintParameters: Swift.String? = nil,
        status: ServiceCatalogClientTypes.Status? = nil
    )
    {
        self.constraintDetail = constraintDetail
        self.constraintParameters = constraintParameters
        self.status = status
    }
}

public struct DescribeCopyProductStatusInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The token for the copy product operation. This token is returned by [CopyProduct].
    /// This member is required.
    public var copyProductToken: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        copyProductToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.copyProductToken = copyProductToken
    }
}

extension ServiceCatalogClientTypes {

    public enum CopyProductStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [CopyProductStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeCopyProductStatusOutput: Swift.Sendable {
    /// The status of the copy product operation.
    public var copyProductStatus: ServiceCatalogClientTypes.CopyProductStatus?
    /// The status message.
    public var statusDetail: Swift.String?
    /// The identifier of the copied product.
    public var targetProductId: Swift.String?

    public init(
        copyProductStatus: ServiceCatalogClientTypes.CopyProductStatus? = nil,
        statusDetail: Swift.String? = nil,
        targetProductId: Swift.String? = nil
    )
    {
        self.copyProductStatus = copyProductStatus
        self.statusDetail = statusDetail
        self.targetProductId = targetProductId
    }
}

public struct DescribePortfolioInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var id: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a budget.
    public struct BudgetDetail: Swift.Sendable {
        /// Name of the associated budget.
        public var budgetName: Swift.String?

        public init(
            budgetName: Swift.String? = nil
        )
        {
            self.budgetName = budgetName
        }
    }
}

public struct DescribePortfolioOutput: Swift.Sendable {
    /// Information about the associated budgets.
    public var budgets: [ServiceCatalogClientTypes.BudgetDetail]?
    /// Information about the portfolio.
    public var portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail?
    /// Information about the TagOptions associated with the portfolio.
    public var tagOptions: [ServiceCatalogClientTypes.TagOptionDetail]?
    /// Information about the tags associated with the portfolio.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        budgets: [ServiceCatalogClientTypes.BudgetDetail]? = nil,
        portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail? = nil,
        tagOptions: [ServiceCatalogClientTypes.TagOptionDetail]? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.budgets = budgets
        self.portfolioDetail = portfolioDetail
        self.tagOptions = tagOptions
        self.tags = tags
    }
}

extension ServiceCatalogClientTypes {

    public enum DescribePortfolioShareType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case organization
        case organizationalUnit
        case organizationMemberAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [DescribePortfolioShareType] {
            return [
                .account,
                .organization,
                .organizationalUnit,
                .organizationMemberAccount
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .organization: return "ORGANIZATION"
            case .organizationalUnit: return "ORGANIZATIONAL_UNIT"
            case .organizationMemberAccount: return "ORGANIZATION_MEMBER_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribePortfolioSharesInput: Swift.Sendable {
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The unique identifier of the portfolio for which shares will be retrieved.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The type of portfolio share to summarize. This field acts as a filter on the type of portfolio share, which can be one of the following: 1. ACCOUNT - Represents an external account to account share. 2. ORGANIZATION - Represents a share to an organization. This share is available to every account in the organization. 3. ORGANIZATIONAL_UNIT - Represents a share to an organizational unit. 4. ORGANIZATION_MEMBER_ACCOUNT - Represents a share to an account in the organization.
    /// This member is required.
    public var type: ServiceCatalogClientTypes.DescribePortfolioShareType?

    public init(
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        type: ServiceCatalogClientTypes.DescribePortfolioShareType? = nil
    )
    {
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
        self.type = type
    }
}

extension ServiceCatalogClientTypes {

    /// Information about the portfolio share.
    public struct PortfolioShareDetail: Swift.Sendable {
        /// Indicates whether the shared portfolio is imported by the recipient account. If the recipient is in an organization node, the share is automatically imported, and the field is always set to true.
        public var accepted: Swift.Bool
        /// The identifier of the recipient entity that received the portfolio share. The recipient entity can be one of the following: 1. An external account. 2. An organziation member account. 3. An organzational unit (OU). 4. The organization itself. (This shares with every account in the organization).
        public var principalId: Swift.String?
        /// Indicates if Principal sharing is enabled or disabled for the portfolio share.
        public var sharePrincipals: Swift.Bool
        /// Indicates whether TagOptions sharing is enabled or disabled for the portfolio share.
        public var shareTagOptions: Swift.Bool
        /// The type of the portfolio share.
        public var type: ServiceCatalogClientTypes.DescribePortfolioShareType?

        public init(
            accepted: Swift.Bool = false,
            principalId: Swift.String? = nil,
            sharePrincipals: Swift.Bool = false,
            shareTagOptions: Swift.Bool = false,
            type: ServiceCatalogClientTypes.DescribePortfolioShareType? = nil
        )
        {
            self.accepted = accepted
            self.principalId = principalId
            self.sharePrincipals = sharePrincipals
            self.shareTagOptions = shareTagOptions
            self.type = type
        }
    }
}

public struct DescribePortfolioSharesOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Summaries about each of the portfolio shares.
    public var portfolioShareDetails: [ServiceCatalogClientTypes.PortfolioShareDetail]?

    public init(
        nextPageToken: Swift.String? = nil,
        portfolioShareDetails: [ServiceCatalogClientTypes.PortfolioShareDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.portfolioShareDetails = portfolioShareDetails
    }
}

public struct DescribePortfolioShareStatusInput: Swift.Sendable {
    /// The token for the portfolio share operation. This token is returned either by CreatePortfolioShare or by DeletePortfolioShare.
    /// This member is required.
    public var portfolioShareToken: Swift.String?

    public init(
        portfolioShareToken: Swift.String? = nil
    )
    {
        self.portfolioShareToken = portfolioShareToken
    }
}

extension ServiceCatalogClientTypes {

    /// Errors that occurred during the portfolio share operation.
    public struct ShareError: Swift.Sendable {
        /// List of accounts impacted by the error.
        public var accounts: [Swift.String]?
        /// Error type that happened when processing the operation.
        public var error: Swift.String?
        /// Information about the error.
        public var message: Swift.String?

        public init(
            accounts: [Swift.String]? = nil,
            error: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.accounts = accounts
            self.error = error
            self.message = message
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Information about the portfolio share operation.
    public struct ShareDetails: Swift.Sendable {
        /// List of errors.
        public var shareErrors: [ServiceCatalogClientTypes.ShareError]?
        /// List of accounts for whom the operation succeeded.
        public var successfulShares: [Swift.String]?

        public init(
            shareErrors: [ServiceCatalogClientTypes.ShareError]? = nil,
            successfulShares: [Swift.String]? = nil
        )
        {
            self.shareErrors = shareErrors
            self.successfulShares = successfulShares
        }
    }
}

extension ServiceCatalogClientTypes {

    public enum ShareStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case completedWithErrors
        case error
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareStatus] {
            return [
                .completed,
                .completedWithErrors,
                .error,
                .inProgress,
                .notStarted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .error: return "ERROR"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribePortfolioShareStatusOutput: Swift.Sendable {
    /// Organization node identifier. It can be either account id, organizational unit id or organization id.
    public var organizationNodeValue: Swift.String?
    /// The portfolio identifier.
    public var portfolioId: Swift.String?
    /// The token for the portfolio share operation. For example, share-6v24abcdefghi.
    public var portfolioShareToken: Swift.String?
    /// Information about the portfolio share operation.
    public var shareDetails: ServiceCatalogClientTypes.ShareDetails?
    /// Status of the portfolio share operation.
    public var status: ServiceCatalogClientTypes.ShareStatus?

    public init(
        organizationNodeValue: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        portfolioShareToken: Swift.String? = nil,
        shareDetails: ServiceCatalogClientTypes.ShareDetails? = nil,
        status: ServiceCatalogClientTypes.ShareStatus? = nil
    )
    {
        self.organizationNodeValue = organizationNodeValue
        self.portfolioId = portfolioId
        self.portfolioShareToken = portfolioShareToken
        self.shareDetails = shareDetails
        self.status = status
    }
}

public struct DescribeProductInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The product identifier.
    public var id: Swift.String?
    /// The product name.
    public var name: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
        self.name = name
    }
}

extension ServiceCatalogClientTypes {

    /// A launch path object.
    public struct LaunchPath: Swift.Sendable {
        /// The identifier of the launch path.
        public var id: Swift.String?
        /// The name of the launch path.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a provisioning artifact. A provisioning artifact is also known as a product version.
    public struct ProvisioningArtifact: Swift.Sendable {
        /// The UTC time stamp of the creation time.
        public var createdTime: Foundation.Date?
        /// The description of the provisioning artifact.
        public var description: Swift.String?
        /// Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.
        public var guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance?
        /// The identifier of the provisioning artifact.
        public var id: Swift.String?
        /// The name of the provisioning artifact.
        public var name: Swift.String?

        public init(
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.description = description
            self.guidance = guidance
            self.id = id
            self.name = name
        }
    }
}

public struct DescribeProductOutput: Swift.Sendable {
    /// Information about the associated budgets.
    public var budgets: [ServiceCatalogClientTypes.BudgetDetail]?
    /// Information about the associated launch paths.
    public var launchPaths: [ServiceCatalogClientTypes.LaunchPath]?
    /// Summary information about the product view.
    public var productViewSummary: ServiceCatalogClientTypes.ProductViewSummary?
    /// Information about the provisioning artifacts for the specified product.
    public var provisioningArtifacts: [ServiceCatalogClientTypes.ProvisioningArtifact]?

    public init(
        budgets: [ServiceCatalogClientTypes.BudgetDetail]? = nil,
        launchPaths: [ServiceCatalogClientTypes.LaunchPath]? = nil,
        productViewSummary: ServiceCatalogClientTypes.ProductViewSummary? = nil,
        provisioningArtifacts: [ServiceCatalogClientTypes.ProvisioningArtifact]? = nil
    )
    {
        self.budgets = budgets
        self.launchPaths = launchPaths
        self.productViewSummary = productViewSummary
        self.provisioningArtifacts = provisioningArtifacts
    }
}

public struct DescribeProductAsAdminInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The product identifier.
    public var id: Swift.String?
    /// The product name.
    public var name: Swift.String?
    /// The unique identifier of the shared portfolio that the specified product is associated with. You can provide this parameter to retrieve the shared TagOptions associated with the product. If this parameter is provided and if TagOptions sharing is enabled in the portfolio share, the API returns both local and shared TagOptions associated with the product. Otherwise only local TagOptions will be returned.
    public var sourcePortfolioId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sourcePortfolioId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
        self.name = name
        self.sourcePortfolioId = sourcePortfolioId
    }
}

extension ServiceCatalogClientTypes {

    /// Summary information about a provisioning artifact (also known as a version) for a product.
    public struct ProvisioningArtifactSummary: Swift.Sendable {
        /// The UTC time stamp of the creation time.
        public var createdTime: Foundation.Date?
        /// The description of the provisioning artifact.
        public var description: Swift.String?
        /// The identifier of the provisioning artifact.
        public var id: Swift.String?
        /// The name of the provisioning artifact.
        public var name: Swift.String?
        /// The metadata for the provisioning artifact. This is used with Amazon Web Services Marketplace products.
        public var provisioningArtifactMetadata: [Swift.String: Swift.String]?

        public init(
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            provisioningArtifactMetadata: [Swift.String: Swift.String]? = nil
        )
        {
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.name = name
            self.provisioningArtifactMetadata = provisioningArtifactMetadata
        }
    }
}

public struct DescribeProductAsAdminOutput: Swift.Sendable {
    /// Information about the associated budgets.
    public var budgets: [ServiceCatalogClientTypes.BudgetDetail]?
    /// Information about the product view.
    public var productViewDetail: ServiceCatalogClientTypes.ProductViewDetail?
    /// Information about the provisioning artifacts (also known as versions) for the specified product.
    public var provisioningArtifactSummaries: [ServiceCatalogClientTypes.ProvisioningArtifactSummary]?
    /// Information about the TagOptions associated with the product.
    public var tagOptions: [ServiceCatalogClientTypes.TagOptionDetail]?
    /// Information about the tags associated with the product.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        budgets: [ServiceCatalogClientTypes.BudgetDetail]? = nil,
        productViewDetail: ServiceCatalogClientTypes.ProductViewDetail? = nil,
        provisioningArtifactSummaries: [ServiceCatalogClientTypes.ProvisioningArtifactSummary]? = nil,
        tagOptions: [ServiceCatalogClientTypes.TagOptionDetail]? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.budgets = budgets
        self.productViewDetail = productViewDetail
        self.provisioningArtifactSummaries = provisioningArtifactSummaries
        self.tagOptions = tagOptions
        self.tags = tags
    }
}

public struct DescribeProductViewInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The product view identifier.
    /// This member is required.
    public var id: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

public struct DescribeProductViewOutput: Swift.Sendable {
    /// Summary information about the product.
    public var productViewSummary: ServiceCatalogClientTypes.ProductViewSummary?
    /// Information about the provisioning artifacts for the product.
    public var provisioningArtifacts: [ServiceCatalogClientTypes.ProvisioningArtifact]?

    public init(
        productViewSummary: ServiceCatalogClientTypes.ProductViewSummary? = nil,
        provisioningArtifacts: [ServiceCatalogClientTypes.ProvisioningArtifact]? = nil
    )
    {
        self.productViewSummary = productViewSummary
        self.provisioningArtifacts = provisioningArtifacts
    }
}

/// DescribeProvisionedProductAPI input structure. AcceptLanguage - [Optional] The language code for localization. Id - [Optional] The provisioned product identifier. Name - [Optional] Another provisioned product identifier. Customers must provide either Id or Name.
public struct DescribeProvisionedProductInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The provisioned product identifier. You must provide the name or ID, but not both. If you do not provide a name or ID, or you provide both name and ID, an InvalidParametersException will occur.
    public var id: Swift.String?
    /// The name of the provisioned product. You must provide the name or ID, but not both. If you do not provide a name or ID, or you provide both name and ID, an InvalidParametersException will occur.
    public var name: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
        self.name = name
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a CloudWatch dashboard.
    public struct CloudWatchDashboard: Swift.Sendable {
        /// The name of the CloudWatch dashboard.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }
}

extension ServiceCatalogClientTypes {

    public enum ProvisionedProductStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case error
        case planInProgress
        case tainted
        case underChange
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedProductStatus] {
            return [
                .available,
                .error,
                .planInProgress,
                .tainted,
                .underChange
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .error: return "ERROR"
            case .planInProgress: return "PLAN_IN_PROGRESS"
            case .tainted: return "TAINTED"
            case .underChange: return "UNDER_CHANGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a provisioned product.
    public struct ProvisionedProductDetail: Swift.Sendable {
        /// The ARN of the provisioned product.
        public var arn: Swift.String?
        /// The UTC time stamp of the creation time.
        public var createdTime: Foundation.Date?
        /// The identifier of the provisioned product.
        public var id: Swift.String?
        /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
        public var idempotencyToken: Swift.String?
        /// The record identifier of the last request performed on this provisioned product of the following types:
        ///
        /// * ProvisionProduct
        ///
        /// * UpdateProvisionedProduct
        ///
        /// * ExecuteProvisionedProductPlan
        ///
        /// * TerminateProvisionedProduct
        public var lastProvisioningRecordId: Swift.String?
        /// The record identifier of the last request performed on this provisioned product.
        public var lastRecordId: Swift.String?
        /// The record identifier of the last successful request performed on this provisioned product of the following types:
        ///
        /// * ProvisionProduct
        ///
        /// * UpdateProvisionedProduct
        ///
        /// * ExecuteProvisionedProductPlan
        ///
        /// * TerminateProvisionedProduct
        public var lastSuccessfulProvisioningRecordId: Swift.String?
        /// The ARN of the launch role associated with the provisioned product.
        public var launchRoleArn: Swift.String?
        /// The user-friendly name of the provisioned product.
        public var name: Swift.String?
        /// The product identifier. For example, prod-abcdzk7xy33qa.
        public var productId: Swift.String?
        /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
        public var provisioningArtifactId: Swift.String?
        /// The current status of the provisioned product.
        ///
        /// * AVAILABLE - Stable state, ready to perform any operation. The most recent operation succeeded and completed.
        ///
        /// * UNDER_CHANGE - Transitive state. Operations performed might not have valid results. Wait for an AVAILABLE status before performing operations.
        ///
        /// * TAINTED - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.
        ///
        /// * ERROR - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.
        ///
        /// * PLAN_IN_PROGRESS - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an AVAILABLE status before performing operations.
        public var status: ServiceCatalogClientTypes.ProvisionedProductStatus?
        /// The current status message of the provisioned product.
        public var statusMessage: Swift.String?
        /// The type of provisioned product. The supported values are CFN_STACK, CFN_STACKSET, TERRAFORM_OPEN_SOURCE, TERRAFORM_CLOUD, and EXTERNAL.
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            idempotencyToken: Swift.String? = nil,
            lastProvisioningRecordId: Swift.String? = nil,
            lastRecordId: Swift.String? = nil,
            lastSuccessfulProvisioningRecordId: Swift.String? = nil,
            launchRoleArn: Swift.String? = nil,
            name: Swift.String? = nil,
            productId: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil,
            status: ServiceCatalogClientTypes.ProvisionedProductStatus? = nil,
            statusMessage: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.idempotencyToken = idempotencyToken
            self.lastProvisioningRecordId = lastProvisioningRecordId
            self.lastRecordId = lastRecordId
            self.lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordId
            self.launchRoleArn = launchRoleArn
            self.name = name
            self.productId = productId
            self.provisioningArtifactId = provisioningArtifactId
            self.status = status
            self.statusMessage = statusMessage
            self.type = type
        }
    }
}

public struct DescribeProvisionedProductOutput: Swift.Sendable {
    /// Any CloudWatch dashboards that were created when provisioning the product.
    public var cloudWatchDashboards: [ServiceCatalogClientTypes.CloudWatchDashboard]?
    /// Information about the provisioned product.
    public var provisionedProductDetail: ServiceCatalogClientTypes.ProvisionedProductDetail?

    public init(
        cloudWatchDashboards: [ServiceCatalogClientTypes.CloudWatchDashboard]? = nil,
        provisionedProductDetail: ServiceCatalogClientTypes.ProvisionedProductDetail? = nil
    )
    {
        self.cloudWatchDashboards = cloudWatchDashboards
        self.provisionedProductDetail = provisionedProductDetail
    }
}

public struct DescribeProvisionedProductPlanInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The plan identifier.
    /// This member is required.
    public var planId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        planId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.planId = planId
    }
}

extension ServiceCatalogClientTypes {

    public enum ProvisionedProductPlanStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createFailed
        case createInProgress
        case createSuccess
        case executeFailed
        case executeInProgress
        case executeSuccess
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedProductPlanStatus] {
            return [
                .createFailed,
                .createInProgress,
                .createSuccess,
                .executeFailed,
                .executeInProgress,
                .executeSuccess
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .createSuccess: return "CREATE_SUCCESS"
            case .executeFailed: return "EXECUTE_FAILED"
            case .executeInProgress: return "EXECUTE_IN_PROGRESS"
            case .executeSuccess: return "EXECUTE_SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a plan.
    public struct ProvisionedProductPlanDetails: Swift.Sendable {
        /// The UTC time stamp of the creation time.
        public var createdTime: Foundation.Date?
        /// Passed to CloudFormation. The SNS topic ARNs to which to publish stack-related events.
        public var notificationArns: [Swift.String]?
        /// The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use [ListLaunchPaths].
        public var pathId: Swift.String?
        /// The plan identifier.
        public var planId: Swift.String?
        /// The name of the plan.
        public var planName: Swift.String?
        /// The plan type.
        public var planType: ServiceCatalogClientTypes.ProvisionedProductPlanType?
        /// The product identifier.
        public var productId: Swift.String?
        /// The product identifier.
        public var provisionProductId: Swift.String?
        /// The user-friendly name of the provisioned product.
        public var provisionProductName: Swift.String?
        /// The identifier of the provisioning artifact.
        public var provisioningArtifactId: Swift.String?
        /// Parameters specified by the administrator that are required for provisioning the product.
        public var provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]?
        /// The status.
        public var status: ServiceCatalogClientTypes.ProvisionedProductPlanStatus?
        /// The status message.
        public var statusMessage: Swift.String?
        /// One or more tags.
        public var tags: [ServiceCatalogClientTypes.Tag]?
        /// The UTC time stamp when the plan was last updated.
        public var updatedTime: Foundation.Date?

        public init(
            createdTime: Foundation.Date? = nil,
            notificationArns: [Swift.String]? = nil,
            pathId: Swift.String? = nil,
            planId: Swift.String? = nil,
            planName: Swift.String? = nil,
            planType: ServiceCatalogClientTypes.ProvisionedProductPlanType? = nil,
            productId: Swift.String? = nil,
            provisionProductId: Swift.String? = nil,
            provisionProductName: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil,
            provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]? = nil,
            status: ServiceCatalogClientTypes.ProvisionedProductPlanStatus? = nil,
            statusMessage: Swift.String? = nil,
            tags: [ServiceCatalogClientTypes.Tag]? = nil,
            updatedTime: Foundation.Date? = nil
        )
        {
            self.createdTime = createdTime
            self.notificationArns = notificationArns
            self.pathId = pathId
            self.planId = planId
            self.planName = planName
            self.planType = planType
            self.productId = productId
            self.provisionProductId = provisionProductId
            self.provisionProductName = provisionProductName
            self.provisioningArtifactId = provisioningArtifactId
            self.provisioningParameters = provisioningParameters
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
            self.updatedTime = updatedTime
        }
    }
}

extension ServiceCatalogClientTypes {

    public enum ChangeAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case add
        case modify
        case remove
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeAction] {
            return [
                .add,
                .modify,
                .remove
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .modify: return "MODIFY"
            case .remove: return "REMOVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    public enum EvaluationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `dynamic`
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationType] {
            return [
                .dynamic,
                .static
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dynamic: return "DYNAMIC"
            case .static: return "STATIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    public enum ResourceAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creationpolicy
        case deletionpolicy
        case metadata
        case properties
        case tags
        case updatepolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceAttribute] {
            return [
                .creationpolicy,
                .deletionpolicy,
                .metadata,
                .properties,
                .tags,
                .updatepolicy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creationpolicy: return "CREATIONPOLICY"
            case .deletionpolicy: return "DELETIONPOLICY"
            case .metadata: return "METADATA"
            case .properties: return "PROPERTIES"
            case .tags: return "TAGS"
            case .updatepolicy: return "UPDATEPOLICY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    public enum RequiresRecreation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case always
        case conditionally
        case never
        case sdkUnknown(Swift.String)

        public static var allCases: [RequiresRecreation] {
            return [
                .always,
                .conditionally,
                .never
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .always: return "ALWAYS"
            case .conditionally: return "CONDITIONALLY"
            case .never: return "NEVER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a change to a resource attribute.
    public struct ResourceTargetDefinition: Swift.Sendable {
        /// The attribute to be changed.
        public var attribute: ServiceCatalogClientTypes.ResourceAttribute?
        /// If the attribute is Properties, the value is the name of the property. Otherwise, the value is null.
        public var name: Swift.String?
        /// If the attribute is Properties, indicates whether a change to this property causes the resource to be re-created.
        public var requiresRecreation: ServiceCatalogClientTypes.RequiresRecreation?

        public init(
            attribute: ServiceCatalogClientTypes.ResourceAttribute? = nil,
            name: Swift.String? = nil,
            requiresRecreation: ServiceCatalogClientTypes.RequiresRecreation? = nil
        )
        {
            self.attribute = attribute
            self.name = name
            self.requiresRecreation = requiresRecreation
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a change to a resource attribute.
    public struct ResourceChangeDetail: Swift.Sendable {
        /// The ID of the entity that caused the change.
        public var causingEntity: Swift.String?
        /// For static evaluations, the value of the resource attribute will change and the new value is known. For dynamic evaluations, the value might change, and any new value will be determined when the plan is updated.
        public var evaluation: ServiceCatalogClientTypes.EvaluationType?
        /// Information about the resource attribute to be modified.
        public var target: ServiceCatalogClientTypes.ResourceTargetDefinition?

        public init(
            causingEntity: Swift.String? = nil,
            evaluation: ServiceCatalogClientTypes.EvaluationType? = nil,
            target: ServiceCatalogClientTypes.ResourceTargetDefinition? = nil
        )
        {
            self.causingEntity = causingEntity
            self.evaluation = evaluation
            self.target = target
        }
    }
}

extension ServiceCatalogClientTypes {

    public enum Replacement: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case conditional
        case `false`
        case `true`
        case sdkUnknown(Swift.String)

        public static var allCases: [Replacement] {
            return [
                .conditional,
                .false,
                .true
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .conditional: return "CONDITIONAL"
            case .false: return "FALSE"
            case .true: return "TRUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a resource change that will occur when a plan is executed.
    public struct ResourceChange: Swift.Sendable {
        /// The change action.
        public var action: ServiceCatalogClientTypes.ChangeAction?
        /// Information about the resource changes.
        public var details: [ServiceCatalogClientTypes.ResourceChangeDetail]?
        /// The ID of the resource, as defined in the CloudFormation template.
        public var logicalResourceId: Swift.String?
        /// The ID of the resource, if it was already created.
        public var physicalResourceId: Swift.String?
        /// If the change type is Modify, indicates whether the existing resource is deleted and replaced with a new one.
        public var replacement: ServiceCatalogClientTypes.Replacement?
        /// The type of resource.
        public var resourceType: Swift.String?
        /// The change scope.
        public var scope: [ServiceCatalogClientTypes.ResourceAttribute]?

        public init(
            action: ServiceCatalogClientTypes.ChangeAction? = nil,
            details: [ServiceCatalogClientTypes.ResourceChangeDetail]? = nil,
            logicalResourceId: Swift.String? = nil,
            physicalResourceId: Swift.String? = nil,
            replacement: ServiceCatalogClientTypes.Replacement? = nil,
            resourceType: Swift.String? = nil,
            scope: [ServiceCatalogClientTypes.ResourceAttribute]? = nil
        )
        {
            self.action = action
            self.details = details
            self.logicalResourceId = logicalResourceId
            self.physicalResourceId = physicalResourceId
            self.replacement = replacement
            self.resourceType = resourceType
            self.scope = scope
        }
    }
}

public struct DescribeProvisionedProductPlanOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the plan.
    public var provisionedProductPlanDetails: ServiceCatalogClientTypes.ProvisionedProductPlanDetails?
    /// Information about the resource changes that will occur when the plan is executed.
    public var resourceChanges: [ServiceCatalogClientTypes.ResourceChange]?

    public init(
        nextPageToken: Swift.String? = nil,
        provisionedProductPlanDetails: ServiceCatalogClientTypes.ProvisionedProductPlanDetails? = nil,
        resourceChanges: [ServiceCatalogClientTypes.ResourceChange]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisionedProductPlanDetails = provisionedProductPlanDetails
        self.resourceChanges = resourceChanges
    }
}

public struct DescribeProvisioningArtifactInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// Indicates if the API call response does or does not include additional details about the provisioning parameters.
    public var includeProvisioningArtifactParameters: Swift.Bool?
    /// The product identifier.
    public var productId: Swift.String?
    /// The product name.
    public var productName: Swift.String?
    /// The identifier of the provisioning artifact.
    public var provisioningArtifactId: Swift.String?
    /// The provisioning artifact name.
    public var provisioningArtifactName: Swift.String?
    /// Indicates whether a verbose level of detail is enabled.
    public var verbose: Swift.Bool?

    public init(
        acceptLanguage: Swift.String? = nil,
        includeProvisioningArtifactParameters: Swift.Bool? = false,
        productId: Swift.String? = nil,
        productName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        provisioningArtifactName: Swift.String? = nil,
        verbose: Swift.Bool? = false
    )
    {
        self.acceptLanguage = acceptLanguage
        self.includeProvisioningArtifactParameters = includeProvisioningArtifactParameters
        self.productId = productId
        self.productName = productName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningArtifactName = provisioningArtifactName
        self.verbose = verbose
    }
}

extension ServiceCatalogClientTypes {

    /// The constraints that the administrator has put on the parameter.
    public struct ParameterConstraints: Swift.Sendable {
        /// A regular expression that represents the patterns that allow for String types. The pattern must match the entire parameter value provided.
        public var allowedPattern: Swift.String?
        /// The values that the administrator has allowed for the parameter.
        public var allowedValues: [Swift.String]?
        /// A string that explains a constraint when the constraint is violated. For example, without a constraint description, a parameter that has an allowed pattern of [A-Za-z0-9]+ displays the following error message when the user specifies an invalid value: Malformed input-Parameter MyParameter must match pattern [A-Za-z0-9]+ By adding a constraint description, such as must only contain letters (uppercase and lowercase) and numbers, you can display the following customized error message: Malformed input-Parameter MyParameter must only contain uppercase and lowercase letters and numbers.
        public var constraintDescription: Swift.String?
        /// An integer value that determines the largest number of characters you want to allow for String types.
        public var maxLength: Swift.String?
        /// A numeric value that determines the largest numeric value you want to allow for Number types.
        public var maxValue: Swift.String?
        /// An integer value that determines the smallest number of characters you want to allow for String types.
        public var minLength: Swift.String?
        /// A numeric value that determines the smallest numeric value you want to allow for Number types.
        public var minValue: Swift.String?

        public init(
            allowedPattern: Swift.String? = nil,
            allowedValues: [Swift.String]? = nil,
            constraintDescription: Swift.String? = nil,
            maxLength: Swift.String? = nil,
            maxValue: Swift.String? = nil,
            minLength: Swift.String? = nil,
            minValue: Swift.String? = nil
        )
        {
            self.allowedPattern = allowedPattern
            self.allowedValues = allowedValues
            self.constraintDescription = constraintDescription
            self.maxLength = maxLength
            self.maxValue = maxValue
            self.minLength = minLength
            self.minValue = minValue
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a parameter used to provision a product.
    public struct ProvisioningArtifactParameter: Swift.Sendable {
        /// The default value.
        public var defaultValue: Swift.String?
        /// The description of the parameter.
        public var description: Swift.String?
        /// If this value is true, the value for this parameter is obfuscated from view when the parameter is retrieved. This parameter is used to hide sensitive information.
        public var isNoEcho: Swift.Bool
        /// Constraints that the administrator has put on a parameter.
        public var parameterConstraints: ServiceCatalogClientTypes.ParameterConstraints?
        /// The parameter key.
        public var parameterKey: Swift.String?
        /// The parameter type.
        public var parameterType: Swift.String?

        public init(
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            isNoEcho: Swift.Bool = false,
            parameterConstraints: ServiceCatalogClientTypes.ParameterConstraints? = nil,
            parameterKey: Swift.String? = nil,
            parameterType: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.isNoEcho = isNoEcho
            self.parameterConstraints = parameterConstraints
            self.parameterKey = parameterKey
            self.parameterType = parameterType
        }
    }
}

public struct DescribeProvisioningArtifactOutput: Swift.Sendable {
    /// The URL of the CloudFormation template in Amazon S3 or GitHub in JSON format.
    public var info: [Swift.String: Swift.String]?
    /// Information about the provisioning artifact.
    public var provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    /// Information about the parameters used to provision the product.
    public var provisioningArtifactParameters: [ServiceCatalogClientTypes.ProvisioningArtifactParameter]?
    /// The status of the current request.
    public var status: ServiceCatalogClientTypes.Status?

    public init(
        info: [Swift.String: Swift.String]? = nil,
        provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail? = nil,
        provisioningArtifactParameters: [ServiceCatalogClientTypes.ProvisioningArtifactParameter]? = nil,
        status: ServiceCatalogClientTypes.Status? = nil
    )
    {
        self.info = info
        self.provisioningArtifactDetail = provisioningArtifactDetail
        self.provisioningArtifactParameters = provisioningArtifactParameters
        self.status = status
    }
}

public struct DescribeProvisioningParametersInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use [ListLaunchPaths]. You must provide the name or ID, but not both.
    public var pathId: Swift.String?
    /// The name of the path. You must provide the name or ID, but not both.
    public var pathName: Swift.String?
    /// The product identifier. You must provide the product name or ID, but not both.
    public var productId: Swift.String?
    /// The name of the product. You must provide the name or ID, but not both.
    public var productName: Swift.String?
    /// The identifier of the provisioning artifact. You must provide the name or ID, but not both.
    public var provisioningArtifactId: Swift.String?
    /// The name of the provisioning artifact. You must provide the name or ID, but not both.
    public var provisioningArtifactName: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pathId: Swift.String? = nil,
        pathName: Swift.String? = nil,
        productId: Swift.String? = nil,
        productName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        provisioningArtifactName: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pathId = pathId
        self.pathName = pathName
        self.productId = productId
        self.productName = productName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningArtifactName = provisioningArtifactName
    }
}

extension ServiceCatalogClientTypes {

    /// Summary information about a constraint.
    public struct ConstraintSummary: Swift.Sendable {
        /// The description of the constraint.
        public var description: Swift.String?
        /// The type of constraint.
        ///
        /// * LAUNCH
        ///
        /// * NOTIFICATION
        ///
        /// * STACKSET
        ///
        /// * TEMPLATE
        public var type: Swift.String?

        public init(
            description: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.type = type
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Provisioning artifact output.
    public struct ProvisioningArtifactOutput: Swift.Sendable {
        /// Description of the provisioning artifact output key.
        public var description: Swift.String?
        /// The provisioning artifact output key.
        public var key: Swift.String?

        public init(
            description: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.description = description
            self.key = key
        }
    }
}

extension ServiceCatalogClientTypes {

    /// The user-defined preferences that will be applied during product provisioning, unless overridden by ProvisioningPreferences or UpdateProvisioningPreferences. For more information on maximum concurrent accounts and failure tolerance, see [Stack set operation options](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-concepts.html#stackset-ops-options) in the CloudFormation User Guide.
    public struct ProvisioningArtifactPreferences: Swift.Sendable {
        /// One or more Amazon Web Services accounts where stack instances are deployed from the stack set. These accounts can be scoped in ProvisioningPreferences$StackSetAccounts and UpdateProvisioningPreferences$StackSetAccounts. Applicable only to a CFN_STACKSET provisioned product type.
        public var stackSetAccounts: [Swift.String]?
        /// One or more Amazon Web Services Regions where stack instances are deployed from the stack set. These Regions can be scoped in ProvisioningPreferences$StackSetRegions and UpdateProvisioningPreferences$StackSetRegions. Applicable only to a CFN_STACKSET provisioned product type.
        public var stackSetRegions: [Swift.String]?

        public init(
            stackSetAccounts: [Swift.String]? = nil,
            stackSetRegions: [Swift.String]? = nil
        )
        {
            self.stackSetAccounts = stackSetAccounts
            self.stackSetRegions = stackSetRegions
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Summary information about a TagOption.
    public struct TagOptionSummary: Swift.Sendable {
        /// The TagOption key.
        public var key: Swift.String?
        /// The TagOption value.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Additional information provided by the administrator.
    public struct UsageInstruction: Swift.Sendable {
        /// The usage instruction type for the value.
        public var type: Swift.String?
        /// The usage instruction value for this type.
        public var value: Swift.String?

        public init(
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }
}

public struct DescribeProvisioningParametersOutput: Swift.Sendable {
    /// Information about the constraints used to provision the product.
    public var constraintSummaries: [ServiceCatalogClientTypes.ConstraintSummary]?
    /// A list of the keys and descriptions of the outputs. These outputs can be referenced from a provisioned product launched from this provisioning artifact.
    public var provisioningArtifactOutputKeys: [ServiceCatalogClientTypes.ProvisioningArtifactOutput]?
    /// The output of the provisioning artifact.
    @available(*, deprecated, message: "This property is deprecated and returns the Id and Description of the Provisioning Artifact. Use ProvisioningArtifactOutputKeys instead to get the Keys and Descriptions of the outputs.")
    public var provisioningArtifactOutputs: [ServiceCatalogClientTypes.ProvisioningArtifactOutput]?
    /// Information about the parameters used to provision the product.
    public var provisioningArtifactParameters: [ServiceCatalogClientTypes.ProvisioningArtifactParameter]?
    /// An object that contains information about preferences, such as Regions and accounts, for the provisioning artifact.
    public var provisioningArtifactPreferences: ServiceCatalogClientTypes.ProvisioningArtifactPreferences?
    /// Information about the TagOptions associated with the resource.
    public var tagOptions: [ServiceCatalogClientTypes.TagOptionSummary]?
    /// Any additional metadata specifically related to the provisioning of the product. For example, see the Version field of the CloudFormation template.
    public var usageInstructions: [ServiceCatalogClientTypes.UsageInstruction]?

    public init(
        constraintSummaries: [ServiceCatalogClientTypes.ConstraintSummary]? = nil,
        provisioningArtifactOutputKeys: [ServiceCatalogClientTypes.ProvisioningArtifactOutput]? = nil,
        provisioningArtifactOutputs: [ServiceCatalogClientTypes.ProvisioningArtifactOutput]? = nil,
        provisioningArtifactParameters: [ServiceCatalogClientTypes.ProvisioningArtifactParameter]? = nil,
        provisioningArtifactPreferences: ServiceCatalogClientTypes.ProvisioningArtifactPreferences? = nil,
        tagOptions: [ServiceCatalogClientTypes.TagOptionSummary]? = nil,
        usageInstructions: [ServiceCatalogClientTypes.UsageInstruction]? = nil
    )
    {
        self.constraintSummaries = constraintSummaries
        self.provisioningArtifactOutputKeys = provisioningArtifactOutputKeys
        self.provisioningArtifactOutputs = provisioningArtifactOutputs
        self.provisioningArtifactParameters = provisioningArtifactParameters
        self.provisioningArtifactPreferences = provisioningArtifactPreferences
        self.tagOptions = tagOptions
        self.usageInstructions = usageInstructions
    }
}

public struct DescribeRecordInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The record identifier of the provisioned product. This identifier is returned by the request operation.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

extension ServiceCatalogClientTypes {

    /// The error code and description resulting from an operation.
    public struct RecordError: Swift.Sendable {
        /// The numeric value of the error.
        public var code: Swift.String?
        /// The description of the error.
        public var description: Swift.String?

        public init(
            code: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.code = code
            self.description = description
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a tag, which is a key-value pair.
    public struct RecordTag: Swift.Sendable {
        /// The key for this tag.
        public var key: Swift.String?
        /// The value for this tag.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension ServiceCatalogClientTypes {

    public enum RecordStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case failed
        case inProgress
        case inProgressInError
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordStatus] {
            return [
                .created,
                .failed,
                .inProgress,
                .inProgressInError,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .inProgressInError: return "IN_PROGRESS_IN_ERROR"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a request operation.
    public struct RecordDetail: Swift.Sendable {
        /// The UTC time stamp of the creation time.
        public var createdTime: Foundation.Date?
        /// The ARN of the launch role associated with the provisioned product.
        public var launchRoleArn: Swift.String?
        /// The path identifier.
        public var pathId: Swift.String?
        /// The product identifier.
        public var productId: Swift.String?
        /// The identifier of the provisioned product.
        public var provisionedProductId: Swift.String?
        /// The user-friendly name of the provisioned product.
        public var provisionedProductName: Swift.String?
        /// The type of provisioned product. The supported values are CFN_STACK, CFN_STACKSET, TERRAFORM_OPEN_SOURCE, TERRAFORM_CLOUD, and EXTERNAL.
        public var provisionedProductType: Swift.String?
        /// The identifier of the provisioning artifact.
        public var provisioningArtifactId: Swift.String?
        /// The errors that occurred.
        public var recordErrors: [ServiceCatalogClientTypes.RecordError]?
        /// The identifier of the record.
        public var recordId: Swift.String?
        /// One or more tags.
        public var recordTags: [ServiceCatalogClientTypes.RecordTag]?
        /// The record type.
        ///
        /// * PROVISION_PRODUCT
        ///
        /// * UPDATE_PROVISIONED_PRODUCT
        ///
        /// * TERMINATE_PROVISIONED_PRODUCT
        public var recordType: Swift.String?
        /// The status of the provisioned product.
        ///
        /// * CREATED - The request was created but the operation has not started.
        ///
        /// * IN_PROGRESS - The requested operation is in progress.
        ///
        /// * IN_PROGRESS_IN_ERROR - The provisioned product is under change but the requested operation failed and some remediation is occurring. For example, a rollback.
        ///
        /// * SUCCEEDED - The requested operation has successfully completed.
        ///
        /// * FAILED - The requested operation has unsuccessfully completed. Investigate using the error messages returned.
        public var status: ServiceCatalogClientTypes.RecordStatus?
        /// The time when the record was last updated.
        public var updatedTime: Foundation.Date?

        public init(
            createdTime: Foundation.Date? = nil,
            launchRoleArn: Swift.String? = nil,
            pathId: Swift.String? = nil,
            productId: Swift.String? = nil,
            provisionedProductId: Swift.String? = nil,
            provisionedProductName: Swift.String? = nil,
            provisionedProductType: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil,
            recordErrors: [ServiceCatalogClientTypes.RecordError]? = nil,
            recordId: Swift.String? = nil,
            recordTags: [ServiceCatalogClientTypes.RecordTag]? = nil,
            recordType: Swift.String? = nil,
            status: ServiceCatalogClientTypes.RecordStatus? = nil,
            updatedTime: Foundation.Date? = nil
        )
        {
            self.createdTime = createdTime
            self.launchRoleArn = launchRoleArn
            self.pathId = pathId
            self.productId = productId
            self.provisionedProductId = provisionedProductId
            self.provisionedProductName = provisionedProductName
            self.provisionedProductType = provisionedProductType
            self.provisioningArtifactId = provisioningArtifactId
            self.recordErrors = recordErrors
            self.recordId = recordId
            self.recordTags = recordTags
            self.recordType = recordType
            self.status = status
            self.updatedTime = updatedTime
        }
    }
}

extension ServiceCatalogClientTypes {

    /// The output for the product created as the result of a request. For example, the output for a CloudFormation-backed product that creates an S3 bucket would include the S3 bucket URL.
    public struct RecordOutput: Swift.Sendable {
        /// The description of the output.
        public var description: Swift.String?
        /// The output key.
        public var outputKey: Swift.String?
        /// The output value.
        public var outputValue: Swift.String?

        public init(
            description: Swift.String? = nil,
            outputKey: Swift.String? = nil,
            outputValue: Swift.String? = nil
        )
        {
            self.description = description
            self.outputKey = outputKey
            self.outputValue = outputValue
        }
    }
}

public struct DescribeRecordOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the product.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?
    /// Information about the product created as the result of a request. For example, the output for a CloudFormation-backed product that creates an S3 bucket would include the S3 bucket URL.
    public var recordOutputs: [ServiceCatalogClientTypes.RecordOutput]?

    public init(
        nextPageToken: Swift.String? = nil,
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil,
        recordOutputs: [ServiceCatalogClientTypes.RecordOutput]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.recordDetail = recordDetail
        self.recordOutputs = recordOutputs
    }
}

public struct DescribeServiceActionInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The self-service action identifier.
    /// This member is required.
    public var id: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

public struct DescribeServiceActionOutput: Swift.Sendable {
    /// Detailed information about the self-service action.
    public var serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail?

    public init(
        serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail? = nil
    )
    {
        self.serviceActionDetail = serviceActionDetail
    }
}

public struct DescribeServiceActionExecutionParametersInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The identifier of the provisioned product.
    /// This member is required.
    public var provisionedProductId: Swift.String?
    /// The self-service action identifier.
    /// This member is required.
    public var serviceActionId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        provisionedProductId: Swift.String? = nil,
        serviceActionId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.provisionedProductId = provisionedProductId
        self.serviceActionId = serviceActionId
    }
}

extension ServiceCatalogClientTypes {

    /// Details of an execution parameter value that is passed to a self-service action when executed on a provisioned product.
    public struct ExecutionParameter: Swift.Sendable {
        /// The default values for the execution parameter.
        public var defaultValues: [Swift.String]?
        /// The name of the execution parameter.
        public var name: Swift.String?
        /// The execution parameter type.
        public var type: Swift.String?

        public init(
            defaultValues: [Swift.String]? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.defaultValues = defaultValues
            self.name = name
            self.type = type
        }
    }
}

public struct DescribeServiceActionExecutionParametersOutput: Swift.Sendable {
    /// The parameters of the self-service action.
    public var serviceActionParameters: [ServiceCatalogClientTypes.ExecutionParameter]?

    public init(
        serviceActionParameters: [ServiceCatalogClientTypes.ExecutionParameter]? = nil
    )
    {
        self.serviceActionParameters = serviceActionParameters
    }
}

public struct DescribeTagOptionInput: Swift.Sendable {
    /// The TagOption identifier.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DescribeTagOptionOutput: Swift.Sendable {
    /// Information about the TagOption.
    public var tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail?

    public init(
        tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail? = nil
    )
    {
        self.tagOptionDetail = tagOptionDetail
    }
}

public struct DisableAWSOrganizationsAccessInput: Swift.Sendable {

    public init() { }
}

public struct DisableAWSOrganizationsAccessOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateBudgetFromResourceInput: Swift.Sendable {
    /// The name of the budget you want to disassociate.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The resource identifier you want to disassociate from. Either a portfolio-id or a product-id.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        budgetName: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.budgetName = budgetName
        self.resourceId = resourceId
    }
}

public struct DisassociateBudgetFromResourceOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociatePrincipalFromPortfolioInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The ARN of the principal (user, role, or group). This field allows an ARN with no accountID with or without wildcard characters if PrincipalType is IAM_PATTERN.
    /// This member is required.
    public var principalARN: Swift.String?
    /// The supported value is IAM if you use a fully defined ARN, or IAM_PATTERN if you specify an IAM ARN with no AccountId, with or without wildcard characters.
    public var principalType: ServiceCatalogClientTypes.PrincipalType?

    public init(
        acceptLanguage: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        principalARN: Swift.String? = nil,
        principalType: ServiceCatalogClientTypes.PrincipalType? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.principalARN = principalARN
        self.principalType = principalType
    }
}

public struct DisassociatePrincipalFromPortfolioOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateProductFromPortfolioInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        productId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.productId = productId
    }
}

public struct DisassociateProductFromPortfolioOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateServiceActionFromProvisioningArtifactInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests from the same Amazon Web Services account use the same idempotency token, the same response is returned for each repeated request.
    public var idempotencyToken: Swift.String?
    /// The product identifier. For example, prod-abcdzk7xy33qa.
    /// This member is required.
    public var productId: Swift.String?
    /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?
    /// The self-service action identifier. For example, act-fs7abcd89wxyz.
    /// This member is required.
    public var serviceActionId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        productId: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        serviceActionId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
        self.serviceActionId = serviceActionId
    }
}

public struct DisassociateServiceActionFromProvisioningArtifactOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateTagOptionFromResourceInput: Swift.Sendable {
    /// The resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The TagOption identifier.
    /// This member is required.
    public var tagOptionId: Swift.String?

    public init(
        resourceId: Swift.String? = nil,
        tagOptionId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
        self.tagOptionId = tagOptionId
    }
}

public struct DisassociateTagOptionFromResourceOutput: Swift.Sendable {

    public init() { }
}

public struct EnableAWSOrganizationsAccessInput: Swift.Sendable {

    public init() { }
}

public struct EnableAWSOrganizationsAccessOutput: Swift.Sendable {

    public init() { }
}

public struct ExecuteProvisionedProductPlanInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The plan identifier.
    /// This member is required.
    public var planId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        planId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.planId = planId
    }
}

public struct ExecuteProvisionedProductPlanOutput: Swift.Sendable {
    /// Information about the result of provisioning the product.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?

    public init(
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

public struct ExecuteProvisionedProductServiceActionInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// An idempotency token that uniquely identifies the execute request.
    /// This member is required.
    public var executeToken: Swift.String?
    /// A map of all self-service action parameters and their values. If a provided parameter is of a special type, such as TARGET, the provided value will override the default value generated by Service Catalog. If the parameters field is not provided, no additional parameters are passed and default values will be used for any special parameters such as TARGET.
    public var parameters: [Swift.String: [Swift.String]]?
    /// The identifier of the provisioned product.
    /// This member is required.
    public var provisionedProductId: Swift.String?
    /// The self-service action identifier. For example, act-fs7abcd89wxyz.
    /// This member is required.
    public var serviceActionId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        executeToken: Swift.String? = nil,
        parameters: [Swift.String: [Swift.String]]? = nil,
        provisionedProductId: Swift.String? = nil,
        serviceActionId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.executeToken = executeToken
        self.parameters = parameters
        self.provisionedProductId = provisionedProductId
        self.serviceActionId = serviceActionId
    }
}

public struct ExecuteProvisionedProductServiceActionOutput: Swift.Sendable {
    /// An object containing detailed information about the result of provisioning the product.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?

    public init(
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

public struct GetAWSOrganizationsAccessStatusInput: Swift.Sendable {

    public init() { }
}

public struct GetAWSOrganizationsAccessStatusOutput: Swift.Sendable {
    /// The status of the portfolio share feature.
    public var accessStatus: ServiceCatalogClientTypes.AccessStatus?

    public init(
        accessStatus: ServiceCatalogClientTypes.AccessStatus? = nil
    )
    {
        self.accessStatus = accessStatus
    }
}

public struct GetProvisionedProductOutputsInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The list of keys that the API should return with their values. If none are provided, the API will return all outputs of the provisioned product.
    public var outputKeys: [Swift.String]?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The identifier of the provisioned product that you want the outputs from.
    public var provisionedProductId: Swift.String?
    /// The name of the provisioned product that you want the outputs from.
    public var provisionedProductName: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        outputKeys: [Swift.String]? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        provisionedProductId: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.outputKeys = outputKeys
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.provisionedProductId = provisionedProductId
        self.provisionedProductName = provisionedProductName
    }
}

public struct GetProvisionedProductOutputsOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the product created as the result of a request. For example, the output for a CloudFormation-backed product that creates an S3 bucket would include the S3 bucket URL.
    public var outputs: [ServiceCatalogClientTypes.RecordOutput]?

    public init(
        nextPageToken: Swift.String? = nil,
        outputs: [ServiceCatalogClientTypes.RecordOutput]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.outputs = outputs
    }
}

public struct ImportAsProvisionedProductInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The unique identifier of the resource to be imported. It only currently supports CloudFormation stack IDs.
    /// This member is required.
    public var physicalId: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?
    /// The user-friendly name of the provisioned product. The value must be unique for the Amazon Web Services account. The name cannot be updated after the product is provisioned.
    /// This member is required.
    public var provisionedProductName: Swift.String?
    /// The identifier of the provisioning artifact.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        physicalId: Swift.String? = nil,
        productId: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.physicalId = physicalId
        self.productId = productId
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
    }
}

public struct ImportAsProvisionedProductOutput: Swift.Sendable {
    /// Information about a request operation.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?

    public init(
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

public struct ListAcceptedPortfolioSharesInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The type of shared portfolios to list. The default is to list imported portfolios.
    ///
    /// * AWS_ORGANIZATIONS - List portfolios accepted and shared via organizational sharing by the management account or delegated administrator of your organization.
    ///
    /// * AWS_SERVICECATALOG - Deprecated type.
    ///
    /// * IMPORTED - List imported portfolios that have been accepted and shared through account-to-account sharing.
    public var portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioShareType = portfolioShareType
    }
}

public struct ListAcceptedPortfolioSharesOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the portfolios.
    public var portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]?

    public init(
        nextPageToken: Swift.String? = nil,
        portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.portfolioDetails = portfolioDetails
    }
}

public struct ListBudgetsForResourceInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.resourceId = resourceId
    }
}

public struct ListBudgetsForResourceOutput: Swift.Sendable {
    /// Information about the associated budgets.
    public var budgets: [ServiceCatalogClientTypes.BudgetDetail]?
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?

    public init(
        budgets: [ServiceCatalogClientTypes.BudgetDetail]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.budgets = budgets
        self.nextPageToken = nextPageToken
    }
}

public struct ListConstraintsForPortfolioInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The product identifier.
    public var productId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        productId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
        self.productId = productId
    }
}

public struct ListConstraintsForPortfolioOutput: Swift.Sendable {
    /// Information about the constraints.
    public var constraintDetails: [ServiceCatalogClientTypes.ConstraintDetail]?
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?

    public init(
        constraintDetails: [ServiceCatalogClientTypes.ConstraintDetail]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.constraintDetails = constraintDetails
        self.nextPageToken = nextPageToken
    }
}

public struct ListLaunchPathsInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        productId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.productId = productId
    }
}

extension ServiceCatalogClientTypes {

    /// Summary information about a product path for a user.
    public struct LaunchPathSummary: Swift.Sendable {
        /// The constraints on the portfolio-product relationship.
        public var constraintSummaries: [ServiceCatalogClientTypes.ConstraintSummary]?
        /// The identifier of the product path.
        public var id: Swift.String?
        /// The name of the portfolio that contains the product.
        public var name: Swift.String?
        /// The tags associated with this product path.
        public var tags: [ServiceCatalogClientTypes.Tag]?

        public init(
            constraintSummaries: [ServiceCatalogClientTypes.ConstraintSummary]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [ServiceCatalogClientTypes.Tag]? = nil
        )
        {
            self.constraintSummaries = constraintSummaries
            self.id = id
            self.name = name
            self.tags = tags
        }
    }
}

public struct ListLaunchPathsOutput: Swift.Sendable {
    /// Information about the launch path.
    public var launchPathSummaries: [ServiceCatalogClientTypes.LaunchPathSummary]?
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?

    public init(
        launchPathSummaries: [ServiceCatalogClientTypes.LaunchPathSummary]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.launchPathSummaries = launchPathSummaries
        self.nextPageToken = nextPageToken
    }
}

public struct ListOrganizationPortfolioAccessInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The organization node type that will be returned in the output.
    ///
    /// * ORGANIZATION - Organization that has access to the portfolio.
    ///
    /// * ORGANIZATIONAL_UNIT - Organizational unit that has access to the portfolio within your organization.
    ///
    /// * ACCOUNT - Account that has access to the portfolio within your organization.
    /// This member is required.
    public var organizationNodeType: ServiceCatalogClientTypes.OrganizationNodeType?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The portfolio identifier. For example, port-2abcdext3y5fk.
    /// This member is required.
    public var portfolioId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        organizationNodeType: ServiceCatalogClientTypes.OrganizationNodeType? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        portfolioId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.organizationNodeType = organizationNodeType
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
    }
}

public struct ListOrganizationPortfolioAccessOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Displays information about the organization nodes.
    public var organizationNodes: [ServiceCatalogClientTypes.OrganizationNode]?

    public init(
        nextPageToken: Swift.String? = nil,
        organizationNodes: [ServiceCatalogClientTypes.OrganizationNode]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.organizationNodes = organizationNodes
    }
}

public struct ListPortfolioAccessInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The ID of an organization node the portfolio is shared with. All children of this node with an inherited portfolio share will be returned.
    public var organizationParentId: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        organizationParentId: Swift.String? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        portfolioId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.organizationParentId = organizationParentId
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
    }
}

public struct ListPortfolioAccessOutput: Swift.Sendable {
    /// Information about the Amazon Web Services accounts with access to the portfolio.
    public var accountIds: [Swift.String]?
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.nextPageToken = nextPageToken
    }
}

public struct ListPortfoliosInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

public struct ListPortfoliosOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the portfolios.
    public var portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]?

    public init(
        nextPageToken: Swift.String? = nil,
        portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.portfolioDetails = portfolioDetails
    }
}

public struct ListPortfoliosForProductInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        productId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.productId = productId
    }
}

public struct ListPortfoliosForProductOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the portfolios.
    public var portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]?

    public init(
        nextPageToken: Swift.String? = nil,
        portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.portfolioDetails = portfolioDetails
    }
}

public struct ListPrincipalsForPortfolioInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        portfolioId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a principal.
    public struct Principal: Swift.Sendable {
        /// The ARN of the principal (user, role, or group). This field allows for an ARN with no accountID, with or without wildcard characters if the PrincipalType is an IAM_PATTERN. For more information, review [associate-principal-with-portfolio](https://docs.aws.amazon.com/cli/latest/reference/servicecatalog/associate-principal-with-portfolio.html#options) in the Amazon Web Services CLI Command Reference.
        public var principalARN: Swift.String?
        /// The principal type. The supported value is IAM if you use a fully defined ARN, or IAM_PATTERN if you use an ARN with no accountID, with or without wildcard characters.
        public var principalType: ServiceCatalogClientTypes.PrincipalType?

        public init(
            principalARN: Swift.String? = nil,
            principalType: ServiceCatalogClientTypes.PrincipalType? = nil
        )
        {
            self.principalARN = principalARN
            self.principalType = principalType
        }
    }
}

public struct ListPrincipalsForPortfolioOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// The PrincipalARNs and corresponding PrincipalTypes associated with the portfolio.
    public var principals: [ServiceCatalogClientTypes.Principal]?

    public init(
        nextPageToken: Swift.String? = nil,
        principals: [ServiceCatalogClientTypes.Principal]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.principals = principals
    }
}

public struct ListProvisionedProductPlansInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The access level to use to obtain results. The default is User.
    public var accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The product identifier.
    public var provisionProductId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        provisionProductId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accessLevelFilter = accessLevelFilter
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.provisionProductId = provisionProductId
    }
}

extension ServiceCatalogClientTypes {

    /// Summary information about a plan.
    public struct ProvisionedProductPlanSummary: Swift.Sendable {
        /// The plan identifier.
        public var planId: Swift.String?
        /// The name of the plan.
        public var planName: Swift.String?
        /// The plan type.
        public var planType: ServiceCatalogClientTypes.ProvisionedProductPlanType?
        /// The product identifier.
        public var provisionProductId: Swift.String?
        /// The user-friendly name of the provisioned product.
        public var provisionProductName: Swift.String?
        /// The identifier of the provisioning artifact.
        public var provisioningArtifactId: Swift.String?

        public init(
            planId: Swift.String? = nil,
            planName: Swift.String? = nil,
            planType: ServiceCatalogClientTypes.ProvisionedProductPlanType? = nil,
            provisionProductId: Swift.String? = nil,
            provisionProductName: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil
        )
        {
            self.planId = planId
            self.planName = planName
            self.planType = planType
            self.provisionProductId = provisionProductId
            self.provisionProductName = provisionProductName
            self.provisioningArtifactId = provisioningArtifactId
        }
    }
}

public struct ListProvisionedProductPlansOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the plans.
    public var provisionedProductPlans: [ServiceCatalogClientTypes.ProvisionedProductPlanSummary]?

    public init(
        nextPageToken: Swift.String? = nil,
        provisionedProductPlans: [ServiceCatalogClientTypes.ProvisionedProductPlanSummary]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisionedProductPlans = provisionedProductPlans
    }
}

public struct ListProvisioningArtifactsInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        productId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.productId = productId
    }
}

public struct ListProvisioningArtifactsOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the provisioning artifacts.
    public var provisioningArtifactDetails: [ServiceCatalogClientTypes.ProvisioningArtifactDetail]?

    public init(
        nextPageToken: Swift.String? = nil,
        provisioningArtifactDetails: [ServiceCatalogClientTypes.ProvisioningArtifactDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisioningArtifactDetails = provisioningArtifactDetails
    }
}

public struct ListProvisioningArtifactsForServiceActionInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The self-service action identifier. For example, act-fs7abcd89wxyz.
    /// This member is required.
    public var serviceActionId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        serviceActionId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.serviceActionId = serviceActionId
    }
}

extension ServiceCatalogClientTypes {

    /// An object that contains summary information about a product view and a provisioning artifact.
    public struct ProvisioningArtifactView: Swift.Sendable {
        /// Summary information about a product view.
        public var productViewSummary: ServiceCatalogClientTypes.ProductViewSummary?
        /// Information about a provisioning artifact. A provisioning artifact is also known as a product version.
        public var provisioningArtifact: ServiceCatalogClientTypes.ProvisioningArtifact?

        public init(
            productViewSummary: ServiceCatalogClientTypes.ProductViewSummary? = nil,
            provisioningArtifact: ServiceCatalogClientTypes.ProvisioningArtifact? = nil
        )
        {
            self.productViewSummary = productViewSummary
            self.provisioningArtifact = provisioningArtifact
        }
    }
}

public struct ListProvisioningArtifactsForServiceActionOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// An array of objects with information about product views and provisioning artifacts.
    public var provisioningArtifactViews: [ServiceCatalogClientTypes.ProvisioningArtifactView]?

    public init(
        nextPageToken: Swift.String? = nil,
        provisioningArtifactViews: [ServiceCatalogClientTypes.ProvisioningArtifactView]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisioningArtifactViews = provisioningArtifactViews
    }
}

extension ServiceCatalogClientTypes {

    /// The search filter to use when listing history records.
    public struct ListRecordHistorySearchFilter: Swift.Sendable {
        /// The filter key.
        ///
        /// * product - Filter results based on the specified product identifier.
        ///
        /// * provisionedproduct - Filter results based on the provisioned product identifier.
        public var key: Swift.String?
        /// The filter value.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct ListRecordHistoryInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The access level to use to obtain results. The default is User.
    public var accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The search filter to scope the results.
    public var searchFilter: ServiceCatalogClientTypes.ListRecordHistorySearchFilter?

    public init(
        acceptLanguage: Swift.String? = nil,
        accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        searchFilter: ServiceCatalogClientTypes.ListRecordHistorySearchFilter? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accessLevelFilter = accessLevelFilter
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.searchFilter = searchFilter
    }
}

public struct ListRecordHistoryOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// The records, in reverse chronological order.
    public var recordDetails: [ServiceCatalogClientTypes.RecordDetail]?

    public init(
        nextPageToken: Swift.String? = nil,
        recordDetails: [ServiceCatalogClientTypes.RecordDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.recordDetails = recordDetails
    }
}

public struct ListResourcesForTagOptionInput: Swift.Sendable {
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The resource type.
    ///
    /// * Portfolio
    ///
    /// * Product
    public var resourceType: Swift.String?
    /// The TagOption identifier.
    /// This member is required.
    public var tagOptionId: Swift.String?

    public init(
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        tagOptionId: Swift.String? = nil
    )
    {
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.resourceType = resourceType
        self.tagOptionId = tagOptionId
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a resource.
    public struct ResourceDetail: Swift.Sendable {
        /// The ARN of the resource.
        public var arn: Swift.String?
        /// The creation time of the resource.
        public var createdTime: Foundation.Date?
        /// The description of the resource.
        public var description: Swift.String?
        /// The identifier of the resource.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.name = name
        }
    }
}

public struct ListResourcesForTagOptionOutput: Swift.Sendable {
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// Information about the resources.
    public var resourceDetails: [ServiceCatalogClientTypes.ResourceDetail]?

    public init(
        pageToken: Swift.String? = nil,
        resourceDetails: [ServiceCatalogClientTypes.ResourceDetail]? = nil
    )
    {
        self.pageToken = pageToken
        self.resourceDetails = resourceDetails
    }
}

public struct ListServiceActionsInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

public struct ListServiceActionsOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// An object containing information about the service actions associated with the provisioning artifact.
    public var serviceActionSummaries: [ServiceCatalogClientTypes.ServiceActionSummary]?

    public init(
        nextPageToken: Swift.String? = nil,
        serviceActionSummaries: [ServiceCatalogClientTypes.ServiceActionSummary]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.serviceActionSummaries = serviceActionSummaries
    }
}

public struct ListServiceActionsForProvisioningArtifactInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The product identifier. For example, prod-abcdzk7xy33qa.
    /// This member is required.
    public var productId: Swift.String?
    /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        productId: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
    }
}

public struct ListServiceActionsForProvisioningArtifactOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// An object containing information about the self-service actions associated with the provisioning artifact.
    public var serviceActionSummaries: [ServiceCatalogClientTypes.ServiceActionSummary]?

    public init(
        nextPageToken: Swift.String? = nil,
        serviceActionSummaries: [ServiceCatalogClientTypes.ServiceActionSummary]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.serviceActionSummaries = serviceActionSummaries
    }
}

public struct ListStackInstancesForProvisionedProductInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The identifier of the provisioned product.
    /// This member is required.
    public var provisionedProductId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        provisionedProductId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.provisionedProductId = provisionedProductId
    }
}

extension ServiceCatalogClientTypes {

    public enum StackInstanceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case current
        case inoperable
        case outdated
        case sdkUnknown(Swift.String)

        public static var allCases: [StackInstanceStatus] {
            return [
                .current,
                .inoperable,
                .outdated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .current: return "CURRENT"
            case .inoperable: return "INOPERABLE"
            case .outdated: return "OUTDATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    /// An CloudFormation stack, in a specific account and Region, that's part of a stack set operation. A stack instance is a reference to an attempted or actual stack in a given account within a given Region. A stack instance can exist without a stackfor example, if the stack couldn't be created for some reason. A stack instance is associated with only one stack set. Each stack instance contains the ID of its associated stack set, as well as the ID of the actual stack and the stack status.
    public struct StackInstance: Swift.Sendable {
        /// The name of the Amazon Web Services account that the stack instance is associated with.
        public var account: Swift.String?
        /// The name of the Amazon Web Services Region that the stack instance is associated with.
        public var region: Swift.String?
        /// The status of the stack instance, in terms of its synchronization with its associated stack set.
        ///
        /// * INOPERABLE: A DeleteStackInstances operation has failed and left the stack in an unstable state. Stacks in this state are excluded from further UpdateStackSet operations. You might need to perform a DeleteStackInstances operation, with RetainStacks set to true, to delete the stack instance, and then delete the stack manually.
        ///
        /// * OUTDATED: The stack isn't currently up to date with the stack set because either the associated stack failed during a CreateStackSet or UpdateStackSet operation, or the stack was part of a CreateStackSet or UpdateStackSet operation that failed or was stopped before the stack was created or updated.
        ///
        /// * CURRENT: The stack is currently up to date with the stack set.
        public var stackInstanceStatus: ServiceCatalogClientTypes.StackInstanceStatus?

        public init(
            account: Swift.String? = nil,
            region: Swift.String? = nil,
            stackInstanceStatus: ServiceCatalogClientTypes.StackInstanceStatus? = nil
        )
        {
            self.account = account
            self.region = region
            self.stackInstanceStatus = stackInstanceStatus
        }
    }
}

public struct ListStackInstancesForProvisionedProductOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// List of stack instances.
    public var stackInstances: [ServiceCatalogClientTypes.StackInstance]?

    public init(
        nextPageToken: Swift.String? = nil,
        stackInstances: [ServiceCatalogClientTypes.StackInstance]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.stackInstances = stackInstances
    }
}

extension ServiceCatalogClientTypes {

    /// Filters to use when listing TagOptions.
    public struct ListTagOptionsFilters: Swift.Sendable {
        /// The active state.
        public var active: Swift.Bool?
        /// The TagOption key.
        public var key: Swift.String?
        /// The TagOption value.
        public var value: Swift.String?

        public init(
            active: Swift.Bool? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.active = active
            self.key = key
            self.value = value
        }
    }
}

public struct ListTagOptionsInput: Swift.Sendable {
    /// The search filters. If no search filters are specified, the output includes all TagOptions.
    public var filters: ServiceCatalogClientTypes.ListTagOptionsFilters?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?

    public init(
        filters: ServiceCatalogClientTypes.ListTagOptionsFilters? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

public struct ListTagOptionsOutput: Swift.Sendable {
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// Information about the TagOptions.
    public var tagOptionDetails: [ServiceCatalogClientTypes.TagOptionDetail]?

    public init(
        pageToken: Swift.String? = nil,
        tagOptionDetails: [ServiceCatalogClientTypes.TagOptionDetail]? = nil
    )
    {
        self.pageToken = pageToken
        self.tagOptionDetails = tagOptionDetails
    }
}

extension ServiceCatalogClientTypes {

    /// The unique key-value pair for a tag that identifies provisioned product resources.
    public struct UniqueTagResourceIdentifier: Swift.Sendable {
        /// A unique key that's attached to a resource.
        public var key: Swift.String?
        /// A unique value that's attached to a resource.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension ServiceCatalogClientTypes {

    /// The ID for the provisioned product resources that are part of a resource group.
    public struct EngineWorkflowResourceIdentifier: Swift.Sendable {
        /// The unique key-value pair for a tag that identifies provisioned product resources.
        public var uniqueTag: ServiceCatalogClientTypes.UniqueTagResourceIdentifier?

        public init(
            uniqueTag: ServiceCatalogClientTypes.UniqueTagResourceIdentifier? = nil
        )
        {
            self.uniqueTag = uniqueTag
        }
    }
}

extension ServiceCatalogClientTypes {

    public enum EngineWorkflowStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [EngineWorkflowStatus] {
            return [
                .failed,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct NotifyProvisionProductEngineWorkflowResultInput: Swift.Sendable {
    /// The reason why the provisioning engine execution failed.
    public var failureReason: Swift.String?
    /// The idempotency token that identifies the provisioning engine execution.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The output of the provisioning engine execution.
    public var outputs: [ServiceCatalogClientTypes.RecordOutput]?
    /// The identifier of the record.
    /// This member is required.
    public var recordId: Swift.String?
    /// The ID for the provisioned product resources that are part of a resource group.
    public var resourceIdentifier: ServiceCatalogClientTypes.EngineWorkflowResourceIdentifier?
    /// The status of the provisioning engine execution.
    /// This member is required.
    public var status: ServiceCatalogClientTypes.EngineWorkflowStatus?
    /// The encrypted contents of the provisioning engine execution payload that Service Catalog sends after the Terraform product provisioning workflow starts.
    /// This member is required.
    public var workflowToken: Swift.String?

    public init(
        failureReason: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        outputs: [ServiceCatalogClientTypes.RecordOutput]? = nil,
        recordId: Swift.String? = nil,
        resourceIdentifier: ServiceCatalogClientTypes.EngineWorkflowResourceIdentifier? = nil,
        status: ServiceCatalogClientTypes.EngineWorkflowStatus? = nil,
        workflowToken: Swift.String? = nil
    )
    {
        self.failureReason = failureReason
        self.idempotencyToken = idempotencyToken
        self.outputs = outputs
        self.recordId = recordId
        self.resourceIdentifier = resourceIdentifier
        self.status = status
        self.workflowToken = workflowToken
    }
}

public struct NotifyProvisionProductEngineWorkflowResultOutput: Swift.Sendable {

    public init() { }
}

public struct NotifyTerminateProvisionedProductEngineWorkflowResultInput: Swift.Sendable {
    /// The reason why the terminate engine execution failed.
    public var failureReason: Swift.String?
    /// The idempotency token that identifies the terminate engine execution.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The identifier of the record.
    /// This member is required.
    public var recordId: Swift.String?
    /// The status of the terminate engine execution.
    /// This member is required.
    public var status: ServiceCatalogClientTypes.EngineWorkflowStatus?
    /// The encrypted contents of the terminate engine execution payload that Service Catalog sends after the Terraform product terminate workflow starts.
    /// This member is required.
    public var workflowToken: Swift.String?

    public init(
        failureReason: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        recordId: Swift.String? = nil,
        status: ServiceCatalogClientTypes.EngineWorkflowStatus? = nil,
        workflowToken: Swift.String? = nil
    )
    {
        self.failureReason = failureReason
        self.idempotencyToken = idempotencyToken
        self.recordId = recordId
        self.status = status
        self.workflowToken = workflowToken
    }
}

public struct NotifyTerminateProvisionedProductEngineWorkflowResultOutput: Swift.Sendable {

    public init() { }
}

public struct NotifyUpdateProvisionedProductEngineWorkflowResultInput: Swift.Sendable {
    /// The reason why the update engine execution failed.
    public var failureReason: Swift.String?
    /// The idempotency token that identifies the update engine execution.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The output of the update engine execution.
    public var outputs: [ServiceCatalogClientTypes.RecordOutput]?
    /// The identifier of the record.
    /// This member is required.
    public var recordId: Swift.String?
    /// The status of the update engine execution.
    /// This member is required.
    public var status: ServiceCatalogClientTypes.EngineWorkflowStatus?
    /// The encrypted contents of the update engine execution payload that Service Catalog sends after the Terraform product update workflow starts.
    /// This member is required.
    public var workflowToken: Swift.String?

    public init(
        failureReason: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        outputs: [ServiceCatalogClientTypes.RecordOutput]? = nil,
        recordId: Swift.String? = nil,
        status: ServiceCatalogClientTypes.EngineWorkflowStatus? = nil,
        workflowToken: Swift.String? = nil
    )
    {
        self.failureReason = failureReason
        self.idempotencyToken = idempotencyToken
        self.outputs = outputs
        self.recordId = recordId
        self.status = status
        self.workflowToken = workflowToken
    }
}

public struct NotifyUpdateProvisionedProductEngineWorkflowResultOutput: Swift.Sendable {

    public init() { }
}

extension ServiceCatalogClientTypes {

    /// Information about a parameter used to provision a product.
    public struct ProvisioningParameter: Swift.Sendable {
        /// The parameter key.
        public var key: Swift.String?
        /// The parameter value.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension ServiceCatalogClientTypes {

    /// The user-defined preferences that will be applied when updating a provisioned product. Not all preferences are applicable to all provisioned product type One or more Amazon Web Services accounts that will have access to the provisioned product. Applicable only to a CFN_STACKSET provisioned product type. The Amazon Web Services accounts specified should be within the list of accounts in the STACKSET constraint. To get the list of accounts in the STACKSET constraint, use the DescribeProvisioningParameters operation. If no values are specified, the default value is all accounts from the STACKSET constraint.
    public struct ProvisioningPreferences: Swift.Sendable {
        /// One or more Amazon Web Services accounts where the provisioned product will be available. Applicable only to a CFN_STACKSET provisioned product type. The specified accounts should be within the list of accounts from the STACKSET constraint. To get the list of accounts in the STACKSET constraint, use the DescribeProvisioningParameters operation. If no values are specified, the default value is all acounts from the STACKSET constraint.
        public var stackSetAccounts: [Swift.String]?
        /// The number of accounts, per Region, for which this operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetFailureToleranceCount or StackSetFailureTolerancePercentage, but not both. The default value is 0 if no value is specified.
        public var stackSetFailureToleranceCount: Swift.Int?
        /// The percentage of accounts, per Region, for which this stack operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions. When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetFailureToleranceCount or StackSetFailureTolerancePercentage, but not both.
        public var stackSetFailureTolerancePercentage: Swift.Int?
        /// The maximum number of accounts in which to perform this operation at one time. This is dependent on the value of StackSetFailureToleranceCount. StackSetMaxConcurrentCount is at most one more than the StackSetFailureToleranceCount. Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetMaxConcurrentCount or StackSetMaxConcurrentPercentage, but not both.
        public var stackSetMaxConcurrencyCount: Swift.Int?
        /// The maximum percentage of accounts in which to perform this operation at one time. When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, Service Catalog sets the number as 1 instead. Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetMaxConcurrentCount or StackSetMaxConcurrentPercentage, but not both.
        public var stackSetMaxConcurrencyPercentage: Swift.Int?
        /// One or more Amazon Web Services Regions where the provisioned product will be available. Applicable only to a CFN_STACKSET provisioned product type. The specified Regions should be within the list of Regions from the STACKSET constraint. To get the list of Regions in the STACKSET constraint, use the DescribeProvisioningParameters operation. If no values are specified, the default value is all Regions from the STACKSET constraint.
        public var stackSetRegions: [Swift.String]?

        public init(
            stackSetAccounts: [Swift.String]? = nil,
            stackSetFailureToleranceCount: Swift.Int? = nil,
            stackSetFailureTolerancePercentage: Swift.Int? = nil,
            stackSetMaxConcurrencyCount: Swift.Int? = nil,
            stackSetMaxConcurrencyPercentage: Swift.Int? = nil,
            stackSetRegions: [Swift.String]? = nil
        )
        {
            self.stackSetAccounts = stackSetAccounts
            self.stackSetFailureToleranceCount = stackSetFailureToleranceCount
            self.stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentage
            self.stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCount
            self.stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentage
            self.stackSetRegions = stackSetRegions
        }
    }
}

public struct ProvisionProductInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// Passed to CloudFormation. The SNS topic ARNs to which to publish stack-related events.
    public var notificationArns: [Swift.String]?
    /// The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path. To list the paths for a product, use [ListLaunchPaths]. You must provide the name or ID, but not both.
    public var pathId: Swift.String?
    /// The name of the path. You must provide the name or ID, but not both.
    public var pathName: Swift.String?
    /// The product identifier. You must provide the name or ID, but not both.
    public var productId: Swift.String?
    /// The name of the product. You must provide the name or ID, but not both.
    public var productName: Swift.String?
    /// An idempotency token that uniquely identifies the provisioning request.
    /// This member is required.
    public var provisionToken: Swift.String?
    /// A user-friendly name for the provisioned product. This value must be unique for the Amazon Web Services account and cannot be updated after the product is provisioned.
    /// This member is required.
    public var provisionedProductName: Swift.String?
    /// The identifier of the provisioning artifact. You must provide the name or ID, but not both.
    public var provisioningArtifactId: Swift.String?
    /// The name of the provisioning artifact. You must provide the name or ID, but not both.
    public var provisioningArtifactName: Swift.String?
    /// Parameters specified by the administrator that are required for provisioning the product.
    public var provisioningParameters: [ServiceCatalogClientTypes.ProvisioningParameter]?
    /// An object that contains information about the provisioning preferences for a stack set.
    public var provisioningPreferences: ServiceCatalogClientTypes.ProvisioningPreferences?
    /// One or more tags.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        acceptLanguage: Swift.String? = nil,
        notificationArns: [Swift.String]? = nil,
        pathId: Swift.String? = nil,
        pathName: Swift.String? = nil,
        productId: Swift.String? = nil,
        productName: Swift.String? = nil,
        provisionToken: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        provisioningArtifactName: Swift.String? = nil,
        provisioningParameters: [ServiceCatalogClientTypes.ProvisioningParameter]? = nil,
        provisioningPreferences: ServiceCatalogClientTypes.ProvisioningPreferences? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.notificationArns = notificationArns
        self.pathId = pathId
        self.pathName = pathName
        self.productId = productId
        self.productName = productName
        self.provisionToken = provisionToken
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningArtifactName = provisioningArtifactName
        self.provisioningParameters = provisioningParameters
        self.provisioningPreferences = provisioningPreferences
        self.tags = tags
    }
}

public struct ProvisionProductOutput: Swift.Sendable {
    /// Information about the result of provisioning the product.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?

    public init(
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

public struct RejectPortfolioShareInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The type of shared portfolios to reject. The default is to reject imported portfolios.
    ///
    /// * AWS_ORGANIZATIONS - Reject portfolios shared by the management account of your organization.
    ///
    /// * IMPORTED - Reject imported portfolios.
    ///
    /// * AWS_SERVICECATALOG - Not supported. (Throws ResourceNotFoundException.)
    ///
    ///
    /// For example, aws servicecatalog reject-portfolio-share --portfolio-id "port-2qwzkwxt3y5fk" --portfolio-share-type AWS_ORGANIZATIONS
    public var portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType?

    public init(
        acceptLanguage: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.portfolioShareType = portfolioShareType
    }
}

public struct RejectPortfolioShareOutput: Swift.Sendable {

    public init() { }
}

public struct ScanProvisionedProductsInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The access level to use to obtain results. The default is User.
    public var accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accessLevelFilter = accessLevelFilter
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

public struct ScanProvisionedProductsOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the provisioned products.
    public var provisionedProducts: [ServiceCatalogClientTypes.ProvisionedProductDetail]?

    public init(
        nextPageToken: Swift.String? = nil,
        provisionedProducts: [ServiceCatalogClientTypes.ProvisionedProductDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisionedProducts = provisionedProducts
    }
}

extension ServiceCatalogClientTypes {

    public enum ProductViewFilterBy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fulltextsearch
        case owner
        case producttype
        case sourceproductid
        case sdkUnknown(Swift.String)

        public static var allCases: [ProductViewFilterBy] {
            return [
                .fulltextsearch,
                .owner,
                .producttype,
                .sourceproductid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fulltextsearch: return "FullTextSearch"
            case .owner: return "Owner"
            case .producttype: return "ProductType"
            case .sourceproductid: return "SourceProductId"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    public enum ProductViewSortBy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creationdate
        case title
        case versioncount
        case sdkUnknown(Swift.String)

        public static var allCases: [ProductViewSortBy] {
            return [
                .creationdate,
                .title,
                .versioncount
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creationdate: return "CreationDate"
            case .title: return "Title"
            case .versioncount: return "VersionCount"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    public enum SortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct SearchProductsInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The search filters. If no search filters are specified, the output includes all products to which the caller has access.
    public var filters: [Swift.String: [Swift.String]]?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The sort field. If no value is specified, the results are not sorted.
    public var sortBy: ServiceCatalogClientTypes.ProductViewSortBy?
    /// The sort order. If no value is specified, the results are not sorted.
    public var sortOrder: ServiceCatalogClientTypes.SortOrder?

    public init(
        acceptLanguage: Swift.String? = nil,
        filters: [Swift.String: [Swift.String]]? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        sortBy: ServiceCatalogClientTypes.ProductViewSortBy? = nil,
        sortOrder: ServiceCatalogClientTypes.SortOrder? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.filters = filters
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

extension ServiceCatalogClientTypes {

    /// A single product view aggregation value/count pair, containing metadata about each product to which the calling user has access.
    public struct ProductViewAggregationValue: Swift.Sendable {
        /// An approximate count of the products that match the value.
        public var approximateCount: Swift.Int
        /// The value of the product view aggregation.
        public var value: Swift.String?

        public init(
            approximateCount: Swift.Int = 0,
            value: Swift.String? = nil
        )
        {
            self.approximateCount = approximateCount
            self.value = value
        }
    }
}

public struct SearchProductsOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// The product view aggregations.
    public var productViewAggregations: [Swift.String: [ServiceCatalogClientTypes.ProductViewAggregationValue]]?
    /// Information about the product views.
    public var productViewSummaries: [ServiceCatalogClientTypes.ProductViewSummary]?

    public init(
        nextPageToken: Swift.String? = nil,
        productViewAggregations: [Swift.String: [ServiceCatalogClientTypes.ProductViewAggregationValue]]? = nil,
        productViewSummaries: [ServiceCatalogClientTypes.ProductViewSummary]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.productViewAggregations = productViewAggregations
        self.productViewSummaries = productViewSummaries
    }
}

extension ServiceCatalogClientTypes {

    public enum ProductSource: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case sdkUnknown(Swift.String)

        public static var allCases: [ProductSource] {
            return [
                .account
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct SearchProductsAsAdminInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The search filters. If no search filters are specified, the output includes all products to which the administrator has access.
    public var filters: [Swift.String: [Swift.String]]?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The portfolio identifier.
    public var portfolioId: Swift.String?
    /// Access level of the source of the product.
    public var productSource: ServiceCatalogClientTypes.ProductSource?
    /// The sort field. If no value is specified, the results are not sorted.
    public var sortBy: ServiceCatalogClientTypes.ProductViewSortBy?
    /// The sort order. If no value is specified, the results are not sorted.
    public var sortOrder: ServiceCatalogClientTypes.SortOrder?

    public init(
        acceptLanguage: Swift.String? = nil,
        filters: [Swift.String: [Swift.String]]? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        productSource: ServiceCatalogClientTypes.ProductSource? = nil,
        sortBy: ServiceCatalogClientTypes.ProductViewSortBy? = nil,
        sortOrder: ServiceCatalogClientTypes.SortOrder? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.filters = filters
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
        self.productSource = productSource
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

public struct SearchProductsAsAdminOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the product views.
    public var productViewDetails: [ServiceCatalogClientTypes.ProductViewDetail]?

    public init(
        nextPageToken: Swift.String? = nil,
        productViewDetails: [ServiceCatalogClientTypes.ProductViewDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.productViewDetails = productViewDetails
    }
}

extension ServiceCatalogClientTypes {

    public enum ProvisionedProductViewFilterBy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case searchquery
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedProductViewFilterBy] {
            return [
                .searchquery
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .searchquery: return "SearchQuery"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct SearchProvisionedProductsInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The access level to use to obtain results. The default is User.
    public var accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
    /// The search filters. When the key is SearchQuery, the searchable fields are arn, createdTime, id, lastRecordId, idempotencyToken, name, physicalId, productId, provisioningArtifactId, type, status, tags, userArn, userArnSession, lastProvisioningRecordId, lastSuccessfulProvisioningRecordId, productName, and provisioningArtifactName. Example: "SearchQuery":["status:AVAILABLE"]
    public var filters: [Swift.String: [Swift.String]]?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int?
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The sort field. If no value is specified, the results are not sorted. The valid values are arn, id, name, and lastRecordId.
    public var sortBy: Swift.String?
    /// The sort order. If no value is specified, the results are not sorted.
    public var sortOrder: ServiceCatalogClientTypes.SortOrder?

    public init(
        acceptLanguage: Swift.String? = nil,
        accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter? = nil,
        filters: [Swift.String: [Swift.String]]? = nil,
        pageSize: Swift.Int? = 0,
        pageToken: Swift.String? = nil,
        sortBy: Swift.String? = nil,
        sortOrder: ServiceCatalogClientTypes.SortOrder? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accessLevelFilter = accessLevelFilter
        self.filters = filters
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

extension ServiceCatalogClientTypes {

    /// Information about a provisioned product.
    public struct ProvisionedProductAttribute: Swift.Sendable {
        /// The ARN of the provisioned product.
        public var arn: Swift.String?
        /// The UTC time stamp of the creation time.
        public var createdTime: Foundation.Date?
        /// The identifier of the provisioned product.
        public var id: Swift.String?
        /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token, the same response is returned for each repeated request.
        public var idempotencyToken: Swift.String?
        /// The record identifier of the last request performed on this provisioned product of the following types:
        ///
        /// * ProvisionProduct
        ///
        /// * UpdateProvisionedProduct
        ///
        /// * ExecuteProvisionedProductPlan
        ///
        /// * TerminateProvisionedProduct
        public var lastProvisioningRecordId: Swift.String?
        /// The record identifier of the last request performed on this provisioned product.
        public var lastRecordId: Swift.String?
        /// The record identifier of the last successful request performed on this provisioned product of the following types:
        ///
        /// * ProvisionProduct
        ///
        /// * UpdateProvisionedProduct
        ///
        /// * ExecuteProvisionedProductPlan
        ///
        /// * TerminateProvisionedProduct
        public var lastSuccessfulProvisioningRecordId: Swift.String?
        /// The user-friendly name of the provisioned product.
        public var name: Swift.String?
        /// The assigned identifier for the resource, such as an EC2 instance ID or an S3 bucket name.
        public var physicalId: Swift.String?
        /// The product identifier.
        public var productId: Swift.String?
        /// The name of the product.
        public var productName: Swift.String?
        /// The identifier of the provisioning artifact.
        public var provisioningArtifactId: Swift.String?
        /// The name of the provisioning artifact.
        public var provisioningArtifactName: Swift.String?
        /// The current status of the provisioned product.
        ///
        /// * AVAILABLE - Stable state, ready to perform any operation. The most recent operation succeeded and completed.
        ///
        /// * UNDER_CHANGE - Transitive state. Operations performed might not have valid results. Wait for an AVAILABLE status before performing operations.
        ///
        /// * TAINTED - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.
        ///
        /// * ERROR - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.
        ///
        /// * PLAN_IN_PROGRESS - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an AVAILABLE status before performing operations.
        public var status: ServiceCatalogClientTypes.ProvisionedProductStatus?
        /// The current status message of the provisioned product.
        public var statusMessage: Swift.String?
        /// One or more tags.
        public var tags: [ServiceCatalogClientTypes.Tag]?
        /// The type of provisioned product. The supported values are CFN_STACK, CFN_STACKSET, TERRAFORM_OPEN_SOURCE, TERRAFORM_CLOUD, and EXTERNAL.
        public var type: Swift.String?
        /// The Amazon Resource Name (ARN) of the user.
        public var userArn: Swift.String?
        /// The ARN of the user in the session. This ARN might contain a session ID.
        public var userArnSession: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            idempotencyToken: Swift.String? = nil,
            lastProvisioningRecordId: Swift.String? = nil,
            lastRecordId: Swift.String? = nil,
            lastSuccessfulProvisioningRecordId: Swift.String? = nil,
            name: Swift.String? = nil,
            physicalId: Swift.String? = nil,
            productId: Swift.String? = nil,
            productName: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil,
            provisioningArtifactName: Swift.String? = nil,
            status: ServiceCatalogClientTypes.ProvisionedProductStatus? = nil,
            statusMessage: Swift.String? = nil,
            tags: [ServiceCatalogClientTypes.Tag]? = nil,
            type: Swift.String? = nil,
            userArn: Swift.String? = nil,
            userArnSession: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.idempotencyToken = idempotencyToken
            self.lastProvisioningRecordId = lastProvisioningRecordId
            self.lastRecordId = lastRecordId
            self.lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordId
            self.name = name
            self.physicalId = physicalId
            self.productId = productId
            self.productName = productName
            self.provisioningArtifactId = provisioningArtifactId
            self.provisioningArtifactName = provisioningArtifactName
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
            self.type = type
            self.userArn = userArn
            self.userArnSession = userArnSession
        }
    }
}

public struct SearchProvisionedProductsOutput: Swift.Sendable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the provisioned products.
    public var provisionedProducts: [ServiceCatalogClientTypes.ProvisionedProductAttribute]?
    /// The number of provisioned products found.
    public var totalResultsCount: Swift.Int

    public init(
        nextPageToken: Swift.String? = nil,
        provisionedProducts: [ServiceCatalogClientTypes.ProvisionedProductAttribute]? = nil,
        totalResultsCount: Swift.Int = 0
    )
    {
        self.nextPageToken = nextPageToken
        self.provisionedProducts = provisionedProducts
        self.totalResultsCount = totalResultsCount
    }
}

public struct TerminateProvisionedProductInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// If set to true, Service Catalog stops managing the specified provisioned product even if it cannot delete the underlying resources.
    public var ignoreErrors: Swift.Bool?
    /// The identifier of the provisioned product. You cannot specify both ProvisionedProductName and ProvisionedProductId.
    public var provisionedProductId: Swift.String?
    /// The name of the provisioned product. You cannot specify both ProvisionedProductName and ProvisionedProductId.
    public var provisionedProductName: Swift.String?
    /// When this boolean parameter is set to true, the TerminateProvisionedProduct API deletes the Service Catalog provisioned product. However, it does not remove the CloudFormation stack, stack set, or the underlying resources of the deleted provisioned product. The default value is false.
    public var retainPhysicalResources: Swift.Bool?
    /// An idempotency token that uniquely identifies the termination request. This token is only valid during the termination process. After the provisioned product is terminated, subsequent requests to terminate the same provisioned product always return ResourceNotFound.
    /// This member is required.
    public var terminateToken: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        ignoreErrors: Swift.Bool? = false,
        provisionedProductId: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil,
        retainPhysicalResources: Swift.Bool? = false,
        terminateToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.ignoreErrors = ignoreErrors
        self.provisionedProductId = provisionedProductId
        self.provisionedProductName = provisionedProductName
        self.retainPhysicalResources = retainPhysicalResources
        self.terminateToken = terminateToken
    }
}

public struct TerminateProvisionedProductOutput: Swift.Sendable {
    /// Information about the result of this request.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?

    public init(
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

public struct UpdateConstraintInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The updated description of the constraint.
    public var description: Swift.String?
    /// The identifier of the constraint.
    /// This member is required.
    public var id: Swift.String?
    /// The constraint parameters, in JSON format. The syntax depends on the constraint type as follows: LAUNCH You are required to specify either the RoleArn or the LocalRoleName but can't use both. Specify the RoleArn property as follows: {"RoleArn" : "arn:aws:iam::123456789012:role/LaunchRole"} Specify the LocalRoleName property as follows: {"LocalRoleName": "SCBasicLaunchRole"} If you specify the LocalRoleName property, when an account uses the launch constraint, the IAM role with that name in the account will be used. This allows launch-role constraints to be account-agnostic so the administrator can create fewer resources per shared account. The given role name must exist in the account used to create the launch constraint and the account of the user who launches a product with this launch constraint. You cannot have both a LAUNCH and a STACKSET constraint. You also cannot have more than one LAUNCH constraint on a product and portfolio. NOTIFICATION Specify the NotificationArns property as follows: {"NotificationArns" : ["arn:aws:sns:us-east-1:123456789012:Topic"]} RESOURCE_UPDATE Specify the TagUpdatesOnProvisionedProduct property as follows: {"Version":"2.0","Properties":{"TagUpdateOnProvisionedProduct":"String"}} The TagUpdatesOnProvisionedProduct property accepts a string value of ALLOWED or NOT_ALLOWED. STACKSET Specify the Parameters property as follows: {"Version": "String", "Properties": {"AccountList": [ "String" ], "RegionList": [ "String" ], "AdminRole": "String", "ExecutionRole": "String"}} You cannot have both a LAUNCH and a STACKSET constraint. You also cannot have more than one STACKSET constraint on a product and portfolio. Products with a STACKSET constraint will launch an CloudFormation stack set. TEMPLATE Specify the Rules property. For more information, see [Template Constraint Rules](http://docs.aws.amazon.com/servicecatalog/latest/adminguide/reference-template_constraint_rules.html).
    public var parameters: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        parameters: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.description = description
        self.id = id
        self.parameters = parameters
    }
}

public struct UpdateConstraintOutput: Swift.Sendable {
    /// Information about the constraint.
    public var constraintDetail: ServiceCatalogClientTypes.ConstraintDetail?
    /// The constraint parameters.
    public var constraintParameters: Swift.String?
    /// The status of the current request.
    public var status: ServiceCatalogClientTypes.Status?

    public init(
        constraintDetail: ServiceCatalogClientTypes.ConstraintDetail? = nil,
        constraintParameters: Swift.String? = nil,
        status: ServiceCatalogClientTypes.Status? = nil
    )
    {
        self.constraintDetail = constraintDetail
        self.constraintParameters = constraintParameters
        self.status = status
    }
}

public struct UpdatePortfolioInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The tags to add.
    public var addTags: [ServiceCatalogClientTypes.Tag]?
    /// The updated description of the portfolio.
    public var description: Swift.String?
    /// The name to use for display purposes.
    public var displayName: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var id: Swift.String?
    /// The updated name of the portfolio provider.
    public var providerName: Swift.String?
    /// The tags to remove.
    public var removeTags: [Swift.String]?

    public init(
        acceptLanguage: Swift.String? = nil,
        addTags: [ServiceCatalogClientTypes.Tag]? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        id: Swift.String? = nil,
        providerName: Swift.String? = nil,
        removeTags: [Swift.String]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.addTags = addTags
        self.description = description
        self.displayName = displayName
        self.id = id
        self.providerName = providerName
        self.removeTags = removeTags
    }
}

public struct UpdatePortfolioOutput: Swift.Sendable {
    /// Information about the portfolio.
    public var portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail?
    /// Information about the tags associated with the portfolio.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.portfolioDetail = portfolioDetail
        self.tags = tags
    }
}

public struct UpdatePortfolioShareInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The Amazon Web Services account Id of the recipient account. This field is required when updating an external account to account type share.
    public var accountId: Swift.String?
    /// Information about the organization node.
    public var organizationNode: ServiceCatalogClientTypes.OrganizationNode?
    /// The unique identifier of the portfolio for which the share will be updated.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// A flag to enables or disables Principals sharing in the portfolio. If this field is not provided, the current state of the Principals sharing on the portfolio share will not be modified.
    public var sharePrincipals: Swift.Bool?
    /// Enables or disables TagOptions sharing for the portfolio share. If this field is not provided, the current state of TagOptions sharing on the portfolio share will not be modified.
    public var shareTagOptions: Swift.Bool?

    public init(
        acceptLanguage: Swift.String? = nil,
        accountId: Swift.String? = nil,
        organizationNode: ServiceCatalogClientTypes.OrganizationNode? = nil,
        portfolioId: Swift.String? = nil,
        sharePrincipals: Swift.Bool? = nil,
        shareTagOptions: Swift.Bool? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accountId = accountId
        self.organizationNode = organizationNode
        self.portfolioId = portfolioId
        self.sharePrincipals = sharePrincipals
        self.shareTagOptions = shareTagOptions
    }
}

public struct UpdatePortfolioShareOutput: Swift.Sendable {
    /// The token that tracks the status of the UpdatePortfolioShare operation for external account to account or organizational type sharing.
    public var portfolioShareToken: Swift.String?
    /// The status of UpdatePortfolioShare operation. You can also obtain the operation status using DescribePortfolioShareStatus API.
    public var status: ServiceCatalogClientTypes.ShareStatus?

    public init(
        portfolioShareToken: Swift.String? = nil,
        status: ServiceCatalogClientTypes.ShareStatus? = nil
    )
    {
        self.portfolioShareToken = portfolioShareToken
        self.status = status
    }
}

public struct UpdateProductInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The tags to add to the product.
    public var addTags: [ServiceCatalogClientTypes.Tag]?
    /// The updated description of the product.
    public var description: Swift.String?
    /// The updated distributor of the product.
    public var distributor: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var id: Swift.String?
    /// The updated product name.
    public var name: Swift.String?
    /// The updated owner of the product.
    public var owner: Swift.String?
    /// The tags to remove from the product.
    public var removeTags: [Swift.String]?
    /// Specifies connection details for the updated product and syncs the product to the connection source artifact. This automatically manages the product's artifacts based on changes to the source. The SourceConnection parameter consists of the following sub-fields.
    ///
    /// * Type
    ///
    /// * ConnectionParamters
    public var sourceConnection: ServiceCatalogClientTypes.SourceConnection?
    /// The updated support description for the product.
    public var supportDescription: Swift.String?
    /// The updated support email for the product.
    public var supportEmail: Swift.String?
    /// The updated support URL for the product.
    public var supportUrl: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        addTags: [ServiceCatalogClientTypes.Tag]? = nil,
        description: Swift.String? = nil,
        distributor: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        owner: Swift.String? = nil,
        removeTags: [Swift.String]? = nil,
        sourceConnection: ServiceCatalogClientTypes.SourceConnection? = nil,
        supportDescription: Swift.String? = nil,
        supportEmail: Swift.String? = nil,
        supportUrl: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.addTags = addTags
        self.description = description
        self.distributor = distributor
        self.id = id
        self.name = name
        self.owner = owner
        self.removeTags = removeTags
        self.sourceConnection = sourceConnection
        self.supportDescription = supportDescription
        self.supportEmail = supportEmail
        self.supportUrl = supportUrl
    }
}

public struct UpdateProductOutput: Swift.Sendable {
    /// Information about the product view.
    public var productViewDetail: ServiceCatalogClientTypes.ProductViewDetail?
    /// Information about the tags associated with the product.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init(
        productViewDetail: ServiceCatalogClientTypes.ProductViewDetail? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.productViewDetail = productViewDetail
        self.tags = tags
    }
}

extension ServiceCatalogClientTypes {

    public enum StackSetOperationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [StackSetOperationType] {
            return [
                .create,
                .delete,
                .update
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceCatalogClientTypes {

    /// The user-defined preferences that will be applied when updating a provisioned product. Not all preferences are applicable to all provisioned product types.
    public struct UpdateProvisioningPreferences: Swift.Sendable {
        /// One or more Amazon Web Services accounts that will have access to the provisioned product. Applicable only to a CFN_STACKSET provisioned product type. The Amazon Web Services accounts specified should be within the list of accounts in the STACKSET constraint. To get the list of accounts in the STACKSET constraint, use the DescribeProvisioningParameters operation. If no values are specified, the default value is all accounts from the STACKSET constraint.
        public var stackSetAccounts: [Swift.String]?
        /// The number of accounts, per Region, for which this operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetFailureToleranceCount or StackSetFailureTolerancePercentage, but not both. The default value is 0 if no value is specified.
        public var stackSetFailureToleranceCount: Swift.Int?
        /// The percentage of accounts, per Region, for which this stack operation can fail before Service Catalog stops the operation in that Region. If the operation is stopped in a Region, Service Catalog doesn't attempt the operation in any subsequent Regions. When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetFailureToleranceCount or StackSetFailureTolerancePercentage, but not both.
        public var stackSetFailureTolerancePercentage: Swift.Int?
        /// The maximum number of accounts in which to perform this operation at one time. This is dependent on the value of StackSetFailureToleranceCount. StackSetMaxConcurrentCount is at most one more than the StackSetFailureToleranceCount. Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetMaxConcurrentCount or StackSetMaxConcurrentPercentage, but not both.
        public var stackSetMaxConcurrencyCount: Swift.Int?
        /// The maximum percentage of accounts in which to perform this operation at one time. When calculating the number of accounts based on the specified percentage, Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, Service Catalog sets the number as 1 instead. Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling. Applicable only to a CFN_STACKSET provisioned product type. Conditional: You must specify either StackSetMaxConcurrentCount or StackSetMaxConcurrentPercentage, but not both.
        public var stackSetMaxConcurrencyPercentage: Swift.Int?
        /// Determines what action Service Catalog performs to a stack set or a stack instance represented by the provisioned product. The default value is UPDATE if nothing is specified. Applicable only to a CFN_STACKSET provisioned product type. CREATE Creates a new stack instance in the stack set represented by the provisioned product. In this case, only new stack instances are created based on accounts and Regions; if new ProductId or ProvisioningArtifactID are passed, they will be ignored. UPDATE Updates the stack set represented by the provisioned product and also its stack instances. DELETE Deletes a stack instance in the stack set represented by the provisioned product.
        public var stackSetOperationType: ServiceCatalogClientTypes.StackSetOperationType?
        /// One or more Amazon Web Services Regions where the provisioned product will be available. Applicable only to a CFN_STACKSET provisioned product type. The specified Regions should be within the list of Regions from the STACKSET constraint. To get the list of Regions in the STACKSET constraint, use the DescribeProvisioningParameters operation. If no values are specified, the default value is all Regions from the STACKSET constraint.
        public var stackSetRegions: [Swift.String]?

        public init(
            stackSetAccounts: [Swift.String]? = nil,
            stackSetFailureToleranceCount: Swift.Int? = nil,
            stackSetFailureTolerancePercentage: Swift.Int? = nil,
            stackSetMaxConcurrencyCount: Swift.Int? = nil,
            stackSetMaxConcurrencyPercentage: Swift.Int? = nil,
            stackSetOperationType: ServiceCatalogClientTypes.StackSetOperationType? = nil,
            stackSetRegions: [Swift.String]? = nil
        )
        {
            self.stackSetAccounts = stackSetAccounts
            self.stackSetFailureToleranceCount = stackSetFailureToleranceCount
            self.stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentage
            self.stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCount
            self.stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentage
            self.stackSetOperationType = stackSetOperationType
            self.stackSetRegions = stackSetRegions
        }
    }
}

public struct UpdateProvisionedProductInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The path identifier. This value is optional if the product has a default path, and required if the product has more than one path. You must provide the name or ID, but not both.
    public var pathId: Swift.String?
    /// The name of the path. You must provide the name or ID, but not both.
    public var pathName: Swift.String?
    /// The identifier of the product. You must provide the name or ID, but not both.
    public var productId: Swift.String?
    /// The name of the product. You must provide the name or ID, but not both.
    public var productName: Swift.String?
    /// The identifier of the provisioned product. You must provide the name or ID, but not both.
    public var provisionedProductId: Swift.String?
    /// The name of the provisioned product. You cannot specify both ProvisionedProductName and ProvisionedProductId.
    public var provisionedProductName: Swift.String?
    /// The identifier of the provisioning artifact.
    public var provisioningArtifactId: Swift.String?
    /// The name of the provisioning artifact. You must provide the name or ID, but not both.
    public var provisioningArtifactName: Swift.String?
    /// The new parameters.
    public var provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]?
    /// An object that contains information about the provisioning preferences for a stack set.
    public var provisioningPreferences: ServiceCatalogClientTypes.UpdateProvisioningPreferences?
    /// One or more tags. Requires the product to have RESOURCE_UPDATE constraint with TagUpdatesOnProvisionedProduct set to ALLOWED to allow tag updates.
    public var tags: [ServiceCatalogClientTypes.Tag]?
    /// The idempotency token that uniquely identifies the provisioning update request.
    /// This member is required.
    public var updateToken: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        pathId: Swift.String? = nil,
        pathName: Swift.String? = nil,
        productId: Swift.String? = nil,
        productName: Swift.String? = nil,
        provisionedProductId: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        provisioningArtifactName: Swift.String? = nil,
        provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]? = nil,
        provisioningPreferences: ServiceCatalogClientTypes.UpdateProvisioningPreferences? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil,
        updateToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pathId = pathId
        self.pathName = pathName
        self.productId = productId
        self.productName = productName
        self.provisionedProductId = provisionedProductId
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningArtifactName = provisioningArtifactName
        self.provisioningParameters = provisioningParameters
        self.provisioningPreferences = provisioningPreferences
        self.tags = tags
        self.updateToken = updateToken
    }
}

public struct UpdateProvisionedProductOutput: Swift.Sendable {
    /// Information about the result of the request.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?

    public init(
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

extension ServiceCatalogClientTypes {

    public enum PropertyKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case launchrole
        case owner
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyKey] {
            return [
                .launchrole,
                .owner
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .launchrole: return "LAUNCH_ROLE"
            case .owner: return "OWNER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateProvisionedProductPropertiesInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// The idempotency token that uniquely identifies the provisioning product update request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The identifier of the provisioned product.
    /// This member is required.
    public var provisionedProductId: Swift.String?
    /// A map that contains the provisioned product properties to be updated. The LAUNCH_ROLE key accepts role ARNs. This key allows an administrator to call UpdateProvisionedProductProperties to update the launch role that is associated with a provisioned product. This role is used when an end user calls a provisioning operation such as UpdateProvisionedProduct, TerminateProvisionedProduct, or ExecuteProvisionedProductServiceAction. Only a role ARN is valid. A user ARN is invalid. The OWNER key accepts user ARNs, IAM role ARNs, and STS assumed-role ARNs. The owner is the user that has permission to see, update, terminate, and execute service actions in the provisioned product. The administrator can change the owner of a provisioned product to another IAM or STS entity within the same account. Both end user owners and administrators can see ownership history of the provisioned product using the ListRecordHistory API. The new owner can describe all past records for the provisioned product using the DescribeRecord API. The previous owner can no longer use DescribeRecord, but can still see the product's history from when he was an owner using ListRecordHistory. If a provisioned product ownership is assigned to an end user, they can see and perform any action through the API or Service Catalog console such as update, terminate, and execute service actions. If an end user provisions a product and the owner is updated to someone else, they will no longer be able to see or perform any actions through API or the Service Catalog console on that provisioned product.
    /// This member is required.
    public var provisionedProductProperties: [Swift.String: Swift.String]?

    public init(
        acceptLanguage: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        provisionedProductId: Swift.String? = nil,
        provisionedProductProperties: [Swift.String: Swift.String]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.provisionedProductId = provisionedProductId
        self.provisionedProductProperties = provisionedProductProperties
    }
}

public struct UpdateProvisionedProductPropertiesOutput: Swift.Sendable {
    /// The provisioned product identifier.
    public var provisionedProductId: Swift.String?
    /// A map that contains the properties updated.
    public var provisionedProductProperties: [Swift.String: Swift.String]?
    /// The identifier of the record.
    public var recordId: Swift.String?
    /// The status of the request.
    public var status: ServiceCatalogClientTypes.RecordStatus?

    public init(
        provisionedProductId: Swift.String? = nil,
        provisionedProductProperties: [Swift.String: Swift.String]? = nil,
        recordId: Swift.String? = nil,
        status: ServiceCatalogClientTypes.RecordStatus? = nil
    )
    {
        self.provisionedProductId = provisionedProductId
        self.provisionedProductProperties = provisionedProductProperties
        self.recordId = recordId
        self.status = status
    }
}

public struct UpdateProvisioningArtifactInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// Indicates whether the product version is active. Inactive provisioning artifacts are invisible to end users. End users cannot launch or update a provisioned product from an inactive provisioning artifact.
    public var active: Swift.Bool?
    /// The updated description of the provisioning artifact.
    public var description: Swift.String?
    /// Information set by the administrator to provide guidance to end users about which provisioning artifacts to use. The DEFAULT value indicates that the product version is active. The administrator can set the guidance to DEPRECATED to inform users that the product version is deprecated. Users are able to make updates to a provisioned product of a deprecated version but cannot launch new provisioned products using a deprecated version.
    public var guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance?
    /// The updated name of the provisioning artifact.
    public var name: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?
    /// The identifier of the provisioning artifact.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        active: Swift.Bool? = nil,
        description: Swift.String? = nil,
        guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance? = nil,
        name: Swift.String? = nil,
        productId: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.active = active
        self.description = description
        self.guidance = guidance
        self.name = name
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
    }
}

public struct UpdateProvisioningArtifactOutput: Swift.Sendable {
    /// The URL of the CloudFormation template in Amazon S3 or GitHub in JSON format.
    public var info: [Swift.String: Swift.String]?
    /// Information about the provisioning artifact.
    public var provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    /// The status of the current request.
    public var status: ServiceCatalogClientTypes.Status?

    public init(
        info: [Swift.String: Swift.String]? = nil,
        provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail? = nil,
        status: ServiceCatalogClientTypes.Status? = nil
    )
    {
        self.info = info
        self.provisioningArtifactDetail = provisioningArtifactDetail
        self.status = status
    }
}

public struct UpdateServiceActionInput: Swift.Sendable {
    /// The language code.
    ///
    /// * jp - Japanese
    ///
    /// * zh - Chinese
    public var acceptLanguage: Swift.String?
    /// A map that defines the self-service action.
    public var definition: [Swift.String: Swift.String]?
    /// The self-service action description.
    public var description: Swift.String?
    /// The self-service action identifier.
    /// This member is required.
    public var id: Swift.String?
    /// The self-service action name.
    public var name: Swift.String?

    public init(
        acceptLanguage: Swift.String? = nil,
        definition: [Swift.String: Swift.String]? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.definition = definition
        self.description = description
        self.id = id
        self.name = name
    }
}

public struct UpdateServiceActionOutput: Swift.Sendable {
    /// Detailed information about the self-service action.
    public var serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail?

    public init(
        serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail? = nil
    )
    {
        self.serviceActionDetail = serviceActionDetail
    }
}

public struct UpdateTagOptionInput: Swift.Sendable {
    /// The updated active state.
    public var active: Swift.Bool?
    /// The TagOption identifier.
    /// This member is required.
    public var id: Swift.String?
    /// The updated value.
    public var value: Swift.String?

    public init(
        active: Swift.Bool? = nil,
        id: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.active = active
        self.id = id
        self.value = value
    }
}

public struct UpdateTagOptionOutput: Swift.Sendable {
    /// Information about the TagOption.
    public var tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail?

    public init(
        tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail? = nil
    )
    {
        self.tagOptionDetail = tagOptionDetail
    }
}

extension AcceptPortfolioShareInput {

    static func urlPathProvider(_ value: AcceptPortfolioShareInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateBudgetWithResourceInput {

    static func urlPathProvider(_ value: AssociateBudgetWithResourceInput) -> Swift.String? {
        return "/"
    }
}

extension AssociatePrincipalWithPortfolioInput {

    static func urlPathProvider(_ value: AssociatePrincipalWithPortfolioInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateProductWithPortfolioInput {

    static func urlPathProvider(_ value: AssociateProductWithPortfolioInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateServiceActionWithProvisioningArtifactInput {

    static func urlPathProvider(_ value: AssociateServiceActionWithProvisioningArtifactInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateTagOptionWithResourceInput {

    static func urlPathProvider(_ value: AssociateTagOptionWithResourceInput) -> Swift.String? {
        return "/"
    }
}

extension BatchAssociateServiceActionWithProvisioningArtifactInput {

    static func urlPathProvider(_ value: BatchAssociateServiceActionWithProvisioningArtifactInput) -> Swift.String? {
        return "/"
    }
}

extension BatchDisassociateServiceActionFromProvisioningArtifactInput {

    static func urlPathProvider(_ value: BatchDisassociateServiceActionFromProvisioningArtifactInput) -> Swift.String? {
        return "/"
    }
}

extension CopyProductInput {

    static func urlPathProvider(_ value: CopyProductInput) -> Swift.String? {
        return "/"
    }
}

extension CreateConstraintInput {

    static func urlPathProvider(_ value: CreateConstraintInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePortfolioInput {

    static func urlPathProvider(_ value: CreatePortfolioInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePortfolioShareInput {

    static func urlPathProvider(_ value: CreatePortfolioShareInput) -> Swift.String? {
        return "/"
    }
}

extension CreateProductInput {

    static func urlPathProvider(_ value: CreateProductInput) -> Swift.String? {
        return "/"
    }
}

extension CreateProvisionedProductPlanInput {

    static func urlPathProvider(_ value: CreateProvisionedProductPlanInput) -> Swift.String? {
        return "/"
    }
}

extension CreateProvisioningArtifactInput {

    static func urlPathProvider(_ value: CreateProvisioningArtifactInput) -> Swift.String? {
        return "/"
    }
}

extension CreateServiceActionInput {

    static func urlPathProvider(_ value: CreateServiceActionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTagOptionInput {

    static func urlPathProvider(_ value: CreateTagOptionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteConstraintInput {

    static func urlPathProvider(_ value: DeleteConstraintInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePortfolioInput {

    static func urlPathProvider(_ value: DeletePortfolioInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePortfolioShareInput {

    static func urlPathProvider(_ value: DeletePortfolioShareInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteProductInput {

    static func urlPathProvider(_ value: DeleteProductInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteProvisionedProductPlanInput {

    static func urlPathProvider(_ value: DeleteProvisionedProductPlanInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteProvisioningArtifactInput {

    static func urlPathProvider(_ value: DeleteProvisioningArtifactInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteServiceActionInput {

    static func urlPathProvider(_ value: DeleteServiceActionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTagOptionInput {

    static func urlPathProvider(_ value: DeleteTagOptionInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConstraintInput {

    static func urlPathProvider(_ value: DescribeConstraintInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeCopyProductStatusInput {

    static func urlPathProvider(_ value: DescribeCopyProductStatusInput) -> Swift.String? {
        return "/"
    }
}

extension DescribePortfolioInput {

    static func urlPathProvider(_ value: DescribePortfolioInput) -> Swift.String? {
        return "/"
    }
}

extension DescribePortfolioSharesInput {

    static func urlPathProvider(_ value: DescribePortfolioSharesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribePortfolioShareStatusInput {

    static func urlPathProvider(_ value: DescribePortfolioShareStatusInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeProductInput {

    static func urlPathProvider(_ value: DescribeProductInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeProductAsAdminInput {

    static func urlPathProvider(_ value: DescribeProductAsAdminInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeProductViewInput {

    static func urlPathProvider(_ value: DescribeProductViewInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeProvisionedProductInput {

    static func urlPathProvider(_ value: DescribeProvisionedProductInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeProvisionedProductPlanInput {

    static func urlPathProvider(_ value: DescribeProvisionedProductPlanInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeProvisioningArtifactInput {

    static func urlPathProvider(_ value: DescribeProvisioningArtifactInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeProvisioningParametersInput {

    static func urlPathProvider(_ value: DescribeProvisioningParametersInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRecordInput {

    static func urlPathProvider(_ value: DescribeRecordInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeServiceActionInput {

    static func urlPathProvider(_ value: DescribeServiceActionInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeServiceActionExecutionParametersInput {

    static func urlPathProvider(_ value: DescribeServiceActionExecutionParametersInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeTagOptionInput {

    static func urlPathProvider(_ value: DescribeTagOptionInput) -> Swift.String? {
        return "/"
    }
}

extension DisableAWSOrganizationsAccessInput {

    static func urlPathProvider(_ value: DisableAWSOrganizationsAccessInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateBudgetFromResourceInput {

    static func urlPathProvider(_ value: DisassociateBudgetFromResourceInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociatePrincipalFromPortfolioInput {

    static func urlPathProvider(_ value: DisassociatePrincipalFromPortfolioInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateProductFromPortfolioInput {

    static func urlPathProvider(_ value: DisassociateProductFromPortfolioInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateServiceActionFromProvisioningArtifactInput {

    static func urlPathProvider(_ value: DisassociateServiceActionFromProvisioningArtifactInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateTagOptionFromResourceInput {

    static func urlPathProvider(_ value: DisassociateTagOptionFromResourceInput) -> Swift.String? {
        return "/"
    }
}

extension EnableAWSOrganizationsAccessInput {

    static func urlPathProvider(_ value: EnableAWSOrganizationsAccessInput) -> Swift.String? {
        return "/"
    }
}

extension ExecuteProvisionedProductPlanInput {

    static func urlPathProvider(_ value: ExecuteProvisionedProductPlanInput) -> Swift.String? {
        return "/"
    }
}

extension ExecuteProvisionedProductServiceActionInput {

    static func urlPathProvider(_ value: ExecuteProvisionedProductServiceActionInput) -> Swift.String? {
        return "/"
    }
}

extension GetAWSOrganizationsAccessStatusInput {

    static func urlPathProvider(_ value: GetAWSOrganizationsAccessStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetProvisionedProductOutputsInput {

    static func urlPathProvider(_ value: GetProvisionedProductOutputsInput) -> Swift.String? {
        return "/"
    }
}

extension ImportAsProvisionedProductInput {

    static func urlPathProvider(_ value: ImportAsProvisionedProductInput) -> Swift.String? {
        return "/"
    }
}

extension ListAcceptedPortfolioSharesInput {

    static func urlPathProvider(_ value: ListAcceptedPortfolioSharesInput) -> Swift.String? {
        return "/"
    }
}

extension ListBudgetsForResourceInput {

    static func urlPathProvider(_ value: ListBudgetsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListConstraintsForPortfolioInput {

    static func urlPathProvider(_ value: ListConstraintsForPortfolioInput) -> Swift.String? {
        return "/"
    }
}

extension ListLaunchPathsInput {

    static func urlPathProvider(_ value: ListLaunchPathsInput) -> Swift.String? {
        return "/"
    }
}

extension ListOrganizationPortfolioAccessInput {

    static func urlPathProvider(_ value: ListOrganizationPortfolioAccessInput) -> Swift.String? {
        return "/"
    }
}

extension ListPortfolioAccessInput {

    static func urlPathProvider(_ value: ListPortfolioAccessInput) -> Swift.String? {
        return "/"
    }
}

extension ListPortfoliosInput {

    static func urlPathProvider(_ value: ListPortfoliosInput) -> Swift.String? {
        return "/"
    }
}

extension ListPortfoliosForProductInput {

    static func urlPathProvider(_ value: ListPortfoliosForProductInput) -> Swift.String? {
        return "/"
    }
}

extension ListPrincipalsForPortfolioInput {

    static func urlPathProvider(_ value: ListPrincipalsForPortfolioInput) -> Swift.String? {
        return "/"
    }
}

extension ListProvisionedProductPlansInput {

    static func urlPathProvider(_ value: ListProvisionedProductPlansInput) -> Swift.String? {
        return "/"
    }
}

extension ListProvisioningArtifactsInput {

    static func urlPathProvider(_ value: ListProvisioningArtifactsInput) -> Swift.String? {
        return "/"
    }
}

extension ListProvisioningArtifactsForServiceActionInput {

    static func urlPathProvider(_ value: ListProvisioningArtifactsForServiceActionInput) -> Swift.String? {
        return "/"
    }
}

extension ListRecordHistoryInput {

    static func urlPathProvider(_ value: ListRecordHistoryInput) -> Swift.String? {
        return "/"
    }
}

extension ListResourcesForTagOptionInput {

    static func urlPathProvider(_ value: ListResourcesForTagOptionInput) -> Swift.String? {
        return "/"
    }
}

extension ListServiceActionsInput {

    static func urlPathProvider(_ value: ListServiceActionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListServiceActionsForProvisioningArtifactInput {

    static func urlPathProvider(_ value: ListServiceActionsForProvisioningArtifactInput) -> Swift.String? {
        return "/"
    }
}

extension ListStackInstancesForProvisionedProductInput {

    static func urlPathProvider(_ value: ListStackInstancesForProvisionedProductInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagOptionsInput {

    static func urlPathProvider(_ value: ListTagOptionsInput) -> Swift.String? {
        return "/"
    }
}

extension NotifyProvisionProductEngineWorkflowResultInput {

    static func urlPathProvider(_ value: NotifyProvisionProductEngineWorkflowResultInput) -> Swift.String? {
        return "/"
    }
}

extension NotifyTerminateProvisionedProductEngineWorkflowResultInput {

    static func urlPathProvider(_ value: NotifyTerminateProvisionedProductEngineWorkflowResultInput) -> Swift.String? {
        return "/"
    }
}

extension NotifyUpdateProvisionedProductEngineWorkflowResultInput {

    static func urlPathProvider(_ value: NotifyUpdateProvisionedProductEngineWorkflowResultInput) -> Swift.String? {
        return "/"
    }
}

extension ProvisionProductInput {

    static func urlPathProvider(_ value: ProvisionProductInput) -> Swift.String? {
        return "/"
    }
}

extension RejectPortfolioShareInput {

    static func urlPathProvider(_ value: RejectPortfolioShareInput) -> Swift.String? {
        return "/"
    }
}

extension ScanProvisionedProductsInput {

    static func urlPathProvider(_ value: ScanProvisionedProductsInput) -> Swift.String? {
        return "/"
    }
}

extension SearchProductsInput {

    static func urlPathProvider(_ value: SearchProductsInput) -> Swift.String? {
        return "/"
    }
}

extension SearchProductsAsAdminInput {

    static func urlPathProvider(_ value: SearchProductsAsAdminInput) -> Swift.String? {
        return "/"
    }
}

extension SearchProvisionedProductsInput {

    static func urlPathProvider(_ value: SearchProvisionedProductsInput) -> Swift.String? {
        return "/"
    }
}

extension TerminateProvisionedProductInput {

    static func urlPathProvider(_ value: TerminateProvisionedProductInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateConstraintInput {

    static func urlPathProvider(_ value: UpdateConstraintInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePortfolioInput {

    static func urlPathProvider(_ value: UpdatePortfolioInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePortfolioShareInput {

    static func urlPathProvider(_ value: UpdatePortfolioShareInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateProductInput {

    static func urlPathProvider(_ value: UpdateProductInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateProvisionedProductInput {

    static func urlPathProvider(_ value: UpdateProvisionedProductInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateProvisionedProductPropertiesInput {

    static func urlPathProvider(_ value: UpdateProvisionedProductPropertiesInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateProvisioningArtifactInput {

    static func urlPathProvider(_ value: UpdateProvisioningArtifactInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateServiceActionInput {

    static func urlPathProvider(_ value: UpdateServiceActionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateTagOptionInput {

    static func urlPathProvider(_ value: UpdateTagOptionInput) -> Swift.String? {
        return "/"
    }
}

extension AcceptPortfolioShareInput {

    static func write(value: AcceptPortfolioShareInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PortfolioId"].write(value.portfolioId)
        try writer["PortfolioShareType"].write(value.portfolioShareType)
    }
}

extension AssociateBudgetWithResourceInput {

    static func write(value: AssociateBudgetWithResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BudgetName"].write(value.budgetName)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension AssociatePrincipalWithPortfolioInput {

    static func write(value: AssociatePrincipalWithPortfolioInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PortfolioId"].write(value.portfolioId)
        try writer["PrincipalARN"].write(value.principalARN)
        try writer["PrincipalType"].write(value.principalType)
    }
}

extension AssociateProductWithPortfolioInput {

    static func write(value: AssociateProductWithPortfolioInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PortfolioId"].write(value.portfolioId)
        try writer["ProductId"].write(value.productId)
        try writer["SourcePortfolioId"].write(value.sourcePortfolioId)
    }
}

extension AssociateServiceActionWithProvisioningArtifactInput {

    static func write(value: AssociateServiceActionWithProvisioningArtifactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["ProductId"].write(value.productId)
        try writer["ProvisioningArtifactId"].write(value.provisioningArtifactId)
        try writer["ServiceActionId"].write(value.serviceActionId)
    }
}

extension AssociateTagOptionWithResourceInput {

    static func write(value: AssociateTagOptionWithResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceId"].write(value.resourceId)
        try writer["TagOptionId"].write(value.tagOptionId)
    }
}

extension BatchAssociateServiceActionWithProvisioningArtifactInput {

    static func write(value: BatchAssociateServiceActionWithProvisioningArtifactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["ServiceActionAssociations"].writeList(value.serviceActionAssociations, memberWritingClosure: ServiceCatalogClientTypes.ServiceActionAssociation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDisassociateServiceActionFromProvisioningArtifactInput {

    static func write(value: BatchDisassociateServiceActionFromProvisioningArtifactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["ServiceActionAssociations"].writeList(value.serviceActionAssociations, memberWritingClosure: ServiceCatalogClientTypes.ServiceActionAssociation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CopyProductInput {

    static func write(value: CopyProductInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["CopyOptions"].writeList(value.copyOptions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ServiceCatalogClientTypes.CopyOption>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["SourceProductArn"].write(value.sourceProductArn)
        try writer["SourceProvisioningArtifactIdentifiers"].writeList(value.sourceProvisioningArtifactIdentifiers, memberWritingClosure: SmithyReadWrite.mapWritingClosure(valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetProductId"].write(value.targetProductId)
        try writer["TargetProductName"].write(value.targetProductName)
    }
}

extension CreateConstraintInput {

    static func write(value: CreateConstraintInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Description"].write(value.description)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["Parameters"].write(value.parameters)
        try writer["PortfolioId"].write(value.portfolioId)
        try writer["ProductId"].write(value.productId)
        try writer["Type"].write(value.type)
    }
}

extension CreatePortfolioInput {

    static func write(value: CreatePortfolioInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Description"].write(value.description)
        try writer["DisplayName"].write(value.displayName)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["ProviderName"].write(value.providerName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ServiceCatalogClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreatePortfolioShareInput {

    static func write(value: CreatePortfolioShareInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["AccountId"].write(value.accountId)
        try writer["OrganizationNode"].write(value.organizationNode, with: ServiceCatalogClientTypes.OrganizationNode.write(value:to:))
        try writer["PortfolioId"].write(value.portfolioId)
        try writer["SharePrincipals"].write(value.sharePrincipals)
        try writer["ShareTagOptions"].write(value.shareTagOptions)
    }
}

extension CreateProductInput {

    static func write(value: CreateProductInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Description"].write(value.description)
        try writer["Distributor"].write(value.distributor)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["Name"].write(value.name)
        try writer["Owner"].write(value.owner)
        try writer["ProductType"].write(value.productType)
        try writer["ProvisioningArtifactParameters"].write(value.provisioningArtifactParameters, with: ServiceCatalogClientTypes.ProvisioningArtifactProperties.write(value:to:))
        try writer["SourceConnection"].write(value.sourceConnection, with: ServiceCatalogClientTypes.SourceConnection.write(value:to:))
        try writer["SupportDescription"].write(value.supportDescription)
        try writer["SupportEmail"].write(value.supportEmail)
        try writer["SupportUrl"].write(value.supportUrl)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ServiceCatalogClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateProvisionedProductPlanInput {

    static func write(value: CreateProvisionedProductPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["NotificationArns"].writeList(value.notificationArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PathId"].write(value.pathId)
        try writer["PlanName"].write(value.planName)
        try writer["PlanType"].write(value.planType)
        try writer["ProductId"].write(value.productId)
        try writer["ProvisionedProductName"].write(value.provisionedProductName)
        try writer["ProvisioningArtifactId"].write(value.provisioningArtifactId)
        try writer["ProvisioningParameters"].writeList(value.provisioningParameters, memberWritingClosure: ServiceCatalogClientTypes.UpdateProvisioningParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ServiceCatalogClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateProvisioningArtifactInput {

    static func write(value: CreateProvisioningArtifactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["Parameters"].write(value.parameters, with: ServiceCatalogClientTypes.ProvisioningArtifactProperties.write(value:to:))
        try writer["ProductId"].write(value.productId)
    }
}

extension CreateServiceActionInput {

    static func write(value: CreateServiceActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Definition"].writeMap(value.definition, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["DefinitionType"].write(value.definitionType)
        try writer["Description"].write(value.description)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["Name"].write(value.name)
    }
}

extension CreateTagOptionInput {

    static func write(value: CreateTagOptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }
}

extension DeleteConstraintInput {

    static func write(value: DeleteConstraintInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Id"].write(value.id)
    }
}

extension DeletePortfolioInput {

    static func write(value: DeletePortfolioInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Id"].write(value.id)
    }
}

extension DeletePortfolioShareInput {

    static func write(value: DeletePortfolioShareInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["AccountId"].write(value.accountId)
        try writer["OrganizationNode"].write(value.organizationNode, with: ServiceCatalogClientTypes.OrganizationNode.write(value:to:))
        try writer["PortfolioId"].write(value.portfolioId)
    }
}

extension DeleteProductInput {

    static func write(value: DeleteProductInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Id"].write(value.id)
    }
}

extension DeleteProvisionedProductPlanInput {

    static func write(value: DeleteProvisionedProductPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["IgnoreErrors"].write(value.ignoreErrors)
        try writer["PlanId"].write(value.planId)
    }
}

extension DeleteProvisioningArtifactInput {

    static func write(value: DeleteProvisioningArtifactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["ProductId"].write(value.productId)
        try writer["ProvisioningArtifactId"].write(value.provisioningArtifactId)
    }
}

extension DeleteServiceActionInput {

    static func write(value: DeleteServiceActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Id"].write(value.id)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
    }
}

extension DeleteTagOptionInput {

    static func write(value: DeleteTagOptionInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribeConstraintInput {

    static func write(value: DescribeConstraintInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Id"].write(value.id)
    }
}

extension DescribeCopyProductStatusInput {

    static func write(value: DescribeCopyProductStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["CopyProductToken"].write(value.copyProductToken)
    }
}

extension DescribePortfolioInput {

    static func write(value: DescribePortfolioInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Id"].write(value.id)
    }
}

extension DescribePortfolioSharesInput {

    static func write(value: DescribePortfolioSharesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
        try writer["PortfolioId"].write(value.portfolioId)
        try writer["Type"].write(value.type)
    }
}

extension DescribePortfolioShareStatusInput {

    static func write(value: DescribePortfolioShareStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PortfolioShareToken"].write(value.portfolioShareToken)
    }
}

extension DescribeProductInput {

    static func write(value: DescribeProductInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Id"].write(value.id)
        try writer["Name"].write(value.name)
    }
}

extension DescribeProductAsAdminInput {

    static func write(value: DescribeProductAsAdminInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Id"].write(value.id)
        try writer["Name"].write(value.name)
        try writer["SourcePortfolioId"].write(value.sourcePortfolioId)
    }
}

extension DescribeProductViewInput {

    static func write(value: DescribeProductViewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Id"].write(value.id)
    }
}

extension DescribeProvisionedProductInput {

    static func write(value: DescribeProvisionedProductInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Id"].write(value.id)
        try writer["Name"].write(value.name)
    }
}

extension DescribeProvisionedProductPlanInput {

    static func write(value: DescribeProvisionedProductPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
        try writer["PlanId"].write(value.planId)
    }
}

extension DescribeProvisioningArtifactInput {

    static func write(value: DescribeProvisioningArtifactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["IncludeProvisioningArtifactParameters"].write(value.includeProvisioningArtifactParameters)
        try writer["ProductId"].write(value.productId)
        try writer["ProductName"].write(value.productName)
        try writer["ProvisioningArtifactId"].write(value.provisioningArtifactId)
        try writer["ProvisioningArtifactName"].write(value.provisioningArtifactName)
        try writer["Verbose"].write(value.verbose)
    }
}

extension DescribeProvisioningParametersInput {

    static func write(value: DescribeProvisioningParametersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PathId"].write(value.pathId)
        try writer["PathName"].write(value.pathName)
        try writer["ProductId"].write(value.productId)
        try writer["ProductName"].write(value.productName)
        try writer["ProvisioningArtifactId"].write(value.provisioningArtifactId)
        try writer["ProvisioningArtifactName"].write(value.provisioningArtifactName)
    }
}

extension DescribeRecordInput {

    static func write(value: DescribeRecordInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Id"].write(value.id)
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
    }
}

extension DescribeServiceActionInput {

    static func write(value: DescribeServiceActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Id"].write(value.id)
    }
}

extension DescribeServiceActionExecutionParametersInput {

    static func write(value: DescribeServiceActionExecutionParametersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["ProvisionedProductId"].write(value.provisionedProductId)
        try writer["ServiceActionId"].write(value.serviceActionId)
    }
}

extension DescribeTagOptionInput {

    static func write(value: DescribeTagOptionInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DisableAWSOrganizationsAccessInput {

    static func write(value: DisableAWSOrganizationsAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DisassociateBudgetFromResourceInput {

    static func write(value: DisassociateBudgetFromResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BudgetName"].write(value.budgetName)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension DisassociatePrincipalFromPortfolioInput {

    static func write(value: DisassociatePrincipalFromPortfolioInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PortfolioId"].write(value.portfolioId)
        try writer["PrincipalARN"].write(value.principalARN)
        try writer["PrincipalType"].write(value.principalType)
    }
}

extension DisassociateProductFromPortfolioInput {

    static func write(value: DisassociateProductFromPortfolioInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PortfolioId"].write(value.portfolioId)
        try writer["ProductId"].write(value.productId)
    }
}

extension DisassociateServiceActionFromProvisioningArtifactInput {

    static func write(value: DisassociateServiceActionFromProvisioningArtifactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["ProductId"].write(value.productId)
        try writer["ProvisioningArtifactId"].write(value.provisioningArtifactId)
        try writer["ServiceActionId"].write(value.serviceActionId)
    }
}

extension DisassociateTagOptionFromResourceInput {

    static func write(value: DisassociateTagOptionFromResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension EnableAWSOrganizationsAccessInput {

    static func write(value: EnableAWSOrganizationsAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ExecuteProvisionedProductPlanInput {

    static func write(value: ExecuteProvisionedProductPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["PlanId"].write(value.planId)
    }
}

extension ExecuteProvisionedProductServiceActionInput {

    static func write(value: ExecuteProvisionedProductServiceActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["ExecuteToken"].write(value.executeToken)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ProvisionedProductId"].write(value.provisionedProductId)
        try writer["ServiceActionId"].write(value.serviceActionId)
    }
}

extension GetAWSOrganizationsAccessStatusInput {

    static func write(value: GetAWSOrganizationsAccessStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetProvisionedProductOutputsInput {

    static func write(value: GetProvisionedProductOutputsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["OutputKeys"].writeList(value.outputKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
        try writer["ProvisionedProductId"].write(value.provisionedProductId)
        try writer["ProvisionedProductName"].write(value.provisionedProductName)
    }
}

extension ImportAsProvisionedProductInput {

    static func write(value: ImportAsProvisionedProductInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["PhysicalId"].write(value.physicalId)
        try writer["ProductId"].write(value.productId)
        try writer["ProvisionedProductName"].write(value.provisionedProductName)
        try writer["ProvisioningArtifactId"].write(value.provisioningArtifactId)
    }
}

extension ListAcceptedPortfolioSharesInput {

    static func write(value: ListAcceptedPortfolioSharesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
        try writer["PortfolioShareType"].write(value.portfolioShareType)
    }
}

extension ListBudgetsForResourceInput {

    static func write(value: ListBudgetsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension ListConstraintsForPortfolioInput {

    static func write(value: ListConstraintsForPortfolioInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
        try writer["PortfolioId"].write(value.portfolioId)
        try writer["ProductId"].write(value.productId)
    }
}

extension ListLaunchPathsInput {

    static func write(value: ListLaunchPathsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
        try writer["ProductId"].write(value.productId)
    }
}

extension ListOrganizationPortfolioAccessInput {

    static func write(value: ListOrganizationPortfolioAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["OrganizationNodeType"].write(value.organizationNodeType)
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
        try writer["PortfolioId"].write(value.portfolioId)
    }
}

extension ListPortfolioAccessInput {

    static func write(value: ListPortfolioAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["OrganizationParentId"].write(value.organizationParentId)
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
        try writer["PortfolioId"].write(value.portfolioId)
    }
}

extension ListPortfoliosInput {

    static func write(value: ListPortfoliosInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
    }
}

extension ListPortfoliosForProductInput {

    static func write(value: ListPortfoliosForProductInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
        try writer["ProductId"].write(value.productId)
    }
}

extension ListPrincipalsForPortfolioInput {

    static func write(value: ListPrincipalsForPortfolioInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
        try writer["PortfolioId"].write(value.portfolioId)
    }
}

extension ListProvisionedProductPlansInput {

    static func write(value: ListProvisionedProductPlansInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["AccessLevelFilter"].write(value.accessLevelFilter, with: ServiceCatalogClientTypes.AccessLevelFilter.write(value:to:))
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
        try writer["ProvisionProductId"].write(value.provisionProductId)
    }
}

extension ListProvisioningArtifactsInput {

    static func write(value: ListProvisioningArtifactsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["ProductId"].write(value.productId)
    }
}

extension ListProvisioningArtifactsForServiceActionInput {

    static func write(value: ListProvisioningArtifactsForServiceActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
        try writer["ServiceActionId"].write(value.serviceActionId)
    }
}

extension ListRecordHistoryInput {

    static func write(value: ListRecordHistoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["AccessLevelFilter"].write(value.accessLevelFilter, with: ServiceCatalogClientTypes.AccessLevelFilter.write(value:to:))
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
        try writer["SearchFilter"].write(value.searchFilter, with: ServiceCatalogClientTypes.ListRecordHistorySearchFilter.write(value:to:))
    }
}

extension ListResourcesForTagOptionInput {

    static func write(value: ListResourcesForTagOptionInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListServiceActionsInput {

    static func write(value: ListServiceActionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
    }
}

extension ListServiceActionsForProvisioningArtifactInput {

    static func write(value: ListServiceActionsForProvisioningArtifactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
        try writer["ProductId"].write(value.productId)
        try writer["ProvisioningArtifactId"].write(value.provisioningArtifactId)
    }
}

extension ListStackInstancesForProvisionedProductInput {

    static func write(value: ListStackInstancesForProvisionedProductInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
        try writer["ProvisionedProductId"].write(value.provisionedProductId)
    }
}

extension ListTagOptionsInput {

    static func write(value: ListTagOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].write(value.filters, with: ServiceCatalogClientTypes.ListTagOptionsFilters.write(value:to:))
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
    }
}

extension NotifyProvisionProductEngineWorkflowResultInput {

    static func write(value: NotifyProvisionProductEngineWorkflowResultInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FailureReason"].write(value.failureReason)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["Outputs"].writeList(value.outputs, memberWritingClosure: ServiceCatalogClientTypes.RecordOutput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RecordId"].write(value.recordId)
        try writer["ResourceIdentifier"].write(value.resourceIdentifier, with: ServiceCatalogClientTypes.EngineWorkflowResourceIdentifier.write(value:to:))
        try writer["Status"].write(value.status)
        try writer["WorkflowToken"].write(value.workflowToken)
    }
}

extension NotifyTerminateProvisionedProductEngineWorkflowResultInput {

    static func write(value: NotifyTerminateProvisionedProductEngineWorkflowResultInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FailureReason"].write(value.failureReason)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["RecordId"].write(value.recordId)
        try writer["Status"].write(value.status)
        try writer["WorkflowToken"].write(value.workflowToken)
    }
}

extension NotifyUpdateProvisionedProductEngineWorkflowResultInput {

    static func write(value: NotifyUpdateProvisionedProductEngineWorkflowResultInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FailureReason"].write(value.failureReason)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["Outputs"].writeList(value.outputs, memberWritingClosure: ServiceCatalogClientTypes.RecordOutput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RecordId"].write(value.recordId)
        try writer["Status"].write(value.status)
        try writer["WorkflowToken"].write(value.workflowToken)
    }
}

extension ProvisionProductInput {

    static func write(value: ProvisionProductInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["NotificationArns"].writeList(value.notificationArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PathId"].write(value.pathId)
        try writer["PathName"].write(value.pathName)
        try writer["ProductId"].write(value.productId)
        try writer["ProductName"].write(value.productName)
        try writer["ProvisionToken"].write(value.provisionToken)
        try writer["ProvisionedProductName"].write(value.provisionedProductName)
        try writer["ProvisioningArtifactId"].write(value.provisioningArtifactId)
        try writer["ProvisioningArtifactName"].write(value.provisioningArtifactName)
        try writer["ProvisioningParameters"].writeList(value.provisioningParameters, memberWritingClosure: ServiceCatalogClientTypes.ProvisioningParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProvisioningPreferences"].write(value.provisioningPreferences, with: ServiceCatalogClientTypes.ProvisioningPreferences.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ServiceCatalogClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension RejectPortfolioShareInput {

    static func write(value: RejectPortfolioShareInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PortfolioId"].write(value.portfolioId)
        try writer["PortfolioShareType"].write(value.portfolioShareType)
    }
}

extension ScanProvisionedProductsInput {

    static func write(value: ScanProvisionedProductsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["AccessLevelFilter"].write(value.accessLevelFilter, with: ServiceCatalogClientTypes.AccessLevelFilter.write(value:to:))
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
    }
}

extension SearchProductsInput {

    static func write(value: SearchProductsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Filters"].writeMap(value.filters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension SearchProductsAsAdminInput {

    static func write(value: SearchProductsAsAdminInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Filters"].writeMap(value.filters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
        try writer["PortfolioId"].write(value.portfolioId)
        try writer["ProductSource"].write(value.productSource)
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension SearchProvisionedProductsInput {

    static func write(value: SearchProvisionedProductsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["AccessLevelFilter"].write(value.accessLevelFilter, with: ServiceCatalogClientTypes.AccessLevelFilter.write(value:to:))
        try writer["Filters"].writeMap(value.filters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["PageSize"].write(value.pageSize)
        try writer["PageToken"].write(value.pageToken)
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension TerminateProvisionedProductInput {

    static func write(value: TerminateProvisionedProductInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["IgnoreErrors"].write(value.ignoreErrors)
        try writer["ProvisionedProductId"].write(value.provisionedProductId)
        try writer["ProvisionedProductName"].write(value.provisionedProductName)
        try writer["RetainPhysicalResources"].write(value.retainPhysicalResources)
        try writer["TerminateToken"].write(value.terminateToken)
    }
}

extension UpdateConstraintInput {

    static func write(value: UpdateConstraintInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Description"].write(value.description)
        try writer["Id"].write(value.id)
        try writer["Parameters"].write(value.parameters)
    }
}

extension UpdatePortfolioInput {

    static func write(value: UpdatePortfolioInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["AddTags"].writeList(value.addTags, memberWritingClosure: ServiceCatalogClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["DisplayName"].write(value.displayName)
        try writer["Id"].write(value.id)
        try writer["ProviderName"].write(value.providerName)
        try writer["RemoveTags"].writeList(value.removeTags, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdatePortfolioShareInput {

    static func write(value: UpdatePortfolioShareInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["AccountId"].write(value.accountId)
        try writer["OrganizationNode"].write(value.organizationNode, with: ServiceCatalogClientTypes.OrganizationNode.write(value:to:))
        try writer["PortfolioId"].write(value.portfolioId)
        try writer["SharePrincipals"].write(value.sharePrincipals)
        try writer["ShareTagOptions"].write(value.shareTagOptions)
    }
}

extension UpdateProductInput {

    static func write(value: UpdateProductInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["AddTags"].writeList(value.addTags, memberWritingClosure: ServiceCatalogClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["Distributor"].write(value.distributor)
        try writer["Id"].write(value.id)
        try writer["Name"].write(value.name)
        try writer["Owner"].write(value.owner)
        try writer["RemoveTags"].writeList(value.removeTags, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SourceConnection"].write(value.sourceConnection, with: ServiceCatalogClientTypes.SourceConnection.write(value:to:))
        try writer["SupportDescription"].write(value.supportDescription)
        try writer["SupportEmail"].write(value.supportEmail)
        try writer["SupportUrl"].write(value.supportUrl)
    }
}

extension UpdateProvisionedProductInput {

    static func write(value: UpdateProvisionedProductInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["PathId"].write(value.pathId)
        try writer["PathName"].write(value.pathName)
        try writer["ProductId"].write(value.productId)
        try writer["ProductName"].write(value.productName)
        try writer["ProvisionedProductId"].write(value.provisionedProductId)
        try writer["ProvisionedProductName"].write(value.provisionedProductName)
        try writer["ProvisioningArtifactId"].write(value.provisioningArtifactId)
        try writer["ProvisioningArtifactName"].write(value.provisioningArtifactName)
        try writer["ProvisioningParameters"].writeList(value.provisioningParameters, memberWritingClosure: ServiceCatalogClientTypes.UpdateProvisioningParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProvisioningPreferences"].write(value.provisioningPreferences, with: ServiceCatalogClientTypes.UpdateProvisioningPreferences.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ServiceCatalogClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UpdateToken"].write(value.updateToken)
    }
}

extension UpdateProvisionedProductPropertiesInput {

    static func write(value: UpdateProvisionedProductPropertiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["ProvisionedProductId"].write(value.provisionedProductId)
        try writer["ProvisionedProductProperties"].writeMap(value.provisionedProductProperties, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateProvisioningArtifactInput {

    static func write(value: UpdateProvisioningArtifactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Active"].write(value.active)
        try writer["Description"].write(value.description)
        try writer["Guidance"].write(value.guidance)
        try writer["Name"].write(value.name)
        try writer["ProductId"].write(value.productId)
        try writer["ProvisioningArtifactId"].write(value.provisioningArtifactId)
    }
}

extension UpdateServiceActionInput {

    static func write(value: UpdateServiceActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptLanguage"].write(value.acceptLanguage)
        try writer["Definition"].writeMap(value.definition, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["Id"].write(value.id)
        try writer["Name"].write(value.name)
    }
}

extension UpdateTagOptionInput {

    static func write(value: UpdateTagOptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Active"].write(value.active)
        try writer["Id"].write(value.id)
        try writer["Value"].write(value.value)
    }
}

extension AcceptPortfolioShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcceptPortfolioShareOutput {
        return AcceptPortfolioShareOutput()
    }
}

extension AssociateBudgetWithResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateBudgetWithResourceOutput {
        return AssociateBudgetWithResourceOutput()
    }
}

extension AssociatePrincipalWithPortfolioOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociatePrincipalWithPortfolioOutput {
        return AssociatePrincipalWithPortfolioOutput()
    }
}

extension AssociateProductWithPortfolioOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateProductWithPortfolioOutput {
        return AssociateProductWithPortfolioOutput()
    }
}

extension AssociateServiceActionWithProvisioningArtifactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateServiceActionWithProvisioningArtifactOutput {
        return AssociateServiceActionWithProvisioningArtifactOutput()
    }
}

extension AssociateTagOptionWithResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateTagOptionWithResourceOutput {
        return AssociateTagOptionWithResourceOutput()
    }
}

extension BatchAssociateServiceActionWithProvisioningArtifactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchAssociateServiceActionWithProvisioningArtifactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchAssociateServiceActionWithProvisioningArtifactOutput()
        value.failedServiceActionAssociations = try reader["FailedServiceActionAssociations"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.FailedServiceActionAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDisassociateServiceActionFromProvisioningArtifactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDisassociateServiceActionFromProvisioningArtifactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDisassociateServiceActionFromProvisioningArtifactOutput()
        value.failedServiceActionAssociations = try reader["FailedServiceActionAssociations"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.FailedServiceActionAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CopyProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CopyProductOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CopyProductOutput()
        value.copyProductToken = try reader["CopyProductToken"].readIfPresent()
        return value
    }
}

extension CreateConstraintOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConstraintOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConstraintOutput()
        value.constraintDetail = try reader["ConstraintDetail"].readIfPresent(with: ServiceCatalogClientTypes.ConstraintDetail.read(from:))
        value.constraintParameters = try reader["ConstraintParameters"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension CreatePortfolioOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePortfolioOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePortfolioOutput()
        value.portfolioDetail = try reader["PortfolioDetail"].readIfPresent(with: ServiceCatalogClientTypes.PortfolioDetail.read(from:))
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreatePortfolioShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePortfolioShareOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePortfolioShareOutput()
        value.portfolioShareToken = try reader["PortfolioShareToken"].readIfPresent()
        return value
    }
}

extension CreateProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProductOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProductOutput()
        value.productViewDetail = try reader["ProductViewDetail"].readIfPresent(with: ServiceCatalogClientTypes.ProductViewDetail.read(from:))
        value.provisioningArtifactDetail = try reader["ProvisioningArtifactDetail"].readIfPresent(with: ServiceCatalogClientTypes.ProvisioningArtifactDetail.read(from:))
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateProvisionedProductPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProvisionedProductPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProvisionedProductPlanOutput()
        value.planId = try reader["PlanId"].readIfPresent()
        value.planName = try reader["PlanName"].readIfPresent()
        value.provisionProductId = try reader["ProvisionProductId"].readIfPresent()
        value.provisionedProductName = try reader["ProvisionedProductName"].readIfPresent()
        value.provisioningArtifactId = try reader["ProvisioningArtifactId"].readIfPresent()
        return value
    }
}

extension CreateProvisioningArtifactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProvisioningArtifactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProvisioningArtifactOutput()
        value.info = try reader["Info"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.provisioningArtifactDetail = try reader["ProvisioningArtifactDetail"].readIfPresent(with: ServiceCatalogClientTypes.ProvisioningArtifactDetail.read(from:))
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension CreateServiceActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateServiceActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServiceActionOutput()
        value.serviceActionDetail = try reader["ServiceActionDetail"].readIfPresent(with: ServiceCatalogClientTypes.ServiceActionDetail.read(from:))
        return value
    }
}

extension CreateTagOptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTagOptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTagOptionOutput()
        value.tagOptionDetail = try reader["TagOptionDetail"].readIfPresent(with: ServiceCatalogClientTypes.TagOptionDetail.read(from:))
        return value
    }
}

extension DeleteConstraintOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConstraintOutput {
        return DeleteConstraintOutput()
    }
}

extension DeletePortfolioOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePortfolioOutput {
        return DeletePortfolioOutput()
    }
}

extension DeletePortfolioShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePortfolioShareOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeletePortfolioShareOutput()
        value.portfolioShareToken = try reader["PortfolioShareToken"].readIfPresent()
        return value
    }
}

extension DeleteProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProductOutput {
        return DeleteProductOutput()
    }
}

extension DeleteProvisionedProductPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProvisionedProductPlanOutput {
        return DeleteProvisionedProductPlanOutput()
    }
}

extension DeleteProvisioningArtifactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProvisioningArtifactOutput {
        return DeleteProvisioningArtifactOutput()
    }
}

extension DeleteServiceActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServiceActionOutput {
        return DeleteServiceActionOutput()
    }
}

extension DeleteTagOptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTagOptionOutput {
        return DeleteTagOptionOutput()
    }
}

extension DescribeConstraintOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConstraintOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConstraintOutput()
        value.constraintDetail = try reader["ConstraintDetail"].readIfPresent(with: ServiceCatalogClientTypes.ConstraintDetail.read(from:))
        value.constraintParameters = try reader["ConstraintParameters"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DescribeCopyProductStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCopyProductStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCopyProductStatusOutput()
        value.copyProductStatus = try reader["CopyProductStatus"].readIfPresent()
        value.statusDetail = try reader["StatusDetail"].readIfPresent()
        value.targetProductId = try reader["TargetProductId"].readIfPresent()
        return value
    }
}

extension DescribePortfolioOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePortfolioOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePortfolioOutput()
        value.budgets = try reader["Budgets"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.BudgetDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.portfolioDetail = try reader["PortfolioDetail"].readIfPresent(with: ServiceCatalogClientTypes.PortfolioDetail.read(from:))
        value.tagOptions = try reader["TagOptions"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.TagOptionDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribePortfolioSharesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePortfolioSharesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePortfolioSharesOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.portfolioShareDetails = try reader["PortfolioShareDetails"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.PortfolioShareDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribePortfolioShareStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePortfolioShareStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePortfolioShareStatusOutput()
        value.organizationNodeValue = try reader["OrganizationNodeValue"].readIfPresent()
        value.portfolioId = try reader["PortfolioId"].readIfPresent()
        value.portfolioShareToken = try reader["PortfolioShareToken"].readIfPresent()
        value.shareDetails = try reader["ShareDetails"].readIfPresent(with: ServiceCatalogClientTypes.ShareDetails.read(from:))
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DescribeProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProductOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProductOutput()
        value.budgets = try reader["Budgets"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.BudgetDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.launchPaths = try reader["LaunchPaths"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.LaunchPath.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.productViewSummary = try reader["ProductViewSummary"].readIfPresent(with: ServiceCatalogClientTypes.ProductViewSummary.read(from:))
        value.provisioningArtifacts = try reader["ProvisioningArtifacts"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ProvisioningArtifact.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeProductAsAdminOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProductAsAdminOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProductAsAdminOutput()
        value.budgets = try reader["Budgets"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.BudgetDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.productViewDetail = try reader["ProductViewDetail"].readIfPresent(with: ServiceCatalogClientTypes.ProductViewDetail.read(from:))
        value.provisioningArtifactSummaries = try reader["ProvisioningArtifactSummaries"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ProvisioningArtifactSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tagOptions = try reader["TagOptions"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.TagOptionDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeProductViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProductViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProductViewOutput()
        value.productViewSummary = try reader["ProductViewSummary"].readIfPresent(with: ServiceCatalogClientTypes.ProductViewSummary.read(from:))
        value.provisioningArtifacts = try reader["ProvisioningArtifacts"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ProvisioningArtifact.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeProvisionedProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProvisionedProductOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProvisionedProductOutput()
        value.cloudWatchDashboards = try reader["CloudWatchDashboards"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.CloudWatchDashboard.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.provisionedProductDetail = try reader["ProvisionedProductDetail"].readIfPresent(with: ServiceCatalogClientTypes.ProvisionedProductDetail.read(from:))
        return value
    }
}

extension DescribeProvisionedProductPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProvisionedProductPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProvisionedProductPlanOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.provisionedProductPlanDetails = try reader["ProvisionedProductPlanDetails"].readIfPresent(with: ServiceCatalogClientTypes.ProvisionedProductPlanDetails.read(from:))
        value.resourceChanges = try reader["ResourceChanges"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ResourceChange.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeProvisioningArtifactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProvisioningArtifactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProvisioningArtifactOutput()
        value.info = try reader["Info"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.provisioningArtifactDetail = try reader["ProvisioningArtifactDetail"].readIfPresent(with: ServiceCatalogClientTypes.ProvisioningArtifactDetail.read(from:))
        value.provisioningArtifactParameters = try reader["ProvisioningArtifactParameters"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ProvisioningArtifactParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DescribeProvisioningParametersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProvisioningParametersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProvisioningParametersOutput()
        value.constraintSummaries = try reader["ConstraintSummaries"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ConstraintSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.provisioningArtifactOutputKeys = try reader["ProvisioningArtifactOutputKeys"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ProvisioningArtifactOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.provisioningArtifactOutputs = try reader["ProvisioningArtifactOutputs"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ProvisioningArtifactOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.provisioningArtifactParameters = try reader["ProvisioningArtifactParameters"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ProvisioningArtifactParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.provisioningArtifactPreferences = try reader["ProvisioningArtifactPreferences"].readIfPresent(with: ServiceCatalogClientTypes.ProvisioningArtifactPreferences.read(from:))
        value.tagOptions = try reader["TagOptions"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.TagOptionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.usageInstructions = try reader["UsageInstructions"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.UsageInstruction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeRecordOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRecordOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRecordOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.recordDetail = try reader["RecordDetail"].readIfPresent(with: ServiceCatalogClientTypes.RecordDetail.read(from:))
        value.recordOutputs = try reader["RecordOutputs"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.RecordOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeServiceActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeServiceActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeServiceActionOutput()
        value.serviceActionDetail = try reader["ServiceActionDetail"].readIfPresent(with: ServiceCatalogClientTypes.ServiceActionDetail.read(from:))
        return value
    }
}

extension DescribeServiceActionExecutionParametersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeServiceActionExecutionParametersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeServiceActionExecutionParametersOutput()
        value.serviceActionParameters = try reader["ServiceActionParameters"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ExecutionParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeTagOptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTagOptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTagOptionOutput()
        value.tagOptionDetail = try reader["TagOptionDetail"].readIfPresent(with: ServiceCatalogClientTypes.TagOptionDetail.read(from:))
        return value
    }
}

extension DisableAWSOrganizationsAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableAWSOrganizationsAccessOutput {
        return DisableAWSOrganizationsAccessOutput()
    }
}

extension DisassociateBudgetFromResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateBudgetFromResourceOutput {
        return DisassociateBudgetFromResourceOutput()
    }
}

extension DisassociatePrincipalFromPortfolioOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociatePrincipalFromPortfolioOutput {
        return DisassociatePrincipalFromPortfolioOutput()
    }
}

extension DisassociateProductFromPortfolioOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateProductFromPortfolioOutput {
        return DisassociateProductFromPortfolioOutput()
    }
}

extension DisassociateServiceActionFromProvisioningArtifactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateServiceActionFromProvisioningArtifactOutput {
        return DisassociateServiceActionFromProvisioningArtifactOutput()
    }
}

extension DisassociateTagOptionFromResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateTagOptionFromResourceOutput {
        return DisassociateTagOptionFromResourceOutput()
    }
}

extension EnableAWSOrganizationsAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableAWSOrganizationsAccessOutput {
        return EnableAWSOrganizationsAccessOutput()
    }
}

extension ExecuteProvisionedProductPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExecuteProvisionedProductPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExecuteProvisionedProductPlanOutput()
        value.recordDetail = try reader["RecordDetail"].readIfPresent(with: ServiceCatalogClientTypes.RecordDetail.read(from:))
        return value
    }
}

extension ExecuteProvisionedProductServiceActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExecuteProvisionedProductServiceActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExecuteProvisionedProductServiceActionOutput()
        value.recordDetail = try reader["RecordDetail"].readIfPresent(with: ServiceCatalogClientTypes.RecordDetail.read(from:))
        return value
    }
}

extension GetAWSOrganizationsAccessStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAWSOrganizationsAccessStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAWSOrganizationsAccessStatusOutput()
        value.accessStatus = try reader["AccessStatus"].readIfPresent()
        return value
    }
}

extension GetProvisionedProductOutputsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProvisionedProductOutputsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProvisionedProductOutputsOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.outputs = try reader["Outputs"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.RecordOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ImportAsProvisionedProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportAsProvisionedProductOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportAsProvisionedProductOutput()
        value.recordDetail = try reader["RecordDetail"].readIfPresent(with: ServiceCatalogClientTypes.RecordDetail.read(from:))
        return value
    }
}

extension ListAcceptedPortfolioSharesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAcceptedPortfolioSharesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAcceptedPortfolioSharesOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.portfolioDetails = try reader["PortfolioDetails"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.PortfolioDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListBudgetsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBudgetsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBudgetsForResourceOutput()
        value.budgets = try reader["Budgets"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.BudgetDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        return value
    }
}

extension ListConstraintsForPortfolioOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConstraintsForPortfolioOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConstraintsForPortfolioOutput()
        value.constraintDetails = try reader["ConstraintDetails"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ConstraintDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        return value
    }
}

extension ListLaunchPathsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLaunchPathsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLaunchPathsOutput()
        value.launchPathSummaries = try reader["LaunchPathSummaries"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.LaunchPathSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        return value
    }
}

extension ListOrganizationPortfolioAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOrganizationPortfolioAccessOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOrganizationPortfolioAccessOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.organizationNodes = try reader["OrganizationNodes"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.OrganizationNode.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPortfolioAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPortfolioAccessOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPortfolioAccessOutput()
        value.accountIds = try reader["AccountIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        return value
    }
}

extension ListPortfoliosOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPortfoliosOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPortfoliosOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.portfolioDetails = try reader["PortfolioDetails"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.PortfolioDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPortfoliosForProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPortfoliosForProductOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPortfoliosForProductOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.portfolioDetails = try reader["PortfolioDetails"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.PortfolioDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPrincipalsForPortfolioOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPrincipalsForPortfolioOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPrincipalsForPortfolioOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.principals = try reader["Principals"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.Principal.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListProvisionedProductPlansOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProvisionedProductPlansOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProvisionedProductPlansOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.provisionedProductPlans = try reader["ProvisionedProductPlans"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ProvisionedProductPlanSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListProvisioningArtifactsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProvisioningArtifactsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProvisioningArtifactsOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.provisioningArtifactDetails = try reader["ProvisioningArtifactDetails"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ProvisioningArtifactDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListProvisioningArtifactsForServiceActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProvisioningArtifactsForServiceActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProvisioningArtifactsForServiceActionOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.provisioningArtifactViews = try reader["ProvisioningArtifactViews"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ProvisioningArtifactView.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRecordHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRecordHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRecordHistoryOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.recordDetails = try reader["RecordDetails"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.RecordDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListResourcesForTagOptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourcesForTagOptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourcesForTagOptionOutput()
        value.pageToken = try reader["PageToken"].readIfPresent()
        value.resourceDetails = try reader["ResourceDetails"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ResourceDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListServiceActionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceActionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceActionsOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.serviceActionSummaries = try reader["ServiceActionSummaries"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ServiceActionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListServiceActionsForProvisioningArtifactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceActionsForProvisioningArtifactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceActionsForProvisioningArtifactOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.serviceActionSummaries = try reader["ServiceActionSummaries"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ServiceActionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListStackInstancesForProvisionedProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStackInstancesForProvisionedProductOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStackInstancesForProvisionedProductOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.stackInstances = try reader["StackInstances"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.StackInstance.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagOptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagOptionsOutput()
        value.pageToken = try reader["PageToken"].readIfPresent()
        value.tagOptionDetails = try reader["TagOptionDetails"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.TagOptionDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NotifyProvisionProductEngineWorkflowResultOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> NotifyProvisionProductEngineWorkflowResultOutput {
        return NotifyProvisionProductEngineWorkflowResultOutput()
    }
}

extension NotifyTerminateProvisionedProductEngineWorkflowResultOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> NotifyTerminateProvisionedProductEngineWorkflowResultOutput {
        return NotifyTerminateProvisionedProductEngineWorkflowResultOutput()
    }
}

extension NotifyUpdateProvisionedProductEngineWorkflowResultOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> NotifyUpdateProvisionedProductEngineWorkflowResultOutput {
        return NotifyUpdateProvisionedProductEngineWorkflowResultOutput()
    }
}

extension ProvisionProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ProvisionProductOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ProvisionProductOutput()
        value.recordDetail = try reader["RecordDetail"].readIfPresent(with: ServiceCatalogClientTypes.RecordDetail.read(from:))
        return value
    }
}

extension RejectPortfolioShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RejectPortfolioShareOutput {
        return RejectPortfolioShareOutput()
    }
}

extension ScanProvisionedProductsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ScanProvisionedProductsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ScanProvisionedProductsOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.provisionedProducts = try reader["ProvisionedProducts"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ProvisionedProductDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchProductsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchProductsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchProductsOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.productViewAggregations = try reader["ProductViewAggregations"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: ServiceCatalogClientTypes.ProductViewAggregationValue.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.productViewSummaries = try reader["ProductViewSummaries"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ProductViewSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchProductsAsAdminOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchProductsAsAdminOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchProductsAsAdminOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.productViewDetails = try reader["ProductViewDetails"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ProductViewDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SearchProvisionedProductsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchProvisionedProductsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchProvisionedProductsOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.provisionedProducts = try reader["ProvisionedProducts"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ProvisionedProductAttribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.totalResultsCount = try reader["TotalResultsCount"].readIfPresent() ?? 0
        return value
    }
}

extension TerminateProvisionedProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TerminateProvisionedProductOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TerminateProvisionedProductOutput()
        value.recordDetail = try reader["RecordDetail"].readIfPresent(with: ServiceCatalogClientTypes.RecordDetail.read(from:))
        return value
    }
}

extension UpdateConstraintOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConstraintOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConstraintOutput()
        value.constraintDetail = try reader["ConstraintDetail"].readIfPresent(with: ServiceCatalogClientTypes.ConstraintDetail.read(from:))
        value.constraintParameters = try reader["ConstraintParameters"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension UpdatePortfolioOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePortfolioOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePortfolioOutput()
        value.portfolioDetail = try reader["PortfolioDetail"].readIfPresent(with: ServiceCatalogClientTypes.PortfolioDetail.read(from:))
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdatePortfolioShareOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePortfolioShareOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePortfolioShareOutput()
        value.portfolioShareToken = try reader["PortfolioShareToken"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension UpdateProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProductOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProductOutput()
        value.productViewDetail = try reader["ProductViewDetail"].readIfPresent(with: ServiceCatalogClientTypes.ProductViewDetail.read(from:))
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateProvisionedProductOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProvisionedProductOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProvisionedProductOutput()
        value.recordDetail = try reader["RecordDetail"].readIfPresent(with: ServiceCatalogClientTypes.RecordDetail.read(from:))
        return value
    }
}

extension UpdateProvisionedProductPropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProvisionedProductPropertiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProvisionedProductPropertiesOutput()
        value.provisionedProductId = try reader["ProvisionedProductId"].readIfPresent()
        value.provisionedProductProperties = try reader["ProvisionedProductProperties"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.recordId = try reader["RecordId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension UpdateProvisioningArtifactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProvisioningArtifactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProvisioningArtifactOutput()
        value.info = try reader["Info"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.provisioningArtifactDetail = try reader["ProvisioningArtifactDetail"].readIfPresent(with: ServiceCatalogClientTypes.ProvisioningArtifactDetail.read(from:))
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension UpdateServiceActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServiceActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateServiceActionOutput()
        value.serviceActionDetail = try reader["ServiceActionDetail"].readIfPresent(with: ServiceCatalogClientTypes.ServiceActionDetail.read(from:))
        return value
    }
}

extension UpdateTagOptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTagOptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTagOptionOutput()
        value.tagOptionDetail = try reader["TagOptionDetail"].readIfPresent(with: ServiceCatalogClientTypes.TagOptionDetail.read(from:))
        return value
    }
}

enum AcceptPortfolioShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateBudgetWithResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociatePrincipalWithPortfolioOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateProductWithPortfolioOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateServiceActionWithProvisioningArtifactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateTagOptionWithResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TagOptionNotMigratedException": return try TagOptionNotMigratedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchAssociateServiceActionWithProvisioningArtifactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDisassociateServiceActionFromProvisioningArtifactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CopyProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConstraintOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePortfolioOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "TagOptionNotMigratedException": return try TagOptionNotMigratedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePortfolioShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "TagOptionNotMigratedException": return try TagOptionNotMigratedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProvisionedProductPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProvisioningArtifactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateServiceActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTagOptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "TagOptionNotMigratedException": return try TagOptionNotMigratedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConstraintOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePortfolioOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TagOptionNotMigratedException": return try TagOptionNotMigratedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePortfolioShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TagOptionNotMigratedException": return try TagOptionNotMigratedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProvisionedProductPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProvisioningArtifactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServiceActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTagOptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TagOptionNotMigratedException": return try TagOptionNotMigratedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConstraintOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCopyProductStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePortfolioOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePortfolioSharesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePortfolioShareStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProductAsAdminOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProductViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProvisionedProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProvisionedProductPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProvisioningArtifactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProvisioningParametersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRecordOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeServiceActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeServiceActionExecutionParametersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTagOptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TagOptionNotMigratedException": return try TagOptionNotMigratedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableAWSOrganizationsAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateBudgetFromResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociatePrincipalFromPortfolioOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateProductFromPortfolioOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateServiceActionFromProvisioningArtifactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateTagOptionFromResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TagOptionNotMigratedException": return try TagOptionNotMigratedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableAWSOrganizationsAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExecuteProvisionedProductPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExecuteProvisionedProductServiceActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAWSOrganizationsAccessStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProvisionedProductOutputsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportAsProvisionedProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAcceptedPortfolioSharesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBudgetsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConstraintsForPortfolioOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLaunchPathsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOrganizationPortfolioAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPortfolioAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPortfoliosOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPortfoliosForProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPrincipalsForPortfolioOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProvisionedProductPlansOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProvisioningArtifactsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProvisioningArtifactsForServiceActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRecordHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourcesForTagOptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TagOptionNotMigratedException": return try TagOptionNotMigratedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceActionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceActionsForProvisioningArtifactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStackInstancesForProvisionedProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "TagOptionNotMigratedException": return try TagOptionNotMigratedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum NotifyProvisionProductEngineWorkflowResultOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum NotifyTerminateProvisionedProductEngineWorkflowResultOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum NotifyUpdateProvisionedProductEngineWorkflowResultOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ProvisionProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RejectPortfolioShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ScanProvisionedProductsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchProductsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchProductsAsAdminOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchProvisionedProductsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TerminateProvisionedProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConstraintOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePortfolioOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TagOptionNotMigratedException": return try TagOptionNotMigratedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePortfolioShareOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "OperationNotSupportedException": return try OperationNotSupportedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TagOptionNotMigratedException": return try TagOptionNotMigratedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProvisionedProductOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProvisionedProductPropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "InvalidStateException": return try InvalidStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProvisioningArtifactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServiceActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTagOptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateResourceException": return try DuplicateResourceException.makeError(baseError: baseError)
            case "InvalidParametersException": return try InvalidParametersException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TagOptionNotMigratedException": return try TagOptionNotMigratedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InvalidParametersException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParametersException {
        let reader = baseError.errorBodyReader
        var value = InvalidParametersException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DuplicateResourceException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DuplicateResourceException {
        let reader = baseError.errorBodyReader
        var value = DuplicateResourceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidStateException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidStateException {
        let reader = baseError.errorBodyReader
        var value = InvalidStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TagOptionNotMigratedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TagOptionNotMigratedException {
        let reader = baseError.errorBodyReader
        var value = TagOptionNotMigratedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OperationNotSupportedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OperationNotSupportedException {
        let reader = baseError.errorBodyReader
        var value = OperationNotSupportedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceCatalogClientTypes.FailedServiceActionAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.FailedServiceActionAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.FailedServiceActionAssociation()
        value.serviceActionId = try reader["ServiceActionId"].readIfPresent()
        value.productId = try reader["ProductId"].readIfPresent()
        value.provisioningArtifactId = try reader["ProvisioningArtifactId"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.ConstraintDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ConstraintDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ConstraintDetail()
        value.constraintId = try reader["ConstraintId"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.productId = try reader["ProductId"].readIfPresent()
        value.portfolioId = try reader["PortfolioId"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.PortfolioDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.PortfolioDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.PortfolioDetail()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["ARN"].readIfPresent()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.providerName = try reader["ProviderName"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.Tag {

    static func write(value: ServiceCatalogClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension ServiceCatalogClientTypes.ProductViewDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ProductViewDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ProductViewDetail()
        value.productViewSummary = try reader["ProductViewSummary"].readIfPresent(with: ServiceCatalogClientTypes.ProductViewSummary.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.productARN = try reader["ProductARN"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sourceConnection = try reader["SourceConnection"].readIfPresent(with: ServiceCatalogClientTypes.SourceConnectionDetail.read(from:))
        return value
    }
}

extension ServiceCatalogClientTypes.SourceConnectionDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.SourceConnectionDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.SourceConnectionDetail()
        value.type = try reader["Type"].readIfPresent()
        value.connectionParameters = try reader["ConnectionParameters"].readIfPresent(with: ServiceCatalogClientTypes.SourceConnectionParameters.read(from:))
        value.lastSync = try reader["LastSync"].readIfPresent(with: ServiceCatalogClientTypes.LastSync.read(from:))
        return value
    }
}

extension ServiceCatalogClientTypes.LastSync {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.LastSync {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.LastSync()
        value.lastSyncTime = try reader["LastSyncTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastSyncStatus = try reader["LastSyncStatus"].readIfPresent()
        value.lastSyncStatusMessage = try reader["LastSyncStatusMessage"].readIfPresent()
        value.lastSuccessfulSyncTime = try reader["LastSuccessfulSyncTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastSuccessfulSyncProvisioningArtifactId = try reader["LastSuccessfulSyncProvisioningArtifactId"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.SourceConnectionParameters {

    static func write(value: ServiceCatalogClientTypes.SourceConnectionParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CodeStar"].write(value.codeStar, with: ServiceCatalogClientTypes.CodeStarParameters.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.SourceConnectionParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.SourceConnectionParameters()
        value.codeStar = try reader["CodeStar"].readIfPresent(with: ServiceCatalogClientTypes.CodeStarParameters.read(from:))
        return value
    }
}

extension ServiceCatalogClientTypes.CodeStarParameters {

    static func write(value: ServiceCatalogClientTypes.CodeStarParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArtifactPath"].write(value.artifactPath)
        try writer["Branch"].write(value.branch)
        try writer["ConnectionArn"].write(value.connectionArn)
        try writer["Repository"].write(value.repository)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.CodeStarParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.CodeStarParameters()
        value.connectionArn = try reader["ConnectionArn"].readIfPresent() ?? ""
        value.repository = try reader["Repository"].readIfPresent() ?? ""
        value.branch = try reader["Branch"].readIfPresent() ?? ""
        value.artifactPath = try reader["ArtifactPath"].readIfPresent() ?? ""
        return value
    }
}

extension ServiceCatalogClientTypes.ProductViewSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ProductViewSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ProductViewSummary()
        value.id = try reader["Id"].readIfPresent()
        value.productId = try reader["ProductId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.shortDescription = try reader["ShortDescription"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.distributor = try reader["Distributor"].readIfPresent()
        value.hasDefaultPath = try reader["HasDefaultPath"].readIfPresent() ?? false
        value.supportEmail = try reader["SupportEmail"].readIfPresent()
        value.supportDescription = try reader["SupportDescription"].readIfPresent()
        value.supportUrl = try reader["SupportUrl"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ProvisioningArtifactDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ProvisioningArtifactDetail()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.active = try reader["Active"].readIfPresent()
        value.guidance = try reader["Guidance"].readIfPresent()
        value.sourceRevision = try reader["SourceRevision"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.ServiceActionDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ServiceActionDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ServiceActionDetail()
        value.serviceActionSummary = try reader["ServiceActionSummary"].readIfPresent(with: ServiceCatalogClientTypes.ServiceActionSummary.read(from:))
        value.definition = try reader["Definition"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ServiceCatalogClientTypes.ServiceActionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ServiceActionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ServiceActionSummary()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.definitionType = try reader["DefinitionType"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.TagOptionDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.TagOptionDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.TagOptionDetail()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.active = try reader["Active"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.BudgetDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.BudgetDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.BudgetDetail()
        value.budgetName = try reader["BudgetName"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.PortfolioShareDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.PortfolioShareDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.PortfolioShareDetail()
        value.principalId = try reader["PrincipalId"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.accepted = try reader["Accepted"].readIfPresent() ?? false
        value.shareTagOptions = try reader["ShareTagOptions"].readIfPresent() ?? false
        value.sharePrincipals = try reader["SharePrincipals"].readIfPresent() ?? false
        return value
    }
}

extension ServiceCatalogClientTypes.ShareDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ShareDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ShareDetails()
        value.successfulShares = try reader["SuccessfulShares"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.shareErrors = try reader["ShareErrors"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ShareError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ServiceCatalogClientTypes.ShareError {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ShareError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ShareError()
        value.accounts = try reader["Accounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.message = try reader["Message"].readIfPresent()
        value.error = try reader["Error"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifact {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ProvisioningArtifact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ProvisioningArtifact()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.guidance = try reader["Guidance"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.LaunchPath {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.LaunchPath {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.LaunchPath()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ProvisioningArtifactSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ProvisioningArtifactSummary()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.provisioningArtifactMetadata = try reader["ProvisioningArtifactMetadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ServiceCatalogClientTypes.ProvisionedProductDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ProvisionedProductDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ProvisionedProductDetail()
        value.name = try reader["Name"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.idempotencyToken = try reader["IdempotencyToken"].readIfPresent()
        value.lastRecordId = try reader["LastRecordId"].readIfPresent()
        value.lastProvisioningRecordId = try reader["LastProvisioningRecordId"].readIfPresent()
        value.lastSuccessfulProvisioningRecordId = try reader["LastSuccessfulProvisioningRecordId"].readIfPresent()
        value.productId = try reader["ProductId"].readIfPresent()
        value.provisioningArtifactId = try reader["ProvisioningArtifactId"].readIfPresent()
        value.launchRoleArn = try reader["LaunchRoleArn"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.CloudWatchDashboard {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.CloudWatchDashboard {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.CloudWatchDashboard()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.ProvisionedProductPlanDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ProvisionedProductPlanDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ProvisionedProductPlanDetails()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.pathId = try reader["PathId"].readIfPresent()
        value.productId = try reader["ProductId"].readIfPresent()
        value.planName = try reader["PlanName"].readIfPresent()
        value.planId = try reader["PlanId"].readIfPresent()
        value.provisionProductId = try reader["ProvisionProductId"].readIfPresent()
        value.provisionProductName = try reader["ProvisionProductName"].readIfPresent()
        value.planType = try reader["PlanType"].readIfPresent()
        value.provisioningArtifactId = try reader["ProvisioningArtifactId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.updatedTime = try reader["UpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.notificationArns = try reader["NotificationArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.provisioningParameters = try reader["ProvisioningParameters"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.UpdateProvisioningParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.UpdateProvisioningParameter {

    static func write(value: ServiceCatalogClientTypes.UpdateProvisioningParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["UsePreviousValue"].write(value.usePreviousValue)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.UpdateProvisioningParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.UpdateProvisioningParameter()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.usePreviousValue = try reader["UsePreviousValue"].readIfPresent() ?? false
        return value
    }
}

extension ServiceCatalogClientTypes.ResourceChange {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ResourceChange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ResourceChange()
        value.action = try reader["Action"].readIfPresent()
        value.logicalResourceId = try reader["LogicalResourceId"].readIfPresent()
        value.physicalResourceId = try reader["PhysicalResourceId"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.replacement = try reader["Replacement"].readIfPresent()
        value.scope = try reader["Scope"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<ServiceCatalogClientTypes.ResourceAttribute>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.details = try reader["Details"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ResourceChangeDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ServiceCatalogClientTypes.ResourceChangeDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ResourceChangeDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ResourceChangeDetail()
        value.target = try reader["Target"].readIfPresent(with: ServiceCatalogClientTypes.ResourceTargetDefinition.read(from:))
        value.evaluation = try reader["Evaluation"].readIfPresent()
        value.causingEntity = try reader["CausingEntity"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.ResourceTargetDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ResourceTargetDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ResourceTargetDefinition()
        value.attribute = try reader["Attribute"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.requiresRecreation = try reader["RequiresRecreation"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactParameter {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ProvisioningArtifactParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ProvisioningArtifactParameter()
        value.parameterKey = try reader["ParameterKey"].readIfPresent()
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        value.parameterType = try reader["ParameterType"].readIfPresent()
        value.isNoEcho = try reader["IsNoEcho"].readIfPresent() ?? false
        value.description = try reader["Description"].readIfPresent()
        value.parameterConstraints = try reader["ParameterConstraints"].readIfPresent(with: ServiceCatalogClientTypes.ParameterConstraints.read(from:))
        return value
    }
}

extension ServiceCatalogClientTypes.ParameterConstraints {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ParameterConstraints {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ParameterConstraints()
        value.allowedValues = try reader["AllowedValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowedPattern = try reader["AllowedPattern"].readIfPresent()
        value.constraintDescription = try reader["ConstraintDescription"].readIfPresent()
        value.maxLength = try reader["MaxLength"].readIfPresent()
        value.minLength = try reader["MinLength"].readIfPresent()
        value.maxValue = try reader["MaxValue"].readIfPresent()
        value.minValue = try reader["MinValue"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.ConstraintSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ConstraintSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ConstraintSummary()
        value.type = try reader["Type"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.UsageInstruction {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.UsageInstruction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.UsageInstruction()
        value.type = try reader["Type"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.TagOptionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.TagOptionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.TagOptionSummary()
        value.key = try reader["Key"].readIfPresent()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactPreferences {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ProvisioningArtifactPreferences {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ProvisioningArtifactPreferences()
        value.stackSetAccounts = try reader["StackSetAccounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.stackSetRegions = try reader["StackSetRegions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ProvisioningArtifactOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ProvisioningArtifactOutput()
        value.key = try reader["Key"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.RecordDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.RecordDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.RecordDetail()
        value.recordId = try reader["RecordId"].readIfPresent()
        value.provisionedProductName = try reader["ProvisionedProductName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedTime = try reader["UpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.provisionedProductType = try reader["ProvisionedProductType"].readIfPresent()
        value.recordType = try reader["RecordType"].readIfPresent()
        value.provisionedProductId = try reader["ProvisionedProductId"].readIfPresent()
        value.productId = try reader["ProductId"].readIfPresent()
        value.provisioningArtifactId = try reader["ProvisioningArtifactId"].readIfPresent()
        value.pathId = try reader["PathId"].readIfPresent()
        value.recordErrors = try reader["RecordErrors"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.RecordError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.recordTags = try reader["RecordTags"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.RecordTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.launchRoleArn = try reader["LaunchRoleArn"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.RecordTag {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.RecordTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.RecordTag()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.RecordError {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.RecordError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.RecordError()
        value.code = try reader["Code"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.RecordOutput {

    static func write(value: ServiceCatalogClientTypes.RecordOutput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["OutputKey"].write(value.outputKey)
        try writer["OutputValue"].write(value.outputValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.RecordOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.RecordOutput()
        value.outputKey = try reader["OutputKey"].readIfPresent()
        value.outputValue = try reader["OutputValue"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.ExecutionParameter {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ExecutionParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ExecutionParameter()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.defaultValues = try reader["DefaultValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ServiceCatalogClientTypes.LaunchPathSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.LaunchPathSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.LaunchPathSummary()
        value.id = try reader["Id"].readIfPresent()
        value.constraintSummaries = try reader["ConstraintSummaries"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.ConstraintSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.OrganizationNode {

    static func write(value: ServiceCatalogClientTypes.OrganizationNode?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.OrganizationNode {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.OrganizationNode()
        value.type = try reader["Type"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.Principal {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.Principal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.Principal()
        value.principalARN = try reader["PrincipalARN"].readIfPresent()
        value.principalType = try reader["PrincipalType"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.ProvisionedProductPlanSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ProvisionedProductPlanSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ProvisionedProductPlanSummary()
        value.planName = try reader["PlanName"].readIfPresent()
        value.planId = try reader["PlanId"].readIfPresent()
        value.provisionProductId = try reader["ProvisionProductId"].readIfPresent()
        value.provisionProductName = try reader["ProvisionProductName"].readIfPresent()
        value.planType = try reader["PlanType"].readIfPresent()
        value.provisioningArtifactId = try reader["ProvisioningArtifactId"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactView {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ProvisioningArtifactView {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ProvisioningArtifactView()
        value.productViewSummary = try reader["ProductViewSummary"].readIfPresent(with: ServiceCatalogClientTypes.ProductViewSummary.read(from:))
        value.provisioningArtifact = try reader["ProvisioningArtifact"].readIfPresent(with: ServiceCatalogClientTypes.ProvisioningArtifact.read(from:))
        return value
    }
}

extension ServiceCatalogClientTypes.ResourceDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ResourceDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ResourceDetail()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["ARN"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ServiceCatalogClientTypes.StackInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.StackInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.StackInstance()
        value.account = try reader["Account"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.stackInstanceStatus = try reader["StackInstanceStatus"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.ProductViewAggregationValue {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ProductViewAggregationValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ProductViewAggregationValue()
        value.value = try reader["Value"].readIfPresent()
        value.approximateCount = try reader["ApproximateCount"].readIfPresent() ?? 0
        return value
    }
}

extension ServiceCatalogClientTypes.ProvisionedProductAttribute {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceCatalogClientTypes.ProvisionedProductAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceCatalogClientTypes.ProvisionedProductAttribute()
        value.name = try reader["Name"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.idempotencyToken = try reader["IdempotencyToken"].readIfPresent()
        value.lastRecordId = try reader["LastRecordId"].readIfPresent()
        value.lastProvisioningRecordId = try reader["LastProvisioningRecordId"].readIfPresent()
        value.lastSuccessfulProvisioningRecordId = try reader["LastSuccessfulProvisioningRecordId"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ServiceCatalogClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.physicalId = try reader["PhysicalId"].readIfPresent()
        value.productId = try reader["ProductId"].readIfPresent()
        value.productName = try reader["ProductName"].readIfPresent()
        value.provisioningArtifactId = try reader["ProvisioningArtifactId"].readIfPresent()
        value.provisioningArtifactName = try reader["ProvisioningArtifactName"].readIfPresent()
        value.userArn = try reader["UserArn"].readIfPresent()
        value.userArnSession = try reader["UserArnSession"].readIfPresent()
        return value
    }
}

extension ServiceCatalogClientTypes.ServiceActionAssociation {

    static func write(value: ServiceCatalogClientTypes.ServiceActionAssociation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProductId"].write(value.productId)
        try writer["ProvisioningArtifactId"].write(value.provisioningArtifactId)
        try writer["ServiceActionId"].write(value.serviceActionId)
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactProperties {

    static func write(value: ServiceCatalogClientTypes.ProvisioningArtifactProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["DisableTemplateValidation"].write(value.disableTemplateValidation)
        try writer["Info"].writeMap(value.info, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Type"].write(value.type)
    }
}

extension ServiceCatalogClientTypes.SourceConnection {

    static func write(value: ServiceCatalogClientTypes.SourceConnection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectionParameters"].write(value.connectionParameters, with: ServiceCatalogClientTypes.SourceConnectionParameters.write(value:to:))
        try writer["Type"].write(value.type)
    }
}

extension ServiceCatalogClientTypes.AccessLevelFilter {

    static func write(value: ServiceCatalogClientTypes.AccessLevelFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }
}

extension ServiceCatalogClientTypes.ListRecordHistorySearchFilter {

    static func write(value: ServiceCatalogClientTypes.ListRecordHistorySearchFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }
}

extension ServiceCatalogClientTypes.ListTagOptionsFilters {

    static func write(value: ServiceCatalogClientTypes.ListTagOptionsFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Active"].write(value.active)
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }
}

extension ServiceCatalogClientTypes.EngineWorkflowResourceIdentifier {

    static func write(value: ServiceCatalogClientTypes.EngineWorkflowResourceIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UniqueTag"].write(value.uniqueTag, with: ServiceCatalogClientTypes.UniqueTagResourceIdentifier.write(value:to:))
    }
}

extension ServiceCatalogClientTypes.UniqueTagResourceIdentifier {

    static func write(value: ServiceCatalogClientTypes.UniqueTagResourceIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }
}

extension ServiceCatalogClientTypes.ProvisioningParameter {

    static func write(value: ServiceCatalogClientTypes.ProvisioningParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }
}

extension ServiceCatalogClientTypes.ProvisioningPreferences {

    static func write(value: ServiceCatalogClientTypes.ProvisioningPreferences?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StackSetAccounts"].writeList(value.stackSetAccounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StackSetFailureToleranceCount"].write(value.stackSetFailureToleranceCount)
        try writer["StackSetFailureTolerancePercentage"].write(value.stackSetFailureTolerancePercentage)
        try writer["StackSetMaxConcurrencyCount"].write(value.stackSetMaxConcurrencyCount)
        try writer["StackSetMaxConcurrencyPercentage"].write(value.stackSetMaxConcurrencyPercentage)
        try writer["StackSetRegions"].writeList(value.stackSetRegions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ServiceCatalogClientTypes.UpdateProvisioningPreferences {

    static func write(value: ServiceCatalogClientTypes.UpdateProvisioningPreferences?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StackSetAccounts"].writeList(value.stackSetAccounts, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StackSetFailureToleranceCount"].write(value.stackSetFailureToleranceCount)
        try writer["StackSetFailureTolerancePercentage"].write(value.stackSetFailureTolerancePercentage)
        try writer["StackSetMaxConcurrencyCount"].write(value.stackSetMaxConcurrencyCount)
        try writer["StackSetMaxConcurrencyPercentage"].write(value.stackSetMaxConcurrencyPercentage)
        try writer["StackSetOperationType"].write(value.stackSetOperationType)
        try writer["StackSetRegions"].writeList(value.stackSetRegions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum ServiceCatalogClientTypes {}
