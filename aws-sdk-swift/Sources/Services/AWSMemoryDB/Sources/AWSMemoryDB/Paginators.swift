//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension MemoryDBClient {
    /// Paginate over `[DescribeACLsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeACLsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeACLsOutput`
    public func describeACLsPaginated(input: DescribeACLsInput) -> ClientRuntime.PaginatorSequence<DescribeACLsInput, DescribeACLsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeACLsInput, DescribeACLsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeACLs(input:))
    }
}

extension DescribeACLsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeACLsInput {
        return DescribeACLsInput(
            aclName: self.aclName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeACLsInput, OperationStackOutput == DescribeACLsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeACLsPaginated`
    /// to access the nested member `[MemoryDBClientTypes.ACL]`
    /// - Returns: `[MemoryDBClientTypes.ACL]`
    public func acLs() async throws -> [MemoryDBClientTypes.ACL] {
        return try await self.asyncCompactMap { item in item.acLs }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeClustersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeClustersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeClustersOutput`
    public func describeClustersPaginated(input: DescribeClustersInput) -> ClientRuntime.PaginatorSequence<DescribeClustersInput, DescribeClustersOutput> {
        return ClientRuntime.PaginatorSequence<DescribeClustersInput, DescribeClustersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeClusters(input:))
    }
}

extension DescribeClustersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeClustersInput {
        return DescribeClustersInput(
            clusterName: self.clusterName,
            maxResults: self.maxResults,
            nextToken: token,
            showShardDetails: self.showShardDetails
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeClustersInput, OperationStackOutput == DescribeClustersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeClustersPaginated`
    /// to access the nested member `[MemoryDBClientTypes.Cluster]`
    /// - Returns: `[MemoryDBClientTypes.Cluster]`
    public func clusters() async throws -> [MemoryDBClientTypes.Cluster] {
        return try await self.asyncCompactMap { item in item.clusters }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeEngineVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEngineVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEngineVersionsOutput`
    public func describeEngineVersionsPaginated(input: DescribeEngineVersionsInput) -> ClientRuntime.PaginatorSequence<DescribeEngineVersionsInput, DescribeEngineVersionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeEngineVersionsInput, DescribeEngineVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeEngineVersions(input:))
    }
}

extension DescribeEngineVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEngineVersionsInput {
        return DescribeEngineVersionsInput(
            defaultOnly: self.defaultOnly,
            engine: self.engine,
            engineVersion: self.engineVersion,
            maxResults: self.maxResults,
            nextToken: token,
            parameterGroupFamily: self.parameterGroupFamily
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeEngineVersionsInput, OperationStackOutput == DescribeEngineVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeEngineVersionsPaginated`
    /// to access the nested member `[MemoryDBClientTypes.EngineVersionInfo]`
    /// - Returns: `[MemoryDBClientTypes.EngineVersionInfo]`
    public func engineVersions() async throws -> [MemoryDBClientTypes.EngineVersionInfo] {
        return try await self.asyncCompactMap { item in item.engineVersions }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeEventsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeEventsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeEventsOutput`
    public func describeEventsPaginated(input: DescribeEventsInput) -> ClientRuntime.PaginatorSequence<DescribeEventsInput, DescribeEventsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeEventsInput, DescribeEventsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeEvents(input:))
    }
}

extension DescribeEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeEventsInput {
        return DescribeEventsInput(
            duration: self.duration,
            endTime: self.endTime,
            maxResults: self.maxResults,
            nextToken: token,
            sourceName: self.sourceName,
            sourceType: self.sourceType,
            startTime: self.startTime
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeEventsInput, OperationStackOutput == DescribeEventsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeEventsPaginated`
    /// to access the nested member `[MemoryDBClientTypes.Event]`
    /// - Returns: `[MemoryDBClientTypes.Event]`
    public func events() async throws -> [MemoryDBClientTypes.Event] {
        return try await self.asyncCompactMap { item in item.events }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeParameterGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeParameterGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeParameterGroupsOutput`
    public func describeParameterGroupsPaginated(input: DescribeParameterGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeParameterGroupsInput, DescribeParameterGroupsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeParameterGroupsInput, DescribeParameterGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeParameterGroups(input:))
    }
}

extension DescribeParameterGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeParameterGroupsInput {
        return DescribeParameterGroupsInput(
            maxResults: self.maxResults,
            nextToken: token,
            parameterGroupName: self.parameterGroupName
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeParameterGroupsInput, OperationStackOutput == DescribeParameterGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeParameterGroupsPaginated`
    /// to access the nested member `[MemoryDBClientTypes.ParameterGroup]`
    /// - Returns: `[MemoryDBClientTypes.ParameterGroup]`
    public func parameterGroups() async throws -> [MemoryDBClientTypes.ParameterGroup] {
        return try await self.asyncCompactMap { item in item.parameterGroups }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeParametersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeParametersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeParametersOutput`
    public func describeParametersPaginated(input: DescribeParametersInput) -> ClientRuntime.PaginatorSequence<DescribeParametersInput, DescribeParametersOutput> {
        return ClientRuntime.PaginatorSequence<DescribeParametersInput, DescribeParametersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeParameters(input:))
    }
}

extension DescribeParametersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeParametersInput {
        return DescribeParametersInput(
            maxResults: self.maxResults,
            nextToken: token,
            parameterGroupName: self.parameterGroupName
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeParametersInput, OperationStackOutput == DescribeParametersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeParametersPaginated`
    /// to access the nested member `[MemoryDBClientTypes.Parameter]`
    /// - Returns: `[MemoryDBClientTypes.Parameter]`
    public func parameters() async throws -> [MemoryDBClientTypes.Parameter] {
        return try await self.asyncCompactMap { item in item.parameters }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeReservedNodesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReservedNodesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReservedNodesOutput`
    public func describeReservedNodesPaginated(input: DescribeReservedNodesInput) -> ClientRuntime.PaginatorSequence<DescribeReservedNodesInput, DescribeReservedNodesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeReservedNodesInput, DescribeReservedNodesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeReservedNodes(input:))
    }
}

extension DescribeReservedNodesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReservedNodesInput {
        return DescribeReservedNodesInput(
            duration: self.duration,
            maxResults: self.maxResults,
            nextToken: token,
            nodeType: self.nodeType,
            offeringType: self.offeringType,
            reservationId: self.reservationId,
            reservedNodesOfferingId: self.reservedNodesOfferingId
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeReservedNodesInput, OperationStackOutput == DescribeReservedNodesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeReservedNodesPaginated`
    /// to access the nested member `[MemoryDBClientTypes.ReservedNode]`
    /// - Returns: `[MemoryDBClientTypes.ReservedNode]`
    public func reservedNodes() async throws -> [MemoryDBClientTypes.ReservedNode] {
        return try await self.asyncCompactMap { item in item.reservedNodes }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeReservedNodesOfferingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeReservedNodesOfferingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeReservedNodesOfferingsOutput`
    public func describeReservedNodesOfferingsPaginated(input: DescribeReservedNodesOfferingsInput) -> ClientRuntime.PaginatorSequence<DescribeReservedNodesOfferingsInput, DescribeReservedNodesOfferingsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeReservedNodesOfferingsInput, DescribeReservedNodesOfferingsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeReservedNodesOfferings(input:))
    }
}

extension DescribeReservedNodesOfferingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeReservedNodesOfferingsInput {
        return DescribeReservedNodesOfferingsInput(
            duration: self.duration,
            maxResults: self.maxResults,
            nextToken: token,
            nodeType: self.nodeType,
            offeringType: self.offeringType,
            reservedNodesOfferingId: self.reservedNodesOfferingId
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeReservedNodesOfferingsInput, OperationStackOutput == DescribeReservedNodesOfferingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeReservedNodesOfferingsPaginated`
    /// to access the nested member `[MemoryDBClientTypes.ReservedNodesOffering]`
    /// - Returns: `[MemoryDBClientTypes.ReservedNodesOffering]`
    public func reservedNodesOfferings() async throws -> [MemoryDBClientTypes.ReservedNodesOffering] {
        return try await self.asyncCompactMap { item in item.reservedNodesOfferings }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeServiceUpdatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeServiceUpdatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeServiceUpdatesOutput`
    public func describeServiceUpdatesPaginated(input: DescribeServiceUpdatesInput) -> ClientRuntime.PaginatorSequence<DescribeServiceUpdatesInput, DescribeServiceUpdatesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeServiceUpdatesInput, DescribeServiceUpdatesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeServiceUpdates(input:))
    }
}

extension DescribeServiceUpdatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeServiceUpdatesInput {
        return DescribeServiceUpdatesInput(
            clusterNames: self.clusterNames,
            maxResults: self.maxResults,
            nextToken: token,
            serviceUpdateName: self.serviceUpdateName,
            status: self.status
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeServiceUpdatesInput, OperationStackOutput == DescribeServiceUpdatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeServiceUpdatesPaginated`
    /// to access the nested member `[MemoryDBClientTypes.ServiceUpdate]`
    /// - Returns: `[MemoryDBClientTypes.ServiceUpdate]`
    public func serviceUpdates() async throws -> [MemoryDBClientTypes.ServiceUpdate] {
        return try await self.asyncCompactMap { item in item.serviceUpdates }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeSnapshotsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeSnapshotsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeSnapshotsOutput`
    public func describeSnapshotsPaginated(input: DescribeSnapshotsInput) -> ClientRuntime.PaginatorSequence<DescribeSnapshotsInput, DescribeSnapshotsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeSnapshotsInput, DescribeSnapshotsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeSnapshots(input:))
    }
}

extension DescribeSnapshotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSnapshotsInput {
        return DescribeSnapshotsInput(
            clusterName: self.clusterName,
            maxResults: self.maxResults,
            nextToken: token,
            showDetail: self.showDetail,
            snapshotName: self.snapshotName,
            source: self.source
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeSnapshotsInput, OperationStackOutput == DescribeSnapshotsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeSnapshotsPaginated`
    /// to access the nested member `[MemoryDBClientTypes.Snapshot]`
    /// - Returns: `[MemoryDBClientTypes.Snapshot]`
    public func snapshots() async throws -> [MemoryDBClientTypes.Snapshot] {
        return try await self.asyncCompactMap { item in item.snapshots }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeSubnetGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeSubnetGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeSubnetGroupsOutput`
    public func describeSubnetGroupsPaginated(input: DescribeSubnetGroupsInput) -> ClientRuntime.PaginatorSequence<DescribeSubnetGroupsInput, DescribeSubnetGroupsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeSubnetGroupsInput, DescribeSubnetGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeSubnetGroups(input:))
    }
}

extension DescribeSubnetGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSubnetGroupsInput {
        return DescribeSubnetGroupsInput(
            maxResults: self.maxResults,
            nextToken: token,
            subnetGroupName: self.subnetGroupName
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeSubnetGroupsInput, OperationStackOutput == DescribeSubnetGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeSubnetGroupsPaginated`
    /// to access the nested member `[MemoryDBClientTypes.SubnetGroup]`
    /// - Returns: `[MemoryDBClientTypes.SubnetGroup]`
    public func subnetGroups() async throws -> [MemoryDBClientTypes.SubnetGroup] {
        return try await self.asyncCompactMap { item in item.subnetGroups }
    }
}
extension MemoryDBClient {
    /// Paginate over `[DescribeUsersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeUsersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeUsersOutput`
    public func describeUsersPaginated(input: DescribeUsersInput) -> ClientRuntime.PaginatorSequence<DescribeUsersInput, DescribeUsersOutput> {
        return ClientRuntime.PaginatorSequence<DescribeUsersInput, DescribeUsersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeUsers(input:))
    }
}

extension DescribeUsersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeUsersInput {
        return DescribeUsersInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            userName: self.userName
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeUsersInput, OperationStackOutput == DescribeUsersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeUsersPaginated`
    /// to access the nested member `[MemoryDBClientTypes.User]`
    /// - Returns: `[MemoryDBClientTypes.User]`
    public func users() async throws -> [MemoryDBClientTypes.User] {
        return try await self.asyncCompactMap { item in item.users }
    }
}
