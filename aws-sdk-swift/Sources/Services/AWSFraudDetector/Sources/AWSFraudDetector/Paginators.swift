//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension FraudDetectorClient {
    /// Paginate over `[DescribeModelVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeModelVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeModelVersionsOutput`
    public func describeModelVersionsPaginated(input: DescribeModelVersionsInput) -> ClientRuntime.PaginatorSequence<DescribeModelVersionsInput, DescribeModelVersionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeModelVersionsInput, DescribeModelVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeModelVersions(input:))
    }
}

extension DescribeModelVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeModelVersionsInput {
        return DescribeModelVersionsInput(
            maxResults: self.maxResults,
            modelId: self.modelId,
            modelType: self.modelType,
            modelVersionNumber: self.modelVersionNumber,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetBatchImportJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetBatchImportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetBatchImportJobsOutput`
    public func getBatchImportJobsPaginated(input: GetBatchImportJobsInput) -> ClientRuntime.PaginatorSequence<GetBatchImportJobsInput, GetBatchImportJobsOutput> {
        return ClientRuntime.PaginatorSequence<GetBatchImportJobsInput, GetBatchImportJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getBatchImportJobs(input:))
    }
}

extension GetBatchImportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetBatchImportJobsInput {
        return GetBatchImportJobsInput(
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetBatchPredictionJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetBatchPredictionJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetBatchPredictionJobsOutput`
    public func getBatchPredictionJobsPaginated(input: GetBatchPredictionJobsInput) -> ClientRuntime.PaginatorSequence<GetBatchPredictionJobsInput, GetBatchPredictionJobsOutput> {
        return ClientRuntime.PaginatorSequence<GetBatchPredictionJobsInput, GetBatchPredictionJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getBatchPredictionJobs(input:))
    }
}

extension GetBatchPredictionJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetBatchPredictionJobsInput {
        return GetBatchPredictionJobsInput(
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetDetectorsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetDetectorsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetDetectorsOutput`
    public func getDetectorsPaginated(input: GetDetectorsInput) -> ClientRuntime.PaginatorSequence<GetDetectorsInput, GetDetectorsOutput> {
        return ClientRuntime.PaginatorSequence<GetDetectorsInput, GetDetectorsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getDetectors(input:))
    }
}

extension GetDetectorsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetDetectorsInput {
        return GetDetectorsInput(
            detectorId: self.detectorId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetEntityTypesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetEntityTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetEntityTypesOutput`
    public func getEntityTypesPaginated(input: GetEntityTypesInput) -> ClientRuntime.PaginatorSequence<GetEntityTypesInput, GetEntityTypesOutput> {
        return ClientRuntime.PaginatorSequence<GetEntityTypesInput, GetEntityTypesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getEntityTypes(input:))
    }
}

extension GetEntityTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetEntityTypesInput {
        return GetEntityTypesInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetEventTypesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetEventTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetEventTypesOutput`
    public func getEventTypesPaginated(input: GetEventTypesInput) -> ClientRuntime.PaginatorSequence<GetEventTypesInput, GetEventTypesOutput> {
        return ClientRuntime.PaginatorSequence<GetEventTypesInput, GetEventTypesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getEventTypes(input:))
    }
}

extension GetEventTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetEventTypesInput {
        return GetEventTypesInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetExternalModelsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetExternalModelsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetExternalModelsOutput`
    public func getExternalModelsPaginated(input: GetExternalModelsInput) -> ClientRuntime.PaginatorSequence<GetExternalModelsInput, GetExternalModelsOutput> {
        return ClientRuntime.PaginatorSequence<GetExternalModelsInput, GetExternalModelsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getExternalModels(input:))
    }
}

extension GetExternalModelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetExternalModelsInput {
        return GetExternalModelsInput(
            maxResults: self.maxResults,
            modelEndpoint: self.modelEndpoint,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetLabelsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetLabelsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetLabelsOutput`
    public func getLabelsPaginated(input: GetLabelsInput) -> ClientRuntime.PaginatorSequence<GetLabelsInput, GetLabelsOutput> {
        return ClientRuntime.PaginatorSequence<GetLabelsInput, GetLabelsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getLabels(input:))
    }
}

extension GetLabelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetLabelsInput {
        return GetLabelsInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetListElementsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetListElementsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetListElementsOutput`
    public func getListElementsPaginated(input: GetListElementsInput) -> ClientRuntime.PaginatorSequence<GetListElementsInput, GetListElementsOutput> {
        return ClientRuntime.PaginatorSequence<GetListElementsInput, GetListElementsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getListElements(input:))
    }
}

extension GetListElementsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetListElementsInput {
        return GetListElementsInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetListsMetadataOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetListsMetadataInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetListsMetadataOutput`
    public func getListsMetadataPaginated(input: GetListsMetadataInput) -> ClientRuntime.PaginatorSequence<GetListsMetadataInput, GetListsMetadataOutput> {
        return ClientRuntime.PaginatorSequence<GetListsMetadataInput, GetListsMetadataOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getListsMetadata(input:))
    }
}

extension GetListsMetadataInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetListsMetadataInput {
        return GetListsMetadataInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetModelsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetModelsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetModelsOutput`
    public func getModelsPaginated(input: GetModelsInput) -> ClientRuntime.PaginatorSequence<GetModelsInput, GetModelsOutput> {
        return ClientRuntime.PaginatorSequence<GetModelsInput, GetModelsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getModels(input:))
    }
}

extension GetModelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetModelsInput {
        return GetModelsInput(
            maxResults: self.maxResults,
            modelId: self.modelId,
            modelType: self.modelType,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetOutcomesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetOutcomesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetOutcomesOutput`
    public func getOutcomesPaginated(input: GetOutcomesInput) -> ClientRuntime.PaginatorSequence<GetOutcomesInput, GetOutcomesOutput> {
        return ClientRuntime.PaginatorSequence<GetOutcomesInput, GetOutcomesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getOutcomes(input:))
    }
}

extension GetOutcomesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetOutcomesInput {
        return GetOutcomesInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetRulesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetRulesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetRulesOutput`
    public func getRulesPaginated(input: GetRulesInput) -> ClientRuntime.PaginatorSequence<GetRulesInput, GetRulesOutput> {
        return ClientRuntime.PaginatorSequence<GetRulesInput, GetRulesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getRules(input:))
    }
}

extension GetRulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetRulesInput {
        return GetRulesInput(
            detectorId: self.detectorId,
            maxResults: self.maxResults,
            nextToken: token,
            ruleId: self.ruleId,
            ruleVersion: self.ruleVersion
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetVariablesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetVariablesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetVariablesOutput`
    public func getVariablesPaginated(input: GetVariablesInput) -> ClientRuntime.PaginatorSequence<GetVariablesInput, GetVariablesOutput> {
        return ClientRuntime.PaginatorSequence<GetVariablesInput, GetVariablesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getVariables(input:))
    }
}

extension GetVariablesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetVariablesInput {
        return GetVariablesInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[ListEventPredictionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListEventPredictionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListEventPredictionsOutput`
    public func listEventPredictionsPaginated(input: ListEventPredictionsInput) -> ClientRuntime.PaginatorSequence<ListEventPredictionsInput, ListEventPredictionsOutput> {
        return ClientRuntime.PaginatorSequence<ListEventPredictionsInput, ListEventPredictionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listEventPredictions(input:))
    }
}

extension ListEventPredictionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEventPredictionsInput {
        return ListEventPredictionsInput(
            detectorId: self.detectorId,
            detectorVersionId: self.detectorVersionId,
            eventId: self.eventId,
            eventType: self.eventType,
            maxResults: self.maxResults,
            nextToken: token,
            predictionTimeRange: self.predictionTimeRange
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[ListTagsForResourceOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTagsForResourceInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTagsForResourceOutput`
    public func listTagsForResourcePaginated(input: ListTagsForResourceInput) -> ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutput> {
        return ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTagsForResource(input:))
    }
}

extension ListTagsForResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsForResourceInput {
        return ListTagsForResourceInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceARN: self.resourceARN
        )}
}
