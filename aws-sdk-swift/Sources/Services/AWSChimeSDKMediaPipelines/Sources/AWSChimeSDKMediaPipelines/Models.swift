//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct DeleteMediaCapturePipelineOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteMediaInsightsPipelineConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteMediaPipelineKinesisVideoStreamPoolOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteMediaPipelineOutput: Swift.Sendable {

    public init() { }
}

public struct StopSpeakerSearchTaskOutput: Swift.Sendable {

    public init() { }
}

public struct StopVoiceToneAnalysisTaskOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateMediaInsightsPipelineStatusOutput: Swift.Sendable {

    public init() { }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum ActiveSpeakerPosition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bottomleft
        case bottomright
        case topleft
        case topright
        case sdkUnknown(Swift.String)

        public static var allCases: [ActiveSpeakerPosition] {
            return [
                .bottomleft,
                .bottomright,
                .topleft,
                .topright
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bottomleft: return "BottomLeft"
            case .bottomright: return "BottomRight"
            case .topleft: return "TopLeft"
            case .topright: return "TopRight"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// Defines the configuration for an ActiveSpeakerOnly video tile.
    public struct ActiveSpeakerOnlyConfiguration: Swift.Sendable {
        /// The position of the ActiveSpeakerOnly video tile.
        public var activeSpeakerPosition: ChimeSDKMediaPipelinesClientTypes.ActiveSpeakerPosition?

        public init(
            activeSpeakerPosition: ChimeSDKMediaPipelinesClientTypes.ActiveSpeakerPosition? = nil
        )
        {
            self.activeSpeakerPosition = activeSpeakerPosition
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum ContentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pii
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentType] {
            return [
                .pii
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pii: return "PII"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum CallAnalyticsLanguageCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deDe
        case enAu
        case enGb
        case enUs
        case esUs
        case frCa
        case frFr
        case itIt
        case ptBr
        case sdkUnknown(Swift.String)

        public static var allCases: [CallAnalyticsLanguageCode] {
            return [
                .deDe,
                .enAu,
                .enGb,
                .enUs,
                .esUs,
                .frCa,
                .frFr,
                .itIt,
                .ptBr
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "de-DE"
            case .enAu: return "en-AU"
            case .enGb: return "en-GB"
            case .enUs: return "en-US"
            case .esUs: return "es-US"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .itIt: return "it-IT"
            case .ptBr: return "pt-BR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum PartialResultsStability: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [PartialResultsStability] {
            return [
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "high"
            case .low: return "low"
            case .medium: return "medium"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum ContentRedactionOutput: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case redacted
        case redactedAndUnredacted
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentRedactionOutput] {
            return [
                .redacted,
                .redactedAndUnredacted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .redacted: return "redacted"
            case .redactedAndUnredacted: return "redacted_and_unredacted"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// Allows you to specify additional settings for your Call Analytics post-call request, including output locations for your redacted transcript, which IAM role to use, and which encryption key to use. DataAccessRoleArn and OutputLocation are required fields. PostCallAnalyticsSettings provides the same insights as a Call Analytics post-call transcription. For more information, refer to [Post-call analytics with real-time transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/tca-post-call.html) in the Amazon Transcribe Developer Guide.
    public struct PostCallAnalyticsSettings: Swift.Sendable {
        /// The content redaction output settings for a post-call analysis task.
        public var contentRedactionOutput: ChimeSDKMediaPipelinesClientTypes.ContentRedactionOutput?
        /// The ARN of the role used by Amazon Web Services Transcribe to upload your post call analysis. For more information, see [Post-call analytics with real-time transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/tca-post-call.html) in the Amazon Transcribe Developer Guide.
        /// This member is required.
        public var dataAccessRoleArn: Swift.String?
        /// The ID of the KMS (Key Management Service) key used to encrypt the output.
        public var outputEncryptionKMSKeyId: Swift.String?
        /// The URL of the Amazon S3 bucket that contains the post-call data.
        /// This member is required.
        public var outputLocation: Swift.String?

        public init(
            contentRedactionOutput: ChimeSDKMediaPipelinesClientTypes.ContentRedactionOutput? = nil,
            dataAccessRoleArn: Swift.String? = nil,
            outputEncryptionKMSKeyId: Swift.String? = nil,
            outputLocation: Swift.String? = nil
        )
        {
            self.contentRedactionOutput = contentRedactionOutput
            self.dataAccessRoleArn = dataAccessRoleArn
            self.outputEncryptionKMSKeyId = outputEncryptionKMSKeyId
            self.outputLocation = outputLocation
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum VocabularyFilterMethod: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mask
        case remove
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [VocabularyFilterMethod] {
            return [
                .mask,
                .remove,
                .tag
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mask: return "mask"
            case .remove: return "remove"
            case .tag: return "tag"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A structure that contains the configuration settings for an Amazon Transcribe call analytics processor.
    public struct AmazonTranscribeCallAnalyticsProcessorConfiguration: Swift.Sendable {
        /// By default, all CategoryEvents are sent to the insights target. If this parameter is specified, only included categories are sent to the insights target.
        public var callAnalyticsStreamCategories: [Swift.String]?
        /// Labels all personally identifiable information (PII) identified in your transcript. Content identification is performed at the segment level; PII specified in PiiEntityTypes is flagged upon complete transcription of an audio segment. You can’t set ContentIdentificationType and ContentRedactionType in the same request. If you do, your request returns a BadRequestException. For more information, see [Redacting or identifying personally identifiable information](https://docs.aws.amazon.com/transcribe/latest/dg/pii-redaction.html) in the Amazon Transcribe Developer Guide.
        public var contentIdentificationType: ChimeSDKMediaPipelinesClientTypes.ContentType?
        /// Redacts all personally identifiable information (PII) identified in your transcript. Content redaction is performed at the segment level; PII specified in PiiEntityTypes is redacted upon complete transcription of an audio segment. You can’t set ContentRedactionType and ContentIdentificationType in the same request. If you do, your request returns a BadRequestException. For more information, see [Redacting or identifying personally identifiable information](https://docs.aws.amazon.com/transcribe/latest/dg/pii-redaction.html) in the Amazon Transcribe Developer Guide.
        public var contentRedactionType: ChimeSDKMediaPipelinesClientTypes.ContentType?
        /// Enables partial result stabilization for your transcription. Partial result stabilization can reduce latency in your output, but may impact accuracy. For more information, see [Partial-result stabilization](https://docs.aws.amazon.com/transcribe/latest/dg/streaming.html#streaming-partial-result-stabilization) in the Amazon Transcribe Developer Guide.
        public var enablePartialResultsStabilization: Swift.Bool
        /// If true, UtteranceEvents with IsPartial: true are filtered out of the insights target.
        public var filterPartialResults: Swift.Bool
        /// The language code in the configuration.
        /// This member is required.
        public var languageCode: ChimeSDKMediaPipelinesClientTypes.CallAnalyticsLanguageCode?
        /// Specifies the name of the custom language model to use when processing a transcription. Note that language model names are case sensitive. The language of the specified language model must match the language code specified in the transcription request. If the languages don't match, the custom language model isn't applied. Language mismatches don't generate errors or warnings. For more information, see [Custom language models](https://docs.aws.amazon.com/transcribe/latest/dg/custom-language-models.html) in the Amazon Transcribe Developer Guide.
        public var languageModelName: Swift.String?
        /// Specifies the level of stability to use when you enable partial results stabilization (EnablePartialResultsStabilization). Low stability provides the highest accuracy. High stability transcribes faster, but with slightly lower accuracy. For more information, see [Partial-result stabilization](https://docs.aws.amazon.com/transcribe/latest/dg/streaming.html#streaming-partial-result-stabilization) in the Amazon Transcribe Developer Guide.
        public var partialResultsStability: ChimeSDKMediaPipelinesClientTypes.PartialResultsStability?
        /// Specifies the types of personally identifiable information (PII) to redact from a transcript. You can include as many types as you'd like, or you can select ALL. To include PiiEntityTypes in your Call Analytics request, you must also include ContentIdentificationType or ContentRedactionType, but you can't include both. Values must be comma-separated and can include: ADDRESS, BANK_ACCOUNT_NUMBER, BANK_ROUTING, CREDIT_DEBIT_CVV, CREDIT_DEBIT_EXPIRY, CREDIT_DEBIT_NUMBER, EMAIL, NAME, PHONE, PIN, SSN, or ALL. Length Constraints: Minimum length of 1. Maximum length of 300.
        public var piiEntityTypes: Swift.String?
        /// The settings for a post-call analysis task in an analytics configuration.
        public var postCallAnalyticsSettings: ChimeSDKMediaPipelinesClientTypes.PostCallAnalyticsSettings?
        /// Specifies how to apply a vocabulary filter to a transcript. To replace words with ***, choose mask. To delete words, choose remove. To flag words without changing them, choose tag.
        public var vocabularyFilterMethod: ChimeSDKMediaPipelinesClientTypes.VocabularyFilterMethod?
        /// Specifies the name of the custom vocabulary filter to use when processing a transcription. Note that vocabulary filter names are case sensitive. If the language of the specified custom vocabulary filter doesn't match the language identified in your media, the vocabulary filter is not applied to your transcription. For more information, see [Using vocabulary filtering with unwanted words](https://docs.aws.amazon.com/transcribe/latest/dg/vocabulary-filtering.html) in the Amazon Transcribe Developer Guide. Length Constraints: Minimum length of 1. Maximum length of 200.
        public var vocabularyFilterName: Swift.String?
        /// Specifies the name of the custom vocabulary to use when processing a transcription. Note that vocabulary names are case sensitive. If the language of the specified custom vocabulary doesn't match the language identified in your media, the custom vocabulary is not applied to your transcription. For more information, see [Custom vocabularies](https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html) in the Amazon Transcribe Developer Guide. Length Constraints: Minimum length of 1. Maximum length of 200.
        public var vocabularyName: Swift.String?

        public init(
            callAnalyticsStreamCategories: [Swift.String]? = nil,
            contentIdentificationType: ChimeSDKMediaPipelinesClientTypes.ContentType? = nil,
            contentRedactionType: ChimeSDKMediaPipelinesClientTypes.ContentType? = nil,
            enablePartialResultsStabilization: Swift.Bool = false,
            filterPartialResults: Swift.Bool = false,
            languageCode: ChimeSDKMediaPipelinesClientTypes.CallAnalyticsLanguageCode? = nil,
            languageModelName: Swift.String? = nil,
            partialResultsStability: ChimeSDKMediaPipelinesClientTypes.PartialResultsStability? = nil,
            piiEntityTypes: Swift.String? = nil,
            postCallAnalyticsSettings: ChimeSDKMediaPipelinesClientTypes.PostCallAnalyticsSettings? = nil,
            vocabularyFilterMethod: ChimeSDKMediaPipelinesClientTypes.VocabularyFilterMethod? = nil,
            vocabularyFilterName: Swift.String? = nil,
            vocabularyName: Swift.String? = nil
        )
        {
            self.callAnalyticsStreamCategories = callAnalyticsStreamCategories
            self.contentIdentificationType = contentIdentificationType
            self.contentRedactionType = contentRedactionType
            self.enablePartialResultsStabilization = enablePartialResultsStabilization
            self.filterPartialResults = filterPartialResults
            self.languageCode = languageCode
            self.languageModelName = languageModelName
            self.partialResultsStability = partialResultsStability
            self.piiEntityTypes = piiEntityTypes
            self.postCallAnalyticsSettings = postCallAnalyticsSettings
            self.vocabularyFilterMethod = vocabularyFilterMethod
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyName = vocabularyName
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A structure that contains the configuration settings for an Amazon Transcribe processor. Calls to this API must include a LanguageCode, IdentifyLanguage, or IdentifyMultipleLanguages parameter. If you include more than one of those parameters, your transcription job fails.
    public struct AmazonTranscribeProcessorConfiguration: Swift.Sendable {
        /// Labels all personally identifiable information (PII) identified in your transcript. Content identification is performed at the segment level; PII specified in PiiEntityTypes is flagged upon complete transcription of an audio segment. You can’t set ContentIdentificationType and ContentRedactionType in the same request. If you set both, your request returns a BadRequestException. For more information, see [Redacting or identifying personally identifiable information](https://docs.aws.amazon.com/transcribe/latest/dg/pii-redaction.html) in the Amazon Transcribe Developer Guide.
        public var contentIdentificationType: ChimeSDKMediaPipelinesClientTypes.ContentType?
        /// Redacts all personally identifiable information (PII) identified in your transcript. Content redaction is performed at the segment level; PII specified in PiiEntityTypes is redacted upon complete transcription of an audio segment. You can’t set ContentRedactionType and ContentIdentificationType in the same request. If you set both, your request returns a BadRequestException. For more information, see [Redacting or identifying personally identifiable information](https://docs.aws.amazon.com/transcribe/latest/dg/pii-redaction.html) in the Amazon Transcribe Developer Guide.
        public var contentRedactionType: ChimeSDKMediaPipelinesClientTypes.ContentType?
        /// Enables partial result stabilization for your transcription. Partial result stabilization can reduce latency in your output, but may impact accuracy. For more information, see [Partial-result stabilization](https://docs.aws.amazon.com/transcribe/latest/dg/streaming.html#streaming-partial-result-stabilization) in the Amazon Transcribe Developer Guide.
        public var enablePartialResultsStabilization: Swift.Bool
        /// If true, TranscriptEvents with IsPartial: true are filtered out of the insights target.
        public var filterPartialResults: Swift.Bool
        /// Turns language identification on or off.
        public var identifyLanguage: Swift.Bool
        /// Turns language identification on or off for multiple languages.
        public var identifyMultipleLanguages: Swift.Bool
        /// The language code that represents the language spoken in your audio. If you're unsure of the language spoken in your audio, consider using IdentifyLanguage to enable automatic language identification. For a list of languages that real-time Call Analytics supports, see the [Supported languages table](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html) in the Amazon Transcribe Developer Guide.
        public var languageCode: ChimeSDKMediaPipelinesClientTypes.CallAnalyticsLanguageCode?
        /// The name of the custom language model that you want to use when processing your transcription. Note that language model names are case sensitive. The language of the specified language model must match the language code you specify in your transcription request. If the languages don't match, the custom language model isn't applied. There are no errors or warnings associated with a language mismatch. For more information, see [Custom language models](https://docs.aws.amazon.com/transcribe/latest/dg/custom-language-models.html) in the Amazon Transcribe Developer Guide.
        public var languageModelName: Swift.String?
        /// The language options for the transcription, such as automatic language detection.
        public var languageOptions: Swift.String?
        /// The level of stability to use when you enable partial results stabilization (EnablePartialResultsStabilization). Low stability provides the highest accuracy. High stability transcribes faster, but with slightly lower accuracy. For more information, see [Partial-result stabilization](https://docs.aws.amazon.com/transcribe/latest/dg/streaming.html#streaming-partial-result-stabilization) in the Amazon Transcribe Developer Guide.
        public var partialResultsStability: ChimeSDKMediaPipelinesClientTypes.PartialResultsStability?
        /// The types of personally identifiable information (PII) to redact from a transcript. You can include as many types as you'd like, or you can select ALL. To include PiiEntityTypes in your Call Analytics request, you must also include ContentIdentificationType or ContentRedactionType, but you can't include both. Values must be comma-separated and can include: ADDRESS, BANK_ACCOUNT_NUMBER, BANK_ROUTING, CREDIT_DEBIT_CVV, CREDIT_DEBIT_EXPIRY, CREDIT_DEBIT_NUMBER, EMAIL, NAME, PHONE, PIN, SSN, or ALL. If you leave this parameter empty, the default behavior is equivalent to ALL.
        public var piiEntityTypes: Swift.String?
        /// The preferred language for the transcription.
        public var preferredLanguage: ChimeSDKMediaPipelinesClientTypes.CallAnalyticsLanguageCode?
        /// Enables speaker partitioning (diarization) in your transcription output. Speaker partitioning labels the speech from individual speakers in your media file. For more information, see [Partitioning speakers (diarization)](https://docs.aws.amazon.com/transcribe/latest/dg/diarization.html) in the Amazon Transcribe Developer Guide.
        public var showSpeakerLabel: Swift.Bool
        /// The vocabulary filtering method used in your Call Analytics transcription.
        public var vocabularyFilterMethod: ChimeSDKMediaPipelinesClientTypes.VocabularyFilterMethod?
        /// The name of the custom vocabulary filter that you specified in your Call Analytics request. Length Constraints: Minimum length of 1. Maximum length of 200.
        public var vocabularyFilterName: Swift.String?
        /// The names of the custom vocabulary filter or filters using during transcription.
        public var vocabularyFilterNames: Swift.String?
        /// The name of the custom vocabulary that you specified in your Call Analytics request. Length Constraints: Minimum length of 1. Maximum length of 200.
        public var vocabularyName: Swift.String?
        /// The names of the custom vocabulary or vocabularies used during transcription.
        public var vocabularyNames: Swift.String?

        public init(
            contentIdentificationType: ChimeSDKMediaPipelinesClientTypes.ContentType? = nil,
            contentRedactionType: ChimeSDKMediaPipelinesClientTypes.ContentType? = nil,
            enablePartialResultsStabilization: Swift.Bool = false,
            filterPartialResults: Swift.Bool = false,
            identifyLanguage: Swift.Bool = false,
            identifyMultipleLanguages: Swift.Bool = false,
            languageCode: ChimeSDKMediaPipelinesClientTypes.CallAnalyticsLanguageCode? = nil,
            languageModelName: Swift.String? = nil,
            languageOptions: Swift.String? = nil,
            partialResultsStability: ChimeSDKMediaPipelinesClientTypes.PartialResultsStability? = nil,
            piiEntityTypes: Swift.String? = nil,
            preferredLanguage: ChimeSDKMediaPipelinesClientTypes.CallAnalyticsLanguageCode? = nil,
            showSpeakerLabel: Swift.Bool = false,
            vocabularyFilterMethod: ChimeSDKMediaPipelinesClientTypes.VocabularyFilterMethod? = nil,
            vocabularyFilterName: Swift.String? = nil,
            vocabularyFilterNames: Swift.String? = nil,
            vocabularyName: Swift.String? = nil,
            vocabularyNames: Swift.String? = nil
        )
        {
            self.contentIdentificationType = contentIdentificationType
            self.contentRedactionType = contentRedactionType
            self.enablePartialResultsStabilization = enablePartialResultsStabilization
            self.filterPartialResults = filterPartialResults
            self.identifyLanguage = identifyLanguage
            self.identifyMultipleLanguages = identifyMultipleLanguages
            self.languageCode = languageCode
            self.languageModelName = languageModelName
            self.languageOptions = languageOptions
            self.partialResultsStability = partialResultsStability
            self.piiEntityTypes = piiEntityTypes
            self.preferredLanguage = preferredLanguage
            self.showSpeakerLabel = showSpeakerLabel
            self.vocabularyFilterMethod = vocabularyFilterMethod
            self.vocabularyFilterName = vocabularyFilterName
            self.vocabularyFilterNames = vocabularyFilterNames
            self.vocabularyName = vocabularyName
            self.vocabularyNames = vocabularyNames
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum AudioArtifactsConcatenationState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AudioArtifactsConcatenationState] {
            return [
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The audio artifact concatenation configuration object.
    public struct AudioConcatenationConfiguration: Swift.Sendable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConcatenationState?

        public init(
            state: ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum ArtifactsConcatenationState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactsConcatenationState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The composited video configuration object for a specified media pipeline. SourceType must be ChimeSdkMeeting.
    public struct CompositedVideoConcatenationConfiguration: Swift.Sendable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState?

        public init(
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The composited content configuration object for a specified media pipeline.
    public struct ContentConcatenationConfiguration: Swift.Sendable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState?

        public init(
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The content configuration object's data channel.
    public struct DataChannelConcatenationConfiguration: Swift.Sendable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState?

        public init(
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The configuration object for an event concatenation pipeline.
    public struct MeetingEventsConcatenationConfiguration: Swift.Sendable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState?

        public init(
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The configuration object for concatenating transcription messages.
    public struct TranscriptionMessagesConcatenationConfiguration: Swift.Sendable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState?

        public init(
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The configuration object of a video concatenation pipeline.
    public struct VideoConcatenationConfiguration: Swift.Sendable {
        /// Enables or disables the configuration object.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState?

        public init(
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationState? = nil
        )
        {
            self.state = state
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The configuration for the artifacts concatenation.
    public struct ArtifactsConcatenationConfiguration: Swift.Sendable {
        /// The configuration for the audio artifacts concatenation.
        /// This member is required.
        public var audio: ChimeSDKMediaPipelinesClientTypes.AudioConcatenationConfiguration?
        /// The configuration for the composited video artifacts concatenation.
        /// This member is required.
        public var compositedVideo: ChimeSDKMediaPipelinesClientTypes.CompositedVideoConcatenationConfiguration?
        /// The configuration for the content artifacts concatenation.
        /// This member is required.
        public var content: ChimeSDKMediaPipelinesClientTypes.ContentConcatenationConfiguration?
        /// The configuration for the data channel artifacts concatenation.
        /// This member is required.
        public var dataChannel: ChimeSDKMediaPipelinesClientTypes.DataChannelConcatenationConfiguration?
        /// The configuration for the meeting events artifacts concatenation.
        /// This member is required.
        public var meetingEvents: ChimeSDKMediaPipelinesClientTypes.MeetingEventsConcatenationConfiguration?
        /// The configuration for the transcription messages artifacts concatenation.
        /// This member is required.
        public var transcriptionMessages: ChimeSDKMediaPipelinesClientTypes.TranscriptionMessagesConcatenationConfiguration?
        /// The configuration for the video artifacts concatenation.
        /// This member is required.
        public var video: ChimeSDKMediaPipelinesClientTypes.VideoConcatenationConfiguration?

        public init(
            audio: ChimeSDKMediaPipelinesClientTypes.AudioConcatenationConfiguration? = nil,
            compositedVideo: ChimeSDKMediaPipelinesClientTypes.CompositedVideoConcatenationConfiguration? = nil,
            content: ChimeSDKMediaPipelinesClientTypes.ContentConcatenationConfiguration? = nil,
            dataChannel: ChimeSDKMediaPipelinesClientTypes.DataChannelConcatenationConfiguration? = nil,
            meetingEvents: ChimeSDKMediaPipelinesClientTypes.MeetingEventsConcatenationConfiguration? = nil,
            transcriptionMessages: ChimeSDKMediaPipelinesClientTypes.TranscriptionMessagesConcatenationConfiguration? = nil,
            video: ChimeSDKMediaPipelinesClientTypes.VideoConcatenationConfiguration? = nil
        )
        {
            self.audio = audio
            self.compositedVideo = compositedVideo
            self.content = content
            self.dataChannel = dataChannel
            self.meetingEvents = meetingEvents
            self.transcriptionMessages = transcriptionMessages
            self.video = video
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum AudioMuxType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case audioonly
        case audiowithactivespeakervideo
        case audiowithcompositedvideo
        case sdkUnknown(Swift.String)

        public static var allCases: [AudioMuxType] {
            return [
                .audioonly,
                .audiowithactivespeakervideo,
                .audiowithcompositedvideo
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .audioonly: return "AudioOnly"
            case .audiowithactivespeakervideo: return "AudioWithActiveSpeakerVideo"
            case .audiowithcompositedvideo: return "AudioWithCompositedVideo"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The audio artifact configuration object.
    public struct AudioArtifactsConfiguration: Swift.Sendable {
        /// The MUX type of the audio artifact configuration object.
        /// This member is required.
        public var muxType: ChimeSDKMediaPipelinesClientTypes.AudioMuxType?

        public init(
            muxType: ChimeSDKMediaPipelinesClientTypes.AudioMuxType? = nil
        )
        {
            self.muxType = muxType
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum CanvasOrientation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case landscape
        case portrait
        case sdkUnknown(Swift.String)

        public static var allCases: [CanvasOrientation] {
            return [
                .landscape,
                .portrait
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .landscape: return "Landscape"
            case .portrait: return "Portrait"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum ContentShareLayoutOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activespeakeronly
        case horizontal
        case presenteronly
        case vertical
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentShareLayoutOption] {
            return [
                .activespeakeronly,
                .horizontal,
                .presenteronly,
                .vertical
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activespeakeronly: return "ActiveSpeakerOnly"
            case .horizontal: return "Horizontal"
            case .presenteronly: return "PresenterOnly"
            case .vertical: return "Vertical"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum TileOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case joinsequence
        case speakersequence
        case sdkUnknown(Swift.String)

        public static var allCases: [TileOrder] {
            return [
                .joinsequence,
                .speakersequence
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .joinsequence: return "JoinSequence"
            case .speakersequence: return "SpeakerSequence"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum HorizontalTilePosition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bottom
        case top
        case sdkUnknown(Swift.String)

        public static var allCases: [HorizontalTilePosition] {
            return [
                .bottom,
                .top
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bottom: return "Bottom"
            case .top: return "Top"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// Defines the configuration settings for the horizontal layout.
    public struct HorizontalLayoutConfiguration: Swift.Sendable {
        /// Specifies the aspect ratio of all video tiles.
        public var tileAspectRatio: Swift.String?
        /// The maximum number of video tiles to display.
        public var tileCount: Swift.Int?
        /// Sets the automatic ordering of the video tiles.
        public var tileOrder: ChimeSDKMediaPipelinesClientTypes.TileOrder?
        /// Sets the position of horizontal tiles.
        public var tilePosition: ChimeSDKMediaPipelinesClientTypes.HorizontalTilePosition?

        public init(
            tileAspectRatio: Swift.String? = nil,
            tileCount: Swift.Int? = nil,
            tileOrder: ChimeSDKMediaPipelinesClientTypes.TileOrder? = nil,
            tilePosition: ChimeSDKMediaPipelinesClientTypes.HorizontalTilePosition? = nil
        )
        {
            self.tileAspectRatio = tileAspectRatio
            self.tileCount = tileCount
            self.tileOrder = tileOrder
            self.tilePosition = tilePosition
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum PresenterPosition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bottomleft
        case bottomright
        case topleft
        case topright
        case sdkUnknown(Swift.String)

        public static var allCases: [PresenterPosition] {
            return [
                .bottomleft,
                .bottomright,
                .topleft,
                .topright
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bottomleft: return "BottomLeft"
            case .bottomright: return "BottomRight"
            case .topleft: return "TopLeft"
            case .topright: return "TopRight"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// Defines the configuration for a presenter-only video tile.
    public struct PresenterOnlyConfiguration: Swift.Sendable {
        /// Defines the position of the presenter video tile. Default: TopRight.
        public var presenterPosition: ChimeSDKMediaPipelinesClientTypes.PresenterPosition?

        public init(
            presenterPosition: ChimeSDKMediaPipelinesClientTypes.PresenterPosition? = nil
        )
        {
            self.presenterPosition = presenterPosition
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum VerticalTilePosition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `left`
        case `right`
        case sdkUnknown(Swift.String)

        public static var allCases: [VerticalTilePosition] {
            return [
                .left,
                .right
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .left: return "Left"
            case .right: return "Right"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// Defines the configuration settings for a vertical layout.
    public struct VerticalLayoutConfiguration: Swift.Sendable {
        /// Sets the aspect ratio of the video tiles, such as 16:9.
        public var tileAspectRatio: Swift.String?
        /// The maximum number of tiles to display.
        public var tileCount: Swift.Int?
        /// Sets the automatic ordering of the video tiles.
        public var tileOrder: ChimeSDKMediaPipelinesClientTypes.TileOrder?
        /// Sets the position of vertical tiles.
        public var tilePosition: ChimeSDKMediaPipelinesClientTypes.VerticalTilePosition?

        public init(
            tileAspectRatio: Swift.String? = nil,
            tileCount: Swift.Int? = nil,
            tileOrder: ChimeSDKMediaPipelinesClientTypes.TileOrder? = nil,
            tilePosition: ChimeSDKMediaPipelinesClientTypes.VerticalTilePosition? = nil
        )
        {
            self.tileAspectRatio = tileAspectRatio
            self.tileCount = tileCount
            self.tileOrder = tileOrder
            self.tilePosition = tilePosition
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum BorderColor: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case black
        case blue
        case green
        case red
        case white
        case yellow
        case sdkUnknown(Swift.String)

        public static var allCases: [BorderColor] {
            return [
                .black,
                .blue,
                .green,
                .red,
                .white,
                .yellow
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .black: return "Black"
            case .blue: return "Blue"
            case .green: return "Green"
            case .red: return "Red"
            case .white: return "White"
            case .yellow: return "Yellow"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum HighlightColor: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case black
        case blue
        case green
        case red
        case white
        case yellow
        case sdkUnknown(Swift.String)

        public static var allCases: [HighlightColor] {
            return [
                .black,
                .blue,
                .green,
                .red,
                .white,
                .yellow
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .black: return "Black"
            case .blue: return "Blue"
            case .green: return "Green"
            case .red: return "Red"
            case .white: return "White"
            case .yellow: return "Yellow"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// Defines the settings for a video tile.
    public struct VideoAttribute: Swift.Sendable {
        /// Defines the border color of all video tiles.
        public var borderColor: ChimeSDKMediaPipelinesClientTypes.BorderColor?
        /// Defines the border thickness for all video tiles.
        public var borderThickness: Swift.Int?
        /// Sets the corner radius of all video tiles.
        public var cornerRadius: Swift.Int?
        /// Defines the highlight color for the active video tile.
        public var highlightColor: ChimeSDKMediaPipelinesClientTypes.HighlightColor?

        public init(
            borderColor: ChimeSDKMediaPipelinesClientTypes.BorderColor? = nil,
            borderThickness: Swift.Int? = nil,
            cornerRadius: Swift.Int? = nil,
            highlightColor: ChimeSDKMediaPipelinesClientTypes.HighlightColor? = nil
        )
        {
            self.borderColor = borderColor
            self.borderThickness = borderThickness
            self.cornerRadius = cornerRadius
            self.highlightColor = highlightColor
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// Specifies the type of grid layout.
    public struct GridViewConfiguration: Swift.Sendable {
        /// The configuration settings for an ActiveSpeakerOnly video tile.
        public var activeSpeakerOnlyConfiguration: ChimeSDKMediaPipelinesClientTypes.ActiveSpeakerOnlyConfiguration?
        /// The orientation setting, horizontal or vertical.
        public var canvasOrientation: ChimeSDKMediaPipelinesClientTypes.CanvasOrientation?
        /// Defines the layout of the video tiles when content sharing is enabled.
        /// This member is required.
        public var contentShareLayout: ChimeSDKMediaPipelinesClientTypes.ContentShareLayoutOption?
        /// The configuration settings for a horizontal layout.
        public var horizontalLayoutConfiguration: ChimeSDKMediaPipelinesClientTypes.HorizontalLayoutConfiguration?
        /// Defines the configuration options for a presenter only video tile.
        public var presenterOnlyConfiguration: ChimeSDKMediaPipelinesClientTypes.PresenterOnlyConfiguration?
        /// The configuration settings for a vertical layout.
        public var verticalLayoutConfiguration: ChimeSDKMediaPipelinesClientTypes.VerticalLayoutConfiguration?
        /// The attribute settings for the video tiles.
        public var videoAttribute: ChimeSDKMediaPipelinesClientTypes.VideoAttribute?

        public init(
            activeSpeakerOnlyConfiguration: ChimeSDKMediaPipelinesClientTypes.ActiveSpeakerOnlyConfiguration? = nil,
            canvasOrientation: ChimeSDKMediaPipelinesClientTypes.CanvasOrientation? = nil,
            contentShareLayout: ChimeSDKMediaPipelinesClientTypes.ContentShareLayoutOption? = nil,
            horizontalLayoutConfiguration: ChimeSDKMediaPipelinesClientTypes.HorizontalLayoutConfiguration? = nil,
            presenterOnlyConfiguration: ChimeSDKMediaPipelinesClientTypes.PresenterOnlyConfiguration? = nil,
            verticalLayoutConfiguration: ChimeSDKMediaPipelinesClientTypes.VerticalLayoutConfiguration? = nil,
            videoAttribute: ChimeSDKMediaPipelinesClientTypes.VideoAttribute? = nil
        )
        {
            self.activeSpeakerOnlyConfiguration = activeSpeakerOnlyConfiguration
            self.canvasOrientation = canvasOrientation
            self.contentShareLayout = contentShareLayout
            self.horizontalLayoutConfiguration = horizontalLayoutConfiguration
            self.presenterOnlyConfiguration = presenterOnlyConfiguration
            self.verticalLayoutConfiguration = verticalLayoutConfiguration
            self.videoAttribute = videoAttribute
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum LayoutOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gridview
        case sdkUnknown(Swift.String)

        public static var allCases: [LayoutOption] {
            return [
                .gridview
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gridview: return "GridView"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum ResolutionOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fhd
        case hd
        case sdkUnknown(Swift.String)

        public static var allCases: [ResolutionOption] {
            return [
                .fhd,
                .hd
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fhd: return "FHD"
            case .hd: return "HD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// Specifies the configuration for compositing video artifacts.
    public struct CompositedVideoArtifactsConfiguration: Swift.Sendable {
        /// The GridView configuration setting.
        /// This member is required.
        public var gridViewConfiguration: ChimeSDKMediaPipelinesClientTypes.GridViewConfiguration?
        /// The layout setting, such as GridView in the configuration object.
        public var layout: ChimeSDKMediaPipelinesClientTypes.LayoutOption?
        /// The video resolution setting in the configuration object. Default: HD at 1280 x 720. FHD resolution: 1920 x 1080.
        public var resolution: ChimeSDKMediaPipelinesClientTypes.ResolutionOption?

        public init(
            gridViewConfiguration: ChimeSDKMediaPipelinesClientTypes.GridViewConfiguration? = nil,
            layout: ChimeSDKMediaPipelinesClientTypes.LayoutOption? = nil,
            resolution: ChimeSDKMediaPipelinesClientTypes.ResolutionOption? = nil
        )
        {
            self.gridViewConfiguration = gridViewConfiguration
            self.layout = layout
            self.resolution = resolution
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum ContentMuxType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contentonly
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentMuxType] {
            return [
                .contentonly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contentonly: return "ContentOnly"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum ArtifactsState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactsState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The content artifact object.
    public struct ContentArtifactsConfiguration: Swift.Sendable {
        /// The MUX type of the artifact configuration.
        public var muxType: ChimeSDKMediaPipelinesClientTypes.ContentMuxType?
        /// Indicates whether the content artifact is enabled or disabled.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsState?

        public init(
            muxType: ChimeSDKMediaPipelinesClientTypes.ContentMuxType? = nil,
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsState? = nil
        )
        {
            self.muxType = muxType
            self.state = state
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum VideoMuxType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case videoonly
        case sdkUnknown(Swift.String)

        public static var allCases: [VideoMuxType] {
            return [
                .videoonly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .videoonly: return "VideoOnly"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The video artifact configuration object.
    public struct VideoArtifactsConfiguration: Swift.Sendable {
        /// The MUX type of the video artifact configuration object.
        public var muxType: ChimeSDKMediaPipelinesClientTypes.VideoMuxType?
        /// Indicates whether the video artifact is enabled or disabled.
        /// This member is required.
        public var state: ChimeSDKMediaPipelinesClientTypes.ArtifactsState?

        public init(
            muxType: ChimeSDKMediaPipelinesClientTypes.VideoMuxType? = nil,
            state: ChimeSDKMediaPipelinesClientTypes.ArtifactsState? = nil
        )
        {
            self.muxType = muxType
            self.state = state
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The configuration for the artifacts.
    public struct ArtifactsConfiguration: Swift.Sendable {
        /// The configuration for the audio artifacts.
        /// This member is required.
        public var audio: ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConfiguration?
        /// Enables video compositing.
        public var compositedVideo: ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration?
        /// The configuration for the content artifacts.
        /// This member is required.
        public var content: ChimeSDKMediaPipelinesClientTypes.ContentArtifactsConfiguration?
        /// The configuration for the video artifacts.
        /// This member is required.
        public var video: ChimeSDKMediaPipelinesClientTypes.VideoArtifactsConfiguration?

        public init(
            audio: ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConfiguration? = nil,
            compositedVideo: ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration? = nil,
            content: ChimeSDKMediaPipelinesClientTypes.ContentArtifactsConfiguration? = nil,
            video: ChimeSDKMediaPipelinesClientTypes.VideoArtifactsConfiguration? = nil
        )
        {
            self.audio = audio
            self.compositedVideo = compositedVideo
            self.content = content
            self.video = video
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum AudioChannelsOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mono
        case stereo
        case sdkUnknown(Swift.String)

        public static var allCases: [AudioChannelsOption] {
            return [
                .mono,
                .stereo
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mono: return "Mono"
            case .stereo: return "Stereo"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum ErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case badrequest
        case forbidden
        case notfound
        case resourcelimitexceeded
        case servicefailure
        case serviceunavailable
        case throttling
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .badrequest,
                .forbidden,
                .notfound,
                .resourcelimitexceeded,
                .servicefailure,
                .serviceunavailable,
                .throttling
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .badrequest: return "BadRequest"
            case .forbidden: return "Forbidden"
            case .notfound: return "NotFound"
            case .resourcelimitexceeded: return "ResourceLimitExceeded"
            case .servicefailure: return "ServiceFailure"
            case .serviceunavailable: return "ServiceUnavailable"
            case .throttling: return "Throttling"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input parameters don't match the service's restrictions.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request ID associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum ParticipantRole: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agent
        case customer
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantRole] {
            return [
                .agent,
                .customer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case .customer: return "CUSTOMER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// Defines an audio channel in a Kinesis video stream.
    public struct ChannelDefinition: Swift.Sendable {
        /// The channel ID.
        /// This member is required.
        public var channelId: Swift.Int
        /// Specifies whether the audio in a channel belongs to the AGENT or CUSTOMER.
        public var participantRole: ChimeSDKMediaPipelinesClientTypes.ParticipantRole?

        public init(
            channelId: Swift.Int = 0,
            participantRole: ChimeSDKMediaPipelinesClientTypes.ParticipantRole? = nil
        )
        {
            self.channelId = channelId
            self.participantRole = participantRole
        }
    }
}

/// The client is permanently forbidden from making the request.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request id associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

/// The request exceeds the resource limit.
public struct ResourceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request ID associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

/// The service encountered an unexpected error.
public struct ServiceFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request ID associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request ID associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

/// The client exceeded its request rate limit.
public struct ThrottledClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request ID associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottledClientException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

/// The client is not currently authorized to make the request.
public struct UnauthorizedClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request ID associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedClientException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The video streams for a specified media pipeline. The total number of video streams can't exceed 25.
    public struct SelectedVideoStreams: Swift.Sendable {
        /// The attendee IDs of the streams selected for a media pipeline.
        public var attendeeIds: [Swift.String]?
        /// The external user IDs of the streams selected for a media pipeline.
        public var externalUserIds: [Swift.String]?

        public init(
            attendeeIds: [Swift.String]? = nil,
            externalUserIds: [Swift.String]? = nil
        )
        {
            self.attendeeIds = attendeeIds
            self.externalUserIds = externalUserIds
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.SelectedVideoStreams: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SelectedVideoStreams(attendeeIds: \(Swift.String(describing: attendeeIds)), externalUserIds: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// Source configuration for a specified media pipeline.
    public struct SourceConfiguration: Swift.Sendable {
        /// The selected video streams for a specified media pipeline. The number of video streams can't exceed 25.
        public var selectedVideoStreams: ChimeSDKMediaPipelinesClientTypes.SelectedVideoStreams?

        public init(
            selectedVideoStreams: ChimeSDKMediaPipelinesClientTypes.SelectedVideoStreams? = nil
        )
        {
            self.selectedVideoStreams = selectedVideoStreams
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The configuration object of the Amazon Chime SDK meeting for a specified media pipeline. SourceType must be ChimeSdkMeeting.
    public struct ChimeSdkMeetingConfiguration: Swift.Sendable {
        /// The configuration for the artifacts in an Amazon Chime SDK meeting.
        public var artifactsConfiguration: ChimeSDKMediaPipelinesClientTypes.ArtifactsConfiguration?
        /// The source configuration for a specified media pipeline.
        public var sourceConfiguration: ChimeSDKMediaPipelinesClientTypes.SourceConfiguration?

        public init(
            artifactsConfiguration: ChimeSDKMediaPipelinesClientTypes.ArtifactsConfiguration? = nil,
            sourceConfiguration: ChimeSDKMediaPipelinesClientTypes.SourceConfiguration? = nil
        )
        {
            self.artifactsConfiguration = artifactsConfiguration
            self.sourceConfiguration = sourceConfiguration
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum MediaPipelineSinkType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case s3bucket
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineSinkType] {
            return [
                .s3bucket
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .s3bucket: return "S3Bucket"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum MediaPipelineSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case chimesdkmeeting
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineSourceType] {
            return [
                .chimesdkmeeting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .chimesdkmeeting: return "ChimeSdkMeeting"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A key/value pair that grants users access to meeting resources.
    public struct Tag: Swift.Sendable {
        /// The key half of a tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value half of a tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateMediaCapturePipelineInput: Swift.Sendable {
    /// The configuration for a specified media pipeline. SourceType must be ChimeSdkMeeting.
    public var chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration?
    /// The unique identifier for the client request. The token makes the API request idempotent. Use a unique token for each media pipeline request.
    public var clientRequestToken: Swift.String?
    /// The ARN of the sink type.
    /// This member is required.
    public var sinkArn: Swift.String?
    /// Destination type to which the media artifacts are saved. You must use an S3 bucket.
    /// This member is required.
    public var sinkType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSinkType?
    /// ARN of the source from which the media artifacts are captured.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// Source type from which the media artifacts are captured. A Chime SDK Meeting is the only supported source.
    /// This member is required.
    public var sourceType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType?
    /// The tag key-value pairs.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init(
        chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration? = nil,
        clientRequestToken: Swift.String? = nil,
        sinkArn: Swift.String? = nil,
        sinkType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSinkType? = nil,
        sourceArn: Swift.String? = nil,
        sourceType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
        self.clientRequestToken = clientRequestToken
        self.sinkArn = sinkArn
        self.sinkType = sinkType
        self.sourceArn = sourceArn
        self.sourceType = sourceType
        self.tags = tags
    }
}

extension CreateMediaCapturePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaCapturePipelineInput(chimeSdkMeetingConfiguration: \(Swift.String(describing: chimeSdkMeetingConfiguration)), sinkType: \(Swift.String(describing: sinkType)), sourceType: \(Swift.String(describing: sourceType)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\", sinkArn: \"CONTENT_REDACTED\", sourceArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum MediaPipelineStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inprogress
        case initializing
        case notstarted
        case paused
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineStatus] {
            return [
                .failed,
                .inprogress,
                .initializing,
                .notstarted,
                .paused,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .initializing: return "Initializing"
            case .notstarted: return "NotStarted"
            case .paused: return "Paused"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A media pipeline object consisting of an ID, source type, source ARN, a sink type, a sink ARN, and a configuration object.
    public struct MediaCapturePipeline: Swift.Sendable {
        /// The configuration for a specified media pipeline. SourceType must be ChimeSdkMeeting.
        public var chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration?
        /// The time at which the pipeline was created, in ISO 8601 format.
        public var createdTimestamp: Foundation.Date?
        /// The ARN of the media capture pipeline
        public var mediaPipelineArn: Swift.String?
        /// The ID of a media pipeline.
        public var mediaPipelineId: Swift.String?
        /// ARN of the destination to which the media artifacts are saved.
        public var sinkArn: Swift.String?
        /// Destination type to which the media artifacts are saved. You must use an S3 Bucket.
        public var sinkType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSinkType?
        /// ARN of the source from which the media artifacts are saved.
        public var sourceArn: Swift.String?
        /// Source type from which media artifacts are saved. You must use ChimeMeeting.
        public var sourceType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType?
        /// The status of the media pipeline.
        public var status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus?
        /// The time at which the pipeline was updated, in ISO 8601 format.
        public var updatedTimestamp: Foundation.Date?

        public init(
            chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration? = nil,
            createdTimestamp: Foundation.Date? = nil,
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil,
            sinkArn: Swift.String? = nil,
            sinkType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSinkType? = nil,
            sourceArn: Swift.String? = nil,
            sourceType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType? = nil,
            status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus? = nil,
            updatedTimestamp: Foundation.Date? = nil
        )
        {
            self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.sinkArn = sinkArn
            self.sinkType = sinkType
            self.sourceArn = sourceArn
            self.sourceType = sourceType
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaCapturePipeline(chimeSdkMeetingConfiguration: \(Swift.String(describing: chimeSdkMeetingConfiguration)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), mediaPipelineArn: \(Swift.String(describing: mediaPipelineArn)), mediaPipelineId: \(Swift.String(describing: mediaPipelineId)), sinkType: \(Swift.String(describing: sinkType)), sourceType: \(Swift.String(describing: sourceType)), status: \(Swift.String(describing: status)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), sinkArn: \"CONTENT_REDACTED\", sourceArn: \"CONTENT_REDACTED\")"}
}

public struct CreateMediaCapturePipelineOutput: Swift.Sendable {
    /// A media pipeline object, the ID, source type, source ARN, sink type, and sink ARN of a media pipeline object.
    public var mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline?

    public init(
        mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline? = nil
    )
    {
        self.mediaCapturePipeline = mediaCapturePipeline
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The configuration settings for the S3 bucket.
    public struct S3BucketSinkConfiguration: Swift.Sendable {
        /// The destination URL of the S3 bucket.
        /// This member is required.
        public var destination: Swift.String?

        public init(
            destination: Swift.String? = nil
        )
        {
            self.destination = destination
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.S3BucketSinkConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3BucketSinkConfiguration(destination: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum ConcatenationSinkType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case s3bucket
        case sdkUnknown(Swift.String)

        public static var allCases: [ConcatenationSinkType] {
            return [
                .s3bucket
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .s3bucket: return "S3Bucket"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The data sink of the configuration object.
    public struct ConcatenationSink: Swift.Sendable {
        /// The configuration settings for an Amazon S3 bucket sink.
        /// This member is required.
        public var s3BucketSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.S3BucketSinkConfiguration?
        /// The type of data sink in the configuration object.
        /// This member is required.
        public var type: ChimeSDKMediaPipelinesClientTypes.ConcatenationSinkType?

        public init(
            s3BucketSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.S3BucketSinkConfiguration? = nil,
            type: ChimeSDKMediaPipelinesClientTypes.ConcatenationSinkType? = nil
        )
        {
            self.s3BucketSinkConfiguration = s3BucketSinkConfiguration
            self.type = type
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The configuration object of the Amazon Chime SDK meeting concatenation for a specified media pipeline.
    public struct ChimeSdkMeetingConcatenationConfiguration: Swift.Sendable {
        /// The configuration for the artifacts in an Amazon Chime SDK meeting concatenation.
        /// This member is required.
        public var artifactsConfiguration: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationConfiguration?

        public init(
            artifactsConfiguration: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationConfiguration? = nil
        )
        {
            self.artifactsConfiguration = artifactsConfiguration
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The source configuration object of a media capture pipeline.
    public struct MediaCapturePipelineSourceConfiguration: Swift.Sendable {
        /// The meeting configuration settings in a media capture pipeline configuration object.
        /// This member is required.
        public var chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConcatenationConfiguration?
        /// The media pipeline ARN in the configuration object of a media capture pipeline.
        /// This member is required.
        public var mediaPipelineArn: Swift.String?

        public init(
            chimeSdkMeetingConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConcatenationConfiguration? = nil,
            mediaPipelineArn: Swift.String? = nil
        )
        {
            self.chimeSdkMeetingConfiguration = chimeSdkMeetingConfiguration
            self.mediaPipelineArn = mediaPipelineArn
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSourceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaCapturePipelineSourceConfiguration(chimeSdkMeetingConfiguration: \(Swift.String(describing: chimeSdkMeetingConfiguration)), mediaPipelineArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum ConcatenationSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mediacapturepipeline
        case sdkUnknown(Swift.String)

        public static var allCases: [ConcatenationSourceType] {
            return [
                .mediacapturepipeline
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mediacapturepipeline: return "MediaCapturePipeline"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The source type and media pipeline configuration settings in a configuration object.
    public struct ConcatenationSource: Swift.Sendable {
        /// The concatenation settings for the media pipeline in a configuration object.
        /// This member is required.
        public var mediaCapturePipelineSourceConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSourceConfiguration?
        /// The type of concatenation source in a configuration object.
        /// This member is required.
        public var type: ChimeSDKMediaPipelinesClientTypes.ConcatenationSourceType?

        public init(
            mediaCapturePipelineSourceConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSourceConfiguration? = nil,
            type: ChimeSDKMediaPipelinesClientTypes.ConcatenationSourceType? = nil
        )
        {
            self.mediaCapturePipelineSourceConfiguration = mediaCapturePipelineSourceConfiguration
            self.type = type
        }
    }
}

public struct CreateMediaConcatenationPipelineInput: Swift.Sendable {
    /// The unique identifier for the client request. The token makes the API request idempotent. Use a unique token for each media concatenation pipeline request.
    public var clientRequestToken: Swift.String?
    /// An object that specifies the data sinks for the media concatenation pipeline.
    /// This member is required.
    public var sinks: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]?
    /// An object that specifies the sources for the media concatenation pipeline.
    /// This member is required.
    public var sources: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]?
    /// The tags associated with the media concatenation pipeline.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        sinks: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]? = nil,
        sources: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.sinks = sinks
        self.sources = sources
        self.tags = tags
    }
}

extension CreateMediaConcatenationPipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaConcatenationPipelineInput(sinks: \(Swift.String(describing: sinks)), sources: \(Swift.String(describing: sources)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// Concatenates audio and video data from one or more data streams.
    public struct MediaConcatenationPipeline: Swift.Sendable {
        /// The time at which the concatenation pipeline was created.
        public var createdTimestamp: Foundation.Date?
        /// The ARN of the media pipeline that you specify in the SourceConfiguration object.
        public var mediaPipelineArn: Swift.String?
        /// The ID of the media pipeline being concatenated.
        public var mediaPipelineId: Swift.String?
        /// The data sinks of the concatenation pipeline.
        public var sinks: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]?
        /// The data sources being concatenated.
        public var sources: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]?
        /// The status of the concatenation pipeline.
        public var status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus?
        /// The time at which the concatenation pipeline was last updated.
        public var updatedTimestamp: Foundation.Date?

        public init(
            createdTimestamp: Foundation.Date? = nil,
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil,
            sinks: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSink]? = nil,
            sources: [ChimeSDKMediaPipelinesClientTypes.ConcatenationSource]? = nil,
            status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus? = nil,
            updatedTimestamp: Foundation.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.sinks = sinks
            self.sources = sources
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }
}

public struct CreateMediaConcatenationPipelineOutput: Swift.Sendable {
    /// A media concatenation pipeline object, the ID, source type, MediaPipelineARN, and sink of a media concatenation pipeline object.
    public var mediaConcatenationPipeline: ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline?

    public init(
        mediaConcatenationPipeline: ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline? = nil
    )
    {
        self.mediaConcatenationPipeline = mediaConcatenationPipeline
    }
}

/// One or more of the resources in the request does not exist in the system.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request ID associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum FragmentSelectorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case producertimestamp
        case servertimestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [FragmentSelectorType] {
            return [
                .producertimestamp,
                .servertimestamp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .producertimestamp: return "ProducerTimestamp"
            case .servertimestamp: return "ServerTimestamp"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The range of timestamps to return.
    public struct TimestampRange: Swift.Sendable {
        /// The ending timestamp for the specified range.
        /// This member is required.
        public var endTimestamp: Foundation.Date?
        /// The starting timestamp for the specified range.
        /// This member is required.
        public var startTimestamp: Foundation.Date?

        public init(
            endTimestamp: Foundation.Date? = nil,
            startTimestamp: Foundation.Date? = nil
        )
        {
            self.endTimestamp = endTimestamp
            self.startTimestamp = startTimestamp
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// Describes the timestamp range and timestamp origin of a range of fragments. Only fragments with a start timestamp greater than or equal to the given start time and less than or equal to the end time are returned. For example, say a stream contains fragments with the following start timestamps:
    ///
    /// * 00:00:00
    ///
    /// * 00:00:02
    ///
    /// * 00:00:04
    ///
    /// * 00:00:06
    ///
    ///
    /// A fragment selector range with a start time of 00:00:01 and end time of 00:00:04 would return the fragments with start times of 00:00:02 and 00:00:04.
    public struct FragmentSelector: Swift.Sendable {
        /// The origin of the timestamps to use, Server or Producer. For more information, see [StartSelectorType](https://docs.aws.amazon.com/kinesisvideostreams/latest/dg/API_dataplane_StartSelector.html) in the Amazon Kinesis Video Streams Developer Guide.
        /// This member is required.
        public var fragmentSelectorType: ChimeSDKMediaPipelinesClientTypes.FragmentSelectorType?
        /// The range of timestamps to return.
        /// This member is required.
        public var timestampRange: ChimeSDKMediaPipelinesClientTypes.TimestampRange?

        public init(
            fragmentSelectorType: ChimeSDKMediaPipelinesClientTypes.FragmentSelectorType? = nil,
            timestampRange: ChimeSDKMediaPipelinesClientTypes.TimestampRange? = nil
        )
        {
            self.fragmentSelectorType = fragmentSelectorType
            self.timestampRange = timestampRange
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A structure that holds the settings for recording media.
    public struct RecordingStreamConfiguration: Swift.Sendable {
        /// The ARN of the recording stream.
        public var streamArn: Swift.String?

        public init(
            streamArn: Swift.String? = nil
        )
        {
            self.streamArn = streamArn
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A structure that contains the runtime settings for recording a Kinesis video stream.
    public struct KinesisVideoStreamRecordingSourceRuntimeConfiguration: Swift.Sendable {
        /// Describes the timestamp range and timestamp origin of a range of fragments in the Kinesis video stream.
        /// This member is required.
        public var fragmentSelector: ChimeSDKMediaPipelinesClientTypes.FragmentSelector?
        /// The stream or streams to be recorded.
        /// This member is required.
        public var streams: [ChimeSDKMediaPipelinesClientTypes.RecordingStreamConfiguration]?

        public init(
            fragmentSelector: ChimeSDKMediaPipelinesClientTypes.FragmentSelector? = nil,
            streams: [ChimeSDKMediaPipelinesClientTypes.RecordingStreamConfiguration]? = nil
        )
        {
            self.fragmentSelector = fragmentSelector
            self.streams = streams
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum MediaEncoding: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pcm
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaEncoding] {
            return [
                .pcm
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pcm: return "pcm"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// Defines a streaming channel.
    public struct StreamChannelDefinition: Swift.Sendable {
        /// The definitions of the channels in a streaming channel.
        public var channelDefinitions: [ChimeSDKMediaPipelinesClientTypes.ChannelDefinition]?
        /// The number of channels in a streaming channel.
        /// This member is required.
        public var numberOfChannels: Swift.Int?

        public init(
            channelDefinitions: [ChimeSDKMediaPipelinesClientTypes.ChannelDefinition]? = nil,
            numberOfChannels: Swift.Int? = nil
        )
        {
            self.channelDefinitions = channelDefinitions
            self.numberOfChannels = numberOfChannels
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The configuration settings for a stream.
    public struct StreamConfiguration: Swift.Sendable {
        /// The unique identifier of the fragment to begin processing.
        public var fragmentNumber: Swift.String?
        /// The ARN of the stream.
        /// This member is required.
        public var streamArn: Swift.String?
        /// The streaming channel definition in the stream configuration.
        /// This member is required.
        public var streamChannelDefinition: ChimeSDKMediaPipelinesClientTypes.StreamChannelDefinition?

        public init(
            fragmentNumber: Swift.String? = nil,
            streamArn: Swift.String? = nil,
            streamChannelDefinition: ChimeSDKMediaPipelinesClientTypes.StreamChannelDefinition? = nil
        )
        {
            self.fragmentNumber = fragmentNumber
            self.streamArn = streamArn
            self.streamChannelDefinition = streamChannelDefinition
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The runtime configuration settings for the Kinesis video stream source.
    public struct KinesisVideoStreamSourceRuntimeConfiguration: Swift.Sendable {
        /// Specifies the encoding of your input audio. Supported format: PCM (only signed 16-bit little-endian audio formats, which does not include WAV) For more information, see [Media formats](https://docs.aws.amazon.com/transcribe/latest/dg/how-input.html#how-input-audio) in the Amazon Transcribe Developer Guide.
        /// This member is required.
        public var mediaEncoding: ChimeSDKMediaPipelinesClientTypes.MediaEncoding?
        /// The sample rate of the input audio (in hertz). Low-quality audio, such as telephone audio, is typically around 8,000 Hz. High-quality audio typically ranges from 16,000 Hz to 48,000 Hz. Note that the sample rate you specify must match that of your audio. Valid Range: Minimum value of 8000. Maximum value of 48000.
        /// This member is required.
        public var mediaSampleRate: Swift.Int?
        /// The streams in the source runtime configuration of a Kinesis video stream.
        /// This member is required.
        public var streams: [ChimeSDKMediaPipelinesClientTypes.StreamConfiguration]?

        public init(
            mediaEncoding: ChimeSDKMediaPipelinesClientTypes.MediaEncoding? = nil,
            mediaSampleRate: Swift.Int? = nil,
            streams: [ChimeSDKMediaPipelinesClientTypes.StreamConfiguration]? = nil
        )
        {
            self.mediaEncoding = mediaEncoding
            self.mediaSampleRate = mediaSampleRate
            self.streams = streams
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum RecordingFileFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case opus
        case wav
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordingFileFormat] {
            return [
                .opus,
                .wav
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .opus: return "Opus"
            case .wav: return "Wav"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A structure that holds the settings for transmitting media files to the Amazon S3 bucket. If specified, the settings in this structure override any settings in S3RecordingSinkConfiguration.
    public struct S3RecordingSinkRuntimeConfiguration: Swift.Sendable {
        /// The URI of the S3 bucket used as the sink.
        /// This member is required.
        public var destination: Swift.String?
        /// The file format for the media files sent to the Amazon S3 bucket.
        /// This member is required.
        public var recordingFileFormat: ChimeSDKMediaPipelinesClientTypes.RecordingFileFormat?

        public init(
            destination: Swift.String? = nil,
            recordingFileFormat: ChimeSDKMediaPipelinesClientTypes.RecordingFileFormat? = nil
        )
        {
            self.destination = destination
            self.recordingFileFormat = recordingFileFormat
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3RecordingSinkRuntimeConfiguration(recordingFileFormat: \(Swift.String(describing: recordingFileFormat)), destination: \"CONTENT_REDACTED\")"}
}

public struct CreateMediaInsightsPipelineInput: Swift.Sendable {
    /// The unique identifier for the media insights pipeline request.
    public var clientRequestToken: Swift.String?
    /// The runtime configuration for the Kinesis video recording stream source.
    public var kinesisVideoStreamRecordingSourceRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamRecordingSourceRuntimeConfiguration?
    /// The runtime configuration for the Kinesis video stream source of the media insights pipeline.
    public var kinesisVideoStreamSourceRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceRuntimeConfiguration?
    /// The ARN of the pipeline's configuration.
    /// This member is required.
    public var mediaInsightsPipelineConfigurationArn: Swift.String?
    /// The runtime metadata for the media insights pipeline. Consists of a key-value map of strings.
    public var mediaInsightsRuntimeMetadata: [Swift.String: Swift.String]?
    /// The runtime configuration for the S3 recording sink. If specified, the settings in this structure override any settings in S3RecordingSinkConfiguration.
    public var s3RecordingSinkRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration?
    /// The tags assigned to the media insights pipeline.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        kinesisVideoStreamRecordingSourceRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamRecordingSourceRuntimeConfiguration? = nil,
        kinesisVideoStreamSourceRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceRuntimeConfiguration? = nil,
        mediaInsightsPipelineConfigurationArn: Swift.String? = nil,
        mediaInsightsRuntimeMetadata: [Swift.String: Swift.String]? = nil,
        s3RecordingSinkRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.kinesisVideoStreamRecordingSourceRuntimeConfiguration = kinesisVideoStreamRecordingSourceRuntimeConfiguration
        self.kinesisVideoStreamSourceRuntimeConfiguration = kinesisVideoStreamSourceRuntimeConfiguration
        self.mediaInsightsPipelineConfigurationArn = mediaInsightsPipelineConfigurationArn
        self.mediaInsightsRuntimeMetadata = mediaInsightsRuntimeMetadata
        self.s3RecordingSinkRuntimeConfiguration = s3RecordingSinkRuntimeConfiguration
        self.tags = tags
    }
}

extension CreateMediaInsightsPipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaInsightsPipelineInput(kinesisVideoStreamRecordingSourceRuntimeConfiguration: \(Swift.String(describing: kinesisVideoStreamRecordingSourceRuntimeConfiguration)), kinesisVideoStreamSourceRuntimeConfiguration: \(Swift.String(describing: kinesisVideoStreamSourceRuntimeConfiguration)), s3RecordingSinkRuntimeConfiguration: \(Swift.String(describing: s3RecordingSinkRuntimeConfiguration)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\", mediaInsightsPipelineConfigurationArn: \"CONTENT_REDACTED\", mediaInsightsRuntimeMetadata: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum MediaPipelineElementStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inprogress
        case initializing
        case notstarted
        case notsupported
        case paused
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineElementStatus] {
            return [
                .failed,
                .inprogress,
                .initializing,
                .notstarted,
                .notsupported,
                .paused,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .initializing: return "Initializing"
            case .notstarted: return "NotStarted"
            case .notsupported: return "NotSupported"
            case .paused: return "Paused"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum MediaInsightsPipelineConfigurationElementType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonTranscribeCallAnalyticsProcessor
        case amazonTranscribeProcessor
        case kinesisDataStreamSink
        case lambdaFunctionSink
        case s3RecordingSink
        case snsTopicSink
        case sqsQueueSink
        case voiceAnalyticsProcessor
        case voiceEnhancementSink
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaInsightsPipelineConfigurationElementType] {
            return [
                .amazonTranscribeCallAnalyticsProcessor,
                .amazonTranscribeProcessor,
                .kinesisDataStreamSink,
                .lambdaFunctionSink,
                .s3RecordingSink,
                .snsTopicSink,
                .sqsQueueSink,
                .voiceAnalyticsProcessor,
                .voiceEnhancementSink
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonTranscribeCallAnalyticsProcessor: return "AmazonTranscribeCallAnalyticsProcessor"
            case .amazonTranscribeProcessor: return "AmazonTranscribeProcessor"
            case .kinesisDataStreamSink: return "KinesisDataStreamSink"
            case .lambdaFunctionSink: return "LambdaFunctionSink"
            case .s3RecordingSink: return "S3RecordingSink"
            case .snsTopicSink: return "SnsTopicSink"
            case .sqsQueueSink: return "SqsQueueSink"
            case .voiceAnalyticsProcessor: return "VoiceAnalyticsProcessor"
            case .voiceEnhancementSink: return "VoiceEnhancementSink"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The status of the pipeline element.
    public struct MediaInsightsPipelineElementStatus: Swift.Sendable {
        /// The element's status.
        public var status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineElementStatus?
        /// The type of status.
        public var type: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElementType?

        public init(
            status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineElementStatus? = nil,
            type: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElementType? = nil
        )
        {
            self.status = status
            self.type = type
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A media pipeline that streams call analytics data.
    public struct MediaInsightsPipeline: Swift.Sendable {
        /// The time at which the media insights pipeline was created.
        public var createdTimestamp: Foundation.Date?
        /// The statuses that the elements in a media insights pipeline can have during data processing.
        public var elementStatuses: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineElementStatus]?
        /// The runtime configuration settings for a Kinesis recording video stream in a media insights pipeline.
        public var kinesisVideoStreamRecordingSourceRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamRecordingSourceRuntimeConfiguration?
        /// The configuration settings for a Kinesis runtime video stream in a media insights pipeline.
        public var kinesisVideoStreamSourceRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceRuntimeConfiguration?
        /// The ARN of a media insight pipeline's configuration settings.
        public var mediaInsightsPipelineConfigurationArn: Swift.String?
        /// The runtime metadata of a media insights pipeline.
        public var mediaInsightsRuntimeMetadata: [Swift.String: Swift.String]?
        /// The ARN of a media insights pipeline.
        public var mediaPipelineArn: Swift.String?
        /// The ID of a media insights pipeline.
        public var mediaPipelineId: Swift.String?
        /// The runtime configuration of the Amazon S3 bucket that stores recordings in a media insights pipeline.
        public var s3RecordingSinkRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration?
        /// The status of a media insights pipeline.
        public var status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus?

        public init(
            createdTimestamp: Foundation.Date? = nil,
            elementStatuses: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineElementStatus]? = nil,
            kinesisVideoStreamRecordingSourceRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamRecordingSourceRuntimeConfiguration? = nil,
            kinesisVideoStreamSourceRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceRuntimeConfiguration? = nil,
            mediaInsightsPipelineConfigurationArn: Swift.String? = nil,
            mediaInsightsRuntimeMetadata: [Swift.String: Swift.String]? = nil,
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil,
            s3RecordingSinkRuntimeConfiguration: ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration? = nil,
            status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.elementStatuses = elementStatuses
            self.kinesisVideoStreamRecordingSourceRuntimeConfiguration = kinesisVideoStreamRecordingSourceRuntimeConfiguration
            self.kinesisVideoStreamSourceRuntimeConfiguration = kinesisVideoStreamSourceRuntimeConfiguration
            self.mediaInsightsPipelineConfigurationArn = mediaInsightsPipelineConfigurationArn
            self.mediaInsightsRuntimeMetadata = mediaInsightsRuntimeMetadata
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.s3RecordingSinkRuntimeConfiguration = s3RecordingSinkRuntimeConfiguration
            self.status = status
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipeline: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaInsightsPipeline(createdTimestamp: \(Swift.String(describing: createdTimestamp)), elementStatuses: \(Swift.String(describing: elementStatuses)), kinesisVideoStreamRecordingSourceRuntimeConfiguration: \(Swift.String(describing: kinesisVideoStreamRecordingSourceRuntimeConfiguration)), kinesisVideoStreamSourceRuntimeConfiguration: \(Swift.String(describing: kinesisVideoStreamSourceRuntimeConfiguration)), mediaPipelineId: \(Swift.String(describing: mediaPipelineId)), s3RecordingSinkRuntimeConfiguration: \(Swift.String(describing: s3RecordingSinkRuntimeConfiguration)), status: \(Swift.String(describing: status)), mediaInsightsPipelineConfigurationArn: \"CONTENT_REDACTED\", mediaInsightsRuntimeMetadata: \"CONTENT_REDACTED\", mediaPipelineArn: \"CONTENT_REDACTED\")"}
}

public struct CreateMediaInsightsPipelineOutput: Swift.Sendable {
    /// The media insights pipeline object.
    /// This member is required.
    public var mediaInsightsPipeline: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipeline?

    public init(
        mediaInsightsPipeline: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipeline? = nil
    )
    {
        self.mediaInsightsPipeline = mediaInsightsPipeline
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A structure that contains the configuration settings for a Kinesis Data Stream sink.
    public struct KinesisDataStreamSinkConfiguration: Swift.Sendable {
        /// The ARN of the sink.
        public var insightsTarget: Swift.String?

        public init(
            insightsTarget: Swift.String? = nil
        )
        {
            self.insightsTarget = insightsTarget
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.KinesisDataStreamSinkConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KinesisDataStreamSinkConfiguration(insightsTarget: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A structure that contains the configuration settings for an AWS Lambda function's data sink.
    public struct LambdaFunctionSinkConfiguration: Swift.Sendable {
        /// The ARN of the sink.
        public var insightsTarget: Swift.String?

        public init(
            insightsTarget: Swift.String? = nil
        )
        {
            self.insightsTarget = insightsTarget
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.LambdaFunctionSinkConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaFunctionSinkConfiguration(insightsTarget: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The structure that holds the settings for transmitting media to the Amazon S3 bucket. These values are used as defaults if S3RecordingSinkRuntimeConfiguration is not specified.
    public struct S3RecordingSinkConfiguration: Swift.Sendable {
        /// The default URI of the Amazon S3 bucket used as the recording sink.
        public var destination: Swift.String?
        /// The default file format for the media files sent to the Amazon S3 bucket.
        public var recordingFileFormat: ChimeSDKMediaPipelinesClientTypes.RecordingFileFormat?

        public init(
            destination: Swift.String? = nil,
            recordingFileFormat: ChimeSDKMediaPipelinesClientTypes.RecordingFileFormat? = nil
        )
        {
            self.destination = destination
            self.recordingFileFormat = recordingFileFormat
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3RecordingSinkConfiguration(recordingFileFormat: \(Swift.String(describing: recordingFileFormat)), destination: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The configuration settings for the SNS topic sink.
    public struct SnsTopicSinkConfiguration: Swift.Sendable {
        /// The ARN of the SNS sink.
        public var insightsTarget: Swift.String?

        public init(
            insightsTarget: Swift.String? = nil
        )
        {
            self.insightsTarget = insightsTarget
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.SnsTopicSinkConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnsTopicSinkConfiguration(insightsTarget: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The configuration settings for the SQS sink.
    public struct SqsQueueSinkConfiguration: Swift.Sendable {
        /// The ARN of the SQS sink.
        public var insightsTarget: Swift.String?

        public init(
            insightsTarget: Swift.String? = nil
        )
        {
            self.insightsTarget = insightsTarget
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.SqsQueueSinkConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SqsQueueSinkConfiguration(insightsTarget: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum VoiceAnalyticsConfigurationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceAnalyticsConfigurationStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .enabled: return "Enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The configuration settings for a voice analytics processor.
    public struct VoiceAnalyticsProcessorConfiguration: Swift.Sendable {
        /// The status of the speaker search task.
        public var speakerSearchStatus: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsConfigurationStatus?
        /// The status of the voice tone analysis task.
        public var voiceToneAnalysisStatus: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsConfigurationStatus?

        public init(
            speakerSearchStatus: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsConfigurationStatus? = nil,
            voiceToneAnalysisStatus: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsConfigurationStatus? = nil
        )
        {
            self.speakerSearchStatus = speakerSearchStatus
            self.voiceToneAnalysisStatus = voiceToneAnalysisStatus
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A static structure that contains the configuration data for a VoiceEnhancementSinkConfiguration element.
    public struct VoiceEnhancementSinkConfiguration: Swift.Sendable {
        /// Disables the VoiceEnhancementSinkConfiguration element.
        public var disabled: Swift.Bool

        public init(
            disabled: Swift.Bool = false
        )
        {
            self.disabled = disabled
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// An element in a media insights pipeline configuration.
    public struct MediaInsightsPipelineConfigurationElement: Swift.Sendable {
        /// The analytics configuration settings for transcribing audio in a media insights pipeline configuration element.
        public var amazonTranscribeCallAnalyticsProcessorConfiguration: ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeCallAnalyticsProcessorConfiguration?
        /// The transcription processor configuration settings in a media insights pipeline configuration element.
        public var amazonTranscribeProcessorConfiguration: ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeProcessorConfiguration?
        /// The configuration settings for the Kinesis Data Stream Sink in a media insights pipeline configuration element.
        public var kinesisDataStreamSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisDataStreamSinkConfiguration?
        /// The configuration settings for the Amazon Web Services Lambda sink in a media insights pipeline configuration element.
        public var lambdaFunctionSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.LambdaFunctionSinkConfiguration?
        /// The configuration settings for the Amazon S3 recording bucket in a media insights pipeline configuration element.
        public var s3RecordingSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkConfiguration?
        /// The configuration settings for an SNS topic sink in a media insights pipeline configuration element.
        public var snsTopicSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.SnsTopicSinkConfiguration?
        /// The configuration settings for an SQS queue sink in a media insights pipeline configuration element.
        public var sqsQueueSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.SqsQueueSinkConfiguration?
        /// The element type.
        /// This member is required.
        public var type: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElementType?
        /// The voice analytics configuration settings in a media insights pipeline configuration element.
        public var voiceAnalyticsProcessorConfiguration: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsProcessorConfiguration?
        /// The configuration settings for voice enhancement sink in a media insights pipeline configuration element.
        public var voiceEnhancementSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.VoiceEnhancementSinkConfiguration?

        public init(
            amazonTranscribeCallAnalyticsProcessorConfiguration: ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeCallAnalyticsProcessorConfiguration? = nil,
            amazonTranscribeProcessorConfiguration: ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeProcessorConfiguration? = nil,
            kinesisDataStreamSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisDataStreamSinkConfiguration? = nil,
            lambdaFunctionSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.LambdaFunctionSinkConfiguration? = nil,
            s3RecordingSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkConfiguration? = nil,
            snsTopicSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.SnsTopicSinkConfiguration? = nil,
            sqsQueueSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.SqsQueueSinkConfiguration? = nil,
            type: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElementType? = nil,
            voiceAnalyticsProcessorConfiguration: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsProcessorConfiguration? = nil,
            voiceEnhancementSinkConfiguration: ChimeSDKMediaPipelinesClientTypes.VoiceEnhancementSinkConfiguration? = nil
        )
        {
            self.amazonTranscribeCallAnalyticsProcessorConfiguration = amazonTranscribeCallAnalyticsProcessorConfiguration
            self.amazonTranscribeProcessorConfiguration = amazonTranscribeProcessorConfiguration
            self.kinesisDataStreamSinkConfiguration = kinesisDataStreamSinkConfiguration
            self.lambdaFunctionSinkConfiguration = lambdaFunctionSinkConfiguration
            self.s3RecordingSinkConfiguration = s3RecordingSinkConfiguration
            self.snsTopicSinkConfiguration = snsTopicSinkConfiguration
            self.sqsQueueSinkConfiguration = sqsQueueSinkConfiguration
            self.type = type
            self.voiceAnalyticsProcessorConfiguration = voiceAnalyticsProcessorConfiguration
            self.voiceEnhancementSinkConfiguration = voiceEnhancementSinkConfiguration
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A structure that contains the configuration settings for an issue detection task.
    public struct IssueDetectionConfiguration: Swift.Sendable {
        /// The name of the issue detection rule.
        /// This member is required.
        public var ruleName: Swift.String?

        public init(
            ruleName: Swift.String? = nil
        )
        {
            self.ruleName = ruleName
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A structure that contains the settings for a keyword match task.
    public struct KeywordMatchConfiguration: Swift.Sendable {
        /// The keywords or phrases that you want to match.
        /// This member is required.
        public var keywords: [Swift.String]?
        /// Matches keywords or phrases on their presence or absence. If set to TRUE, the rule matches when all the specified keywords or phrases are absent. Default: FALSE.
        public var negate: Swift.Bool
        /// The name of the keyword match rule.
        /// This member is required.
        public var ruleName: Swift.String?

        public init(
            keywords: [Swift.String]? = nil,
            negate: Swift.Bool = false,
            ruleName: Swift.String? = nil
        )
        {
            self.keywords = keywords
            self.negate = negate
            self.ruleName = ruleName
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum SentimentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case negative
        case sdkUnknown(Swift.String)

        public static var allCases: [SentimentType] {
            return [
                .negative
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .negative: return "NEGATIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A structure that contains the configuration settings for a sentiment analysis task.
    public struct SentimentConfiguration: Swift.Sendable {
        /// The name of the rule in the sentiment configuration.
        /// This member is required.
        public var ruleName: Swift.String?
        /// The type of sentiment, POSITIVE, NEGATIVE, or NEUTRAL.
        /// This member is required.
        public var sentimentType: ChimeSDKMediaPipelinesClientTypes.SentimentType?
        /// Specifies the analysis interval.
        /// This member is required.
        public var timePeriod: Swift.Int?

        public init(
            ruleName: Swift.String? = nil,
            sentimentType: ChimeSDKMediaPipelinesClientTypes.SentimentType? = nil,
            timePeriod: Swift.Int? = nil
        )
        {
            self.ruleName = ruleName
            self.sentimentType = sentimentType
            self.timePeriod = timePeriod
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum RealTimeAlertRuleType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case issuedetection
        case keywordmatch
        case sentiment
        case sdkUnknown(Swift.String)

        public static var allCases: [RealTimeAlertRuleType] {
            return [
                .issuedetection,
                .keywordmatch,
                .sentiment
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .issuedetection: return "IssueDetection"
            case .keywordmatch: return "KeywordMatch"
            case .sentiment: return "Sentiment"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// Specifies the words or phrases that trigger an alert.
    public struct RealTimeAlertRule: Swift.Sendable {
        /// Specifies the issue detection settings for a real-time alert rule.
        public var issueDetectionConfiguration: ChimeSDKMediaPipelinesClientTypes.IssueDetectionConfiguration?
        /// Specifies the settings for matching the keywords in a real-time alert rule.
        public var keywordMatchConfiguration: ChimeSDKMediaPipelinesClientTypes.KeywordMatchConfiguration?
        /// Specifies the settings for predicting sentiment in a real-time alert rule.
        public var sentimentConfiguration: ChimeSDKMediaPipelinesClientTypes.SentimentConfiguration?
        /// The type of alert rule.
        /// This member is required.
        public var type: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertRuleType?

        public init(
            issueDetectionConfiguration: ChimeSDKMediaPipelinesClientTypes.IssueDetectionConfiguration? = nil,
            keywordMatchConfiguration: ChimeSDKMediaPipelinesClientTypes.KeywordMatchConfiguration? = nil,
            sentimentConfiguration: ChimeSDKMediaPipelinesClientTypes.SentimentConfiguration? = nil,
            type: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertRuleType? = nil
        )
        {
            self.issueDetectionConfiguration = issueDetectionConfiguration
            self.keywordMatchConfiguration = keywordMatchConfiguration
            self.sentimentConfiguration = sentimentConfiguration
            self.type = type
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A structure that contains the configuration settings for real-time alerts.
    public struct RealTimeAlertConfiguration: Swift.Sendable {
        /// Turns off real-time alerts.
        public var disabled: Swift.Bool
        /// The rules in the alert. Rules specify the words or phrases that you want to be notified about.
        public var rules: [ChimeSDKMediaPipelinesClientTypes.RealTimeAlertRule]?

        public init(
            disabled: Swift.Bool = false,
            rules: [ChimeSDKMediaPipelinesClientTypes.RealTimeAlertRule]? = nil
        )
        {
            self.disabled = disabled
            self.rules = rules
        }
    }
}

public struct CreateMediaInsightsPipelineConfigurationInput: Swift.Sendable {
    /// The unique identifier for the media insights pipeline configuration request.
    public var clientRequestToken: Swift.String?
    /// The elements in the request, such as a processor for Amazon Transcribe or a sink for a Kinesis Data Stream.
    /// This member is required.
    public var elements: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]?
    /// The name of the media insights pipeline configuration.
    /// This member is required.
    public var mediaInsightsPipelineConfigurationName: Swift.String?
    /// The configuration settings for the real-time alerts in a media insights pipeline configuration.
    public var realTimeAlertConfiguration: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration?
    /// The ARN of the role used by the service to access Amazon Web Services resources, including Transcribe and Transcribe Call Analytics, on the caller’s behalf.
    /// This member is required.
    public var resourceAccessRoleArn: Swift.String?
    /// The tags assigned to the media insights pipeline configuration.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        elements: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]? = nil,
        mediaInsightsPipelineConfigurationName: Swift.String? = nil,
        realTimeAlertConfiguration: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration? = nil,
        resourceAccessRoleArn: Swift.String? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.elements = elements
        self.mediaInsightsPipelineConfigurationName = mediaInsightsPipelineConfigurationName
        self.realTimeAlertConfiguration = realTimeAlertConfiguration
        self.resourceAccessRoleArn = resourceAccessRoleArn
        self.tags = tags
    }
}

extension CreateMediaInsightsPipelineConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaInsightsPipelineConfigurationInput(elements: \(Swift.String(describing: elements)), mediaInsightsPipelineConfigurationName: \(Swift.String(describing: mediaInsightsPipelineConfigurationName)), realTimeAlertConfiguration: \(Swift.String(describing: realTimeAlertConfiguration)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\", resourceAccessRoleArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A structure that contains the configuration settings for a media insights pipeline.
    public struct MediaInsightsPipelineConfiguration: Swift.Sendable {
        /// The time at which the configuration was created.
        public var createdTimestamp: Foundation.Date?
        /// The elements in the configuration.
        public var elements: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]?
        /// The ARN of the configuration.
        public var mediaInsightsPipelineConfigurationArn: Swift.String?
        /// The ID of the configuration.
        public var mediaInsightsPipelineConfigurationId: Swift.String?
        /// The name of the configuration.
        public var mediaInsightsPipelineConfigurationName: Swift.String?
        /// Lists the rules that trigger a real-time alert.
        public var realTimeAlertConfiguration: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration?
        /// The ARN of the role used by the service to access Amazon Web Services resources.
        public var resourceAccessRoleArn: Swift.String?
        /// The time at which the configuration was last updated.
        public var updatedTimestamp: Foundation.Date?

        public init(
            createdTimestamp: Foundation.Date? = nil,
            elements: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]? = nil,
            mediaInsightsPipelineConfigurationArn: Swift.String? = nil,
            mediaInsightsPipelineConfigurationId: Swift.String? = nil,
            mediaInsightsPipelineConfigurationName: Swift.String? = nil,
            realTimeAlertConfiguration: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration? = nil,
            resourceAccessRoleArn: Swift.String? = nil,
            updatedTimestamp: Foundation.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.elements = elements
            self.mediaInsightsPipelineConfigurationArn = mediaInsightsPipelineConfigurationArn
            self.mediaInsightsPipelineConfigurationId = mediaInsightsPipelineConfigurationId
            self.mediaInsightsPipelineConfigurationName = mediaInsightsPipelineConfigurationName
            self.realTimeAlertConfiguration = realTimeAlertConfiguration
            self.resourceAccessRoleArn = resourceAccessRoleArn
            self.updatedTimestamp = updatedTimestamp
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaInsightsPipelineConfiguration(createdTimestamp: \(Swift.String(describing: createdTimestamp)), elements: \(Swift.String(describing: elements)), mediaInsightsPipelineConfigurationId: \(Swift.String(describing: mediaInsightsPipelineConfigurationId)), mediaInsightsPipelineConfigurationName: \(Swift.String(describing: mediaInsightsPipelineConfigurationName)), realTimeAlertConfiguration: \(Swift.String(describing: realTimeAlertConfiguration)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), mediaInsightsPipelineConfigurationArn: \"CONTENT_REDACTED\", resourceAccessRoleArn: \"CONTENT_REDACTED\")"}
}

public struct CreateMediaInsightsPipelineConfigurationOutput: Swift.Sendable {
    /// The configuration settings for the media insights pipeline.
    public var mediaInsightsPipelineConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration?

    public init(
        mediaInsightsPipelineConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration? = nil
    )
    {
        self.mediaInsightsPipelineConfiguration = mediaInsightsPipelineConfiguration
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The media pipeline's RTMP configuration object.
    public struct LiveConnectorRTMPConfiguration: Swift.Sendable {
        /// The audio channels set for the RTMP configuration
        public var audioChannels: ChimeSDKMediaPipelinesClientTypes.AudioChannelsOption?
        /// The audio sample rate set for the RTMP configuration. Default: 48000.
        public var audioSampleRate: Swift.String?
        /// The URL of the RTMP configuration.
        /// This member is required.
        public var url: Swift.String?

        public init(
            audioChannels: ChimeSDKMediaPipelinesClientTypes.AudioChannelsOption? = nil,
            audioSampleRate: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.audioChannels = audioChannels
            self.audioSampleRate = audioSampleRate
            self.url = url
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.LiveConnectorRTMPConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LiveConnectorRTMPConfiguration(audioChannels: \(Swift.String(describing: audioChannels)), audioSampleRate: \(Swift.String(describing: audioSampleRate)), url: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum LiveConnectorSinkType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case rtmp
        case sdkUnknown(Swift.String)

        public static var allCases: [LiveConnectorSinkType] {
            return [
                .rtmp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .rtmp: return "RTMP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The media pipeline's sink configuration settings.
    public struct LiveConnectorSinkConfiguration: Swift.Sendable {
        /// The sink configuration's RTMP configuration settings.
        /// This member is required.
        public var rtmpConfiguration: ChimeSDKMediaPipelinesClientTypes.LiveConnectorRTMPConfiguration?
        /// The sink configuration's sink type.
        /// This member is required.
        public var sinkType: ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkType?

        public init(
            rtmpConfiguration: ChimeSDKMediaPipelinesClientTypes.LiveConnectorRTMPConfiguration? = nil,
            sinkType: ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkType? = nil
        )
        {
            self.rtmpConfiguration = rtmpConfiguration
            self.sinkType = sinkType
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum LiveConnectorMuxType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case audiowithactivespeakervideo
        case audiowithcompositedvideo
        case sdkUnknown(Swift.String)

        public static var allCases: [LiveConnectorMuxType] {
            return [
                .audiowithactivespeakervideo,
                .audiowithcompositedvideo
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .audiowithactivespeakervideo: return "AudioWithActiveSpeakerVideo"
            case .audiowithcompositedvideo: return "AudioWithCompositedVideo"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The media pipeline's configuration object.
    public struct ChimeSdkMeetingLiveConnectorConfiguration: Swift.Sendable {
        /// The configuration object's Chime SDK meeting ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// The media pipeline's composited video.
        public var compositedVideo: ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration?
        /// The configuration object's multiplex type.
        /// This member is required.
        public var muxType: ChimeSDKMediaPipelinesClientTypes.LiveConnectorMuxType?
        /// The source configuration settings of the media pipeline's configuration object.
        public var sourceConfiguration: ChimeSDKMediaPipelinesClientTypes.SourceConfiguration?

        public init(
            arn: Swift.String? = nil,
            compositedVideo: ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration? = nil,
            muxType: ChimeSDKMediaPipelinesClientTypes.LiveConnectorMuxType? = nil,
            sourceConfiguration: ChimeSDKMediaPipelinesClientTypes.SourceConfiguration? = nil
        )
        {
            self.arn = arn
            self.compositedVideo = compositedVideo
            self.muxType = muxType
            self.sourceConfiguration = sourceConfiguration
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingLiveConnectorConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChimeSdkMeetingLiveConnectorConfiguration(compositedVideo: \(Swift.String(describing: compositedVideo)), muxType: \(Swift.String(describing: muxType)), sourceConfiguration: \(Swift.String(describing: sourceConfiguration)), arn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum LiveConnectorSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case chimesdkmeeting
        case sdkUnknown(Swift.String)

        public static var allCases: [LiveConnectorSourceType] {
            return [
                .chimesdkmeeting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .chimesdkmeeting: return "ChimeSdkMeeting"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The data source configuration object of a streaming media pipeline.
    public struct LiveConnectorSourceConfiguration: Swift.Sendable {
        /// The configuration settings of the connector pipeline.
        /// This member is required.
        public var chimeSdkMeetingLiveConnectorConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingLiveConnectorConfiguration?
        /// The source configuration's media source type.
        /// This member is required.
        public var sourceType: ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceType?

        public init(
            chimeSdkMeetingLiveConnectorConfiguration: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingLiveConnectorConfiguration? = nil,
            sourceType: ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceType? = nil
        )
        {
            self.chimeSdkMeetingLiveConnectorConfiguration = chimeSdkMeetingLiveConnectorConfiguration
            self.sourceType = sourceType
        }
    }
}

public struct CreateMediaLiveConnectorPipelineInput: Swift.Sendable {
    /// The token assigned to the client making the request.
    public var clientRequestToken: Swift.String?
    /// The media live connector pipeline's data sinks.
    /// This member is required.
    public var sinks: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]?
    /// The media live connector pipeline's data sources.
    /// This member is required.
    public var sources: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]?
    /// The tags associated with the media live connector pipeline.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        sinks: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]? = nil,
        sources: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.sinks = sinks
        self.sources = sources
        self.tags = tags
    }
}

extension CreateMediaLiveConnectorPipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaLiveConnectorPipelineInput(sinks: \(Swift.String(describing: sinks)), sources: \(Swift.String(describing: sources)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The connector pipeline.
    public struct MediaLiveConnectorPipeline: Swift.Sendable {
        /// The time at which the connector pipeline was created.
        public var createdTimestamp: Foundation.Date?
        /// The connector pipeline's ARN.
        public var mediaPipelineArn: Swift.String?
        /// The connector pipeline's ID.
        public var mediaPipelineId: Swift.String?
        /// The connector pipeline's data sinks.
        public var sinks: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]?
        /// The connector pipeline's data sources.
        public var sources: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]?
        /// The connector pipeline's status.
        public var status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus?
        /// The time at which the connector pipeline was last updated.
        public var updatedTimestamp: Foundation.Date?

        public init(
            createdTimestamp: Foundation.Date? = nil,
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil,
            sinks: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration]? = nil,
            sources: [ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration]? = nil,
            status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus? = nil,
            updatedTimestamp: Foundation.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.sinks = sinks
            self.sources = sources
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }
}

public struct CreateMediaLiveConnectorPipelineOutput: Swift.Sendable {
    /// The new media live connector pipeline.
    public var mediaLiveConnectorPipeline: ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline?

    public init(
        mediaLiveConnectorPipeline: ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline? = nil
    )
    {
        self.mediaLiveConnectorPipeline = mediaLiveConnectorPipeline
    }
}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
        /// The request ID associated with the call responsible for the exception.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKMediaPipelinesClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The configuration of an Kinesis video stream. If a meeting uses an opt-in Region as its [MediaRegion](https://docs.aws.amazon.com/chime-sdk/latest/APIReference/API_meeting-chime_CreateMeeting.html#chimesdk-meeting-chime_CreateMeeting-request-MediaRegion), the KVS stream must be in that same Region. For example, if a meeting uses the af-south-1 Region, the KVS stream must also be in af-south-1. However, if the meeting uses a Region that AWS turns on by default, the KVS stream can be in any available Region, including an opt-in Region. For example, if the meeting uses ca-central-1, the KVS stream can be in eu-west-2, us-east-1, af-south-1, or any other Region that the Amazon Chime SDK supports. To learn which AWS Region a meeting uses, call the [GetMeeting](https://docs.aws.amazon.com/chime-sdk/latest/APIReference/API_meeting-chime_GetMeeting.html) API and use the [MediaRegion](https://docs.aws.amazon.com/chime-sdk/latest/APIReference/API_meeting-chime_CreateMeeting.html#chimesdk-meeting-chime_CreateMeeting-request-MediaRegion) parameter from the response. For more information about opt-in Regions, refer to [Available Regions](https://docs.aws.amazon.com/chime-sdk/latest/dg/sdk-available-regions.html) in the Amazon Chime SDK Developer Guide, and [Specify which AWS Regions your account can use](https://docs.aws.amazon.com/accounts/latest/reference/manage-acct-regions.html#rande-manage-enable.html), in the AWS Account Management Reference Guide.
    public struct KinesisVideoStreamConfiguration: Swift.Sendable {
        /// The amount of time that data is retained.
        public var dataRetentionInHours: Swift.Int?
        /// The Amazon Web Services Region of the video stream.
        /// This member is required.
        public var region: Swift.String?

        public init(
            dataRetentionInHours: Swift.Int? = nil,
            region: Swift.String? = nil
        )
        {
            self.dataRetentionInHours = dataRetentionInHours
            self.region = region
        }
    }
}

public struct CreateMediaPipelineKinesisVideoStreamPoolInput: Swift.Sendable {
    /// The token assigned to the client making the request.
    public var clientRequestToken: Swift.String?
    /// The name of the pool.
    /// This member is required.
    public var poolName: Swift.String?
    /// The configuration settings for the stream.
    /// This member is required.
    public var streamConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfiguration?
    /// The tags assigned to the stream pool.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        poolName: Swift.String? = nil,
        streamConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfiguration? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.poolName = poolName
        self.streamConfiguration = streamConfiguration
        self.tags = tags
    }
}

extension CreateMediaPipelineKinesisVideoStreamPoolInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaPipelineKinesisVideoStreamPoolInput(poolName: \(Swift.String(describing: poolName)), streamConfiguration: \(Swift.String(describing: streamConfiguration)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum KinesisVideoStreamPoolStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [KinesisVideoStreamPoolStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The video stream pool configuration object.
    public struct KinesisVideoStreamPoolConfiguration: Swift.Sendable {
        /// The time at which the configuration was created.
        public var createdTimestamp: Foundation.Date?
        /// The ARN of the video stream pool configuration.
        public var poolArn: Swift.String?
        /// The ID of the video stream pool in the configuration.
        public var poolId: Swift.String?
        /// The name of the video stream pool configuration.
        public var poolName: Swift.String?
        /// The size of the video stream pool in the configuration.
        public var poolSize: Swift.Int?
        /// The status of the video stream pool in the configuration.
        public var poolStatus: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolStatus?
        /// The Kinesis video stream pool configuration object.
        public var streamConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfiguration?
        /// The time at which the configuration was updated.
        public var updatedTimestamp: Foundation.Date?

        public init(
            createdTimestamp: Foundation.Date? = nil,
            poolArn: Swift.String? = nil,
            poolId: Swift.String? = nil,
            poolName: Swift.String? = nil,
            poolSize: Swift.Int? = nil,
            poolStatus: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolStatus? = nil,
            streamConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfiguration? = nil,
            updatedTimestamp: Foundation.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.poolArn = poolArn
            self.poolId = poolId
            self.poolName = poolName
            self.poolSize = poolSize
            self.poolStatus = poolStatus
            self.streamConfiguration = streamConfiguration
            self.updatedTimestamp = updatedTimestamp
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KinesisVideoStreamPoolConfiguration(createdTimestamp: \(Swift.String(describing: createdTimestamp)), poolId: \(Swift.String(describing: poolId)), poolName: \(Swift.String(describing: poolName)), poolSize: \(Swift.String(describing: poolSize)), poolStatus: \(Swift.String(describing: poolStatus)), streamConfiguration: \(Swift.String(describing: streamConfiguration)), updatedTimestamp: \(Swift.String(describing: updatedTimestamp)), poolArn: \"CONTENT_REDACTED\")"}
}

public struct CreateMediaPipelineKinesisVideoStreamPoolOutput: Swift.Sendable {
    /// The configuration for applying the streams to the pool.
    public var kinesisVideoStreamPoolConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration?

    public init(
        kinesisVideoStreamPoolConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration? = nil
    )
    {
        self.kinesisVideoStreamPoolConfiguration = kinesisVideoStreamPoolConfiguration
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum MediaStreamType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case individualaudio
        case mixedaudio
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaStreamType] {
            return [
                .individualaudio,
                .mixedaudio
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .individualaudio: return "IndividualAudio"
            case .mixedaudio: return "MixedAudio"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum MediaStreamPipelineSinkType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case kinesisvideostreampool
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaStreamPipelineSinkType] {
            return [
                .kinesisvideostreampool
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .kinesisvideostreampool: return "KinesisVideoStreamPool"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// Structure that contains the settings for a media stream sink.
    public struct MediaStreamSink: Swift.Sendable {
        /// The media stream sink's media stream type.
        /// This member is required.
        public var mediaStreamType: ChimeSDKMediaPipelinesClientTypes.MediaStreamType?
        /// Specifies the number of streams that the sink can accept.
        /// This member is required.
        public var reservedStreamCapacity: Swift.Int?
        /// The ARN of the Kinesis Video Stream pool returned by the [CreateMediaPipelineKinesisVideoStreamPool] API.
        /// This member is required.
        public var sinkArn: Swift.String?
        /// The media stream sink's type.
        /// This member is required.
        public var sinkType: ChimeSDKMediaPipelinesClientTypes.MediaStreamPipelineSinkType?

        public init(
            mediaStreamType: ChimeSDKMediaPipelinesClientTypes.MediaStreamType? = nil,
            reservedStreamCapacity: Swift.Int? = nil,
            sinkArn: Swift.String? = nil,
            sinkType: ChimeSDKMediaPipelinesClientTypes.MediaStreamPipelineSinkType? = nil
        )
        {
            self.mediaStreamType = mediaStreamType
            self.reservedStreamCapacity = reservedStreamCapacity
            self.sinkArn = sinkArn
            self.sinkType = sinkType
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaStreamSink: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaStreamSink(mediaStreamType: \(Swift.String(describing: mediaStreamType)), reservedStreamCapacity: \(Swift.String(describing: reservedStreamCapacity)), sinkType: \(Swift.String(describing: sinkType)), sinkArn: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// Structure that contains the settings for media stream sources.
    public struct MediaStreamSource: Swift.Sendable {
        /// The ARN of the meeting.
        /// This member is required.
        public var sourceArn: Swift.String?
        /// The type of media stream source.
        /// This member is required.
        public var sourceType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType?

        public init(
            sourceArn: Swift.String? = nil,
            sourceType: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSourceType? = nil
        )
        {
            self.sourceArn = sourceArn
            self.sourceType = sourceType
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaStreamSource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaStreamSource(sourceType: \(Swift.String(describing: sourceType)), sourceArn: \"CONTENT_REDACTED\")"}
}

public struct CreateMediaStreamPipelineInput: Swift.Sendable {
    /// The token assigned to the client making the request.
    public var clientRequestToken: Swift.String?
    /// The data sink for the media pipeline.
    /// This member is required.
    public var sinks: [ChimeSDKMediaPipelinesClientTypes.MediaStreamSink]?
    /// The data sources for the media pipeline.
    /// This member is required.
    public var sources: [ChimeSDKMediaPipelinesClientTypes.MediaStreamSource]?
    /// The tags assigned to the media pipeline.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        sinks: [ChimeSDKMediaPipelinesClientTypes.MediaStreamSink]? = nil,
        sources: [ChimeSDKMediaPipelinesClientTypes.MediaStreamSource]? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.sinks = sinks
        self.sources = sources
        self.tags = tags
    }
}

extension CreateMediaStreamPipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMediaStreamPipelineInput(sinks: \(Swift.String(describing: sinks)), sources: \(Swift.String(describing: sources)), tags: \(Swift.String(describing: tags)), clientRequestToken: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// Structure that contains the settings for a media stream pipeline.
    public struct MediaStreamPipeline: Swift.Sendable {
        /// The time at which the media stream pipeline was created.
        public var createdTimestamp: Foundation.Date?
        /// The ARN of the media stream pipeline.
        public var mediaPipelineArn: Swift.String?
        /// The ID of the media stream pipeline
        public var mediaPipelineId: Swift.String?
        /// The media stream pipeline's data sinks.
        public var sinks: [ChimeSDKMediaPipelinesClientTypes.MediaStreamSink]?
        /// The media stream pipeline's data sources.
        public var sources: [ChimeSDKMediaPipelinesClientTypes.MediaStreamSource]?
        /// The status of the media stream pipeline.
        public var status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus?
        /// The time at which the media stream pipeline was updated.
        public var updatedTimestamp: Foundation.Date?

        public init(
            createdTimestamp: Foundation.Date? = nil,
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil,
            sinks: [ChimeSDKMediaPipelinesClientTypes.MediaStreamSink]? = nil,
            sources: [ChimeSDKMediaPipelinesClientTypes.MediaStreamSource]? = nil,
            status: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatus? = nil,
            updatedTimestamp: Foundation.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
            self.sinks = sinks
            self.sources = sources
            self.status = status
            self.updatedTimestamp = updatedTimestamp
        }
    }
}

public struct CreateMediaStreamPipelineOutput: Swift.Sendable {
    /// The requested media pipeline.
    public var mediaStreamPipeline: ChimeSDKMediaPipelinesClientTypes.MediaStreamPipeline?

    public init(
        mediaStreamPipeline: ChimeSDKMediaPipelinesClientTypes.MediaStreamPipeline? = nil
    )
    {
        self.mediaStreamPipeline = mediaStreamPipeline
    }
}

public struct DeleteMediaCapturePipelineInput: Swift.Sendable {
    /// The ID of the media pipeline being deleted.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init(
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

public struct DeleteMediaInsightsPipelineConfigurationInput: Swift.Sendable {
    /// The unique identifier of the resource to be deleted. Valid values include the name and ARN of the media insights pipeline configuration.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct DeleteMediaPipelineInput: Swift.Sendable {
    /// The ID of the media pipeline to delete.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init(
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

public struct DeleteMediaPipelineKinesisVideoStreamPoolInput: Swift.Sendable {
    /// The unique identifier of the requested resource. Valid values include the name and ARN of the media pipeline Kinesis Video Stream pool.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct GetMediaCapturePipelineInput: Swift.Sendable {
    /// The ID of the pipeline that you want to get.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init(
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

public struct GetMediaCapturePipelineOutput: Swift.Sendable {
    /// The media pipeline object.
    public var mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline?

    public init(
        mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline? = nil
    )
    {
        self.mediaCapturePipeline = mediaCapturePipeline
    }
}

public struct GetMediaInsightsPipelineConfigurationInput: Swift.Sendable {
    /// The unique identifier of the requested resource. Valid values include the name and ARN of the media insights pipeline configuration.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct GetMediaInsightsPipelineConfigurationOutput: Swift.Sendable {
    /// The requested media insights pipeline configuration.
    public var mediaInsightsPipelineConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration?

    public init(
        mediaInsightsPipelineConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration? = nil
    )
    {
        self.mediaInsightsPipelineConfiguration = mediaInsightsPipelineConfiguration
    }
}

public struct GetMediaPipelineInput: Swift.Sendable {
    /// The ID of the pipeline that you want to get.
    /// This member is required.
    public var mediaPipelineId: Swift.String?

    public init(
        mediaPipelineId: Swift.String? = nil
    )
    {
        self.mediaPipelineId = mediaPipelineId
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A pipeline consisting of a media capture, media concatenation, or live-streaming pipeline.
    public struct MediaPipeline: Swift.Sendable {
        /// A pipeline that enables users to capture audio and video.
        public var mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline?
        /// The media concatenation pipeline in a media pipeline.
        public var mediaConcatenationPipeline: ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline?
        /// The media insights pipeline of a media pipeline.
        public var mediaInsightsPipeline: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipeline?
        /// The connector pipeline of the media pipeline.
        public var mediaLiveConnectorPipeline: ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline?
        /// Designates a media pipeline as a media stream pipeline.
        public var mediaStreamPipeline: ChimeSDKMediaPipelinesClientTypes.MediaStreamPipeline?

        public init(
            mediaCapturePipeline: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline? = nil,
            mediaConcatenationPipeline: ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline? = nil,
            mediaInsightsPipeline: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipeline? = nil,
            mediaLiveConnectorPipeline: ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline? = nil,
            mediaStreamPipeline: ChimeSDKMediaPipelinesClientTypes.MediaStreamPipeline? = nil
        )
        {
            self.mediaCapturePipeline = mediaCapturePipeline
            self.mediaConcatenationPipeline = mediaConcatenationPipeline
            self.mediaInsightsPipeline = mediaInsightsPipeline
            self.mediaLiveConnectorPipeline = mediaLiveConnectorPipeline
            self.mediaStreamPipeline = mediaStreamPipeline
        }
    }
}

public struct GetMediaPipelineOutput: Swift.Sendable {
    /// The media pipeline object.
    public var mediaPipeline: ChimeSDKMediaPipelinesClientTypes.MediaPipeline?

    public init(
        mediaPipeline: ChimeSDKMediaPipelinesClientTypes.MediaPipeline? = nil
    )
    {
        self.mediaPipeline = mediaPipeline
    }
}

public struct GetMediaPipelineKinesisVideoStreamPoolInput: Swift.Sendable {
    /// The unique identifier of the requested resource. Valid values include the name and ARN of the media pipeline Kinesis Video Stream pool.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct GetMediaPipelineKinesisVideoStreamPoolOutput: Swift.Sendable {
    /// The video stream pool configuration object.
    public var kinesisVideoStreamPoolConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration?

    public init(
        kinesisVideoStreamPoolConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration? = nil
    )
    {
        self.kinesisVideoStreamPoolConfiguration = kinesisVideoStreamPoolConfiguration
    }
}

public struct GetSpeakerSearchTaskInput: Swift.Sendable {
    /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
    /// This member is required.
    public var identifier: Swift.String?
    /// The ID of the speaker search task.
    /// This member is required.
    public var speakerSearchTaskId: Swift.String?

    public init(
        identifier: Swift.String? = nil,
        speakerSearchTaskId: Swift.String? = nil
    )
    {
        self.identifier = identifier
        self.speakerSearchTaskId = speakerSearchTaskId
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum MediaPipelineTaskStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inprogress
        case initializing
        case notstarted
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineTaskStatus] {
            return [
                .failed,
                .inprogress,
                .initializing,
                .notstarted,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .initializing: return "Initializing"
            case .notstarted: return "NotStarted"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A representation of an asynchronous request to perform speaker search analysis on a media insights pipeline.
    public struct SpeakerSearchTask: Swift.Sendable {
        /// The time at which a speaker search task was created.
        public var createdTimestamp: Foundation.Date?
        /// The speaker search task ID.
        public var speakerSearchTaskId: Swift.String?
        /// The status of the speaker search task.
        public var speakerSearchTaskStatus: ChimeSDKMediaPipelinesClientTypes.MediaPipelineTaskStatus?
        /// The time at which a speaker search task was updated.
        public var updatedTimestamp: Foundation.Date?

        public init(
            createdTimestamp: Foundation.Date? = nil,
            speakerSearchTaskId: Swift.String? = nil,
            speakerSearchTaskStatus: ChimeSDKMediaPipelinesClientTypes.MediaPipelineTaskStatus? = nil,
            updatedTimestamp: Foundation.Date? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.speakerSearchTaskId = speakerSearchTaskId
            self.speakerSearchTaskStatus = speakerSearchTaskStatus
            self.updatedTimestamp = updatedTimestamp
        }
    }
}

public struct GetSpeakerSearchTaskOutput: Swift.Sendable {
    /// The details of the speaker search task.
    public var speakerSearchTask: ChimeSDKMediaPipelinesClientTypes.SpeakerSearchTask?

    public init(
        speakerSearchTask: ChimeSDKMediaPipelinesClientTypes.SpeakerSearchTask? = nil
    )
    {
        self.speakerSearchTask = speakerSearchTask
    }
}

public struct GetVoiceToneAnalysisTaskInput: Swift.Sendable {
    /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
    /// This member is required.
    public var identifier: Swift.String?
    /// The ID of the voice tone analysis task.
    /// This member is required.
    public var voiceToneAnalysisTaskId: Swift.String?

    public init(
        identifier: Swift.String? = nil,
        voiceToneAnalysisTaskId: Swift.String? = nil
    )
    {
        self.identifier = identifier
        self.voiceToneAnalysisTaskId = voiceToneAnalysisTaskId
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A representation of an asynchronous request to perform voice tone analysis on a media insights pipeline.
    public struct VoiceToneAnalysisTask: Swift.Sendable {
        /// The time at which a voice tone analysis task was created.
        public var createdTimestamp: Foundation.Date?
        /// The time at which a voice tone analysis task was updated.
        public var updatedTimestamp: Foundation.Date?
        /// The ID of the voice tone analysis task.
        public var voiceToneAnalysisTaskId: Swift.String?
        /// The status of a voice tone analysis task.
        public var voiceToneAnalysisTaskStatus: ChimeSDKMediaPipelinesClientTypes.MediaPipelineTaskStatus?

        public init(
            createdTimestamp: Foundation.Date? = nil,
            updatedTimestamp: Foundation.Date? = nil,
            voiceToneAnalysisTaskId: Swift.String? = nil,
            voiceToneAnalysisTaskStatus: ChimeSDKMediaPipelinesClientTypes.MediaPipelineTaskStatus? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.updatedTimestamp = updatedTimestamp
            self.voiceToneAnalysisTaskId = voiceToneAnalysisTaskId
            self.voiceToneAnalysisTaskStatus = voiceToneAnalysisTaskStatus
        }
    }
}

public struct GetVoiceToneAnalysisTaskOutput: Swift.Sendable {
    /// The details of the voice tone analysis task.
    public var voiceToneAnalysisTask: ChimeSDKMediaPipelinesClientTypes.VoiceToneAnalysisTask?

    public init(
        voiceToneAnalysisTask: ChimeSDKMediaPipelinesClientTypes.VoiceToneAnalysisTask? = nil
    )
    {
        self.voiceToneAnalysisTask = voiceToneAnalysisTask
    }
}

public struct ListMediaCapturePipelinesInput: Swift.Sendable {
    /// The maximum number of results to return in a single call. Valid Range: 1 - 99.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The summary data of a media capture pipeline.
    public struct MediaCapturePipelineSummary: Swift.Sendable {
        /// The ARN of the media pipeline in the summary.
        public var mediaPipelineArn: Swift.String?
        /// The ID of the media pipeline in the summary.
        public var mediaPipelineId: Swift.String?

        public init(
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil
        )
        {
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
        }
    }
}

public struct ListMediaCapturePipelinesOutput: Swift.Sendable {
    /// The media pipeline objects in the list.
    public var mediaCapturePipelines: [ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary]?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        mediaCapturePipelines: [ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mediaCapturePipelines = mediaCapturePipelines
        self.nextToken = nextToken
    }
}

public struct ListMediaInsightsPipelineConfigurationsInput: Swift.Sendable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A summary of the media insights pipeline configuration.
    public struct MediaInsightsPipelineConfigurationSummary: Swift.Sendable {
        /// The ARN of the media insights pipeline configuration.
        public var mediaInsightsPipelineConfigurationArn: Swift.String?
        /// The ID of the media insights pipeline configuration.
        public var mediaInsightsPipelineConfigurationId: Swift.String?
        /// The name of the media insights pipeline configuration.
        public var mediaInsightsPipelineConfigurationName: Swift.String?

        public init(
            mediaInsightsPipelineConfigurationArn: Swift.String? = nil,
            mediaInsightsPipelineConfigurationId: Swift.String? = nil,
            mediaInsightsPipelineConfigurationName: Swift.String? = nil
        )
        {
            self.mediaInsightsPipelineConfigurationArn = mediaInsightsPipelineConfigurationArn
            self.mediaInsightsPipelineConfigurationId = mediaInsightsPipelineConfigurationId
            self.mediaInsightsPipelineConfigurationName = mediaInsightsPipelineConfigurationName
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaInsightsPipelineConfigurationSummary(mediaInsightsPipelineConfigurationId: \(Swift.String(describing: mediaInsightsPipelineConfigurationId)), mediaInsightsPipelineConfigurationName: \(Swift.String(describing: mediaInsightsPipelineConfigurationName)), mediaInsightsPipelineConfigurationArn: \"CONTENT_REDACTED\")"}
}

public struct ListMediaInsightsPipelineConfigurationsOutput: Swift.Sendable {
    /// The requested list of media insights pipeline configurations.
    public var mediaInsightsPipelineConfigurations: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationSummary]?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        mediaInsightsPipelineConfigurations: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mediaInsightsPipelineConfigurations = mediaInsightsPipelineConfigurations
        self.nextToken = nextToken
    }
}

public struct ListMediaPipelineKinesisVideoStreamPoolsInput: Swift.Sendable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// A summary of the Kinesis video stream pool.
    public struct KinesisVideoStreamPoolSummary: Swift.Sendable {
        /// The ARN of the video stream pool.
        public var poolArn: Swift.String?
        /// The ID of the video stream pool.
        public var poolId: Swift.String?
        /// The name of the video stream pool.
        public var poolName: Swift.String?

        public init(
            poolArn: Swift.String? = nil,
            poolId: Swift.String? = nil,
            poolName: Swift.String? = nil
        )
        {
            self.poolArn = poolArn
            self.poolId = poolId
            self.poolName = poolName
        }
    }
}

extension ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KinesisVideoStreamPoolSummary(poolId: \(Swift.String(describing: poolId)), poolName: \(Swift.String(describing: poolName)), poolArn: \"CONTENT_REDACTED\")"}
}

public struct ListMediaPipelineKinesisVideoStreamPoolsOutput: Swift.Sendable {
    /// The list of video stream pools.
    public var kinesisVideoStreamPools: [ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolSummary]?
    /// The token used to return the next page of results.
    public var nextToken: Swift.String?

    public init(
        kinesisVideoStreamPools: [ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.kinesisVideoStreamPools = kinesisVideoStreamPools
        self.nextToken = nextToken
    }
}

public struct ListMediaPipelinesInput: Swift.Sendable {
    /// The maximum number of results to return in a single call. Valid Range: 1 - 99.
    public var maxResults: Swift.Int?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The summary of the media pipeline.
    public struct MediaPipelineSummary: Swift.Sendable {
        /// The ARN of the media pipeline in the summary.
        public var mediaPipelineArn: Swift.String?
        /// The ID of the media pipeline in the summary.
        public var mediaPipelineId: Swift.String?

        public init(
            mediaPipelineArn: Swift.String? = nil,
            mediaPipelineId: Swift.String? = nil
        )
        {
            self.mediaPipelineArn = mediaPipelineArn
            self.mediaPipelineId = mediaPipelineId
        }
    }
}

public struct ListMediaPipelinesOutput: Swift.Sendable {
    /// The media pipeline objects in the list.
    public var mediaPipelines: [ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary]?
    /// The token used to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        mediaPipelines: [ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mediaPipelines = mediaPipelines
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the media pipeline associated with any tags. The ARN consists of the pipeline's region, resource ID, and pipeline ID.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags associated with the specified media pipeline.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init(
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The task configuration settings for the Kinesis video stream source.
    public struct KinesisVideoStreamSourceTaskConfiguration: Swift.Sendable {
        /// The channel ID.
        /// This member is required.
        public var channelId: Swift.Int
        /// The unique identifier of the fragment to begin processing.
        public var fragmentNumber: Swift.String?
        /// The ARN of the stream.
        /// This member is required.
        public var streamArn: Swift.String?

        public init(
            channelId: Swift.Int = 0,
            fragmentNumber: Swift.String? = nil,
            streamArn: Swift.String? = nil
        )
        {
            self.channelId = channelId
            self.fragmentNumber = fragmentNumber
            self.streamArn = streamArn
        }
    }
}

public struct StartSpeakerSearchTaskInput: Swift.Sendable {
    /// The unique identifier for the client request. Use a different token for different speaker search tasks.
    public var clientRequestToken: Swift.String?
    /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
    /// This member is required.
    public var identifier: Swift.String?
    /// The task configuration for the Kinesis video stream source of the media insights pipeline.
    public var kinesisVideoStreamSourceTaskConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceTaskConfiguration?
    /// The ARN of the voice profile domain that will store the voice profile.
    /// This member is required.
    public var voiceProfileDomainArn: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        identifier: Swift.String? = nil,
        kinesisVideoStreamSourceTaskConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceTaskConfiguration? = nil,
        voiceProfileDomainArn: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.identifier = identifier
        self.kinesisVideoStreamSourceTaskConfiguration = kinesisVideoStreamSourceTaskConfiguration
        self.voiceProfileDomainArn = voiceProfileDomainArn
    }
}

extension StartSpeakerSearchTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSpeakerSearchTaskInput(identifier: \(Swift.String(describing: identifier)), kinesisVideoStreamSourceTaskConfiguration: \(Swift.String(describing: kinesisVideoStreamSourceTaskConfiguration)), clientRequestToken: \"CONTENT_REDACTED\", voiceProfileDomainArn: \"CONTENT_REDACTED\")"}
}

public struct StartSpeakerSearchTaskOutput: Swift.Sendable {
    /// The details of the speaker search task.
    public var speakerSearchTask: ChimeSDKMediaPipelinesClientTypes.SpeakerSearchTask?

    public init(
        speakerSearchTask: ChimeSDKMediaPipelinesClientTypes.SpeakerSearchTask? = nil
    )
    {
        self.speakerSearchTask = speakerSearchTask
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum VoiceAnalyticsLanguageCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enUs
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceAnalyticsLanguageCode] {
            return [
                .enUs
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enUs: return "en-US"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StartVoiceToneAnalysisTaskInput: Swift.Sendable {
    /// The unique identifier for the client request. Use a different token for different voice tone analysis tasks.
    public var clientRequestToken: Swift.String?
    /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
    /// This member is required.
    public var identifier: Swift.String?
    /// The task configuration for the Kinesis video stream source of the media insights pipeline.
    public var kinesisVideoStreamSourceTaskConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceTaskConfiguration?
    /// The language code.
    /// This member is required.
    public var languageCode: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsLanguageCode?

    public init(
        clientRequestToken: Swift.String? = nil,
        identifier: Swift.String? = nil,
        kinesisVideoStreamSourceTaskConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceTaskConfiguration? = nil,
        languageCode: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsLanguageCode? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.identifier = identifier
        self.kinesisVideoStreamSourceTaskConfiguration = kinesisVideoStreamSourceTaskConfiguration
        self.languageCode = languageCode
    }
}

extension StartVoiceToneAnalysisTaskInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartVoiceToneAnalysisTaskInput(identifier: \(Swift.String(describing: identifier)), kinesisVideoStreamSourceTaskConfiguration: \(Swift.String(describing: kinesisVideoStreamSourceTaskConfiguration)), languageCode: \(Swift.String(describing: languageCode)), clientRequestToken: \"CONTENT_REDACTED\")"}
}

public struct StartVoiceToneAnalysisTaskOutput: Swift.Sendable {
    /// The details of the voice tone analysis task.
    public var voiceToneAnalysisTask: ChimeSDKMediaPipelinesClientTypes.VoiceToneAnalysisTask?

    public init(
        voiceToneAnalysisTask: ChimeSDKMediaPipelinesClientTypes.VoiceToneAnalysisTask? = nil
    )
    {
        self.voiceToneAnalysisTask = voiceToneAnalysisTask
    }
}

public struct StopSpeakerSearchTaskInput: Swift.Sendable {
    /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
    /// This member is required.
    public var identifier: Swift.String?
    /// The speaker search task ID.
    /// This member is required.
    public var speakerSearchTaskId: Swift.String?

    public init(
        identifier: Swift.String? = nil,
        speakerSearchTaskId: Swift.String? = nil
    )
    {
        self.identifier = identifier
        self.speakerSearchTaskId = speakerSearchTaskId
    }
}

public struct StopVoiceToneAnalysisTaskInput: Swift.Sendable {
    /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
    /// This member is required.
    public var identifier: Swift.String?
    /// The ID of the voice tone analysis task.
    /// This member is required.
    public var voiceToneAnalysisTaskId: Swift.String?

    public init(
        identifier: Swift.String? = nil,
        voiceToneAnalysisTaskId: Swift.String? = nil
    )
    {
        self.identifier = identifier
        self.voiceToneAnalysisTaskId = voiceToneAnalysisTaskId
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the media pipeline associated with any tags. The ARN consists of the pipeline's endpoint region, resource ID, and pipeline ID.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags associated with the specified media pipeline.
    /// This member is required.
    public var tags: [ChimeSDKMediaPipelinesClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [ChimeSDKMediaPipelinesClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the pipeline that you want to untag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The key/value pairs in the tag that you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateMediaInsightsPipelineConfigurationInput: Swift.Sendable {
    /// The elements in the request, such as a processor for Amazon Transcribe or a sink for a Kinesis Data Stream..
    /// This member is required.
    public var elements: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]?
    /// The unique identifier for the resource to be updated. Valid values include the name and ARN of the media insights pipeline configuration.
    /// This member is required.
    public var identifier: Swift.String?
    /// The configuration settings for real-time alerts for the media insights pipeline.
    public var realTimeAlertConfiguration: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration?
    /// The ARN of the role used by the service to access Amazon Web Services resources.
    /// This member is required.
    public var resourceAccessRoleArn: Swift.String?

    public init(
        elements: [ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement]? = nil,
        identifier: Swift.String? = nil,
        realTimeAlertConfiguration: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration? = nil,
        resourceAccessRoleArn: Swift.String? = nil
    )
    {
        self.elements = elements
        self.identifier = identifier
        self.realTimeAlertConfiguration = realTimeAlertConfiguration
        self.resourceAccessRoleArn = resourceAccessRoleArn
    }
}

extension UpdateMediaInsightsPipelineConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMediaInsightsPipelineConfigurationInput(elements: \(Swift.String(describing: elements)), identifier: \(Swift.String(describing: identifier)), realTimeAlertConfiguration: \(Swift.String(describing: realTimeAlertConfiguration)), resourceAccessRoleArn: \"CONTENT_REDACTED\")"}
}

public struct UpdateMediaInsightsPipelineConfigurationOutput: Swift.Sendable {
    /// The updated configuration settings.
    public var mediaInsightsPipelineConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration?

    public init(
        mediaInsightsPipelineConfiguration: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration? = nil
    )
    {
        self.mediaInsightsPipelineConfiguration = mediaInsightsPipelineConfiguration
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    public enum MediaPipelineStatusUpdate: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pause
        case resume
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaPipelineStatusUpdate] {
            return [
                .pause,
                .resume
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pause: return "Pause"
            case .resume: return "Resume"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateMediaInsightsPipelineStatusInput: Swift.Sendable {
    /// The unique identifier of the resource to be updated. Valid values include the ID and ARN of the media insights pipeline.
    /// This member is required.
    public var identifier: Swift.String?
    /// The requested status of the media insights pipeline.
    /// This member is required.
    public var updateStatus: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatusUpdate?

    public init(
        identifier: Swift.String? = nil,
        updateStatus: ChimeSDKMediaPipelinesClientTypes.MediaPipelineStatusUpdate? = nil
    )
    {
        self.identifier = identifier
        self.updateStatus = updateStatus
    }
}

extension ChimeSDKMediaPipelinesClientTypes {

    /// The updated Kinesis video stream configuration object.
    public struct KinesisVideoStreamConfigurationUpdate: Swift.Sendable {
        /// The updated time that data is retained.
        public var dataRetentionInHours: Swift.Int?

        public init(
            dataRetentionInHours: Swift.Int? = nil
        )
        {
            self.dataRetentionInHours = dataRetentionInHours
        }
    }
}

public struct UpdateMediaPipelineKinesisVideoStreamPoolInput: Swift.Sendable {
    /// The unique identifier of the requested resource. Valid values include the name and ARN of the media pipeline Kinesis Video Stream pool.
    /// This member is required.
    public var identifier: Swift.String?
    /// The configuration settings for the video stream.
    public var streamConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfigurationUpdate?

    public init(
        identifier: Swift.String? = nil,
        streamConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfigurationUpdate? = nil
    )
    {
        self.identifier = identifier
        self.streamConfiguration = streamConfiguration
    }
}

public struct UpdateMediaPipelineKinesisVideoStreamPoolOutput: Swift.Sendable {
    /// The video stream pool configuration object.
    public var kinesisVideoStreamPoolConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration?

    public init(
        kinesisVideoStreamPoolConfiguration: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration? = nil
    )
    {
        self.kinesisVideoStreamPoolConfiguration = kinesisVideoStreamPoolConfiguration
    }
}

extension CreateMediaCapturePipelineInput {

    static func urlPathProvider(_ value: CreateMediaCapturePipelineInput) -> Swift.String? {
        return "/sdk-media-capture-pipelines"
    }
}

extension CreateMediaConcatenationPipelineInput {

    static func urlPathProvider(_ value: CreateMediaConcatenationPipelineInput) -> Swift.String? {
        return "/sdk-media-concatenation-pipelines"
    }
}

extension CreateMediaInsightsPipelineInput {

    static func urlPathProvider(_ value: CreateMediaInsightsPipelineInput) -> Swift.String? {
        return "/media-insights-pipelines"
    }
}

extension CreateMediaInsightsPipelineConfigurationInput {

    static func urlPathProvider(_ value: CreateMediaInsightsPipelineConfigurationInput) -> Swift.String? {
        return "/media-insights-pipeline-configurations"
    }
}

extension CreateMediaLiveConnectorPipelineInput {

    static func urlPathProvider(_ value: CreateMediaLiveConnectorPipelineInput) -> Swift.String? {
        return "/sdk-media-live-connector-pipelines"
    }
}

extension CreateMediaPipelineKinesisVideoStreamPoolInput {

    static func urlPathProvider(_ value: CreateMediaPipelineKinesisVideoStreamPoolInput) -> Swift.String? {
        return "/media-pipeline-kinesis-video-stream-pools"
    }
}

extension CreateMediaStreamPipelineInput {

    static func urlPathProvider(_ value: CreateMediaStreamPipelineInput) -> Swift.String? {
        return "/sdk-media-stream-pipelines"
    }
}

extension DeleteMediaCapturePipelineInput {

    static func urlPathProvider(_ value: DeleteMediaCapturePipelineInput) -> Swift.String? {
        guard let mediaPipelineId = value.mediaPipelineId else {
            return nil
        }
        return "/sdk-media-capture-pipelines/\(mediaPipelineId.urlPercentEncoding())"
    }
}

extension DeleteMediaInsightsPipelineConfigurationInput {

    static func urlPathProvider(_ value: DeleteMediaInsightsPipelineConfigurationInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/media-insights-pipeline-configurations/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteMediaPipelineInput {

    static func urlPathProvider(_ value: DeleteMediaPipelineInput) -> Swift.String? {
        guard let mediaPipelineId = value.mediaPipelineId else {
            return nil
        }
        return "/sdk-media-pipelines/\(mediaPipelineId.urlPercentEncoding())"
    }
}

extension DeleteMediaPipelineKinesisVideoStreamPoolInput {

    static func urlPathProvider(_ value: DeleteMediaPipelineKinesisVideoStreamPoolInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/media-pipeline-kinesis-video-stream-pools/\(identifier.urlPercentEncoding())"
    }
}

extension GetMediaCapturePipelineInput {

    static func urlPathProvider(_ value: GetMediaCapturePipelineInput) -> Swift.String? {
        guard let mediaPipelineId = value.mediaPipelineId else {
            return nil
        }
        return "/sdk-media-capture-pipelines/\(mediaPipelineId.urlPercentEncoding())"
    }
}

extension GetMediaInsightsPipelineConfigurationInput {

    static func urlPathProvider(_ value: GetMediaInsightsPipelineConfigurationInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/media-insights-pipeline-configurations/\(identifier.urlPercentEncoding())"
    }
}

extension GetMediaPipelineInput {

    static func urlPathProvider(_ value: GetMediaPipelineInput) -> Swift.String? {
        guard let mediaPipelineId = value.mediaPipelineId else {
            return nil
        }
        return "/sdk-media-pipelines/\(mediaPipelineId.urlPercentEncoding())"
    }
}

extension GetMediaPipelineKinesisVideoStreamPoolInput {

    static func urlPathProvider(_ value: GetMediaPipelineKinesisVideoStreamPoolInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/media-pipeline-kinesis-video-stream-pools/\(identifier.urlPercentEncoding())"
    }
}

extension GetSpeakerSearchTaskInput {

    static func urlPathProvider(_ value: GetSpeakerSearchTaskInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        guard let speakerSearchTaskId = value.speakerSearchTaskId else {
            return nil
        }
        return "/media-insights-pipelines/\(identifier.urlPercentEncoding())/speaker-search-tasks/\(speakerSearchTaskId.urlPercentEncoding())"
    }
}

extension GetVoiceToneAnalysisTaskInput {

    static func urlPathProvider(_ value: GetVoiceToneAnalysisTaskInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        guard let voiceToneAnalysisTaskId = value.voiceToneAnalysisTaskId else {
            return nil
        }
        return "/media-insights-pipelines/\(identifier.urlPercentEncoding())/voice-tone-analysis-tasks/\(voiceToneAnalysisTaskId.urlPercentEncoding())"
    }
}

extension ListMediaCapturePipelinesInput {

    static func urlPathProvider(_ value: ListMediaCapturePipelinesInput) -> Swift.String? {
        return "/sdk-media-capture-pipelines"
    }
}

extension ListMediaCapturePipelinesInput {

    static func queryItemProvider(_ value: ListMediaCapturePipelinesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMediaInsightsPipelineConfigurationsInput {

    static func urlPathProvider(_ value: ListMediaInsightsPipelineConfigurationsInput) -> Swift.String? {
        return "/media-insights-pipeline-configurations"
    }
}

extension ListMediaInsightsPipelineConfigurationsInput {

    static func queryItemProvider(_ value: ListMediaInsightsPipelineConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMediaPipelineKinesisVideoStreamPoolsInput {

    static func urlPathProvider(_ value: ListMediaPipelineKinesisVideoStreamPoolsInput) -> Swift.String? {
        return "/media-pipeline-kinesis-video-stream-pools"
    }
}

extension ListMediaPipelineKinesisVideoStreamPoolsInput {

    static func queryItemProvider(_ value: ListMediaPipelineKinesisVideoStreamPoolsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMediaPipelinesInput {

    static func urlPathProvider(_ value: ListMediaPipelinesInput) -> Swift.String? {
        return "/sdk-media-pipelines"
    }
}

extension ListMediaPipelinesInput {

    static func queryItemProvider(_ value: ListMediaPipelinesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension ListTagsForResourceInput {

    static func queryItemProvider(_ value: ListTagsForResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceARN = value.resourceARN else {
            let message = "Creating a URL Query Item failed. resourceARN is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceARNQueryItem = Smithy.URIQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
        items.append(resourceARNQueryItem)
        return items
    }
}

extension StartSpeakerSearchTaskInput {

    static func urlPathProvider(_ value: StartSpeakerSearchTaskInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/media-insights-pipelines/\(identifier.urlPercentEncoding())/speaker-search-tasks"
    }
}

extension StartSpeakerSearchTaskInput {

    static func queryItemProvider(_ value: StartSpeakerSearchTaskInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "start"))
        return items
    }
}

extension StartVoiceToneAnalysisTaskInput {

    static func urlPathProvider(_ value: StartVoiceToneAnalysisTaskInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/media-insights-pipelines/\(identifier.urlPercentEncoding())/voice-tone-analysis-tasks"
    }
}

extension StartVoiceToneAnalysisTaskInput {

    static func queryItemProvider(_ value: StartVoiceToneAnalysisTaskInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "start"))
        return items
    }
}

extension StopSpeakerSearchTaskInput {

    static func urlPathProvider(_ value: StopSpeakerSearchTaskInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        guard let speakerSearchTaskId = value.speakerSearchTaskId else {
            return nil
        }
        return "/media-insights-pipelines/\(identifier.urlPercentEncoding())/speaker-search-tasks/\(speakerSearchTaskId.urlPercentEncoding())"
    }
}

extension StopSpeakerSearchTaskInput {

    static func queryItemProvider(_ value: StopSpeakerSearchTaskInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "stop"))
        return items
    }
}

extension StopVoiceToneAnalysisTaskInput {

    static func urlPathProvider(_ value: StopVoiceToneAnalysisTaskInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        guard let voiceToneAnalysisTaskId = value.voiceToneAnalysisTaskId else {
            return nil
        }
        return "/media-insights-pipelines/\(identifier.urlPercentEncoding())/voice-tone-analysis-tasks/\(voiceToneAnalysisTaskId.urlPercentEncoding())"
    }
}

extension StopVoiceToneAnalysisTaskInput {

    static func queryItemProvider(_ value: StopVoiceToneAnalysisTaskInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "stop"))
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension TagResourceInput {

    static func queryItemProvider(_ value: TagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "tag-resource"))
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        items.append(Smithy.URIQueryItem(name: "operation", value: "untag-resource"))
        return items
    }
}

extension UpdateMediaInsightsPipelineConfigurationInput {

    static func urlPathProvider(_ value: UpdateMediaInsightsPipelineConfigurationInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/media-insights-pipeline-configurations/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateMediaInsightsPipelineStatusInput {

    static func urlPathProvider(_ value: UpdateMediaInsightsPipelineStatusInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/media-insights-pipeline-status/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateMediaPipelineKinesisVideoStreamPoolInput {

    static func urlPathProvider(_ value: UpdateMediaPipelineKinesisVideoStreamPoolInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/media-pipeline-kinesis-video-stream-pools/\(identifier.urlPercentEncoding())"
    }
}

extension CreateMediaCapturePipelineInput {

    static func write(value: CreateMediaCapturePipelineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChimeSdkMeetingConfiguration"].write(value.chimeSdkMeetingConfiguration, with: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration.write(value:to:))
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["SinkArn"].write(value.sinkArn)
        try writer["SinkType"].write(value.sinkType)
        try writer["SourceArn"].write(value.sourceArn)
        try writer["SourceType"].write(value.sourceType)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateMediaConcatenationPipelineInput {

    static func write(value: CreateMediaConcatenationPipelineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Sinks"].writeList(value.sinks, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.ConcatenationSink.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Sources"].writeList(value.sources, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.ConcatenationSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateMediaInsightsPipelineInput {

    static func write(value: CreateMediaInsightsPipelineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["KinesisVideoStreamRecordingSourceRuntimeConfiguration"].write(value.kinesisVideoStreamRecordingSourceRuntimeConfiguration, with: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamRecordingSourceRuntimeConfiguration.write(value:to:))
        try writer["KinesisVideoStreamSourceRuntimeConfiguration"].write(value.kinesisVideoStreamSourceRuntimeConfiguration, with: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceRuntimeConfiguration.write(value:to:))
        try writer["MediaInsightsPipelineConfigurationArn"].write(value.mediaInsightsPipelineConfigurationArn)
        try writer["MediaInsightsRuntimeMetadata"].writeMap(value.mediaInsightsRuntimeMetadata, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["S3RecordingSinkRuntimeConfiguration"].write(value.s3RecordingSinkRuntimeConfiguration, with: ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateMediaInsightsPipelineConfigurationInput {

    static func write(value: CreateMediaInsightsPipelineConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Elements"].writeList(value.elements, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MediaInsightsPipelineConfigurationName"].write(value.mediaInsightsPipelineConfigurationName)
        try writer["RealTimeAlertConfiguration"].write(value.realTimeAlertConfiguration, with: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration.write(value:to:))
        try writer["ResourceAccessRoleArn"].write(value.resourceAccessRoleArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateMediaLiveConnectorPipelineInput {

    static func write(value: CreateMediaLiveConnectorPipelineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Sinks"].writeList(value.sinks, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Sources"].writeList(value.sources, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateMediaPipelineKinesisVideoStreamPoolInput {

    static func write(value: CreateMediaPipelineKinesisVideoStreamPoolInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["PoolName"].write(value.poolName)
        try writer["StreamConfiguration"].write(value.streamConfiguration, with: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfiguration.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateMediaStreamPipelineInput {

    static func write(value: CreateMediaStreamPipelineInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Sinks"].writeList(value.sinks, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.MediaStreamSink.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Sources"].writeList(value.sources, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.MediaStreamSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartSpeakerSearchTaskInput {

    static func write(value: StartSpeakerSearchTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["KinesisVideoStreamSourceTaskConfiguration"].write(value.kinesisVideoStreamSourceTaskConfiguration, with: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceTaskConfiguration.write(value:to:))
        try writer["VoiceProfileDomainArn"].write(value.voiceProfileDomainArn)
    }
}

extension StartVoiceToneAnalysisTaskInput {

    static func write(value: StartVoiceToneAnalysisTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["KinesisVideoStreamSourceTaskConfiguration"].write(value.kinesisVideoStreamSourceTaskConfiguration, with: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceTaskConfiguration.write(value:to:))
        try writer["LanguageCode"].write(value.languageCode)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateMediaInsightsPipelineConfigurationInput {

    static func write(value: UpdateMediaInsightsPipelineConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Elements"].writeList(value.elements, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RealTimeAlertConfiguration"].write(value.realTimeAlertConfiguration, with: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration.write(value:to:))
        try writer["ResourceAccessRoleArn"].write(value.resourceAccessRoleArn)
    }
}

extension UpdateMediaInsightsPipelineStatusInput {

    static func write(value: UpdateMediaInsightsPipelineStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["UpdateStatus"].write(value.updateStatus)
    }
}

extension UpdateMediaPipelineKinesisVideoStreamPoolInput {

    static func write(value: UpdateMediaPipelineKinesisVideoStreamPoolInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StreamConfiguration"].write(value.streamConfiguration, with: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfigurationUpdate.write(value:to:))
    }
}

extension CreateMediaCapturePipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMediaCapturePipelineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMediaCapturePipelineOutput()
        value.mediaCapturePipeline = try reader["MediaCapturePipeline"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline.read(from:))
        return value
    }
}

extension CreateMediaConcatenationPipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMediaConcatenationPipelineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMediaConcatenationPipelineOutput()
        value.mediaConcatenationPipeline = try reader["MediaConcatenationPipeline"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline.read(from:))
        return value
    }
}

extension CreateMediaInsightsPipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMediaInsightsPipelineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMediaInsightsPipelineOutput()
        value.mediaInsightsPipeline = try reader["MediaInsightsPipeline"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipeline.read(from:))
        return value
    }
}

extension CreateMediaInsightsPipelineConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMediaInsightsPipelineConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMediaInsightsPipelineConfigurationOutput()
        value.mediaInsightsPipelineConfiguration = try reader["MediaInsightsPipelineConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration.read(from:))
        return value
    }
}

extension CreateMediaLiveConnectorPipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMediaLiveConnectorPipelineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMediaLiveConnectorPipelineOutput()
        value.mediaLiveConnectorPipeline = try reader["MediaLiveConnectorPipeline"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline.read(from:))
        return value
    }
}

extension CreateMediaPipelineKinesisVideoStreamPoolOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMediaPipelineKinesisVideoStreamPoolOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMediaPipelineKinesisVideoStreamPoolOutput()
        value.kinesisVideoStreamPoolConfiguration = try reader["KinesisVideoStreamPoolConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration.read(from:))
        return value
    }
}

extension CreateMediaStreamPipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMediaStreamPipelineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMediaStreamPipelineOutput()
        value.mediaStreamPipeline = try reader["MediaStreamPipeline"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.MediaStreamPipeline.read(from:))
        return value
    }
}

extension DeleteMediaCapturePipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMediaCapturePipelineOutput {
        return DeleteMediaCapturePipelineOutput()
    }
}

extension DeleteMediaInsightsPipelineConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMediaInsightsPipelineConfigurationOutput {
        return DeleteMediaInsightsPipelineConfigurationOutput()
    }
}

extension DeleteMediaPipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMediaPipelineOutput {
        return DeleteMediaPipelineOutput()
    }
}

extension DeleteMediaPipelineKinesisVideoStreamPoolOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMediaPipelineKinesisVideoStreamPoolOutput {
        return DeleteMediaPipelineKinesisVideoStreamPoolOutput()
    }
}

extension GetMediaCapturePipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMediaCapturePipelineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMediaCapturePipelineOutput()
        value.mediaCapturePipeline = try reader["MediaCapturePipeline"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline.read(from:))
        return value
    }
}

extension GetMediaInsightsPipelineConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMediaInsightsPipelineConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMediaInsightsPipelineConfigurationOutput()
        value.mediaInsightsPipelineConfiguration = try reader["MediaInsightsPipelineConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration.read(from:))
        return value
    }
}

extension GetMediaPipelineOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMediaPipelineOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMediaPipelineOutput()
        value.mediaPipeline = try reader["MediaPipeline"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.MediaPipeline.read(from:))
        return value
    }
}

extension GetMediaPipelineKinesisVideoStreamPoolOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMediaPipelineKinesisVideoStreamPoolOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMediaPipelineKinesisVideoStreamPoolOutput()
        value.kinesisVideoStreamPoolConfiguration = try reader["KinesisVideoStreamPoolConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration.read(from:))
        return value
    }
}

extension GetSpeakerSearchTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSpeakerSearchTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSpeakerSearchTaskOutput()
        value.speakerSearchTask = try reader["SpeakerSearchTask"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.SpeakerSearchTask.read(from:))
        return value
    }
}

extension GetVoiceToneAnalysisTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVoiceToneAnalysisTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVoiceToneAnalysisTaskOutput()
        value.voiceToneAnalysisTask = try reader["VoiceToneAnalysisTask"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.VoiceToneAnalysisTask.read(from:))
        return value
    }
}

extension ListMediaCapturePipelinesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMediaCapturePipelinesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMediaCapturePipelinesOutput()
        value.mediaCapturePipelines = try reader["MediaCapturePipelines"].readListIfPresent(memberReadingClosure: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListMediaInsightsPipelineConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMediaInsightsPipelineConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMediaInsightsPipelineConfigurationsOutput()
        value.mediaInsightsPipelineConfigurations = try reader["MediaInsightsPipelineConfigurations"].readListIfPresent(memberReadingClosure: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListMediaPipelineKinesisVideoStreamPoolsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMediaPipelineKinesisVideoStreamPoolsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMediaPipelineKinesisVideoStreamPoolsOutput()
        value.kinesisVideoStreamPools = try reader["KinesisVideoStreamPools"].readListIfPresent(memberReadingClosure: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListMediaPipelinesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMediaPipelinesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMediaPipelinesOutput()
        value.mediaPipelines = try reader["MediaPipelines"].readListIfPresent(memberReadingClosure: ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ChimeSDKMediaPipelinesClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartSpeakerSearchTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartSpeakerSearchTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartSpeakerSearchTaskOutput()
        value.speakerSearchTask = try reader["SpeakerSearchTask"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.SpeakerSearchTask.read(from:))
        return value
    }
}

extension StartVoiceToneAnalysisTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartVoiceToneAnalysisTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartVoiceToneAnalysisTaskOutput()
        value.voiceToneAnalysisTask = try reader["VoiceToneAnalysisTask"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.VoiceToneAnalysisTask.read(from:))
        return value
    }
}

extension StopSpeakerSearchTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopSpeakerSearchTaskOutput {
        return StopSpeakerSearchTaskOutput()
    }
}

extension StopVoiceToneAnalysisTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopVoiceToneAnalysisTaskOutput {
        return StopVoiceToneAnalysisTaskOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateMediaInsightsPipelineConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMediaInsightsPipelineConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMediaInsightsPipelineConfigurationOutput()
        value.mediaInsightsPipelineConfiguration = try reader["MediaInsightsPipelineConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration.read(from:))
        return value
    }
}

extension UpdateMediaInsightsPipelineStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMediaInsightsPipelineStatusOutput {
        return UpdateMediaInsightsPipelineStatusOutput()
    }
}

extension UpdateMediaPipelineKinesisVideoStreamPoolOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMediaPipelineKinesisVideoStreamPoolOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMediaPipelineKinesisVideoStreamPoolOutput()
        value.kinesisVideoStreamPoolConfiguration = try reader["KinesisVideoStreamPoolConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration.read(from:))
        return value
    }
}

enum CreateMediaCapturePipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMediaConcatenationPipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMediaInsightsPipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMediaInsightsPipelineConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMediaLiveConnectorPipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMediaPipelineKinesisVideoStreamPoolOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMediaStreamPipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMediaCapturePipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMediaInsightsPipelineConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMediaPipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMediaPipelineKinesisVideoStreamPoolOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMediaCapturePipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMediaInsightsPipelineConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMediaPipelineOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMediaPipelineKinesisVideoStreamPoolOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSpeakerSearchTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVoiceToneAnalysisTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMediaCapturePipelinesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMediaInsightsPipelineConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMediaPipelineKinesisVideoStreamPoolsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMediaPipelinesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "ResourceLimitExceededException": return try ResourceLimitExceededException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartSpeakerSearchTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartVoiceToneAnalysisTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopSpeakerSearchTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopVoiceToneAnalysisTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMediaInsightsPipelineConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMediaInsightsPipelineStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMediaPipelineKinesisVideoStreamPoolOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceFailureException": return try ServiceFailureException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottledClientException": return try ThrottledClientException.makeError(baseError: baseError)
            case "UnauthorizedClientException": return try UnauthorizedClientException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceFailureException {
        let reader = baseError.errorBodyReader
        var value = ServiceFailureException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottledClientException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottledClientException {
        let reader = baseError.errorBodyReader
        var value = ThrottledClientException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ResourceLimitExceededException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedClientException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedClientException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedClientException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline()
        value.mediaPipelineId = try reader["MediaPipelineId"].readIfPresent()
        value.mediaPipelineArn = try reader["MediaPipelineArn"].readIfPresent()
        value.sourceType = try reader["SourceType"].readIfPresent()
        value.sourceArn = try reader["SourceArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.sinkType = try reader["SinkType"].readIfPresent()
        value.sinkArn = try reader["SinkArn"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.chimeSdkMeetingConfiguration = try reader["ChimeSdkMeetingConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration.read(from:))
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArtifactsConfiguration"].write(value.artifactsConfiguration, with: ChimeSDKMediaPipelinesClientTypes.ArtifactsConfiguration.write(value:to:))
        try writer["SourceConfiguration"].write(value.sourceConfiguration, with: ChimeSDKMediaPipelinesClientTypes.SourceConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConfiguration()
        value.sourceConfiguration = try reader["SourceConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.SourceConfiguration.read(from:))
        value.artifactsConfiguration = try reader["ArtifactsConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.ArtifactsConfiguration.read(from:))
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ArtifactsConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.ArtifactsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Audio"].write(value.audio, with: ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConfiguration.write(value:to:))
        try writer["CompositedVideo"].write(value.compositedVideo, with: ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration.write(value:to:))
        try writer["Content"].write(value.content, with: ChimeSDKMediaPipelinesClientTypes.ContentArtifactsConfiguration.write(value:to:))
        try writer["Video"].write(value.video, with: ChimeSDKMediaPipelinesClientTypes.VideoArtifactsConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.ArtifactsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.ArtifactsConfiguration()
        value.audio = try reader["Audio"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConfiguration.read(from:))
        value.video = try reader["Video"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.VideoArtifactsConfiguration.read(from:))
        value.content = try reader["Content"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.ContentArtifactsConfiguration.read(from:))
        value.compositedVideo = try reader["CompositedVideo"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration.read(from:))
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GridViewConfiguration"].write(value.gridViewConfiguration, with: ChimeSDKMediaPipelinesClientTypes.GridViewConfiguration.write(value:to:))
        try writer["Layout"].write(value.layout)
        try writer["Resolution"].write(value.resolution)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration()
        value.layout = try reader["Layout"].readIfPresent()
        value.resolution = try reader["Resolution"].readIfPresent()
        value.gridViewConfiguration = try reader["GridViewConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.GridViewConfiguration.read(from:))
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.GridViewConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.GridViewConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActiveSpeakerOnlyConfiguration"].write(value.activeSpeakerOnlyConfiguration, with: ChimeSDKMediaPipelinesClientTypes.ActiveSpeakerOnlyConfiguration.write(value:to:))
        try writer["CanvasOrientation"].write(value.canvasOrientation)
        try writer["ContentShareLayout"].write(value.contentShareLayout)
        try writer["HorizontalLayoutConfiguration"].write(value.horizontalLayoutConfiguration, with: ChimeSDKMediaPipelinesClientTypes.HorizontalLayoutConfiguration.write(value:to:))
        try writer["PresenterOnlyConfiguration"].write(value.presenterOnlyConfiguration, with: ChimeSDKMediaPipelinesClientTypes.PresenterOnlyConfiguration.write(value:to:))
        try writer["VerticalLayoutConfiguration"].write(value.verticalLayoutConfiguration, with: ChimeSDKMediaPipelinesClientTypes.VerticalLayoutConfiguration.write(value:to:))
        try writer["VideoAttribute"].write(value.videoAttribute, with: ChimeSDKMediaPipelinesClientTypes.VideoAttribute.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.GridViewConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.GridViewConfiguration()
        value.contentShareLayout = try reader["ContentShareLayout"].readIfPresent() ?? .sdkUnknown("")
        value.presenterOnlyConfiguration = try reader["PresenterOnlyConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.PresenterOnlyConfiguration.read(from:))
        value.activeSpeakerOnlyConfiguration = try reader["ActiveSpeakerOnlyConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.ActiveSpeakerOnlyConfiguration.read(from:))
        value.horizontalLayoutConfiguration = try reader["HorizontalLayoutConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.HorizontalLayoutConfiguration.read(from:))
        value.verticalLayoutConfiguration = try reader["VerticalLayoutConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.VerticalLayoutConfiguration.read(from:))
        value.videoAttribute = try reader["VideoAttribute"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.VideoAttribute.read(from:))
        value.canvasOrientation = try reader["CanvasOrientation"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.VideoAttribute {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.VideoAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BorderColor"].write(value.borderColor)
        try writer["BorderThickness"].write(value.borderThickness)
        try writer["CornerRadius"].write(value.cornerRadius)
        try writer["HighlightColor"].write(value.highlightColor)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.VideoAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.VideoAttribute()
        value.cornerRadius = try reader["CornerRadius"].readIfPresent()
        value.borderColor = try reader["BorderColor"].readIfPresent()
        value.highlightColor = try reader["HighlightColor"].readIfPresent()
        value.borderThickness = try reader["BorderThickness"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.VerticalLayoutConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.VerticalLayoutConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TileAspectRatio"].write(value.tileAspectRatio)
        try writer["TileCount"].write(value.tileCount)
        try writer["TileOrder"].write(value.tileOrder)
        try writer["TilePosition"].write(value.tilePosition)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.VerticalLayoutConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.VerticalLayoutConfiguration()
        value.tileOrder = try reader["TileOrder"].readIfPresent()
        value.tilePosition = try reader["TilePosition"].readIfPresent()
        value.tileCount = try reader["TileCount"].readIfPresent()
        value.tileAspectRatio = try reader["TileAspectRatio"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.HorizontalLayoutConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.HorizontalLayoutConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TileAspectRatio"].write(value.tileAspectRatio)
        try writer["TileCount"].write(value.tileCount)
        try writer["TileOrder"].write(value.tileOrder)
        try writer["TilePosition"].write(value.tilePosition)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.HorizontalLayoutConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.HorizontalLayoutConfiguration()
        value.tileOrder = try reader["TileOrder"].readIfPresent()
        value.tilePosition = try reader["TilePosition"].readIfPresent()
        value.tileCount = try reader["TileCount"].readIfPresent()
        value.tileAspectRatio = try reader["TileAspectRatio"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ActiveSpeakerOnlyConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.ActiveSpeakerOnlyConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActiveSpeakerPosition"].write(value.activeSpeakerPosition)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.ActiveSpeakerOnlyConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.ActiveSpeakerOnlyConfiguration()
        value.activeSpeakerPosition = try reader["ActiveSpeakerPosition"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.PresenterOnlyConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.PresenterOnlyConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PresenterPosition"].write(value.presenterPosition)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.PresenterOnlyConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.PresenterOnlyConfiguration()
        value.presenterPosition = try reader["PresenterPosition"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ContentArtifactsConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.ContentArtifactsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MuxType"].write(value.muxType)
        try writer["State"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.ContentArtifactsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.ContentArtifactsConfiguration()
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.muxType = try reader["MuxType"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.VideoArtifactsConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.VideoArtifactsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MuxType"].write(value.muxType)
        try writer["State"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.VideoArtifactsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.VideoArtifactsConfiguration()
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        value.muxType = try reader["MuxType"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MuxType"].write(value.muxType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.AudioArtifactsConfiguration()
        value.muxType = try reader["MuxType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.SourceConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.SourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SelectedVideoStreams"].write(value.selectedVideoStreams, with: ChimeSDKMediaPipelinesClientTypes.SelectedVideoStreams.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.SourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.SourceConfiguration()
        value.selectedVideoStreams = try reader["SelectedVideoStreams"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.SelectedVideoStreams.read(from:))
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.SelectedVideoStreams {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.SelectedVideoStreams?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttendeeIds"].writeList(value.attendeeIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExternalUserIds"].writeList(value.externalUserIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.SelectedVideoStreams {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.SelectedVideoStreams()
        value.attendeeIds = try reader["AttendeeIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.externalUserIds = try reader["ExternalUserIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline()
        value.mediaPipelineId = try reader["MediaPipelineId"].readIfPresent()
        value.mediaPipelineArn = try reader["MediaPipelineArn"].readIfPresent()
        value.sources = try reader["Sources"].readListIfPresent(memberReadingClosure: ChimeSDKMediaPipelinesClientTypes.ConcatenationSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sinks = try reader["Sinks"].readListIfPresent(memberReadingClosure: ChimeSDKMediaPipelinesClientTypes.ConcatenationSink.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ConcatenationSink {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.ConcatenationSink?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3BucketSinkConfiguration"].write(value.s3BucketSinkConfiguration, with: ChimeSDKMediaPipelinesClientTypes.S3BucketSinkConfiguration.write(value:to:))
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.ConcatenationSink {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.ConcatenationSink()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.s3BucketSinkConfiguration = try reader["S3BucketSinkConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.S3BucketSinkConfiguration.read(from:))
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.S3BucketSinkConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.S3BucketSinkConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.S3BucketSinkConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.S3BucketSinkConfiguration()
        value.destination = try reader["Destination"].readIfPresent() ?? ""
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ConcatenationSource {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.ConcatenationSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MediaCapturePipelineSourceConfiguration"].write(value.mediaCapturePipelineSourceConfiguration, with: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSourceConfiguration.write(value:to:))
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.ConcatenationSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.ConcatenationSource()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.mediaCapturePipelineSourceConfiguration = try reader["MediaCapturePipelineSourceConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSourceConfiguration.read(from:))
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSourceConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChimeSdkMeetingConfiguration"].write(value.chimeSdkMeetingConfiguration, with: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConcatenationConfiguration.write(value:to:))
        try writer["MediaPipelineArn"].write(value.mediaPipelineArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSourceConfiguration()
        value.mediaPipelineArn = try reader["MediaPipelineArn"].readIfPresent() ?? ""
        value.chimeSdkMeetingConfiguration = try reader["ChimeSdkMeetingConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConcatenationConfiguration.read(from:))
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConcatenationConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConcatenationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ArtifactsConfiguration"].write(value.artifactsConfiguration, with: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConcatenationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingConcatenationConfiguration()
        value.artifactsConfiguration = try reader["ArtifactsConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationConfiguration.read(from:))
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Audio"].write(value.audio, with: ChimeSDKMediaPipelinesClientTypes.AudioConcatenationConfiguration.write(value:to:))
        try writer["CompositedVideo"].write(value.compositedVideo, with: ChimeSDKMediaPipelinesClientTypes.CompositedVideoConcatenationConfiguration.write(value:to:))
        try writer["Content"].write(value.content, with: ChimeSDKMediaPipelinesClientTypes.ContentConcatenationConfiguration.write(value:to:))
        try writer["DataChannel"].write(value.dataChannel, with: ChimeSDKMediaPipelinesClientTypes.DataChannelConcatenationConfiguration.write(value:to:))
        try writer["MeetingEvents"].write(value.meetingEvents, with: ChimeSDKMediaPipelinesClientTypes.MeetingEventsConcatenationConfiguration.write(value:to:))
        try writer["TranscriptionMessages"].write(value.transcriptionMessages, with: ChimeSDKMediaPipelinesClientTypes.TranscriptionMessagesConcatenationConfiguration.write(value:to:))
        try writer["Video"].write(value.video, with: ChimeSDKMediaPipelinesClientTypes.VideoConcatenationConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.ArtifactsConcatenationConfiguration()
        value.audio = try reader["Audio"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.AudioConcatenationConfiguration.read(from:))
        value.video = try reader["Video"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.VideoConcatenationConfiguration.read(from:))
        value.content = try reader["Content"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.ContentConcatenationConfiguration.read(from:))
        value.dataChannel = try reader["DataChannel"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.DataChannelConcatenationConfiguration.read(from:))
        value.transcriptionMessages = try reader["TranscriptionMessages"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.TranscriptionMessagesConcatenationConfiguration.read(from:))
        value.meetingEvents = try reader["MeetingEvents"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.MeetingEventsConcatenationConfiguration.read(from:))
        value.compositedVideo = try reader["CompositedVideo"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.CompositedVideoConcatenationConfiguration.read(from:))
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.CompositedVideoConcatenationConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.CompositedVideoConcatenationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["State"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.CompositedVideoConcatenationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.CompositedVideoConcatenationConfiguration()
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MeetingEventsConcatenationConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.MeetingEventsConcatenationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["State"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.MeetingEventsConcatenationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.MeetingEventsConcatenationConfiguration()
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.TranscriptionMessagesConcatenationConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.TranscriptionMessagesConcatenationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["State"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.TranscriptionMessagesConcatenationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.TranscriptionMessagesConcatenationConfiguration()
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.DataChannelConcatenationConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.DataChannelConcatenationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["State"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.DataChannelConcatenationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.DataChannelConcatenationConfiguration()
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ContentConcatenationConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.ContentConcatenationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["State"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.ContentConcatenationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.ContentConcatenationConfiguration()
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.VideoConcatenationConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.VideoConcatenationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["State"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.VideoConcatenationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.VideoConcatenationConfiguration()
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.AudioConcatenationConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.AudioConcatenationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["State"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.AudioConcatenationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.AudioConcatenationConfiguration()
        value.state = try reader["State"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipeline {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipeline {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipeline()
        value.mediaPipelineId = try reader["MediaPipelineId"].readIfPresent()
        value.mediaPipelineArn = try reader["MediaPipelineArn"].readIfPresent()
        value.mediaInsightsPipelineConfigurationArn = try reader["MediaInsightsPipelineConfigurationArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.kinesisVideoStreamSourceRuntimeConfiguration = try reader["KinesisVideoStreamSourceRuntimeConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceRuntimeConfiguration.read(from:))
        value.mediaInsightsRuntimeMetadata = try reader["MediaInsightsRuntimeMetadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.kinesisVideoStreamRecordingSourceRuntimeConfiguration = try reader["KinesisVideoStreamRecordingSourceRuntimeConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamRecordingSourceRuntimeConfiguration.read(from:))
        value.s3RecordingSinkRuntimeConfiguration = try reader["S3RecordingSinkRuntimeConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration.read(from:))
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.elementStatuses = try reader["ElementStatuses"].readListIfPresent(memberReadingClosure: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineElementStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineElementStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineElementStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineElementStatus()
        value.type = try reader["Type"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination)
        try writer["RecordingFileFormat"].write(value.recordingFileFormat)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkRuntimeConfiguration()
        value.destination = try reader["Destination"].readIfPresent() ?? ""
        value.recordingFileFormat = try reader["RecordingFileFormat"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamRecordingSourceRuntimeConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamRecordingSourceRuntimeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FragmentSelector"].write(value.fragmentSelector, with: ChimeSDKMediaPipelinesClientTypes.FragmentSelector.write(value:to:))
        try writer["Streams"].writeList(value.streams, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.RecordingStreamConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamRecordingSourceRuntimeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamRecordingSourceRuntimeConfiguration()
        value.streams = try reader["Streams"].readListIfPresent(memberReadingClosure: ChimeSDKMediaPipelinesClientTypes.RecordingStreamConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.fragmentSelector = try reader["FragmentSelector"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.FragmentSelector.read(from:))
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.FragmentSelector {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.FragmentSelector?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FragmentSelectorType"].write(value.fragmentSelectorType)
        try writer["TimestampRange"].write(value.timestampRange, with: ChimeSDKMediaPipelinesClientTypes.TimestampRange.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.FragmentSelector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.FragmentSelector()
        value.fragmentSelectorType = try reader["FragmentSelectorType"].readIfPresent() ?? .sdkUnknown("")
        value.timestampRange = try reader["TimestampRange"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.TimestampRange.read(from:))
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.TimestampRange {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.TimestampRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTimestamp"].writeTimestamp(value.endTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["StartTimestamp"].writeTimestamp(value.startTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.TimestampRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.TimestampRange()
        value.startTimestamp = try reader["StartTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTimestamp = try reader["EndTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.RecordingStreamConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.RecordingStreamConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StreamArn"].write(value.streamArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.RecordingStreamConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.RecordingStreamConfiguration()
        value.streamArn = try reader["StreamArn"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceRuntimeConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceRuntimeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MediaEncoding"].write(value.mediaEncoding)
        try writer["MediaSampleRate"].write(value.mediaSampleRate)
        try writer["Streams"].writeList(value.streams, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.StreamConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceRuntimeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceRuntimeConfiguration()
        value.streams = try reader["Streams"].readListIfPresent(memberReadingClosure: ChimeSDKMediaPipelinesClientTypes.StreamConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.mediaEncoding = try reader["MediaEncoding"].readIfPresent() ?? .sdkUnknown("")
        value.mediaSampleRate = try reader["MediaSampleRate"].readIfPresent() ?? 0
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.StreamConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.StreamConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FragmentNumber"].write(value.fragmentNumber)
        try writer["StreamArn"].write(value.streamArn)
        try writer["StreamChannelDefinition"].write(value.streamChannelDefinition, with: ChimeSDKMediaPipelinesClientTypes.StreamChannelDefinition.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.StreamConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.StreamConfiguration()
        value.streamArn = try reader["StreamArn"].readIfPresent() ?? ""
        value.fragmentNumber = try reader["FragmentNumber"].readIfPresent()
        value.streamChannelDefinition = try reader["StreamChannelDefinition"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.StreamChannelDefinition.read(from:))
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.StreamChannelDefinition {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.StreamChannelDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelDefinitions"].writeList(value.channelDefinitions, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.ChannelDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NumberOfChannels"].write(value.numberOfChannels)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.StreamChannelDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.StreamChannelDefinition()
        value.numberOfChannels = try reader["NumberOfChannels"].readIfPresent() ?? 0
        value.channelDefinitions = try reader["ChannelDefinitions"].readListIfPresent(memberReadingClosure: ChimeSDKMediaPipelinesClientTypes.ChannelDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ChannelDefinition {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.ChannelDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelId"].write(value.channelId)
        try writer["ParticipantRole"].write(value.participantRole)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.ChannelDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.ChannelDefinition()
        value.channelId = try reader["ChannelId"].readIfPresent() ?? 0
        value.participantRole = try reader["ParticipantRole"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfiguration()
        value.mediaInsightsPipelineConfigurationName = try reader["MediaInsightsPipelineConfigurationName"].readIfPresent()
        value.mediaInsightsPipelineConfigurationArn = try reader["MediaInsightsPipelineConfigurationArn"].readIfPresent()
        value.resourceAccessRoleArn = try reader["ResourceAccessRoleArn"].readIfPresent()
        value.realTimeAlertConfiguration = try reader["RealTimeAlertConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration.read(from:))
        value.elements = try reader["Elements"].readListIfPresent(memberReadingClosure: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.mediaInsightsPipelineConfigurationId = try reader["MediaInsightsPipelineConfigurationId"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AmazonTranscribeCallAnalyticsProcessorConfiguration"].write(value.amazonTranscribeCallAnalyticsProcessorConfiguration, with: ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeCallAnalyticsProcessorConfiguration.write(value:to:))
        try writer["AmazonTranscribeProcessorConfiguration"].write(value.amazonTranscribeProcessorConfiguration, with: ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeProcessorConfiguration.write(value:to:))
        try writer["KinesisDataStreamSinkConfiguration"].write(value.kinesisDataStreamSinkConfiguration, with: ChimeSDKMediaPipelinesClientTypes.KinesisDataStreamSinkConfiguration.write(value:to:))
        try writer["LambdaFunctionSinkConfiguration"].write(value.lambdaFunctionSinkConfiguration, with: ChimeSDKMediaPipelinesClientTypes.LambdaFunctionSinkConfiguration.write(value:to:))
        try writer["S3RecordingSinkConfiguration"].write(value.s3RecordingSinkConfiguration, with: ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkConfiguration.write(value:to:))
        try writer["SnsTopicSinkConfiguration"].write(value.snsTopicSinkConfiguration, with: ChimeSDKMediaPipelinesClientTypes.SnsTopicSinkConfiguration.write(value:to:))
        try writer["SqsQueueSinkConfiguration"].write(value.sqsQueueSinkConfiguration, with: ChimeSDKMediaPipelinesClientTypes.SqsQueueSinkConfiguration.write(value:to:))
        try writer["Type"].write(value.type)
        try writer["VoiceAnalyticsProcessorConfiguration"].write(value.voiceAnalyticsProcessorConfiguration, with: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsProcessorConfiguration.write(value:to:))
        try writer["VoiceEnhancementSinkConfiguration"].write(value.voiceEnhancementSinkConfiguration, with: ChimeSDKMediaPipelinesClientTypes.VoiceEnhancementSinkConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationElement()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.amazonTranscribeCallAnalyticsProcessorConfiguration = try reader["AmazonTranscribeCallAnalyticsProcessorConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeCallAnalyticsProcessorConfiguration.read(from:))
        value.amazonTranscribeProcessorConfiguration = try reader["AmazonTranscribeProcessorConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeProcessorConfiguration.read(from:))
        value.kinesisDataStreamSinkConfiguration = try reader["KinesisDataStreamSinkConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.KinesisDataStreamSinkConfiguration.read(from:))
        value.s3RecordingSinkConfiguration = try reader["S3RecordingSinkConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkConfiguration.read(from:))
        value.voiceAnalyticsProcessorConfiguration = try reader["VoiceAnalyticsProcessorConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsProcessorConfiguration.read(from:))
        value.lambdaFunctionSinkConfiguration = try reader["LambdaFunctionSinkConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.LambdaFunctionSinkConfiguration.read(from:))
        value.sqsQueueSinkConfiguration = try reader["SqsQueueSinkConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.SqsQueueSinkConfiguration.read(from:))
        value.snsTopicSinkConfiguration = try reader["SnsTopicSinkConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.SnsTopicSinkConfiguration.read(from:))
        value.voiceEnhancementSinkConfiguration = try reader["VoiceEnhancementSinkConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.VoiceEnhancementSinkConfiguration.read(from:))
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.VoiceEnhancementSinkConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.VoiceEnhancementSinkConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Disabled"].write(value.disabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.VoiceEnhancementSinkConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.VoiceEnhancementSinkConfiguration()
        value.disabled = try reader["Disabled"].readIfPresent() ?? false
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.SnsTopicSinkConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.SnsTopicSinkConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InsightsTarget"].write(value.insightsTarget)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.SnsTopicSinkConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.SnsTopicSinkConfiguration()
        value.insightsTarget = try reader["InsightsTarget"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.SqsQueueSinkConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.SqsQueueSinkConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InsightsTarget"].write(value.insightsTarget)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.SqsQueueSinkConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.SqsQueueSinkConfiguration()
        value.insightsTarget = try reader["InsightsTarget"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.LambdaFunctionSinkConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.LambdaFunctionSinkConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InsightsTarget"].write(value.insightsTarget)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.LambdaFunctionSinkConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.LambdaFunctionSinkConfiguration()
        value.insightsTarget = try reader["InsightsTarget"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsProcessorConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsProcessorConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SpeakerSearchStatus"].write(value.speakerSearchStatus)
        try writer["VoiceToneAnalysisStatus"].write(value.voiceToneAnalysisStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsProcessorConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.VoiceAnalyticsProcessorConfiguration()
        value.speakerSearchStatus = try reader["SpeakerSearchStatus"].readIfPresent()
        value.voiceToneAnalysisStatus = try reader["VoiceToneAnalysisStatus"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Destination"].write(value.destination)
        try writer["RecordingFileFormat"].write(value.recordingFileFormat)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.S3RecordingSinkConfiguration()
        value.destination = try reader["Destination"].readIfPresent()
        value.recordingFileFormat = try reader["RecordingFileFormat"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.KinesisDataStreamSinkConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.KinesisDataStreamSinkConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InsightsTarget"].write(value.insightsTarget)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.KinesisDataStreamSinkConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.KinesisDataStreamSinkConfiguration()
        value.insightsTarget = try reader["InsightsTarget"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeProcessorConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeProcessorConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContentIdentificationType"].write(value.contentIdentificationType)
        try writer["ContentRedactionType"].write(value.contentRedactionType)
        try writer["EnablePartialResultsStabilization"].write(value.enablePartialResultsStabilization)
        try writer["FilterPartialResults"].write(value.filterPartialResults)
        try writer["IdentifyLanguage"].write(value.identifyLanguage)
        try writer["IdentifyMultipleLanguages"].write(value.identifyMultipleLanguages)
        try writer["LanguageCode"].write(value.languageCode)
        try writer["LanguageModelName"].write(value.languageModelName)
        try writer["LanguageOptions"].write(value.languageOptions)
        try writer["PartialResultsStability"].write(value.partialResultsStability)
        try writer["PiiEntityTypes"].write(value.piiEntityTypes)
        try writer["PreferredLanguage"].write(value.preferredLanguage)
        try writer["ShowSpeakerLabel"].write(value.showSpeakerLabel)
        try writer["VocabularyFilterMethod"].write(value.vocabularyFilterMethod)
        try writer["VocabularyFilterName"].write(value.vocabularyFilterName)
        try writer["VocabularyFilterNames"].write(value.vocabularyFilterNames)
        try writer["VocabularyName"].write(value.vocabularyName)
        try writer["VocabularyNames"].write(value.vocabularyNames)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeProcessorConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeProcessorConfiguration()
        value.languageCode = try reader["LanguageCode"].readIfPresent()
        value.vocabularyName = try reader["VocabularyName"].readIfPresent()
        value.vocabularyFilterName = try reader["VocabularyFilterName"].readIfPresent()
        value.vocabularyFilterMethod = try reader["VocabularyFilterMethod"].readIfPresent()
        value.showSpeakerLabel = try reader["ShowSpeakerLabel"].readIfPresent() ?? false
        value.enablePartialResultsStabilization = try reader["EnablePartialResultsStabilization"].readIfPresent() ?? false
        value.partialResultsStability = try reader["PartialResultsStability"].readIfPresent()
        value.contentIdentificationType = try reader["ContentIdentificationType"].readIfPresent()
        value.contentRedactionType = try reader["ContentRedactionType"].readIfPresent()
        value.piiEntityTypes = try reader["PiiEntityTypes"].readIfPresent()
        value.languageModelName = try reader["LanguageModelName"].readIfPresent()
        value.filterPartialResults = try reader["FilterPartialResults"].readIfPresent() ?? false
        value.identifyLanguage = try reader["IdentifyLanguage"].readIfPresent() ?? false
        value.identifyMultipleLanguages = try reader["IdentifyMultipleLanguages"].readIfPresent() ?? false
        value.languageOptions = try reader["LanguageOptions"].readIfPresent()
        value.preferredLanguage = try reader["PreferredLanguage"].readIfPresent()
        value.vocabularyNames = try reader["VocabularyNames"].readIfPresent()
        value.vocabularyFilterNames = try reader["VocabularyFilterNames"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeCallAnalyticsProcessorConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeCallAnalyticsProcessorConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CallAnalyticsStreamCategories"].writeList(value.callAnalyticsStreamCategories, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ContentIdentificationType"].write(value.contentIdentificationType)
        try writer["ContentRedactionType"].write(value.contentRedactionType)
        try writer["EnablePartialResultsStabilization"].write(value.enablePartialResultsStabilization)
        try writer["FilterPartialResults"].write(value.filterPartialResults)
        try writer["LanguageCode"].write(value.languageCode)
        try writer["LanguageModelName"].write(value.languageModelName)
        try writer["PartialResultsStability"].write(value.partialResultsStability)
        try writer["PiiEntityTypes"].write(value.piiEntityTypes)
        try writer["PostCallAnalyticsSettings"].write(value.postCallAnalyticsSettings, with: ChimeSDKMediaPipelinesClientTypes.PostCallAnalyticsSettings.write(value:to:))
        try writer["VocabularyFilterMethod"].write(value.vocabularyFilterMethod)
        try writer["VocabularyFilterName"].write(value.vocabularyFilterName)
        try writer["VocabularyName"].write(value.vocabularyName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeCallAnalyticsProcessorConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.AmazonTranscribeCallAnalyticsProcessorConfiguration()
        value.languageCode = try reader["LanguageCode"].readIfPresent() ?? .sdkUnknown("")
        value.vocabularyName = try reader["VocabularyName"].readIfPresent()
        value.vocabularyFilterName = try reader["VocabularyFilterName"].readIfPresent()
        value.vocabularyFilterMethod = try reader["VocabularyFilterMethod"].readIfPresent()
        value.languageModelName = try reader["LanguageModelName"].readIfPresent()
        value.enablePartialResultsStabilization = try reader["EnablePartialResultsStabilization"].readIfPresent() ?? false
        value.partialResultsStability = try reader["PartialResultsStability"].readIfPresent()
        value.contentIdentificationType = try reader["ContentIdentificationType"].readIfPresent()
        value.contentRedactionType = try reader["ContentRedactionType"].readIfPresent()
        value.piiEntityTypes = try reader["PiiEntityTypes"].readIfPresent()
        value.filterPartialResults = try reader["FilterPartialResults"].readIfPresent() ?? false
        value.postCallAnalyticsSettings = try reader["PostCallAnalyticsSettings"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.PostCallAnalyticsSettings.read(from:))
        value.callAnalyticsStreamCategories = try reader["CallAnalyticsStreamCategories"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.PostCallAnalyticsSettings {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.PostCallAnalyticsSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContentRedactionOutput"].write(value.contentRedactionOutput)
        try writer["DataAccessRoleArn"].write(value.dataAccessRoleArn)
        try writer["OutputEncryptionKMSKeyId"].write(value.outputEncryptionKMSKeyId)
        try writer["OutputLocation"].write(value.outputLocation)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.PostCallAnalyticsSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.PostCallAnalyticsSettings()
        value.outputLocation = try reader["OutputLocation"].readIfPresent() ?? ""
        value.dataAccessRoleArn = try reader["DataAccessRoleArn"].readIfPresent() ?? ""
        value.contentRedactionOutput = try reader["ContentRedactionOutput"].readIfPresent()
        value.outputEncryptionKMSKeyId = try reader["OutputEncryptionKMSKeyId"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Disabled"].write(value.disabled)
        try writer["Rules"].writeList(value.rules, memberWritingClosure: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.RealTimeAlertConfiguration()
        value.disabled = try reader["Disabled"].readIfPresent() ?? false
        value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.RealTimeAlertRule {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.RealTimeAlertRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IssueDetectionConfiguration"].write(value.issueDetectionConfiguration, with: ChimeSDKMediaPipelinesClientTypes.IssueDetectionConfiguration.write(value:to:))
        try writer["KeywordMatchConfiguration"].write(value.keywordMatchConfiguration, with: ChimeSDKMediaPipelinesClientTypes.KeywordMatchConfiguration.write(value:to:))
        try writer["SentimentConfiguration"].write(value.sentimentConfiguration, with: ChimeSDKMediaPipelinesClientTypes.SentimentConfiguration.write(value:to:))
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.RealTimeAlertRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.RealTimeAlertRule()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.keywordMatchConfiguration = try reader["KeywordMatchConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.KeywordMatchConfiguration.read(from:))
        value.sentimentConfiguration = try reader["SentimentConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.SentimentConfiguration.read(from:))
        value.issueDetectionConfiguration = try reader["IssueDetectionConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.IssueDetectionConfiguration.read(from:))
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.IssueDetectionConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.IssueDetectionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RuleName"].write(value.ruleName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.IssueDetectionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.IssueDetectionConfiguration()
        value.ruleName = try reader["RuleName"].readIfPresent() ?? ""
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.SentimentConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.SentimentConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RuleName"].write(value.ruleName)
        try writer["SentimentType"].write(value.sentimentType)
        try writer["TimePeriod"].write(value.timePeriod)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.SentimentConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.SentimentConfiguration()
        value.ruleName = try reader["RuleName"].readIfPresent() ?? ""
        value.sentimentType = try reader["SentimentType"].readIfPresent() ?? .sdkUnknown("")
        value.timePeriod = try reader["TimePeriod"].readIfPresent() ?? 0
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.KeywordMatchConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.KeywordMatchConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Keywords"].writeList(value.keywords, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Negate"].write(value.negate)
        try writer["RuleName"].write(value.ruleName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.KeywordMatchConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.KeywordMatchConfiguration()
        value.ruleName = try reader["RuleName"].readIfPresent() ?? ""
        value.keywords = try reader["Keywords"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.negate = try reader["Negate"].readIfPresent() ?? false
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline()
        value.sources = try reader["Sources"].readListIfPresent(memberReadingClosure: ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sinks = try reader["Sinks"].readListIfPresent(memberReadingClosure: ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.mediaPipelineId = try reader["MediaPipelineId"].readIfPresent()
        value.mediaPipelineArn = try reader["MediaPipelineArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RTMPConfiguration"].write(value.rtmpConfiguration, with: ChimeSDKMediaPipelinesClientTypes.LiveConnectorRTMPConfiguration.write(value:to:))
        try writer["SinkType"].write(value.sinkType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.LiveConnectorSinkConfiguration()
        value.sinkType = try reader["SinkType"].readIfPresent() ?? .sdkUnknown("")
        value.rtmpConfiguration = try reader["RTMPConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.LiveConnectorRTMPConfiguration.read(from:))
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.LiveConnectorRTMPConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.LiveConnectorRTMPConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AudioChannels"].write(value.audioChannels)
        try writer["AudioSampleRate"].write(value.audioSampleRate)
        try writer["Url"].write(value.url)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.LiveConnectorRTMPConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.LiveConnectorRTMPConfiguration()
        value.url = try reader["Url"].readIfPresent() ?? ""
        value.audioChannels = try reader["AudioChannels"].readIfPresent()
        value.audioSampleRate = try reader["AudioSampleRate"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChimeSdkMeetingLiveConnectorConfiguration"].write(value.chimeSdkMeetingLiveConnectorConfiguration, with: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingLiveConnectorConfiguration.write(value:to:))
        try writer["SourceType"].write(value.sourceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.LiveConnectorSourceConfiguration()
        value.sourceType = try reader["SourceType"].readIfPresent() ?? .sdkUnknown("")
        value.chimeSdkMeetingLiveConnectorConfiguration = try reader["ChimeSdkMeetingLiveConnectorConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingLiveConnectorConfiguration.read(from:))
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingLiveConnectorConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingLiveConnectorConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["CompositedVideo"].write(value.compositedVideo, with: ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration.write(value:to:))
        try writer["MuxType"].write(value.muxType)
        try writer["SourceConfiguration"].write(value.sourceConfiguration, with: ChimeSDKMediaPipelinesClientTypes.SourceConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingLiveConnectorConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.ChimeSdkMeetingLiveConnectorConfiguration()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.muxType = try reader["MuxType"].readIfPresent() ?? .sdkUnknown("")
        value.compositedVideo = try reader["CompositedVideo"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.CompositedVideoArtifactsConfiguration.read(from:))
        value.sourceConfiguration = try reader["SourceConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.SourceConfiguration.read(from:))
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolConfiguration()
        value.poolArn = try reader["PoolArn"].readIfPresent()
        value.poolName = try reader["PoolName"].readIfPresent()
        value.poolId = try reader["PoolId"].readIfPresent()
        value.poolStatus = try reader["PoolStatus"].readIfPresent()
        value.poolSize = try reader["PoolSize"].readIfPresent()
        value.streamConfiguration = try reader["StreamConfiguration"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfiguration.read(from:))
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataRetentionInHours"].write(value.dataRetentionInHours)
        try writer["Region"].write(value.region)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfiguration()
        value.region = try reader["Region"].readIfPresent() ?? ""
        value.dataRetentionInHours = try reader["DataRetentionInHours"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaStreamPipeline {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.MediaStreamPipeline {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.MediaStreamPipeline()
        value.mediaPipelineId = try reader["MediaPipelineId"].readIfPresent()
        value.mediaPipelineArn = try reader["MediaPipelineArn"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.status = try reader["Status"].readIfPresent()
        value.sources = try reader["Sources"].readListIfPresent(memberReadingClosure: ChimeSDKMediaPipelinesClientTypes.MediaStreamSource.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sinks = try reader["Sinks"].readListIfPresent(memberReadingClosure: ChimeSDKMediaPipelinesClientTypes.MediaStreamSink.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaStreamSink {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.MediaStreamSink?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MediaStreamType"].write(value.mediaStreamType)
        try writer["ReservedStreamCapacity"].write(value.reservedStreamCapacity)
        try writer["SinkArn"].write(value.sinkArn)
        try writer["SinkType"].write(value.sinkType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.MediaStreamSink {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.MediaStreamSink()
        value.sinkArn = try reader["SinkArn"].readIfPresent() ?? ""
        value.sinkType = try reader["SinkType"].readIfPresent() ?? .sdkUnknown("")
        value.reservedStreamCapacity = try reader["ReservedStreamCapacity"].readIfPresent() ?? 0
        value.mediaStreamType = try reader["MediaStreamType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaStreamSource {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.MediaStreamSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SourceArn"].write(value.sourceArn)
        try writer["SourceType"].write(value.sourceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.MediaStreamSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.MediaStreamSource()
        value.sourceType = try reader["SourceType"].readIfPresent() ?? .sdkUnknown("")
        value.sourceArn = try reader["SourceArn"].readIfPresent() ?? ""
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaPipeline {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.MediaPipeline {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.MediaPipeline()
        value.mediaCapturePipeline = try reader["MediaCapturePipeline"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.MediaCapturePipeline.read(from:))
        value.mediaLiveConnectorPipeline = try reader["MediaLiveConnectorPipeline"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.MediaLiveConnectorPipeline.read(from:))
        value.mediaConcatenationPipeline = try reader["MediaConcatenationPipeline"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.MediaConcatenationPipeline.read(from:))
        value.mediaInsightsPipeline = try reader["MediaInsightsPipeline"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipeline.read(from:))
        value.mediaStreamPipeline = try reader["MediaStreamPipeline"].readIfPresent(with: ChimeSDKMediaPipelinesClientTypes.MediaStreamPipeline.read(from:))
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.SpeakerSearchTask {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.SpeakerSearchTask {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.SpeakerSearchTask()
        value.speakerSearchTaskId = try reader["SpeakerSearchTaskId"].readIfPresent()
        value.speakerSearchTaskStatus = try reader["SpeakerSearchTaskStatus"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.VoiceToneAnalysisTask {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.VoiceToneAnalysisTask {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.VoiceToneAnalysisTask()
        value.voiceToneAnalysisTaskId = try reader["VoiceToneAnalysisTaskId"].readIfPresent()
        value.voiceToneAnalysisTaskStatus = try reader["VoiceToneAnalysisTaskStatus"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedTimestamp = try reader["UpdatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.MediaCapturePipelineSummary()
        value.mediaPipelineId = try reader["MediaPipelineId"].readIfPresent()
        value.mediaPipelineArn = try reader["MediaPipelineArn"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.MediaInsightsPipelineConfigurationSummary()
        value.mediaInsightsPipelineConfigurationName = try reader["MediaInsightsPipelineConfigurationName"].readIfPresent()
        value.mediaInsightsPipelineConfigurationId = try reader["MediaInsightsPipelineConfigurationId"].readIfPresent()
        value.mediaInsightsPipelineConfigurationArn = try reader["MediaInsightsPipelineConfigurationArn"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamPoolSummary()
        value.poolName = try reader["PoolName"].readIfPresent()
        value.poolId = try reader["PoolId"].readIfPresent()
        value.poolArn = try reader["PoolArn"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.MediaPipelineSummary()
        value.mediaPipelineId = try reader["MediaPipelineId"].readIfPresent()
        value.mediaPipelineArn = try reader["MediaPipelineArn"].readIfPresent()
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.Tag {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ChimeSDKMediaPipelinesClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ChimeSDKMediaPipelinesClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceTaskConfiguration {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamSourceTaskConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelId"].write(value.channelId)
        try writer["FragmentNumber"].write(value.fragmentNumber)
        try writer["StreamArn"].write(value.streamArn)
    }
}

extension ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfigurationUpdate {

    static func write(value: ChimeSDKMediaPipelinesClientTypes.KinesisVideoStreamConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataRetentionInHours"].write(value.dataRetentionInHours)
    }
}

public enum ChimeSDKMediaPipelinesClientTypes {}
