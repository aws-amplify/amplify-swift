//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension WellArchitectedClient {
    /// Paginate over `[GetConsolidatedReportOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetConsolidatedReportInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetConsolidatedReportOutput`
    public func getConsolidatedReportPaginated(input: GetConsolidatedReportInput) -> ClientRuntime.PaginatorSequence<GetConsolidatedReportInput, GetConsolidatedReportOutput> {
        return ClientRuntime.PaginatorSequence<GetConsolidatedReportInput, GetConsolidatedReportOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getConsolidatedReport(input:))
    }
}

extension GetConsolidatedReportInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetConsolidatedReportInput {
        return GetConsolidatedReportInput(
            format: self.format,
            includeSharedResources: self.includeSharedResources,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension WellArchitectedClient {
    /// Paginate over `[ListAnswersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAnswersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAnswersOutput`
    public func listAnswersPaginated(input: ListAnswersInput) -> ClientRuntime.PaginatorSequence<ListAnswersInput, ListAnswersOutput> {
        return ClientRuntime.PaginatorSequence<ListAnswersInput, ListAnswersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAnswers(input:))
    }
}

extension ListAnswersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAnswersInput {
        return ListAnswersInput(
            lensAlias: self.lensAlias,
            maxResults: self.maxResults,
            milestoneNumber: self.milestoneNumber,
            nextToken: token,
            pillarId: self.pillarId,
            questionPriority: self.questionPriority,
            workloadId: self.workloadId
        )}
}
extension WellArchitectedClient {
    /// Paginate over `[ListCheckDetailsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCheckDetailsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCheckDetailsOutput`
    public func listCheckDetailsPaginated(input: ListCheckDetailsInput) -> ClientRuntime.PaginatorSequence<ListCheckDetailsInput, ListCheckDetailsOutput> {
        return ClientRuntime.PaginatorSequence<ListCheckDetailsInput, ListCheckDetailsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCheckDetails(input:))
    }
}

extension ListCheckDetailsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCheckDetailsInput {
        return ListCheckDetailsInput(
            choiceId: self.choiceId,
            lensArn: self.lensArn,
            maxResults: self.maxResults,
            nextToken: token,
            pillarId: self.pillarId,
            questionId: self.questionId,
            workloadId: self.workloadId
        )}
}
extension WellArchitectedClient {
    /// Paginate over `[ListCheckSummariesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCheckSummariesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCheckSummariesOutput`
    public func listCheckSummariesPaginated(input: ListCheckSummariesInput) -> ClientRuntime.PaginatorSequence<ListCheckSummariesInput, ListCheckSummariesOutput> {
        return ClientRuntime.PaginatorSequence<ListCheckSummariesInput, ListCheckSummariesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCheckSummaries(input:))
    }
}

extension ListCheckSummariesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCheckSummariesInput {
        return ListCheckSummariesInput(
            choiceId: self.choiceId,
            lensArn: self.lensArn,
            maxResults: self.maxResults,
            nextToken: token,
            pillarId: self.pillarId,
            questionId: self.questionId,
            workloadId: self.workloadId
        )}
}
extension WellArchitectedClient {
    /// Paginate over `[ListLensesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLensesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLensesOutput`
    public func listLensesPaginated(input: ListLensesInput) -> ClientRuntime.PaginatorSequence<ListLensesInput, ListLensesOutput> {
        return ClientRuntime.PaginatorSequence<ListLensesInput, ListLensesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listLenses(input:))
    }
}

extension ListLensesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLensesInput {
        return ListLensesInput(
            lensName: self.lensName,
            lensStatus: self.lensStatus,
            lensType: self.lensType,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension WellArchitectedClient {
    /// Paginate over `[ListLensReviewImprovementsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLensReviewImprovementsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLensReviewImprovementsOutput`
    public func listLensReviewImprovementsPaginated(input: ListLensReviewImprovementsInput) -> ClientRuntime.PaginatorSequence<ListLensReviewImprovementsInput, ListLensReviewImprovementsOutput> {
        return ClientRuntime.PaginatorSequence<ListLensReviewImprovementsInput, ListLensReviewImprovementsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listLensReviewImprovements(input:))
    }
}

extension ListLensReviewImprovementsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLensReviewImprovementsInput {
        return ListLensReviewImprovementsInput(
            lensAlias: self.lensAlias,
            maxResults: self.maxResults,
            milestoneNumber: self.milestoneNumber,
            nextToken: token,
            pillarId: self.pillarId,
            questionPriority: self.questionPriority,
            workloadId: self.workloadId
        )}
}
extension WellArchitectedClient {
    /// Paginate over `[ListLensReviewsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLensReviewsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLensReviewsOutput`
    public func listLensReviewsPaginated(input: ListLensReviewsInput) -> ClientRuntime.PaginatorSequence<ListLensReviewsInput, ListLensReviewsOutput> {
        return ClientRuntime.PaginatorSequence<ListLensReviewsInput, ListLensReviewsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listLensReviews(input:))
    }
}

extension ListLensReviewsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLensReviewsInput {
        return ListLensReviewsInput(
            maxResults: self.maxResults,
            milestoneNumber: self.milestoneNumber,
            nextToken: token,
            workloadId: self.workloadId
        )}
}
extension WellArchitectedClient {
    /// Paginate over `[ListLensSharesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLensSharesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLensSharesOutput`
    public func listLensSharesPaginated(input: ListLensSharesInput) -> ClientRuntime.PaginatorSequence<ListLensSharesInput, ListLensSharesOutput> {
        return ClientRuntime.PaginatorSequence<ListLensSharesInput, ListLensSharesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listLensShares(input:))
    }
}

extension ListLensSharesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLensSharesInput {
        return ListLensSharesInput(
            lensAlias: self.lensAlias,
            maxResults: self.maxResults,
            nextToken: token,
            sharedWithPrefix: self.sharedWithPrefix,
            status: self.status
        )}
}
extension WellArchitectedClient {
    /// Paginate over `[ListMilestonesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMilestonesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMilestonesOutput`
    public func listMilestonesPaginated(input: ListMilestonesInput) -> ClientRuntime.PaginatorSequence<ListMilestonesInput, ListMilestonesOutput> {
        return ClientRuntime.PaginatorSequence<ListMilestonesInput, ListMilestonesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMilestones(input:))
    }
}

extension ListMilestonesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMilestonesInput {
        return ListMilestonesInput(
            maxResults: self.maxResults,
            nextToken: token,
            workloadId: self.workloadId
        )}
}
extension WellArchitectedClient {
    /// Paginate over `[ListNotificationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListNotificationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListNotificationsOutput`
    public func listNotificationsPaginated(input: ListNotificationsInput) -> ClientRuntime.PaginatorSequence<ListNotificationsInput, ListNotificationsOutput> {
        return ClientRuntime.PaginatorSequence<ListNotificationsInput, ListNotificationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listNotifications(input:))
    }
}

extension ListNotificationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNotificationsInput {
        return ListNotificationsInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn,
            workloadId: self.workloadId
        )}
}
extension WellArchitectedClient {
    /// Paginate over `[ListProfileNotificationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProfileNotificationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProfileNotificationsOutput`
    public func listProfileNotificationsPaginated(input: ListProfileNotificationsInput) -> ClientRuntime.PaginatorSequence<ListProfileNotificationsInput, ListProfileNotificationsOutput> {
        return ClientRuntime.PaginatorSequence<ListProfileNotificationsInput, ListProfileNotificationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listProfileNotifications(input:))
    }
}

extension ListProfileNotificationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProfileNotificationsInput {
        return ListProfileNotificationsInput(
            maxResults: self.maxResults,
            nextToken: token,
            workloadId: self.workloadId
        )}
}
extension WellArchitectedClient {
    /// Paginate over `[ListProfilesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProfilesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProfilesOutput`
    public func listProfilesPaginated(input: ListProfilesInput) -> ClientRuntime.PaginatorSequence<ListProfilesInput, ListProfilesOutput> {
        return ClientRuntime.PaginatorSequence<ListProfilesInput, ListProfilesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listProfiles(input:))
    }
}

extension ListProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProfilesInput {
        return ListProfilesInput(
            maxResults: self.maxResults,
            nextToken: token,
            profileNamePrefix: self.profileNamePrefix,
            profileOwnerType: self.profileOwnerType
        )}
}
extension WellArchitectedClient {
    /// Paginate over `[ListProfileSharesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProfileSharesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProfileSharesOutput`
    public func listProfileSharesPaginated(input: ListProfileSharesInput) -> ClientRuntime.PaginatorSequence<ListProfileSharesInput, ListProfileSharesOutput> {
        return ClientRuntime.PaginatorSequence<ListProfileSharesInput, ListProfileSharesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listProfileShares(input:))
    }
}

extension ListProfileSharesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProfileSharesInput {
        return ListProfileSharesInput(
            maxResults: self.maxResults,
            nextToken: token,
            profileArn: self.profileArn,
            sharedWithPrefix: self.sharedWithPrefix,
            status: self.status
        )}
}
extension WellArchitectedClient {
    /// Paginate over `[ListReviewTemplateAnswersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListReviewTemplateAnswersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListReviewTemplateAnswersOutput`
    public func listReviewTemplateAnswersPaginated(input: ListReviewTemplateAnswersInput) -> ClientRuntime.PaginatorSequence<ListReviewTemplateAnswersInput, ListReviewTemplateAnswersOutput> {
        return ClientRuntime.PaginatorSequence<ListReviewTemplateAnswersInput, ListReviewTemplateAnswersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listReviewTemplateAnswers(input:))
    }
}

extension ListReviewTemplateAnswersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListReviewTemplateAnswersInput {
        return ListReviewTemplateAnswersInput(
            lensAlias: self.lensAlias,
            maxResults: self.maxResults,
            nextToken: token,
            pillarId: self.pillarId,
            templateArn: self.templateArn
        )}
}
extension WellArchitectedClient {
    /// Paginate over `[ListReviewTemplatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListReviewTemplatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListReviewTemplatesOutput`
    public func listReviewTemplatesPaginated(input: ListReviewTemplatesInput) -> ClientRuntime.PaginatorSequence<ListReviewTemplatesInput, ListReviewTemplatesOutput> {
        return ClientRuntime.PaginatorSequence<ListReviewTemplatesInput, ListReviewTemplatesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listReviewTemplates(input:))
    }
}

extension ListReviewTemplatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListReviewTemplatesInput {
        return ListReviewTemplatesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension WellArchitectedClient {
    /// Paginate over `[ListShareInvitationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListShareInvitationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListShareInvitationsOutput`
    public func listShareInvitationsPaginated(input: ListShareInvitationsInput) -> ClientRuntime.PaginatorSequence<ListShareInvitationsInput, ListShareInvitationsOutput> {
        return ClientRuntime.PaginatorSequence<ListShareInvitationsInput, ListShareInvitationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listShareInvitations(input:))
    }
}

extension ListShareInvitationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListShareInvitationsInput {
        return ListShareInvitationsInput(
            lensNamePrefix: self.lensNamePrefix,
            maxResults: self.maxResults,
            nextToken: token,
            profileNamePrefix: self.profileNamePrefix,
            shareResourceType: self.shareResourceType,
            templateNamePrefix: self.templateNamePrefix,
            workloadNamePrefix: self.workloadNamePrefix
        )}
}
extension WellArchitectedClient {
    /// Paginate over `[ListTemplateSharesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTemplateSharesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTemplateSharesOutput`
    public func listTemplateSharesPaginated(input: ListTemplateSharesInput) -> ClientRuntime.PaginatorSequence<ListTemplateSharesInput, ListTemplateSharesOutput> {
        return ClientRuntime.PaginatorSequence<ListTemplateSharesInput, ListTemplateSharesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTemplateShares(input:))
    }
}

extension ListTemplateSharesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTemplateSharesInput {
        return ListTemplateSharesInput(
            maxResults: self.maxResults,
            nextToken: token,
            sharedWithPrefix: self.sharedWithPrefix,
            status: self.status,
            templateArn: self.templateArn
        )}
}
extension WellArchitectedClient {
    /// Paginate over `[ListWorkloadsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorkloadsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorkloadsOutput`
    public func listWorkloadsPaginated(input: ListWorkloadsInput) -> ClientRuntime.PaginatorSequence<ListWorkloadsInput, ListWorkloadsOutput> {
        return ClientRuntime.PaginatorSequence<ListWorkloadsInput, ListWorkloadsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listWorkloads(input:))
    }
}

extension ListWorkloadsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkloadsInput {
        return ListWorkloadsInput(
            maxResults: self.maxResults,
            nextToken: token,
            workloadNamePrefix: self.workloadNamePrefix
        )}
}
extension WellArchitectedClient {
    /// Paginate over `[ListWorkloadSharesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorkloadSharesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorkloadSharesOutput`
    public func listWorkloadSharesPaginated(input: ListWorkloadSharesInput) -> ClientRuntime.PaginatorSequence<ListWorkloadSharesInput, ListWorkloadSharesOutput> {
        return ClientRuntime.PaginatorSequence<ListWorkloadSharesInput, ListWorkloadSharesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listWorkloadShares(input:))
    }
}

extension ListWorkloadSharesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkloadSharesInput {
        return ListWorkloadSharesInput(
            maxResults: self.maxResults,
            nextToken: token,
            sharedWithPrefix: self.sharedWithPrefix,
            status: self.status,
            workloadId: self.workloadId
        )}
}
