//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You don't have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension VerifiedPermissionsClientTypes {

    /// Contains information about an action for a request for which an authorization decision is made. This data type is used as a request parameter to the [IsAuthorized](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorized.html), [BatchIsAuthorized](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_BatchIsAuthorized.html), and [IsAuthorizedWithToken](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorizedWithToken.html) operations. Example: { "actionId": "<action name>", "actionType": "Action" }
    public struct ActionIdentifier: Swift.Sendable {
        /// The ID of an action.
        /// This member is required.
        public var actionId: Swift.String?
        /// The type of an action.
        /// This member is required.
        public var actionType: Swift.String?

        public init(
            actionId: Swift.String? = nil,
            actionType: Swift.String? = nil
        )
        {
            self.actionId = actionId
            self.actionType = actionType
        }
    }
}

extension VerifiedPermissionsClientTypes.ActionIdentifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionIdentifier(actionId: \"CONTENT_REDACTED\", actionType: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// Contains the identifier of an entity, including its ID and type. This data type is used as a request parameter for [IsAuthorized](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorized.html) operation, and as a response parameter for the [CreatePolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreatePolicy.html), [GetPolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_GetPolicy.html), and [UpdatePolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdatePolicy.html) operations. Example: {"entityId":"string","entityType":"string"}
    public struct EntityIdentifier: Swift.Sendable {
        /// The identifier of an entity. "entityId":"identifier"
        /// This member is required.
        public var entityId: Swift.String?
        /// The type of an entity. Example: "entityType":"typeName"
        /// This member is required.
        public var entityType: Swift.String?

        public init(
            entityId: Swift.String? = nil,
            entityType: Swift.String? = nil
        )
        {
            self.entityId = entityId
            self.entityType = entityType
        }
    }
}

extension VerifiedPermissionsClientTypes.EntityIdentifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EntityIdentifier(entityId: \"CONTENT_REDACTED\", entityType: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case identitySource
        case policy
        case policyStore
        case policyTemplate
        case schema
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .identitySource,
                .policy,
                .policyStore,
                .policyTemplate,
                .schema
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .identitySource: return "IDENTITY_SOURCE"
            case .policy: return "POLICY"
            case .policyStore: return "POLICY_STORE"
            case .policyTemplate: return "POLICY_TEMPLATE"
            case .schema: return "SCHEMA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request failed because it references a resource that doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The unique ID of the resource referenced in the failed request.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type of the resource referenced in the failed request.
        /// This member is required.
        public internal(set) var resourceType: VerifiedPermissionsClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: VerifiedPermissionsClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension VerifiedPermissionsClientTypes {

    public enum Decision: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [Decision] {
            return [
                .allow,
                .deny
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VerifiedPermissionsClientTypes {

    /// Contains information about one of the policies that determined an authorization decision. This data type is used as an element in a response parameter for the [IsAuthorized](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorized.html), [BatchIsAuthorized](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_BatchIsAuthorized.html), and [IsAuthorizedWithToken](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorizedWithToken.html) operations. Example: "determiningPolicies":[{"policyId":"SPEXAMPLEabcdefg111111"}]
    public struct DeterminingPolicyItem: Swift.Sendable {
        /// The Id of a policy that determined to an authorization decision. Example: "policyId":"SPEXAMPLEabcdefg111111"
        /// This member is required.
        public var policyId: Swift.String?

        public init(
            policyId: Swift.String? = nil
        )
        {
            self.policyId = policyId
        }
    }
}

extension VerifiedPermissionsClientTypes {

    /// Contains a description of an evaluation error. This data type is a response parameter of the [IsAuthorized](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorized.html), [BatchIsAuthorized](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_BatchIsAuthorized.html), and [IsAuthorizedWithToken](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorizedWithToken.html) operations.
    public struct EvaluationErrorItem: Swift.Sendable {
        /// The error description.
        /// This member is required.
        public var errorDescription: Swift.String?

        public init(
            errorDescription: Swift.String? = nil
        )
        {
            self.errorDescription = errorDescription
        }
    }
}

extension VerifiedPermissionsClientTypes.EvaluationErrorItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension VerifiedPermissionsClientTypes {

    /// The type of entity that a policy store maps to groups from an Amazon Cognito user pool identity source. This data type is part of a [CognitoUserPoolConfiguration](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CognitoUserPoolConfiguration.html) structure and is a request parameter in [CreateIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreateIdentitySource.html).
    public struct CognitoGroupConfiguration: Swift.Sendable {
        /// The name of the schema entity type that's mapped to the user pool group. Defaults to AWS::CognitoGroup.
        /// This member is required.
        public var groupEntityType: Swift.String?

        public init(
            groupEntityType: Swift.String? = nil
        )
        {
            self.groupEntityType = groupEntityType
        }
    }
}

extension VerifiedPermissionsClientTypes.CognitoGroupConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CognitoGroupConfiguration(groupEntityType: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The type of entity that a policy store maps to groups from an Amazon Cognito user pool identity source. This data type is part of an [CognitoUserPoolConfigurationDetail](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CognitoUserPoolConfigurationItem.html) structure and is a response parameter to [GetIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_GetIdentitySource.html).
    public struct CognitoGroupConfigurationDetail: Swift.Sendable {
        /// The name of the schema entity type that's mapped to the user pool group. Defaults to AWS::CognitoGroup.
        public var groupEntityType: Swift.String?

        public init(
            groupEntityType: Swift.String? = nil
        )
        {
            self.groupEntityType = groupEntityType
        }
    }
}

extension VerifiedPermissionsClientTypes.CognitoGroupConfigurationDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CognitoGroupConfigurationDetail(groupEntityType: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The type of entity that a policy store maps to groups from an Amazon Cognito user pool identity source. This data type is part of an [CognitoUserPoolConfigurationItem](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CognitoUserPoolConfigurationDetail.html) structure and is a response parameter to [ListIdentitySources](http://forums.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListIdentitySources.html).
    public struct CognitoGroupConfigurationItem: Swift.Sendable {
        /// The name of the schema entity type that's mapped to the user pool group. Defaults to AWS::CognitoGroup.
        public var groupEntityType: Swift.String?

        public init(
            groupEntityType: Swift.String? = nil
        )
        {
            self.groupEntityType = groupEntityType
        }
    }
}

extension VerifiedPermissionsClientTypes.CognitoGroupConfigurationItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CognitoGroupConfigurationItem(groupEntityType: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The configuration for an identity source that represents a connection to an Amazon Cognito user pool used as an identity provider for Verified Permissions. This data type part of a [Configuration](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_Configuration.html) structure that is used as a parameter to [CreateIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreateIdentitySource.html). Example:"CognitoUserPoolConfiguration":{"UserPoolArn":"arn:aws:cognito-idp:us-east-1:123456789012:userpool/us-east-1_1a2b3c4d5","ClientIds": ["a1b2c3d4e5f6g7h8i9j0kalbmc"],"groupConfiguration": {"groupEntityType": "MyCorp::Group"}}
    public struct CognitoUserPoolConfiguration: Swift.Sendable {
        /// The unique application client IDs that are associated with the specified Amazon Cognito user pool. Example: "ClientIds": ["&ExampleCogClientId;"]
        public var clientIds: [Swift.String]?
        /// The type of entity that a policy store maps to groups from an Amazon Cognito user pool identity source.
        public var groupConfiguration: VerifiedPermissionsClientTypes.CognitoGroupConfiguration?
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Amazon Cognito user pool that contains the identities to be authorized. Example: "UserPoolArn": "arn:aws:cognito-idp:us-east-1:123456789012:userpool/us-east-1_1a2b3c4d5"
        /// This member is required.
        public var userPoolArn: Swift.String?

        public init(
            clientIds: [Swift.String]? = nil,
            groupConfiguration: VerifiedPermissionsClientTypes.CognitoGroupConfiguration? = nil,
            userPoolArn: Swift.String? = nil
        )
        {
            self.clientIds = clientIds
            self.groupConfiguration = groupConfiguration
            self.userPoolArn = userPoolArn
        }
    }
}

extension VerifiedPermissionsClientTypes.CognitoUserPoolConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CognitoUserPoolConfiguration(groupConfiguration: \(Swift.String(describing: groupConfiguration)), userPoolArn: \(Swift.String(describing: userPoolArn)), clientIds: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The configuration for an identity source that represents a connection to an Amazon Cognito user pool used as an identity provider for Verified Permissions. This data type is used as a field that is part of an [ConfigurationDetail](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ConfigurationDetail.html) structure that is part of the response to [GetIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_GetIdentitySource.html). Example:"CognitoUserPoolConfiguration":{"UserPoolArn":"arn:aws:cognito-idp:us-east-1:123456789012:userpool/us-east-1_1a2b3c4d5","ClientIds": ["a1b2c3d4e5f6g7h8i9j0kalbmc"],"groupConfiguration": {"groupEntityType": "MyCorp::Group"}}
    public struct CognitoUserPoolConfigurationDetail: Swift.Sendable {
        /// The unique application client IDs that are associated with the specified Amazon Cognito user pool. Example: "clientIds": ["&ExampleCogClientId;"]
        /// This member is required.
        public var clientIds: [Swift.String]?
        /// The type of entity that a policy store maps to groups from an Amazon Cognito user pool identity source.
        public var groupConfiguration: VerifiedPermissionsClientTypes.CognitoGroupConfigurationDetail?
        /// The OpenID Connect (OIDC) issuer ID of the Amazon Cognito user pool that contains the identities to be authorized. Example: "issuer": "https://cognito-idp.us-east-1.amazonaws.com/us-east-1_1a2b3c4d5"
        /// This member is required.
        public var issuer: Swift.String?
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Amazon Cognito user pool that contains the identities to be authorized. Example: "userPoolArn": "arn:aws:cognito-idp:us-east-1:123456789012:userpool/us-east-1_1a2b3c4d5"
        /// This member is required.
        public var userPoolArn: Swift.String?

        public init(
            clientIds: [Swift.String]? = nil,
            groupConfiguration: VerifiedPermissionsClientTypes.CognitoGroupConfigurationDetail? = nil,
            issuer: Swift.String? = nil,
            userPoolArn: Swift.String? = nil
        )
        {
            self.clientIds = clientIds
            self.groupConfiguration = groupConfiguration
            self.issuer = issuer
            self.userPoolArn = userPoolArn
        }
    }
}

extension VerifiedPermissionsClientTypes.CognitoUserPoolConfigurationDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CognitoUserPoolConfigurationDetail(groupConfiguration: \(Swift.String(describing: groupConfiguration)), issuer: \(Swift.String(describing: issuer)), userPoolArn: \(Swift.String(describing: userPoolArn)), clientIds: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The configuration for an identity source that represents a connection to an Amazon Cognito user pool used as an identity provider for Verified Permissions. This data type is used as a field that is part of the [ConfigurationItem](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ConfigurationItem.html) structure that is part of the response to [ListIdentitySources](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListIdentitySources.html). Example:"CognitoUserPoolConfiguration":{"UserPoolArn":"arn:aws:cognito-idp:us-east-1:123456789012:userpool/us-east-1_1a2b3c4d5","ClientIds": ["a1b2c3d4e5f6g7h8i9j0kalbmc"],"groupConfiguration": {"groupEntityType": "MyCorp::Group"}}
    public struct CognitoUserPoolConfigurationItem: Swift.Sendable {
        /// The unique application client IDs that are associated with the specified Amazon Cognito user pool. Example: "clientIds": ["&ExampleCogClientId;"]
        /// This member is required.
        public var clientIds: [Swift.String]?
        /// The type of entity that a policy store maps to groups from an Amazon Cognito user pool identity source.
        public var groupConfiguration: VerifiedPermissionsClientTypes.CognitoGroupConfigurationItem?
        /// The OpenID Connect (OIDC) issuer ID of the Amazon Cognito user pool that contains the identities to be authorized. Example: "issuer": "https://cognito-idp.us-east-1.amazonaws.com/us-east-1_1a2b3c4d5"
        /// This member is required.
        public var issuer: Swift.String?
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Amazon Cognito user pool that contains the identities to be authorized. Example: "userPoolArn": "arn:aws:cognito-idp:us-east-1:123456789012:userpool/us-east-1_1a2b3c4d5"
        /// This member is required.
        public var userPoolArn: Swift.String?

        public init(
            clientIds: [Swift.String]? = nil,
            groupConfiguration: VerifiedPermissionsClientTypes.CognitoGroupConfigurationItem? = nil,
            issuer: Swift.String? = nil,
            userPoolArn: Swift.String? = nil
        )
        {
            self.clientIds = clientIds
            self.groupConfiguration = groupConfiguration
            self.issuer = issuer
            self.userPoolArn = userPoolArn
        }
    }
}

extension VerifiedPermissionsClientTypes.CognitoUserPoolConfigurationItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CognitoUserPoolConfigurationItem(groupConfiguration: \(Swift.String(describing: groupConfiguration)), issuer: \(Swift.String(describing: issuer)), userPoolArn: \(Swift.String(describing: userPoolArn)), clientIds: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The claim in OIDC identity provider tokens that indicates a user's group membership, and the entity type that you want to map it to. For example, this object can map the contents of a groups claim to MyCorp::UserGroup. This data type is part of a [OpenIdConnectConfiguration](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_OpenIdConnectConfiguration.html) structure, which is a parameter of [CreateIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreateIdentitySource.html).
    public struct OpenIdConnectGroupConfiguration: Swift.Sendable {
        /// The token claim that you want Verified Permissions to interpret as group membership. For example, groups.
        /// This member is required.
        public var groupClaim: Swift.String?
        /// The policy store entity type that you want to map your users' group claim to. For example, MyCorp::UserGroup. A group entity type is an entity that can have a user entity type as a member.
        /// This member is required.
        public var groupEntityType: Swift.String?

        public init(
            groupClaim: Swift.String? = nil,
            groupEntityType: Swift.String? = nil
        )
        {
            self.groupClaim = groupClaim
            self.groupEntityType = groupEntityType
        }
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectGroupConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenIdConnectGroupConfiguration(groupClaim: \"CONTENT_REDACTED\", groupEntityType: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The configuration of an OpenID Connect (OIDC) identity source for handling access token claims. Contains the claim that you want to identify as the principal in an authorization request, and the values of the aud claim, or audiences, that you want to accept. This data type is part of a [OpenIdConnectTokenSelection](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_OpenIdConnectTokenSelection.html) structure, which is a parameter of [CreateIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreateIdentitySource.html).
    public struct OpenIdConnectAccessTokenConfiguration: Swift.Sendable {
        /// The access token aud claim values that you want to accept in your policy store. For example, https://myapp.example.com, https://myapp2.example.com.
        public var audiences: [Swift.String]?
        /// The claim that determines the principal in OIDC access tokens. For example, sub.
        public var principalIdClaim: Swift.String?

        public init(
            audiences: [Swift.String]? = nil,
            principalIdClaim: Swift.String? = "sub"
        )
        {
            self.audiences = audiences
            self.principalIdClaim = principalIdClaim
        }
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectAccessTokenConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenIdConnectAccessTokenConfiguration(audiences: \(Swift.String(describing: audiences)), principalIdClaim: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The configuration of an OpenID Connect (OIDC) identity source for handling identity (ID) token claims. Contains the claim that you want to identify as the principal in an authorization request, and the values of the aud claim, or audiences, that you want to accept. This data type is part of a [OpenIdConnectTokenSelection](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_OpenIdConnectTokenSelection.html) structure, which is a parameter of [CreateIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreateIdentitySource.html).
    public struct OpenIdConnectIdentityTokenConfiguration: Swift.Sendable {
        /// The ID token audience, or client ID, claim values that you want to accept in your policy store from an OIDC identity provider. For example, 1example23456789, 2example10111213.
        public var clientIds: [Swift.String]?
        /// The claim that determines the principal in OIDC access tokens. For example, sub.
        public var principalIdClaim: Swift.String?

        public init(
            clientIds: [Swift.String]? = nil,
            principalIdClaim: Swift.String? = "sub"
        )
        {
            self.clientIds = clientIds
            self.principalIdClaim = principalIdClaim
        }
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectIdentityTokenConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenIdConnectIdentityTokenConfiguration(clientIds: \"CONTENT_REDACTED\", principalIdClaim: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The token type that you want to process from your OIDC identity provider. Your policy store can process either identity (ID) or access tokens from a given OIDC identity source. This data type is part of a [OpenIdConnectConfiguration](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_OpenIdConnectConfiguration.html) structure, which is a parameter of [CreateIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreateIdentitySource.html).
    public enum OpenIdConnectTokenSelection: Swift.Sendable {
        /// The OIDC configuration for processing access tokens. Contains allowed audience claims, for example https://auth.example.com, and the claim that you want to map to the principal, for example sub.
        case accesstokenonly(VerifiedPermissionsClientTypes.OpenIdConnectAccessTokenConfiguration)
        /// The OIDC configuration for processing identity (ID) tokens. Contains allowed client ID claims, for example 1example23456789, and the claim that you want to map to the principal, for example sub.
        case identitytokenonly(VerifiedPermissionsClientTypes.OpenIdConnectIdentityTokenConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension VerifiedPermissionsClientTypes {

    /// Contains configuration details of an OpenID Connect (OIDC) identity provider, or identity source, that Verified Permissions can use to generate entities from authenticated identities. It specifies the issuer URL, token type that you want to use, and policy store entity details. This data type is part of a [Configuration](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_Configuration.html) structure, which is a parameter to [CreateIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreateIdentitySource.html).
    public struct OpenIdConnectConfiguration: Swift.Sendable {
        /// A descriptive string that you want to prefix to user entities from your OIDC identity provider. For example, if you set an entityIdPrefix of MyOIDCProvider, you can reference principals in your policies in the format MyCorp::User::MyOIDCProvider|Carlos.
        public var entityIdPrefix: Swift.String?
        /// The claim in OIDC identity provider tokens that indicates a user's group membership, and the entity type that you want to map it to. For example, this object can map the contents of a groups claim to MyCorp::UserGroup.
        public var groupConfiguration: VerifiedPermissionsClientTypes.OpenIdConnectGroupConfiguration?
        /// The issuer URL of an OIDC identity provider. This URL must have an OIDC discovery endpoint at the path .well-known/openid-configuration.
        /// This member is required.
        public var issuer: Swift.String?
        /// The token type that you want to process from your OIDC identity provider. Your policy store can process either identity (ID) or access tokens from a given OIDC identity source.
        /// This member is required.
        public var tokenSelection: VerifiedPermissionsClientTypes.OpenIdConnectTokenSelection?

        public init(
            entityIdPrefix: Swift.String? = nil,
            groupConfiguration: VerifiedPermissionsClientTypes.OpenIdConnectGroupConfiguration? = nil,
            issuer: Swift.String? = nil,
            tokenSelection: VerifiedPermissionsClientTypes.OpenIdConnectTokenSelection? = nil
        )
        {
            self.entityIdPrefix = entityIdPrefix
            self.groupConfiguration = groupConfiguration
            self.issuer = issuer
            self.tokenSelection = tokenSelection
        }
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenIdConnectConfiguration(groupConfiguration: \(Swift.String(describing: groupConfiguration)), issuer: \(Swift.String(describing: issuer)), tokenSelection: \(Swift.String(describing: tokenSelection)), entityIdPrefix: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// Contains configuration information used when creating a new identity source. This data type is used as a request parameter for the [CreateIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreateIdentitySource.html) operation.
    public enum Configuration: Swift.Sendable {
        /// Contains configuration details of a Amazon Cognito user pool that Verified Permissions can use as a source of authenticated identities as entities. It specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of a Amazon Cognito user pool and one or more application client IDs. Example: "configuration":{"cognitoUserPoolConfiguration":{"userPoolArn":"arn:aws:cognito-idp:us-east-1:123456789012:userpool/us-east-1_1a2b3c4d5","clientIds": ["a1b2c3d4e5f6g7h8i9j0kalbmc"],"groupConfiguration": {"groupEntityType": "MyCorp::Group"}}}
        case cognitouserpoolconfiguration(VerifiedPermissionsClientTypes.CognitoUserPoolConfiguration)
        /// Contains configuration details of an OpenID Connect (OIDC) identity provider, or identity source, that Verified Permissions can use to generate entities from authenticated identities. It specifies the issuer URL, token type that you want to use, and policy store entity details. Example:"configuration":{"openIdConnectConfiguration":{"issuer":"https://auth.example.com","tokenSelection":{"accessTokenOnly":{"audiences":["https://myapp.example.com","https://myapp2.example.com"],"principalIdClaim":"sub"}},"entityIdPrefix":"MyOIDCProvider","groupConfiguration":{"groupClaim":"groups","groupEntityType":"MyCorp::UserGroup"}}}
        case openidconnectconfiguration(VerifiedPermissionsClientTypes.OpenIdConnectConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension VerifiedPermissionsClientTypes {

    /// The claim in OIDC identity provider tokens that indicates a user's group membership, and the entity type that you want to map it to. For example, this object can map the contents of a groups claim to MyCorp::UserGroup. This data type is part of a [OpenIdConnectConfigurationDetail](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_OpenIdConnectConfigurationDetail.html) structure, which is a parameter of [GetIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_GetIdentitySource.html).
    public struct OpenIdConnectGroupConfigurationDetail: Swift.Sendable {
        /// The token claim that you want Verified Permissions to interpret as group membership. For example, groups.
        /// This member is required.
        public var groupClaim: Swift.String?
        /// The policy store entity type that you want to map your users' group claim to. For example, MyCorp::UserGroup. A group entity type is an entity that can have a user entity type as a member.
        /// This member is required.
        public var groupEntityType: Swift.String?

        public init(
            groupClaim: Swift.String? = nil,
            groupEntityType: Swift.String? = nil
        )
        {
            self.groupClaim = groupClaim
            self.groupEntityType = groupEntityType
        }
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectGroupConfigurationDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenIdConnectGroupConfigurationDetail(groupClaim: \"CONTENT_REDACTED\", groupEntityType: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The configuration of an OpenID Connect (OIDC) identity source for handling access token claims. Contains the claim that you want to identify as the principal in an authorization request, and the values of the aud claim, or audiences, that you want to accept. This data type is part of a [OpenIdConnectTokenSelectionDetail](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_OpenIdConnectTokenSelectionDetail.html) structure, which is a parameter of [GetIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_GetIdentitySource.html).
    public struct OpenIdConnectAccessTokenConfigurationDetail: Swift.Sendable {
        /// The access token aud claim values that you want to accept in your policy store. For example, https://myapp.example.com, https://myapp2.example.com.
        public var audiences: [Swift.String]?
        /// The claim that determines the principal in OIDC access tokens. For example, sub.
        public var principalIdClaim: Swift.String?

        public init(
            audiences: [Swift.String]? = nil,
            principalIdClaim: Swift.String? = "sub"
        )
        {
            self.audiences = audiences
            self.principalIdClaim = principalIdClaim
        }
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectAccessTokenConfigurationDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenIdConnectAccessTokenConfigurationDetail(audiences: \(Swift.String(describing: audiences)), principalIdClaim: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The configuration of an OpenID Connect (OIDC) identity source for handling identity (ID) token claims. Contains the claim that you want to identify as the principal in an authorization request, and the values of the aud claim, or audiences, that you want to accept. This data type is part of a [OpenIdConnectTokenSelectionDetail](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_OpenIdConnectTokenSelectionDetail.html) structure, which is a parameter of [GetIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_GetIdentitySource.html).
    public struct OpenIdConnectIdentityTokenConfigurationDetail: Swift.Sendable {
        /// The ID token audience, or client ID, claim values that you want to accept in your policy store from an OIDC identity provider. For example, 1example23456789, 2example10111213.
        public var clientIds: [Swift.String]?
        /// The claim that determines the principal in OIDC access tokens. For example, sub.
        public var principalIdClaim: Swift.String?

        public init(
            clientIds: [Swift.String]? = nil,
            principalIdClaim: Swift.String? = "sub"
        )
        {
            self.clientIds = clientIds
            self.principalIdClaim = principalIdClaim
        }
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectIdentityTokenConfigurationDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenIdConnectIdentityTokenConfigurationDetail(clientIds: \"CONTENT_REDACTED\", principalIdClaim: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The token type that you want to process from your OIDC identity provider. Your policy store can process either identity (ID) or access tokens from a given OIDC identity source. This data type is part of a [OpenIdConnectConfigurationDetail](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_OpenIdConnectConfigurationDetail.html) structure, which is a parameter of [GetIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_GetIdentitySource.html).
    public enum OpenIdConnectTokenSelectionDetail: Swift.Sendable {
        /// The OIDC configuration for processing access tokens. Contains allowed audience claims, for example https://auth.example.com, and the claim that you want to map to the principal, for example sub.
        case accesstokenonly(VerifiedPermissionsClientTypes.OpenIdConnectAccessTokenConfigurationDetail)
        /// The OIDC configuration for processing identity (ID) tokens. Contains allowed client ID claims, for example 1example23456789, and the claim that you want to map to the principal, for example sub.
        case identitytokenonly(VerifiedPermissionsClientTypes.OpenIdConnectIdentityTokenConfigurationDetail)
        case sdkUnknown(Swift.String)
    }
}

extension VerifiedPermissionsClientTypes {

    /// Contains configuration details of an OpenID Connect (OIDC) identity provider, or identity source, that Verified Permissions can use to generate entities from authenticated identities. It specifies the issuer URL, token type that you want to use, and policy store entity details. This data type is part of a [ConfigurationDetail](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ConfigurationDetail.html) structure, which is a parameter to [GetIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_GetIdentitySource.html).
    public struct OpenIdConnectConfigurationDetail: Swift.Sendable {
        /// A descriptive string that you want to prefix to user entities from your OIDC identity provider. For example, if you set an entityIdPrefix of MyOIDCProvider, you can reference principals in your policies in the format MyCorp::User::MyOIDCProvider|Carlos.
        public var entityIdPrefix: Swift.String?
        /// The claim in OIDC identity provider tokens that indicates a user's group membership, and the entity type that you want to map it to. For example, this object can map the contents of a groups claim to MyCorp::UserGroup.
        public var groupConfiguration: VerifiedPermissionsClientTypes.OpenIdConnectGroupConfigurationDetail?
        /// The issuer URL of an OIDC identity provider. This URL must have an OIDC discovery endpoint at the path .well-known/openid-configuration.
        /// This member is required.
        public var issuer: Swift.String?
        /// The token type that you want to process from your OIDC identity provider. Your policy store can process either identity (ID) or access tokens from a given OIDC identity source.
        /// This member is required.
        public var tokenSelection: VerifiedPermissionsClientTypes.OpenIdConnectTokenSelectionDetail?

        public init(
            entityIdPrefix: Swift.String? = nil,
            groupConfiguration: VerifiedPermissionsClientTypes.OpenIdConnectGroupConfigurationDetail? = nil,
            issuer: Swift.String? = nil,
            tokenSelection: VerifiedPermissionsClientTypes.OpenIdConnectTokenSelectionDetail? = nil
        )
        {
            self.entityIdPrefix = entityIdPrefix
            self.groupConfiguration = groupConfiguration
            self.issuer = issuer
            self.tokenSelection = tokenSelection
        }
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectConfigurationDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenIdConnectConfigurationDetail(groupConfiguration: \(Swift.String(describing: groupConfiguration)), issuer: \(Swift.String(describing: issuer)), tokenSelection: \(Swift.String(describing: tokenSelection)), entityIdPrefix: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// Contains configuration information about an identity source. This data type is a response parameter to the [GetIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_GetIdentitySource.html) operation.
    public enum ConfigurationDetail: Swift.Sendable {
        /// Contains configuration details of a Amazon Cognito user pool that Verified Permissions can use as a source of authenticated identities as entities. It specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of a Amazon Cognito user pool, the policy store entity that you want to assign to user groups, and one or more application client IDs. Example: "configuration":{"cognitoUserPoolConfiguration":{"userPoolArn":"arn:aws:cognito-idp:us-east-1:123456789012:userpool/us-east-1_1a2b3c4d5","clientIds": ["a1b2c3d4e5f6g7h8i9j0kalbmc"],"groupConfiguration": {"groupEntityType": "MyCorp::Group"}}}
        case cognitouserpoolconfiguration(VerifiedPermissionsClientTypes.CognitoUserPoolConfigurationDetail)
        /// Contains configuration details of an OpenID Connect (OIDC) identity provider, or identity source, that Verified Permissions can use to generate entities from authenticated identities. It specifies the issuer URL, token type that you want to use, and policy store entity details. Example:"configuration":{"openIdConnectConfiguration":{"issuer":"https://auth.example.com","tokenSelection":{"accessTokenOnly":{"audiences":["https://myapp.example.com","https://myapp2.example.com"],"principalIdClaim":"sub"}},"entityIdPrefix":"MyOIDCProvider","groupConfiguration":{"groupClaim":"groups","groupEntityType":"MyCorp::UserGroup"}}}
        case openidconnectconfiguration(VerifiedPermissionsClientTypes.OpenIdConnectConfigurationDetail)
        case sdkUnknown(Swift.String)
    }
}

extension VerifiedPermissionsClientTypes {

    /// The claim in OIDC identity provider tokens that indicates a user's group membership, and the entity type that you want to map it to. For example, this object can map the contents of a groups claim to MyCorp::UserGroup. This data type is part of a [OpenIdConnectConfigurationItem](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_OpenIdConnectConfigurationItem.html) structure, which is a parameter of [ListIdentitySourcea](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListIdentitySources.html).
    public struct OpenIdConnectGroupConfigurationItem: Swift.Sendable {
        /// The token claim that you want Verified Permissions to interpret as group membership. For example, groups.
        /// This member is required.
        public var groupClaim: Swift.String?
        /// The policy store entity type that you want to map your users' group claim to. For example, MyCorp::UserGroup. A group entity type is an entity that can have a user entity type as a member.
        /// This member is required.
        public var groupEntityType: Swift.String?

        public init(
            groupClaim: Swift.String? = nil,
            groupEntityType: Swift.String? = nil
        )
        {
            self.groupClaim = groupClaim
            self.groupEntityType = groupEntityType
        }
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectGroupConfigurationItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenIdConnectGroupConfigurationItem(groupClaim: \"CONTENT_REDACTED\", groupEntityType: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The configuration of an OpenID Connect (OIDC) identity source for handling access token claims. Contains the claim that you want to identify as the principal in an authorization request, and the values of the aud claim, or audiences, that you want to accept. This data type is part of a [OpenIdConnectTokenSelectionItem](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_OpenIdConnectTokenSelectionItem.html) structure, which is a parameter of [ListIdentitySources](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListIdentitySources.html).
    public struct OpenIdConnectAccessTokenConfigurationItem: Swift.Sendable {
        /// The access token aud claim values that you want to accept in your policy store. For example, https://myapp.example.com, https://myapp2.example.com.
        public var audiences: [Swift.String]?
        /// The claim that determines the principal in OIDC access tokens. For example, sub.
        public var principalIdClaim: Swift.String?

        public init(
            audiences: [Swift.String]? = nil,
            principalIdClaim: Swift.String? = "sub"
        )
        {
            self.audiences = audiences
            self.principalIdClaim = principalIdClaim
        }
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectAccessTokenConfigurationItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenIdConnectAccessTokenConfigurationItem(audiences: \(Swift.String(describing: audiences)), principalIdClaim: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The configuration of an OpenID Connect (OIDC) identity source for handling identity (ID) token claims. Contains the claim that you want to identify as the principal in an authorization request, and the values of the aud claim, or audiences, that you want to accept. This data type is part of a [OpenIdConnectTokenSelectionItem](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_OpenIdConnectTokenSelectionItem.html) structure, which is a parameter of [ListIdentitySources](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListIdentitySources.html).
    public struct OpenIdConnectIdentityTokenConfigurationItem: Swift.Sendable {
        /// The ID token audience, or client ID, claim values that you want to accept in your policy store from an OIDC identity provider. For example, 1example23456789, 2example10111213.
        public var clientIds: [Swift.String]?
        /// The claim that determines the principal in OIDC access tokens. For example, sub.
        public var principalIdClaim: Swift.String?

        public init(
            clientIds: [Swift.String]? = nil,
            principalIdClaim: Swift.String? = "sub"
        )
        {
            self.clientIds = clientIds
            self.principalIdClaim = principalIdClaim
        }
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectIdentityTokenConfigurationItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenIdConnectIdentityTokenConfigurationItem(clientIds: \"CONTENT_REDACTED\", principalIdClaim: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The token type that you want to process from your OIDC identity provider. Your policy store can process either identity (ID) or access tokens from a given OIDC identity source. This data type is part of a [OpenIdConnectConfigurationItem](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_OpenIdConnectConfigurationItem.html) structure, which is a parameter of [ListIdentitySources](http://amazonaws.com/verifiedpermissions/latest/apireference/API_ListIdentitySources.html).
    public enum OpenIdConnectTokenSelectionItem: Swift.Sendable {
        /// The OIDC configuration for processing access tokens. Contains allowed audience claims, for example https://auth.example.com, and the claim that you want to map to the principal, for example sub.
        case accesstokenonly(VerifiedPermissionsClientTypes.OpenIdConnectAccessTokenConfigurationItem)
        /// The OIDC configuration for processing identity (ID) tokens. Contains allowed client ID claims, for example 1example23456789, and the claim that you want to map to the principal, for example sub.
        case identitytokenonly(VerifiedPermissionsClientTypes.OpenIdConnectIdentityTokenConfigurationItem)
        case sdkUnknown(Swift.String)
    }
}

extension VerifiedPermissionsClientTypes {

    /// Contains configuration details of an OpenID Connect (OIDC) identity provider, or identity source, that Verified Permissions can use to generate entities from authenticated identities. It specifies the issuer URL, token type that you want to use, and policy store entity details. This data type is part of a [ConfigurationItem](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ConfigurationDetail.html) structure, which is a parameter to [ListIdentitySources](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListIdentitySources.html).
    public struct OpenIdConnectConfigurationItem: Swift.Sendable {
        /// A descriptive string that you want to prefix to user entities from your OIDC identity provider. For example, if you set an entityIdPrefix of MyOIDCProvider, you can reference principals in your policies in the format MyCorp::User::MyOIDCProvider|Carlos.
        public var entityIdPrefix: Swift.String?
        /// The claim in OIDC identity provider tokens that indicates a user's group membership, and the entity type that you want to map it to. For example, this object can map the contents of a groups claim to MyCorp::UserGroup.
        public var groupConfiguration: VerifiedPermissionsClientTypes.OpenIdConnectGroupConfigurationItem?
        /// The issuer URL of an OIDC identity provider. This URL must have an OIDC discovery endpoint at the path .well-known/openid-configuration.
        /// This member is required.
        public var issuer: Swift.String?
        /// The token type that you want to process from your OIDC identity provider. Your policy store can process either identity (ID) or access tokens from a given OIDC identity source.
        /// This member is required.
        public var tokenSelection: VerifiedPermissionsClientTypes.OpenIdConnectTokenSelectionItem?

        public init(
            entityIdPrefix: Swift.String? = nil,
            groupConfiguration: VerifiedPermissionsClientTypes.OpenIdConnectGroupConfigurationItem? = nil,
            issuer: Swift.String? = nil,
            tokenSelection: VerifiedPermissionsClientTypes.OpenIdConnectTokenSelectionItem? = nil
        )
        {
            self.entityIdPrefix = entityIdPrefix
            self.groupConfiguration = groupConfiguration
            self.issuer = issuer
            self.tokenSelection = tokenSelection
        }
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectConfigurationItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OpenIdConnectConfigurationItem(groupConfiguration: \(Swift.String(describing: groupConfiguration)), issuer: \(Swift.String(describing: issuer)), tokenSelection: \(Swift.String(describing: tokenSelection)), entityIdPrefix: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// Contains configuration information about an identity source. This data type is a response parameter to the [ListIdentitySources](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListIdentitySources.html) operation.
    public enum ConfigurationItem: Swift.Sendable {
        /// Contains configuration details of a Amazon Cognito user pool that Verified Permissions can use as a source of authenticated identities as entities. It specifies the [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of a Amazon Cognito user pool, the policy store entity that you want to assign to user groups, and one or more application client IDs. Example: "configuration":{"cognitoUserPoolConfiguration":{"userPoolArn":"arn:aws:cognito-idp:us-east-1:123456789012:userpool/us-east-1_1a2b3c4d5","clientIds": ["a1b2c3d4e5f6g7h8i9j0kalbmc"],"groupConfiguration": {"groupEntityType": "MyCorp::Group"}}}
        case cognitouserpoolconfiguration(VerifiedPermissionsClientTypes.CognitoUserPoolConfigurationItem)
        /// Contains configuration details of an OpenID Connect (OIDC) identity provider, or identity source, that Verified Permissions can use to generate entities from authenticated identities. It specifies the issuer URL, token type that you want to use, and policy store entity details. Example:"configuration":{"openIdConnectConfiguration":{"issuer":"https://auth.example.com","tokenSelection":{"accessTokenOnly":{"audiences":["https://myapp.example.com","https://myapp2.example.com"],"principalIdClaim":"sub"}},"entityIdPrefix":"MyOIDCProvider","groupConfiguration":{"groupClaim":"groups","groupEntityType":"MyCorp::UserGroup"}}}
        case openidconnectconfiguration(VerifiedPermissionsClientTypes.OpenIdConnectConfigurationItem)
        case sdkUnknown(Swift.String)
    }
}

extension VerifiedPermissionsClientTypes {

    /// Contains information about a resource conflict.
    public struct ResourceConflict: Swift.Sendable {
        /// The unique identifier of the resource involved in a conflict.
        /// This member is required.
        public var resourceId: Swift.String?
        /// The type of the resource involved in a conflict.
        /// This member is required.
        public var resourceType: VerifiedPermissionsClientTypes.ResourceType?

        public init(
            resourceId: Swift.String? = nil,
            resourceType: VerifiedPermissionsClientTypes.ResourceType? = nil
        )
        {
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }
}

/// The request failed because another request to modify a resource occurred at the same.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The list of resources referenced with this failed request.
        /// This member is required.
        public internal(set) var resources: [VerifiedPermissionsClientTypes.ResourceConflict]? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resources: [VerifiedPermissionsClientTypes.ResourceConflict]? = nil
    )
    {
        self.properties.message = message
        self.properties.resources = resources
    }
}

/// The request failed because it would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota code recognized by the Amazon Web Services Service Quotas service.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The unique ID of the resource referenced in the failed request.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type of the resource referenced in the failed request.
        /// This member is required.
        public internal(set) var resourceType: VerifiedPermissionsClientTypes.ResourceType? = nil
        /// The code for the Amazon Web Services service that owns the quota.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: VerifiedPermissionsClientTypes.ResourceType? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

public struct CreateIdentitySourceInput: Swift.Sendable {
    /// Specifies a unique, case-sensitive ID that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an ConflictException error. Verified Permissions recognizes a ClientToken for eight hours. After eight hours, the next request with the same parameters performs the operation again regardless of the value of ClientToken.
    public var clientToken: Swift.String?
    /// Specifies the details required to communicate with the identity provider (IdP) associated with this identity source.
    /// This member is required.
    public var configuration: VerifiedPermissionsClientTypes.Configuration?
    /// Specifies the ID of the policy store in which you want to store this identity source. Only policies and requests made using this policy store can reference identities from the identity provider configured in the new identity source.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// Specifies the namespace and data type of the principals generated for identities authenticated by the new identity source.
    public var principalEntityType: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        configuration: VerifiedPermissionsClientTypes.Configuration? = nil,
        policyStoreId: Swift.String? = nil,
        principalEntityType: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.policyStoreId = policyStoreId
        self.principalEntityType = principalEntityType
    }
}

extension CreateIdentitySourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateIdentitySourceInput(clientToken: \(Swift.String(describing: clientToken)), configuration: \(Swift.String(describing: configuration)), policyStoreId: \(Swift.String(describing: policyStoreId)), principalEntityType: \"CONTENT_REDACTED\")"}
}

public struct CreateIdentitySourceOutput: Swift.Sendable {
    /// The date and time the identity source was originally created.
    /// This member is required.
    public var createdDate: Foundation.Date?
    /// The unique ID of the new identity source.
    /// This member is required.
    public var identitySourceId: Swift.String?
    /// The date and time the identity source was most recently updated.
    /// This member is required.
    public var lastUpdatedDate: Foundation.Date?
    /// The ID of the policy store that contains the identity source.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        createdDate: Foundation.Date? = nil,
        identitySourceId: Swift.String? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.identitySourceId = identitySourceId
        self.lastUpdatedDate = lastUpdatedDate
        self.policyStoreId = policyStoreId
    }
}

extension VerifiedPermissionsClientTypes {

    /// Contains information about a static policy. This data type is used as a field that is part of the [PolicyDefinitionDetail](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_PolicyDefinitionDetail.html) type.
    public struct StaticPolicyDefinition: Swift.Sendable {
        /// The description of the static policy.
        public var description: Swift.String?
        /// The policy content of the static policy, written in the Cedar policy language.
        /// This member is required.
        public var statement: Swift.String?

        public init(
            description: Swift.String? = nil,
            statement: Swift.String? = nil
        )
        {
            self.description = description
            self.statement = statement
        }
    }
}

extension VerifiedPermissionsClientTypes.StaticPolicyDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StaticPolicyDefinition(description: \"CONTENT_REDACTED\", statement: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// Contains information about a policy created by instantiating a policy template.
    public struct TemplateLinkedPolicyDefinition: Swift.Sendable {
        /// The unique identifier of the policy template used to create this policy.
        /// This member is required.
        public var policyTemplateId: Swift.String?
        /// The principal associated with this template-linked policy. Verified Permissions substitutes this principal for the ?principal placeholder in the policy template when it evaluates an authorization request.
        public var principal: VerifiedPermissionsClientTypes.EntityIdentifier?
        /// The resource associated with this template-linked policy. Verified Permissions substitutes this resource for the ?resource placeholder in the policy template when it evaluates an authorization request.
        public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

        public init(
            policyTemplateId: Swift.String? = nil,
            principal: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
            resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
        )
        {
            self.policyTemplateId = policyTemplateId
            self.principal = principal
            self.resource = resource
        }
    }
}

extension VerifiedPermissionsClientTypes {

    /// A structure that contains the details for a Cedar policy definition. It includes the policy type, a description, and a policy body. This is a top level data type used to create a policy. This data type is used as a request parameter for the [CreatePolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreatePolicy.html) operation. This structure must always have either an static or a templateLinked element.
    public enum PolicyDefinition: Swift.Sendable {
        /// A structure that describes a static policy. An static policy doesn't use a template or allow placeholders for entities.
        case `static`(VerifiedPermissionsClientTypes.StaticPolicyDefinition)
        /// A structure that describes a policy that was instantiated from a template. The template can specify placeholders for principal and resource. When you use [CreatePolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreatePolicy.html) to create a policy from a template, you specify the exact principal and resource to use for the instantiated policy.
        case templatelinked(VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinition)
        case sdkUnknown(Swift.String)
    }
}

public struct CreatePolicyInput: Swift.Sendable {
    /// Specifies a unique, case-sensitive ID that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an ConflictException error. Verified Permissions recognizes a ClientToken for eight hours. After eight hours, the next request with the same parameters performs the operation again regardless of the value of ClientToken.
    public var clientToken: Swift.String?
    /// A structure that specifies the policy type and content to use for the new policy. You must include either a static or a templateLinked element. The policy content must be written in the Cedar policy language.
    /// This member is required.
    public var definition: VerifiedPermissionsClientTypes.PolicyDefinition?
    /// Specifies the PolicyStoreId of the policy store you want to store the policy in.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        definition: VerifiedPermissionsClientTypes.PolicyDefinition? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.definition = definition
        self.policyStoreId = policyStoreId
    }
}

extension VerifiedPermissionsClientTypes {

    public enum PolicyEffect: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case forbid
        case permit
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyEffect] {
            return [
                .forbid,
                .permit
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .forbid: return "Forbid"
            case .permit: return "Permit"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VerifiedPermissionsClientTypes {

    public enum PolicyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `static`
        case templateLinked
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyType] {
            return [
                .static,
                .templateLinked
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .static: return "STATIC"
            case .templateLinked: return "TEMPLATE_LINKED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreatePolicyOutput: Swift.Sendable {
    /// The action that a policy permits or forbids. For example, {"actions": [{"actionId": "ViewPhoto", "actionType": "PhotoFlash::Action"}, {"entityID": "SharePhoto", "entityType": "PhotoFlash::Action"}]}.
    public var actions: [VerifiedPermissionsClientTypes.ActionIdentifier]?
    /// The date and time the policy was originally created.
    /// This member is required.
    public var createdDate: Foundation.Date?
    /// The effect of the decision that a policy returns to an authorization request. For example, "effect": "Permit".
    public var effect: VerifiedPermissionsClientTypes.PolicyEffect?
    /// The date and time the policy was last updated.
    /// This member is required.
    public var lastUpdatedDate: Foundation.Date?
    /// The unique ID of the new policy.
    /// This member is required.
    public var policyId: Swift.String?
    /// The ID of the policy store that contains the new policy.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// The policy type of the new policy.
    /// This member is required.
    public var policyType: VerifiedPermissionsClientTypes.PolicyType?
    /// The principal specified in the new policy's scope. This response element isn't present when principal isn't specified in the policy content.
    public var principal: VerifiedPermissionsClientTypes.EntityIdentifier?
    /// The resource specified in the new policy's scope. This response element isn't present when the resource isn't specified in the policy content.
    public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

    public init(
        actions: [VerifiedPermissionsClientTypes.ActionIdentifier]? = nil,
        createdDate: Foundation.Date? = nil,
        effect: VerifiedPermissionsClientTypes.PolicyEffect? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        policyId: Swift.String? = nil,
        policyStoreId: Swift.String? = nil,
        policyType: VerifiedPermissionsClientTypes.PolicyType? = nil,
        principal: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
        resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
    )
    {
        self.actions = actions
        self.createdDate = createdDate
        self.effect = effect
        self.lastUpdatedDate = lastUpdatedDate
        self.policyId = policyId
        self.policyStoreId = policyStoreId
        self.policyType = policyType
        self.principal = principal
        self.resource = resource
    }
}

extension VerifiedPermissionsClientTypes {

    public enum ValidationMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case off
        case strict
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationMode] {
            return [
                .off,
                .strict
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .strict: return "STRICT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VerifiedPermissionsClientTypes {

    /// A structure that contains Cedar policy validation settings for the policy store. The validation mode determines which validation failures that Cedar considers serious enough to block acceptance of a new or edited static policy or policy template. This data type is used as a request parameter in the [CreatePolicyStore](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreatePolicyStore.html) and [UpdatePolicyStore](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdatePolicyStore.html) operations.
    public struct ValidationSettings: Swift.Sendable {
        /// The validation mode currently configured for this policy store. The valid values are:
        ///
        /// * OFF  Neither Verified Permissions nor Cedar perform any validation on policies. No validation errors are reported by either service.
        ///
        /// * STRICT  Requires a schema to be present in the policy store. Cedar performs validation on all submitted new or updated static policies and policy templates. Any that fail validation are rejected and Cedar doesn't store them in the policy store.
        ///
        ///
        /// If Mode=STRICT and the policy store doesn't contain a schema, Verified Permissions rejects all static policies and policy templates because there is no schema to validate against. To submit a static policy or policy template without a schema, you must turn off validation.
        /// This member is required.
        public var mode: VerifiedPermissionsClientTypes.ValidationMode?

        public init(
            mode: VerifiedPermissionsClientTypes.ValidationMode? = nil
        )
        {
            self.mode = mode
        }
    }
}

public struct CreatePolicyStoreInput: Swift.Sendable {
    /// Specifies a unique, case-sensitive ID that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an ConflictException error. Verified Permissions recognizes a ClientToken for eight hours. After eight hours, the next request with the same parameters performs the operation again regardless of the value of ClientToken.
    public var clientToken: Swift.String?
    /// Descriptive text that you can provide to help with identification of the current policy store.
    public var description: Swift.String?
    /// Specifies the validation setting for this policy store. Currently, the only valid and required value is Mode. We recommend that you turn on STRICT mode only after you define a schema. If a schema doesn't exist, then STRICT mode causes any policy to fail validation, and Verified Permissions rejects the policy. You can turn off validation by using the [UpdatePolicyStore](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdatePolicyStore). Then, when you have a schema defined, use [UpdatePolicyStore](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdatePolicyStore) again to turn validation back on.
    /// This member is required.
    public var validationSettings: VerifiedPermissionsClientTypes.ValidationSettings?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        validationSettings: VerifiedPermissionsClientTypes.ValidationSettings? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.validationSettings = validationSettings
    }
}

extension CreatePolicyStoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePolicyStoreInput(clientToken: \(Swift.String(describing: clientToken)), validationSettings: \(Swift.String(describing: validationSettings)), description: \"CONTENT_REDACTED\")"}
}

public struct CreatePolicyStoreOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the new policy store.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time the policy store was originally created.
    /// This member is required.
    public var createdDate: Foundation.Date?
    /// The date and time the policy store was last updated.
    /// This member is required.
    public var lastUpdatedDate: Foundation.Date?
    /// The unique ID of the new policy store.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdDate = createdDate
        self.lastUpdatedDate = lastUpdatedDate
        self.policyStoreId = policyStoreId
    }
}

public struct CreatePolicyTemplateInput: Swift.Sendable {
    /// Specifies a unique, case-sensitive ID that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an ConflictException error. Verified Permissions recognizes a ClientToken for eight hours. After eight hours, the next request with the same parameters performs the operation again regardless of the value of ClientToken.
    public var clientToken: Swift.String?
    /// Specifies a description for the policy template.
    public var description: Swift.String?
    /// The ID of the policy store in which to create the policy template.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// Specifies the content that you want to use for the new policy template, written in the Cedar policy language.
    /// This member is required.
    public var statement: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        policyStoreId: Swift.String? = nil,
        statement: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.policyStoreId = policyStoreId
        self.statement = statement
    }
}

extension CreatePolicyTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePolicyTemplateInput(clientToken: \(Swift.String(describing: clientToken)), policyStoreId: \(Swift.String(describing: policyStoreId)), description: \"CONTENT_REDACTED\", statement: \"CONTENT_REDACTED\")"}
}

public struct CreatePolicyTemplateOutput: Swift.Sendable {
    /// The date and time the policy template was originally created.
    /// This member is required.
    public var createdDate: Foundation.Date?
    /// The date and time the policy template was most recently updated.
    /// This member is required.
    public var lastUpdatedDate: Foundation.Date?
    /// The ID of the policy store that contains the policy template.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// The unique ID of the new policy template.
    /// This member is required.
    public var policyTemplateId: Swift.String?

    public init(
        createdDate: Foundation.Date? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        policyStoreId: Swift.String? = nil,
        policyTemplateId: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.lastUpdatedDate = lastUpdatedDate
        self.policyStoreId = policyStoreId
        self.policyTemplateId = policyTemplateId
    }
}

public struct DeleteIdentitySourceInput: Swift.Sendable {
    /// Specifies the ID of the identity source that you want to delete.
    /// This member is required.
    public var identitySourceId: Swift.String?
    /// Specifies the ID of the policy store that contains the identity source that you want to delete.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        identitySourceId: Swift.String? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.identitySourceId = identitySourceId
        self.policyStoreId = policyStoreId
    }
}

public struct DeleteIdentitySourceOutput: Swift.Sendable {

    public init() { }
}

public struct DeletePolicyInput: Swift.Sendable {
    /// Specifies the ID of the policy that you want to delete.
    /// This member is required.
    public var policyId: Swift.String?
    /// Specifies the ID of the policy store that contains the policy that you want to delete.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        policyId: Swift.String? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.policyId = policyId
        self.policyStoreId = policyStoreId
    }
}

public struct DeletePolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeletePolicyStoreInput: Swift.Sendable {
    /// Specifies the ID of the policy store that you want to delete.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        policyStoreId: Swift.String? = nil
    )
    {
        self.policyStoreId = policyStoreId
    }
}

public struct DeletePolicyStoreOutput: Swift.Sendable {

    public init() { }
}

public struct DeletePolicyTemplateInput: Swift.Sendable {
    /// Specifies the ID of the policy store that contains the policy template that you want to delete.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// Specifies the ID of the policy template that you want to delete.
    /// This member is required.
    public var policyTemplateId: Swift.String?

    public init(
        policyStoreId: Swift.String? = nil,
        policyTemplateId: Swift.String? = nil
    )
    {
        self.policyStoreId = policyStoreId
        self.policyTemplateId = policyTemplateId
    }
}

public struct DeletePolicyTemplateOutput: Swift.Sendable {

    public init() { }
}

extension VerifiedPermissionsClientTypes {

    /// Contains information about a principal or resource that can be referenced in a Cedar policy. This data type is used as part of the [PolicyFilter](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_PolicyFilter.html) structure that is used as a request parameter for the [ListPolicies](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListPolicies.html) operation..
    public enum EntityReference: Swift.Sendable {
        /// Used to indicate that a principal or resource is not specified. This can be used to search for policies that are not associated with a specific principal or resource.
        case unspecified(Swift.Bool)
        /// The identifier of the entity. It can consist of either an EntityType and EntityId, a principal, or a resource.
        case identifier(VerifiedPermissionsClientTypes.EntityIdentifier)
        case sdkUnknown(Swift.String)
    }
}

public struct GetIdentitySourceInput: Swift.Sendable {
    /// Specifies the ID of the identity source you want information about.
    /// This member is required.
    public var identitySourceId: Swift.String?
    /// Specifies the ID of the policy store that contains the identity source you want information about.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        identitySourceId: Swift.String? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.identitySourceId = identitySourceId
        self.policyStoreId = policyStoreId
    }
}

extension VerifiedPermissionsClientTypes {

    public enum OpenIdIssuer: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cognito
        case sdkUnknown(Swift.String)

        public static var allCases: [OpenIdIssuer] {
            return [
                .cognito
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cognito: return "COGNITO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VerifiedPermissionsClientTypes {

    /// A structure that contains configuration of the identity source. This data type was a response parameter for the [GetIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_GetIdentitySource.html) operation. Replaced by [ConfigurationDetail](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ConfigurationDetail.html).
    @available(*, deprecated, message: "This shape has been replaced by ConfigurationDetail")
    public struct IdentitySourceDetails: Swift.Sendable {
        /// The application client IDs associated with the specified Amazon Cognito user pool that are enabled for this identity source.
        @available(*, deprecated, message: "This attribute has been replaced by configuration.cognitoUserPoolConfiguration.clientIds")
        public var clientIds: [Swift.String]?
        /// The well-known URL that points to this user pool's OIDC discovery endpoint. This is a URL string in the following format. This URL replaces the placeholders for both the Amazon Web Services Region and the user pool identifier with those appropriate for this user pool. https://cognito-idp.<region>.amazonaws.com/<user-pool-id>/.well-known/openid-configuration
        @available(*, deprecated, message: "This attribute has been replaced by configuration.cognitoUserPoolConfiguration.issuer")
        public var discoveryUrl: Swift.String?
        /// A string that identifies the type of OIDC service represented by this identity source. At this time, the only valid value is cognito.
        @available(*, deprecated, message: "This attribute has been replaced by configuration")
        public var openIdIssuer: VerifiedPermissionsClientTypes.OpenIdIssuer?
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Amazon Cognito user pool whose identities are accessible to this Verified Permissions policy store.
        @available(*, deprecated, message: "This attribute has been replaced by configuration.cognitoUserPoolConfiguration.userPoolArn")
        public var userPoolArn: Swift.String?

        public init(
            clientIds: [Swift.String]? = nil,
            discoveryUrl: Swift.String? = nil,
            openIdIssuer: VerifiedPermissionsClientTypes.OpenIdIssuer? = nil,
            userPoolArn: Swift.String? = nil
        )
        {
            self.clientIds = clientIds
            self.discoveryUrl = discoveryUrl
            self.openIdIssuer = openIdIssuer
            self.userPoolArn = userPoolArn
        }
    }
}

extension VerifiedPermissionsClientTypes.IdentitySourceDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentitySourceDetails(discoveryUrl: \(Swift.String(describing: discoveryUrl)), openIdIssuer: \(Swift.String(describing: openIdIssuer)), userPoolArn: \(Swift.String(describing: userPoolArn)), clientIds: \"CONTENT_REDACTED\")"}
}

public struct GetIdentitySourceOutput: Swift.Sendable {
    /// Contains configuration information about an identity source.
    public var configuration: VerifiedPermissionsClientTypes.ConfigurationDetail?
    /// The date and time that the identity source was originally created.
    /// This member is required.
    public var createdDate: Foundation.Date?
    /// A structure that describes the configuration of the identity source.
    @available(*, deprecated, message: "This attribute has been replaced by configuration.cognitoUserPoolConfiguration")
    public var details: VerifiedPermissionsClientTypes.IdentitySourceDetails?
    /// The ID of the identity source.
    /// This member is required.
    public var identitySourceId: Swift.String?
    /// The date and time that the identity source was most recently updated.
    /// This member is required.
    public var lastUpdatedDate: Foundation.Date?
    /// The ID of the policy store that contains the identity source.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// The data type of principals generated for identities authenticated by this identity source.
    /// This member is required.
    public var principalEntityType: Swift.String?

    public init(
        configuration: VerifiedPermissionsClientTypes.ConfigurationDetail? = nil,
        createdDate: Foundation.Date? = nil,
        details: VerifiedPermissionsClientTypes.IdentitySourceDetails? = nil,
        identitySourceId: Swift.String? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        policyStoreId: Swift.String? = nil,
        principalEntityType: Swift.String? = nil
    )
    {
        self.configuration = configuration
        self.createdDate = createdDate
        self.details = details
        self.identitySourceId = identitySourceId
        self.lastUpdatedDate = lastUpdatedDate
        self.policyStoreId = policyStoreId
        self.principalEntityType = principalEntityType
    }
}

extension GetIdentitySourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetIdentitySourceOutput(configuration: \(Swift.String(describing: configuration)), createdDate: \(Swift.String(describing: createdDate)), details: \(Swift.String(describing: details)), identitySourceId: \(Swift.String(describing: identitySourceId)), lastUpdatedDate: \(Swift.String(describing: lastUpdatedDate)), policyStoreId: \(Swift.String(describing: policyStoreId)), principalEntityType: \"CONTENT_REDACTED\")"}
}

public struct GetPolicyInput: Swift.Sendable {
    /// Specifies the ID of the policy you want information about.
    /// This member is required.
    public var policyId: Swift.String?
    /// Specifies the ID of the policy store that contains the policy that you want information about.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        policyId: Swift.String? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.policyId = policyId
        self.policyStoreId = policyStoreId
    }
}

extension VerifiedPermissionsClientTypes {

    /// A structure that contains details about a static policy. It includes the description and policy body. This data type is used within a [PolicyDefinition](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_PolicyDefinition.html) structure as part of a request parameter for the [CreatePolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreatePolicy.html) operation.
    public struct StaticPolicyDefinitionDetail: Swift.Sendable {
        /// A description of the static policy.
        public var description: Swift.String?
        /// The content of the static policy written in the Cedar policy language.
        /// This member is required.
        public var statement: Swift.String?

        public init(
            description: Swift.String? = nil,
            statement: Swift.String? = nil
        )
        {
            self.description = description
            self.statement = statement
        }
    }
}

extension VerifiedPermissionsClientTypes.StaticPolicyDefinitionDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StaticPolicyDefinitionDetail(description: \"CONTENT_REDACTED\", statement: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// Contains information about a policy that was created by instantiating a policy template.
    public struct TemplateLinkedPolicyDefinitionDetail: Swift.Sendable {
        /// The unique identifier of the policy template used to create this policy.
        /// This member is required.
        public var policyTemplateId: Swift.String?
        /// The principal associated with this template-linked policy. Verified Permissions substitutes this principal for the ?principal placeholder in the policy template when it evaluates an authorization request.
        public var principal: VerifiedPermissionsClientTypes.EntityIdentifier?
        /// The resource associated with this template-linked policy. Verified Permissions substitutes this resource for the ?resource placeholder in the policy template when it evaluates an authorization request.
        public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

        public init(
            policyTemplateId: Swift.String? = nil,
            principal: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
            resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
        )
        {
            self.policyTemplateId = policyTemplateId
            self.principal = principal
            self.resource = resource
        }
    }
}

extension VerifiedPermissionsClientTypes {

    /// A structure that describes a policy definition. It must always have either an static or a templateLinked element. This data type is used as a response parameter for the [GetPolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_GetPolicy.html) operation.
    public enum PolicyDefinitionDetail: Swift.Sendable {
        /// Information about a static policy that wasn't created with a policy template.
        case `static`(VerifiedPermissionsClientTypes.StaticPolicyDefinitionDetail)
        /// Information about a template-linked policy that was created by instantiating a policy template.
        case templatelinked(VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinitionDetail)
        case sdkUnknown(Swift.String)
    }
}

public struct GetPolicyOutput: Swift.Sendable {
    /// The action that a policy permits or forbids. For example, {"actions": [{"actionId": "ViewPhoto", "actionType": "PhotoFlash::Action"}, {"entityID": "SharePhoto", "entityType": "PhotoFlash::Action"}]}.
    public var actions: [VerifiedPermissionsClientTypes.ActionIdentifier]?
    /// The date and time that the policy was originally created.
    /// This member is required.
    public var createdDate: Foundation.Date?
    /// The definition of the requested policy.
    /// This member is required.
    public var definition: VerifiedPermissionsClientTypes.PolicyDefinitionDetail?
    /// The effect of the decision that a policy returns to an authorization request. For example, "effect": "Permit".
    public var effect: VerifiedPermissionsClientTypes.PolicyEffect?
    /// The date and time that the policy was last updated.
    /// This member is required.
    public var lastUpdatedDate: Foundation.Date?
    /// The unique ID of the policy that you want information about.
    /// This member is required.
    public var policyId: Swift.String?
    /// The ID of the policy store that contains the policy that you want information about.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// The type of the policy.
    /// This member is required.
    public var policyType: VerifiedPermissionsClientTypes.PolicyType?
    /// The principal specified in the policy's scope. This element isn't included in the response when Principal isn't present in the policy content.
    public var principal: VerifiedPermissionsClientTypes.EntityIdentifier?
    /// The resource specified in the policy's scope. This element isn't included in the response when Resource isn't present in the policy content.
    public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

    public init(
        actions: [VerifiedPermissionsClientTypes.ActionIdentifier]? = nil,
        createdDate: Foundation.Date? = nil,
        definition: VerifiedPermissionsClientTypes.PolicyDefinitionDetail? = nil,
        effect: VerifiedPermissionsClientTypes.PolicyEffect? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        policyId: Swift.String? = nil,
        policyStoreId: Swift.String? = nil,
        policyType: VerifiedPermissionsClientTypes.PolicyType? = nil,
        principal: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
        resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
    )
    {
        self.actions = actions
        self.createdDate = createdDate
        self.definition = definition
        self.effect = effect
        self.lastUpdatedDate = lastUpdatedDate
        self.policyId = policyId
        self.policyStoreId = policyStoreId
        self.policyType = policyType
        self.principal = principal
        self.resource = resource
    }
}

public struct GetPolicyStoreInput: Swift.Sendable {
    /// Specifies the ID of the policy store that you want information about.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        policyStoreId: Swift.String? = nil
    )
    {
        self.policyStoreId = policyStoreId
    }
}

public struct GetPolicyStoreOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the policy store.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time that the policy store was originally created.
    /// This member is required.
    public var createdDate: Foundation.Date?
    /// Descriptive text that you can provide to help with identification of the current policy store.
    public var description: Swift.String?
    /// The date and time that the policy store was last updated.
    /// This member is required.
    public var lastUpdatedDate: Foundation.Date?
    /// The ID of the policy store;
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// The current validation settings for the policy store.
    /// This member is required.
    public var validationSettings: VerifiedPermissionsClientTypes.ValidationSettings?

    public init(
        arn: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        policyStoreId: Swift.String? = nil,
        validationSettings: VerifiedPermissionsClientTypes.ValidationSettings? = nil
    )
    {
        self.arn = arn
        self.createdDate = createdDate
        self.description = description
        self.lastUpdatedDate = lastUpdatedDate
        self.policyStoreId = policyStoreId
        self.validationSettings = validationSettings
    }
}

extension GetPolicyStoreOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPolicyStoreOutput(arn: \(Swift.String(describing: arn)), createdDate: \(Swift.String(describing: createdDate)), lastUpdatedDate: \(Swift.String(describing: lastUpdatedDate)), policyStoreId: \(Swift.String(describing: policyStoreId)), validationSettings: \(Swift.String(describing: validationSettings)), description: \"CONTENT_REDACTED\")"}
}

public struct GetPolicyTemplateInput: Swift.Sendable {
    /// Specifies the ID of the policy store that contains the policy template that you want information about.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// Specifies the ID of the policy template that you want information about.
    /// This member is required.
    public var policyTemplateId: Swift.String?

    public init(
        policyStoreId: Swift.String? = nil,
        policyTemplateId: Swift.String? = nil
    )
    {
        self.policyStoreId = policyStoreId
        self.policyTemplateId = policyTemplateId
    }
}

public struct GetPolicyTemplateOutput: Swift.Sendable {
    /// The date and time that the policy template was originally created.
    /// This member is required.
    public var createdDate: Foundation.Date?
    /// The description of the policy template.
    public var description: Swift.String?
    /// The date and time that the policy template was most recently updated.
    /// This member is required.
    public var lastUpdatedDate: Foundation.Date?
    /// The ID of the policy store that contains the policy template.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// The ID of the policy template.
    /// This member is required.
    public var policyTemplateId: Swift.String?
    /// The content of the body of the policy template written in the Cedar policy language.
    /// This member is required.
    public var statement: Swift.String?

    public init(
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        policyStoreId: Swift.String? = nil,
        policyTemplateId: Swift.String? = nil,
        statement: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.description = description
        self.lastUpdatedDate = lastUpdatedDate
        self.policyStoreId = policyStoreId
        self.policyTemplateId = policyTemplateId
        self.statement = statement
    }
}

extension GetPolicyTemplateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPolicyTemplateOutput(createdDate: \(Swift.String(describing: createdDate)), lastUpdatedDate: \(Swift.String(describing: lastUpdatedDate)), policyStoreId: \(Swift.String(describing: policyStoreId)), policyTemplateId: \(Swift.String(describing: policyTemplateId)), description: \"CONTENT_REDACTED\", statement: \"CONTENT_REDACTED\")"}
}

public struct GetSchemaInput: Swift.Sendable {
    /// Specifies the ID of the policy store that contains the schema.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        policyStoreId: Swift.String? = nil
    )
    {
        self.policyStoreId = policyStoreId
    }
}

public struct GetSchemaOutput: Swift.Sendable {
    /// The date and time that the schema was originally created.
    /// This member is required.
    public var createdDate: Foundation.Date?
    /// The date and time that the schema was most recently updated.
    /// This member is required.
    public var lastUpdatedDate: Foundation.Date?
    /// The namespaces of the entities referenced by this schema.
    public var namespaces: [Swift.String]?
    /// The ID of the policy store that contains the schema.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// The body of the schema, written in Cedar schema JSON.
    /// This member is required.
    public var schema: Swift.String?

    public init(
        createdDate: Foundation.Date? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        namespaces: [Swift.String]? = nil,
        policyStoreId: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.lastUpdatedDate = lastUpdatedDate
        self.namespaces = namespaces
        self.policyStoreId = policyStoreId
        self.schema = schema
    }
}

extension GetSchemaOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSchemaOutput(createdDate: \(Swift.String(describing: createdDate)), lastUpdatedDate: \(Swift.String(describing: lastUpdatedDate)), policyStoreId: \(Swift.String(describing: policyStoreId)), namespaces: \"CONTENT_REDACTED\", schema: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// A structure that defines characteristics of an identity source that you can use to filter. This data type is a request parameter for the [ListIdentityStores](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListIdentityStores.html) operation.
    public struct IdentitySourceFilter: Swift.Sendable {
        /// The Cedar entity type of the principals returned by the identity provider (IdP) associated with this identity source.
        public var principalEntityType: Swift.String?

        public init(
            principalEntityType: Swift.String? = nil
        )
        {
            self.principalEntityType = principalEntityType
        }
    }
}

extension VerifiedPermissionsClientTypes.IdentitySourceFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentitySourceFilter(principalEntityType: \"CONTENT_REDACTED\")"}
}

public struct ListIdentitySourcesInput: Swift.Sendable {
    /// Specifies characteristics of an identity source that you can use to limit the output to matching identity sources.
    public var filters: [VerifiedPermissionsClientTypes.IdentitySourceFilter]?
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results. If you do not specify this parameter, the operation defaults to 10 identity sources per response. You can specify a maximum of 50 identity sources per response.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the ID of the policy store that contains the identity sources that you want to list.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        filters: [VerifiedPermissionsClientTypes.IdentitySourceFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyStoreId = policyStoreId
    }
}

extension VerifiedPermissionsClientTypes {

    /// A structure that contains configuration of the identity source. This data type was a response parameter for the [ListIdentitySources](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListIdentitySources.html) operation. Replaced by [ConfigurationItem](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ConfigurationItem.html).
    @available(*, deprecated, message: "This shape has been replaced by ConfigurationItem")
    public struct IdentitySourceItemDetails: Swift.Sendable {
        /// The application client IDs associated with the specified Amazon Cognito user pool that are enabled for this identity source.
        @available(*, deprecated, message: "This attribute has been replaced by configuration.cognitoUserPoolConfiguration.clientIds")
        public var clientIds: [Swift.String]?
        /// The well-known URL that points to this user pool's OIDC discovery endpoint. This is a URL string in the following format. This URL replaces the placeholders for both the Amazon Web Services Region and the user pool identifier with those appropriate for this user pool. https://cognito-idp.<region>.amazonaws.com/<user-pool-id>/.well-known/openid-configuration
        @available(*, deprecated, message: "This attribute has been replaced by configuration.cognitoUserPoolConfiguration.issuer")
        public var discoveryUrl: Swift.String?
        /// A string that identifies the type of OIDC service represented by this identity source. At this time, the only valid value is cognito.
        @available(*, deprecated, message: "This attribute has been replaced by configuration")
        public var openIdIssuer: VerifiedPermissionsClientTypes.OpenIdIssuer?
        /// The Amazon Cognito user pool whose identities are accessible to this Verified Permissions policy store.
        @available(*, deprecated, message: "This attribute has been replaced by configuration.cognitoUserPoolConfiguration.userPoolArn")
        public var userPoolArn: Swift.String?

        public init(
            clientIds: [Swift.String]? = nil,
            discoveryUrl: Swift.String? = nil,
            openIdIssuer: VerifiedPermissionsClientTypes.OpenIdIssuer? = nil,
            userPoolArn: Swift.String? = nil
        )
        {
            self.clientIds = clientIds
            self.discoveryUrl = discoveryUrl
            self.openIdIssuer = openIdIssuer
            self.userPoolArn = userPoolArn
        }
    }
}

extension VerifiedPermissionsClientTypes.IdentitySourceItemDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentitySourceItemDetails(discoveryUrl: \(Swift.String(describing: discoveryUrl)), openIdIssuer: \(Swift.String(describing: openIdIssuer)), userPoolArn: \(Swift.String(describing: userPoolArn)), clientIds: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// A structure that defines an identity source. This data type is a response parameter to the [ListIdentitySources](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListIdentitySources.html) operation.
    public struct IdentitySourceItem: Swift.Sendable {
        /// Contains configuration information about an identity source.
        public var configuration: VerifiedPermissionsClientTypes.ConfigurationItem?
        /// The date and time the identity source was originally created.
        /// This member is required.
        public var createdDate: Foundation.Date?
        /// A structure that contains the details of the associated identity provider (IdP).
        @available(*, deprecated, message: "This attribute has been replaced by configuration.cognitoUserPoolConfiguration")
        public var details: VerifiedPermissionsClientTypes.IdentitySourceItemDetails?
        /// The unique identifier of the identity source.
        /// This member is required.
        public var identitySourceId: Swift.String?
        /// The date and time the identity source was most recently updated.
        /// This member is required.
        public var lastUpdatedDate: Foundation.Date?
        /// The identifier of the policy store that contains the identity source.
        /// This member is required.
        public var policyStoreId: Swift.String?
        /// The Cedar entity type of the principals returned from the IdP associated with this identity source.
        /// This member is required.
        public var principalEntityType: Swift.String?

        public init(
            configuration: VerifiedPermissionsClientTypes.ConfigurationItem? = nil,
            createdDate: Foundation.Date? = nil,
            details: VerifiedPermissionsClientTypes.IdentitySourceItemDetails? = nil,
            identitySourceId: Swift.String? = nil,
            lastUpdatedDate: Foundation.Date? = nil,
            policyStoreId: Swift.String? = nil,
            principalEntityType: Swift.String? = nil
        )
        {
            self.configuration = configuration
            self.createdDate = createdDate
            self.details = details
            self.identitySourceId = identitySourceId
            self.lastUpdatedDate = lastUpdatedDate
            self.policyStoreId = policyStoreId
            self.principalEntityType = principalEntityType
        }
    }
}

extension VerifiedPermissionsClientTypes.IdentitySourceItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdentitySourceItem(configuration: \(Swift.String(describing: configuration)), createdDate: \(Swift.String(describing: createdDate)), details: \(Swift.String(describing: details)), identitySourceId: \(Swift.String(describing: identitySourceId)), lastUpdatedDate: \(Swift.String(describing: lastUpdatedDate)), policyStoreId: \(Swift.String(describing: policyStoreId)), principalEntityType: \"CONTENT_REDACTED\")"}
}

public struct ListIdentitySourcesOutput: Swift.Sendable {
    /// The list of identity sources stored in the specified policy store.
    /// This member is required.
    public var identitySources: [VerifiedPermissionsClientTypes.IdentitySourceItem]?
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?

    public init(
        identitySources: [VerifiedPermissionsClientTypes.IdentitySourceItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.identitySources = identitySources
        self.nextToken = nextToken
    }
}

extension VerifiedPermissionsClientTypes {

    /// The user group entities from an Amazon Cognito user pool identity source.
    public struct UpdateCognitoGroupConfiguration: Swift.Sendable {
        /// The name of the schema entity type that's mapped to the user pool group. Defaults to AWS::CognitoGroup.
        /// This member is required.
        public var groupEntityType: Swift.String?

        public init(
            groupEntityType: Swift.String? = nil
        )
        {
            self.groupEntityType = groupEntityType
        }
    }
}

extension VerifiedPermissionsClientTypes.UpdateCognitoGroupConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCognitoGroupConfiguration(groupEntityType: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// Contains configuration details of a Amazon Cognito user pool for use with an identity source.
    public struct UpdateCognitoUserPoolConfiguration: Swift.Sendable {
        /// The client ID of an app client that is configured for the specified Amazon Cognito user pool.
        public var clientIds: [Swift.String]?
        /// The configuration of the user groups from an Amazon Cognito user pool identity source.
        public var groupConfiguration: VerifiedPermissionsClientTypes.UpdateCognitoGroupConfiguration?
        /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Amazon Cognito user pool associated with this identity source.
        /// This member is required.
        public var userPoolArn: Swift.String?

        public init(
            clientIds: [Swift.String]? = nil,
            groupConfiguration: VerifiedPermissionsClientTypes.UpdateCognitoGroupConfiguration? = nil,
            userPoolArn: Swift.String? = nil
        )
        {
            self.clientIds = clientIds
            self.groupConfiguration = groupConfiguration
            self.userPoolArn = userPoolArn
        }
    }
}

extension VerifiedPermissionsClientTypes.UpdateCognitoUserPoolConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCognitoUserPoolConfiguration(groupConfiguration: \(Swift.String(describing: groupConfiguration)), userPoolArn: \(Swift.String(describing: userPoolArn)), clientIds: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The claim in OIDC identity provider tokens that indicates a user's group membership, and the entity type that you want to map it to. For example, this object can map the contents of a groups claim to MyCorp::UserGroup. This data type is part of a [UpdateOpenIdConnectConfiguration](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdateOpenIdConnectConfiguration.html) structure, which is a parameter to [UpdateIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdateIdentitySource.html).
    public struct UpdateOpenIdConnectGroupConfiguration: Swift.Sendable {
        /// The token claim that you want Verified Permissions to interpret as group membership. For example, groups.
        /// This member is required.
        public var groupClaim: Swift.String?
        /// The policy store entity type that you want to map your users' group claim to. For example, MyCorp::UserGroup. A group entity type is an entity that can have a user entity type as a member.
        /// This member is required.
        public var groupEntityType: Swift.String?

        public init(
            groupClaim: Swift.String? = nil,
            groupEntityType: Swift.String? = nil
        )
        {
            self.groupClaim = groupClaim
            self.groupEntityType = groupEntityType
        }
    }
}

extension VerifiedPermissionsClientTypes.UpdateOpenIdConnectGroupConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateOpenIdConnectGroupConfiguration(groupClaim: \"CONTENT_REDACTED\", groupEntityType: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The configuration of an OpenID Connect (OIDC) identity source for handling access token claims. Contains the claim that you want to identify as the principal in an authorization request, and the values of the aud claim, or audiences, that you want to accept. This data type is part of a [UpdateOpenIdConnectTokenSelection](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdateOpenIdConnectTokenSelection.html) structure, which is a parameter to [UpdateIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdateIdentitySource.html).
    public struct UpdateOpenIdConnectAccessTokenConfiguration: Swift.Sendable {
        /// The access token aud claim values that you want to accept in your policy store. For example, https://myapp.example.com, https://myapp2.example.com.
        public var audiences: [Swift.String]?
        /// The claim that determines the principal in OIDC access tokens. For example, sub.
        public var principalIdClaim: Swift.String?

        public init(
            audiences: [Swift.String]? = nil,
            principalIdClaim: Swift.String? = "sub"
        )
        {
            self.audiences = audiences
            self.principalIdClaim = principalIdClaim
        }
    }
}

extension VerifiedPermissionsClientTypes.UpdateOpenIdConnectAccessTokenConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateOpenIdConnectAccessTokenConfiguration(audiences: \(Swift.String(describing: audiences)), principalIdClaim: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The configuration of an OpenID Connect (OIDC) identity source for handling identity (ID) token claims. Contains the claim that you want to identify as the principal in an authorization request, and the values of the aud claim, or audiences, that you want to accept. This data type is part of a [UpdateOpenIdConnectTokenSelection](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdateOpenIdConnectTokenSelection.html) structure, which is a parameter to [UpdateIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdateIdentitySource.html).
    public struct UpdateOpenIdConnectIdentityTokenConfiguration: Swift.Sendable {
        /// The ID token audience, or client ID, claim values that you want to accept in your policy store from an OIDC identity provider. For example, 1example23456789, 2example10111213.
        public var clientIds: [Swift.String]?
        /// The claim that determines the principal in OIDC access tokens. For example, sub.
        public var principalIdClaim: Swift.String?

        public init(
            clientIds: [Swift.String]? = nil,
            principalIdClaim: Swift.String? = "sub"
        )
        {
            self.clientIds = clientIds
            self.principalIdClaim = principalIdClaim
        }
    }
}

extension VerifiedPermissionsClientTypes.UpdateOpenIdConnectIdentityTokenConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateOpenIdConnectIdentityTokenConfiguration(clientIds: \"CONTENT_REDACTED\", principalIdClaim: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The token type that you want to process from your OIDC identity provider. Your policy store can process either identity (ID) or access tokens from a given OIDC identity source. This data type is part of a [UpdateOpenIdConnectConfiguration](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdateOpenIdConnectConfiguration.html) structure, which is a parameter to [UpdateIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdateIdentitySource.html).
    public enum UpdateOpenIdConnectTokenSelection: Swift.Sendable {
        /// The OIDC configuration for processing access tokens. Contains allowed audience claims, for example https://auth.example.com, and the claim that you want to map to the principal, for example sub.
        case accesstokenonly(VerifiedPermissionsClientTypes.UpdateOpenIdConnectAccessTokenConfiguration)
        /// The OIDC configuration for processing identity (ID) tokens. Contains allowed client ID claims, for example 1example23456789, and the claim that you want to map to the principal, for example sub.
        case identitytokenonly(VerifiedPermissionsClientTypes.UpdateOpenIdConnectIdentityTokenConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension VerifiedPermissionsClientTypes {

    /// Contains configuration details of an OpenID Connect (OIDC) identity provider, or identity source, that Verified Permissions can use to generate entities from authenticated identities. It specifies the issuer URL, token type that you want to use, and policy store entity details. This data type is part of a [UpdateConfiguration](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdateConfiguration.html) structure, which is a parameter to [UpdateIdentitySource](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdateIdentitySource.html).
    public struct UpdateOpenIdConnectConfiguration: Swift.Sendable {
        /// A descriptive string that you want to prefix to user entities from your OIDC identity provider. For example, if you set an entityIdPrefix of MyOIDCProvider, you can reference principals in your policies in the format MyCorp::User::MyOIDCProvider|Carlos.
        public var entityIdPrefix: Swift.String?
        /// The claim in OIDC identity provider tokens that indicates a user's group membership, and the entity type that you want to map it to. For example, this object can map the contents of a groups claim to MyCorp::UserGroup.
        public var groupConfiguration: VerifiedPermissionsClientTypes.UpdateOpenIdConnectGroupConfiguration?
        /// The issuer URL of an OIDC identity provider. This URL must have an OIDC discovery endpoint at the path .well-known/openid-configuration.
        /// This member is required.
        public var issuer: Swift.String?
        /// The token type that you want to process from your OIDC identity provider. Your policy store can process either identity (ID) or access tokens from a given OIDC identity source.
        /// This member is required.
        public var tokenSelection: VerifiedPermissionsClientTypes.UpdateOpenIdConnectTokenSelection?

        public init(
            entityIdPrefix: Swift.String? = nil,
            groupConfiguration: VerifiedPermissionsClientTypes.UpdateOpenIdConnectGroupConfiguration? = nil,
            issuer: Swift.String? = nil,
            tokenSelection: VerifiedPermissionsClientTypes.UpdateOpenIdConnectTokenSelection? = nil
        )
        {
            self.entityIdPrefix = entityIdPrefix
            self.groupConfiguration = groupConfiguration
            self.issuer = issuer
            self.tokenSelection = tokenSelection
        }
    }
}

extension VerifiedPermissionsClientTypes.UpdateOpenIdConnectConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateOpenIdConnectConfiguration(groupConfiguration: \(Swift.String(describing: groupConfiguration)), issuer: \(Swift.String(describing: issuer)), tokenSelection: \(Swift.String(describing: tokenSelection)), entityIdPrefix: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// Contains an update to replace the configuration in an existing identity source.
    public enum UpdateConfiguration: Swift.Sendable {
        /// Contains configuration details of a Amazon Cognito user pool.
        case cognitouserpoolconfiguration(VerifiedPermissionsClientTypes.UpdateCognitoUserPoolConfiguration)
        /// Contains configuration details of an OpenID Connect (OIDC) identity provider, or identity source, that Verified Permissions can use to generate entities from authenticated identities. It specifies the issuer URL, token type that you want to use, and policy store entity details.
        case openidconnectconfiguration(VerifiedPermissionsClientTypes.UpdateOpenIdConnectConfiguration)
        case sdkUnknown(Swift.String)
    }
}

public struct UpdateIdentitySourceInput: Swift.Sendable {
    /// Specifies the ID of the identity source that you want to update.
    /// This member is required.
    public var identitySourceId: Swift.String?
    /// Specifies the ID of the policy store that contains the identity source that you want to update.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// Specifies the data type of principals generated for identities authenticated by the identity source.
    public var principalEntityType: Swift.String?
    /// Specifies the details required to communicate with the identity provider (IdP) associated with this identity source.
    /// This member is required.
    public var updateConfiguration: VerifiedPermissionsClientTypes.UpdateConfiguration?

    public init(
        identitySourceId: Swift.String? = nil,
        policyStoreId: Swift.String? = nil,
        principalEntityType: Swift.String? = nil,
        updateConfiguration: VerifiedPermissionsClientTypes.UpdateConfiguration? = nil
    )
    {
        self.identitySourceId = identitySourceId
        self.policyStoreId = policyStoreId
        self.principalEntityType = principalEntityType
        self.updateConfiguration = updateConfiguration
    }
}

extension UpdateIdentitySourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateIdentitySourceInput(identitySourceId: \(Swift.String(describing: identitySourceId)), policyStoreId: \(Swift.String(describing: policyStoreId)), updateConfiguration: \(Swift.String(describing: updateConfiguration)), principalEntityType: \"CONTENT_REDACTED\")"}
}

public struct UpdateIdentitySourceOutput: Swift.Sendable {
    /// The date and time that the updated identity source was originally created.
    /// This member is required.
    public var createdDate: Foundation.Date?
    /// The ID of the updated identity source.
    /// This member is required.
    public var identitySourceId: Swift.String?
    /// The date and time that the identity source was most recently updated.
    /// This member is required.
    public var lastUpdatedDate: Foundation.Date?
    /// The ID of the policy store that contains the updated identity source.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        createdDate: Foundation.Date? = nil,
        identitySourceId: Swift.String? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.identitySourceId = identitySourceId
        self.lastUpdatedDate = lastUpdatedDate
        self.policyStoreId = policyStoreId
    }
}

/// The request failed because of an internal error. Try your request again later
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct IsAuthorizedOutput: Swift.Sendable {
    /// An authorization decision that indicates if the authorization request should be allowed or denied.
    /// This member is required.
    public var decision: VerifiedPermissionsClientTypes.Decision?
    /// The list of determining policies used to make the authorization decision. For example, if there are two matching policies, where one is a forbid and the other is a permit, then the forbid policy will be the determining policy. In the case of multiple matching permit policies then there would be multiple determining policies. In the case that no policies match, and hence the response is DENY, there would be no determining policies.
    /// This member is required.
    public var determiningPolicies: [VerifiedPermissionsClientTypes.DeterminingPolicyItem]?
    /// Errors that occurred while making an authorization decision, for example, a policy references an Entity or entity Attribute that does not exist in the slice.
    /// This member is required.
    public var errors: [VerifiedPermissionsClientTypes.EvaluationErrorItem]?

    public init(
        decision: VerifiedPermissionsClientTypes.Decision? = nil,
        determiningPolicies: [VerifiedPermissionsClientTypes.DeterminingPolicyItem]? = nil,
        errors: [VerifiedPermissionsClientTypes.EvaluationErrorItem]? = nil
    )
    {
        self.decision = decision
        self.determiningPolicies = determiningPolicies
        self.errors = errors
    }
}

extension IsAuthorizedOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IsAuthorizedOutput(decision: \(Swift.String(describing: decision)), determiningPolicies: \(Swift.String(describing: determiningPolicies)), errors: \"CONTENT_REDACTED\")"}
}

public struct IsAuthorizedWithTokenOutput: Swift.Sendable {
    /// An authorization decision that indicates if the authorization request should be allowed or denied.
    /// This member is required.
    public var decision: VerifiedPermissionsClientTypes.Decision?
    /// The list of determining policies used to make the authorization decision. For example, if there are multiple matching policies, where at least one is a forbid policy, then because forbid always overrides permit the forbid policies are the determining policies. If all matching policies are permit policies, then those policies are the determining policies. When no policies match and the response is the default DENY, there are no determining policies.
    /// This member is required.
    public var determiningPolicies: [VerifiedPermissionsClientTypes.DeterminingPolicyItem]?
    /// Errors that occurred while making an authorization decision. For example, a policy references an entity or entity attribute that does not exist in the slice.
    /// This member is required.
    public var errors: [VerifiedPermissionsClientTypes.EvaluationErrorItem]?
    /// The identifier of the principal in the ID or access token.
    public var principal: VerifiedPermissionsClientTypes.EntityIdentifier?

    public init(
        decision: VerifiedPermissionsClientTypes.Decision? = nil,
        determiningPolicies: [VerifiedPermissionsClientTypes.DeterminingPolicyItem]? = nil,
        errors: [VerifiedPermissionsClientTypes.EvaluationErrorItem]? = nil,
        principal: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
    )
    {
        self.decision = decision
        self.determiningPolicies = determiningPolicies
        self.errors = errors
        self.principal = principal
    }
}

extension IsAuthorizedWithTokenOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IsAuthorizedWithTokenOutput(decision: \(Swift.String(describing: decision)), determiningPolicies: \(Swift.String(describing: determiningPolicies)), principal: \(Swift.String(describing: principal)), errors: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// Contains information about a filter to refine policies returned in a query. This data type is used as a response parameter for the [ListPolicies](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListPolicies.html) operation.
    public struct PolicyFilter: Swift.Sendable {
        /// Filters the output to only template-linked policies that were instantiated from the specified policy template.
        public var policyTemplateId: Swift.String?
        /// Filters the output to only policies of the specified type.
        public var policyType: VerifiedPermissionsClientTypes.PolicyType?
        /// Filters the output to only policies that reference the specified principal.
        public var principal: VerifiedPermissionsClientTypes.EntityReference?
        /// Filters the output to only policies that reference the specified resource.
        public var resource: VerifiedPermissionsClientTypes.EntityReference?

        public init(
            policyTemplateId: Swift.String? = nil,
            policyType: VerifiedPermissionsClientTypes.PolicyType? = nil,
            principal: VerifiedPermissionsClientTypes.EntityReference? = nil,
            resource: VerifiedPermissionsClientTypes.EntityReference? = nil
        )
        {
            self.policyTemplateId = policyTemplateId
            self.policyType = policyType
            self.principal = principal
            self.resource = resource
        }
    }
}

public struct ListPoliciesInput: Swift.Sendable {
    /// Specifies a filter that limits the response to only policies that match the specified criteria. For example, you list only the policies that reference a specified principal.
    public var filter: VerifiedPermissionsClientTypes.PolicyFilter?
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results. If you do not specify this parameter, the operation defaults to 10 policies per response. You can specify a maximum of 50 policies per response.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the ID of the policy store you want to list policies from.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        filter: VerifiedPermissionsClientTypes.PolicyFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyStoreId = policyStoreId
    }
}

extension VerifiedPermissionsClientTypes {

    /// A structure that contains details about a static policy. It includes the description and policy statement. This data type is used within a [PolicyDefinition](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_PolicyDefinition.html) structure as part of a request parameter for the [CreatePolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreatePolicy.html) operation.
    public struct StaticPolicyDefinitionItem: Swift.Sendable {
        /// A description of the static policy.
        public var description: Swift.String?

        public init(
            description: Swift.String? = nil
        )
        {
            self.description = description
        }
    }
}

extension VerifiedPermissionsClientTypes.StaticPolicyDefinitionItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StaticPolicyDefinitionItem(description: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// Contains information about a policy created by instantiating a policy template. This
    public struct TemplateLinkedPolicyDefinitionItem: Swift.Sendable {
        /// The unique identifier of the policy template used to create this policy.
        /// This member is required.
        public var policyTemplateId: Swift.String?
        /// The principal associated with this template-linked policy. Verified Permissions substitutes this principal for the ?principal placeholder in the policy template when it evaluates an authorization request.
        public var principal: VerifiedPermissionsClientTypes.EntityIdentifier?
        /// The resource associated with this template-linked policy. Verified Permissions substitutes this resource for the ?resource placeholder in the policy template when it evaluates an authorization request.
        public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

        public init(
            policyTemplateId: Swift.String? = nil,
            principal: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
            resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
        )
        {
            self.policyTemplateId = policyTemplateId
            self.principal = principal
            self.resource = resource
        }
    }
}

extension VerifiedPermissionsClientTypes {

    /// A structure that describes a [PolicyDefinintion](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_PolicyDefinintion.html). It will always have either an StaticPolicy or a TemplateLinkedPolicy element. This data type is used as a response parameter for the [CreatePolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_CreatePolicy.html) and [ListPolicies](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListPolicies.html) operations.
    public enum PolicyDefinitionItem: Swift.Sendable {
        /// Information about a static policy that wasn't created with a policy template.
        case `static`(VerifiedPermissionsClientTypes.StaticPolicyDefinitionItem)
        /// Information about a template-linked policy that was created by instantiating a policy template.
        case templatelinked(VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinitionItem)
        case sdkUnknown(Swift.String)
    }
}

extension VerifiedPermissionsClientTypes {

    /// Contains information about a policy. This data type is used as a response parameter for the [ListPolicies](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListPolicies.html) operation.
    public struct PolicyItem: Swift.Sendable {
        /// The action that a policy permits or forbids. For example, {"actions": [{"actionId": "ViewPhoto", "actionType": "PhotoFlash::Action"}, {"entityID": "SharePhoto", "entityType": "PhotoFlash::Action"}]}.
        public var actions: [VerifiedPermissionsClientTypes.ActionIdentifier]?
        /// The date and time the policy was created.
        /// This member is required.
        public var createdDate: Foundation.Date?
        /// The policy definition of an item in the list of policies returned.
        /// This member is required.
        public var definition: VerifiedPermissionsClientTypes.PolicyDefinitionItem?
        /// The effect of the decision that a policy returns to an authorization request. For example, "effect": "Permit".
        public var effect: VerifiedPermissionsClientTypes.PolicyEffect?
        /// The date and time the policy was most recently updated.
        /// This member is required.
        public var lastUpdatedDate: Foundation.Date?
        /// The identifier of the policy you want information about.
        /// This member is required.
        public var policyId: Swift.String?
        /// The identifier of the PolicyStore where the policy you want information about is stored.
        /// This member is required.
        public var policyStoreId: Swift.String?
        /// The type of the policy. This is one of the following values:
        ///
        /// * STATIC
        ///
        /// * TEMPLATE_LINKED
        /// This member is required.
        public var policyType: VerifiedPermissionsClientTypes.PolicyType?
        /// The principal associated with the policy.
        public var principal: VerifiedPermissionsClientTypes.EntityIdentifier?
        /// The resource associated with the policy.
        public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

        public init(
            actions: [VerifiedPermissionsClientTypes.ActionIdentifier]? = nil,
            createdDate: Foundation.Date? = nil,
            definition: VerifiedPermissionsClientTypes.PolicyDefinitionItem? = nil,
            effect: VerifiedPermissionsClientTypes.PolicyEffect? = nil,
            lastUpdatedDate: Foundation.Date? = nil,
            policyId: Swift.String? = nil,
            policyStoreId: Swift.String? = nil,
            policyType: VerifiedPermissionsClientTypes.PolicyType? = nil,
            principal: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
            resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
        )
        {
            self.actions = actions
            self.createdDate = createdDate
            self.definition = definition
            self.effect = effect
            self.lastUpdatedDate = lastUpdatedDate
            self.policyId = policyId
            self.policyStoreId = policyStoreId
            self.policyType = policyType
            self.principal = principal
            self.resource = resource
        }
    }
}

public struct ListPoliciesOutput: Swift.Sendable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// Lists all policies that are available in the specified policy store.
    /// This member is required.
    public var policies: [VerifiedPermissionsClientTypes.PolicyItem]?

    public init(
        nextToken: Swift.String? = nil,
        policies: [VerifiedPermissionsClientTypes.PolicyItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.policies = policies
    }
}

public struct ListPolicyStoresInput: Swift.Sendable {
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results. If you do not specify this parameter, the operation defaults to 10 policy stores per response. You can specify a maximum of 50 policy stores per response.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension VerifiedPermissionsClientTypes {

    /// Contains information about a policy store. This data type is used as a response parameter for the [ListPolicyStores](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListPolicyStores.html) operation.
    public struct PolicyStoreItem: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the policy store.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time the policy was created.
        /// This member is required.
        public var createdDate: Foundation.Date?
        /// Descriptive text that you can provide to help with identification of the current policy store.
        public var description: Swift.String?
        /// The date and time the policy store was most recently updated.
        public var lastUpdatedDate: Foundation.Date?
        /// The unique identifier of the policy store.
        /// This member is required.
        public var policyStoreId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastUpdatedDate: Foundation.Date? = nil,
            policyStoreId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdDate = createdDate
            self.description = description
            self.lastUpdatedDate = lastUpdatedDate
            self.policyStoreId = policyStoreId
        }
    }
}

extension VerifiedPermissionsClientTypes.PolicyStoreItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PolicyStoreItem(arn: \(Swift.String(describing: arn)), createdDate: \(Swift.String(describing: createdDate)), lastUpdatedDate: \(Swift.String(describing: lastUpdatedDate)), policyStoreId: \(Swift.String(describing: policyStoreId)), description: \"CONTENT_REDACTED\")"}
}

public struct ListPolicyStoresOutput: Swift.Sendable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// The list of policy stores in the account.
    /// This member is required.
    public var policyStores: [VerifiedPermissionsClientTypes.PolicyStoreItem]?

    public init(
        nextToken: Swift.String? = nil,
        policyStores: [VerifiedPermissionsClientTypes.PolicyStoreItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyStores = policyStores
    }
}

public struct ListPolicyTemplatesInput: Swift.Sendable {
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results. If you do not specify this parameter, the operation defaults to 10 policy templates per response. You can specify a maximum of 50 policy templates per response.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the ID of the policy store that contains the policy templates you want to list.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyStoreId = policyStoreId
    }
}

extension VerifiedPermissionsClientTypes {

    /// Contains details about a policy template This data type is used as a response parameter for the [ListPolicyTemplates](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListPolicyTemplates.html) operation.
    public struct PolicyTemplateItem: Swift.Sendable {
        /// The date and time that the policy template was created.
        /// This member is required.
        public var createdDate: Foundation.Date?
        /// The description attached to the policy template.
        public var description: Swift.String?
        /// The date and time that the policy template was most recently updated.
        /// This member is required.
        public var lastUpdatedDate: Foundation.Date?
        /// The unique identifier of the policy store that contains the template.
        /// This member is required.
        public var policyStoreId: Swift.String?
        /// The unique identifier of the policy template.
        /// This member is required.
        public var policyTemplateId: Swift.String?

        public init(
            createdDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastUpdatedDate: Foundation.Date? = nil,
            policyStoreId: Swift.String? = nil,
            policyTemplateId: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.lastUpdatedDate = lastUpdatedDate
            self.policyStoreId = policyStoreId
            self.policyTemplateId = policyTemplateId
        }
    }
}

extension VerifiedPermissionsClientTypes.PolicyTemplateItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PolicyTemplateItem(createdDate: \(Swift.String(describing: createdDate)), lastUpdatedDate: \(Swift.String(describing: lastUpdatedDate)), policyStoreId: \(Swift.String(describing: policyStoreId)), policyTemplateId: \(Swift.String(describing: policyTemplateId)), description: \"CONTENT_REDACTED\")"}
}

public struct ListPolicyTemplatesOutput: Swift.Sendable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// The list of the policy templates in the specified policy store.
    /// This member is required.
    public var policyTemplates: [VerifiedPermissionsClientTypes.PolicyTemplateItem]?

    public init(
        nextToken: Swift.String? = nil,
        policyTemplates: [VerifiedPermissionsClientTypes.PolicyTemplateItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyTemplates = policyTemplates
    }
}

extension VerifiedPermissionsClientTypes {

    /// Contains information about an update to a static policy.
    public struct UpdateStaticPolicyDefinition: Swift.Sendable {
        /// Specifies the description to be added to or replaced on the static policy.
        public var description: Swift.String?
        /// Specifies the Cedar policy language text to be added to or replaced on the static policy. You can change only the following elements from the original content:
        ///
        /// * The action referenced by the policy.
        ///
        /// * Any conditional clauses, such as when or unless clauses.
        ///
        ///
        /// You can't change the following elements:
        ///
        /// * Changing from StaticPolicy to TemplateLinkedPolicy.
        ///
        /// * The effect (permit or forbid) of the policy.
        ///
        /// * The principal referenced by the policy.
        ///
        /// * The resource referenced by the policy.
        /// This member is required.
        public var statement: Swift.String?

        public init(
            description: Swift.String? = nil,
            statement: Swift.String? = nil
        )
        {
            self.description = description
            self.statement = statement
        }
    }
}

extension VerifiedPermissionsClientTypes.UpdateStaticPolicyDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStaticPolicyDefinition(description: \"CONTENT_REDACTED\", statement: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// Contains information about updates to be applied to a policy. This data type is used as a request parameter in the [UpdatePolicy](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdatePolicy.html) operation.
    public enum UpdatePolicyDefinition: Swift.Sendable {
        /// Contains details about the updates to be applied to a static policy.
        case `static`(VerifiedPermissionsClientTypes.UpdateStaticPolicyDefinition)
        case sdkUnknown(Swift.String)
    }
}

public struct UpdatePolicyInput: Swift.Sendable {
    /// Specifies the updated policy content that you want to replace on the specified policy. The content must be valid Cedar policy language text. You can change only the following elements from the policy definition:
    ///
    /// * The action referenced by the policy.
    ///
    /// * Any conditional clauses, such as when or unless clauses.
    ///
    ///
    /// You can't change the following elements:
    ///
    /// * Changing from static to templateLinked.
    ///
    /// * Changing the effect of the policy from permit or forbid.
    ///
    /// * The principal referenced by the policy.
    ///
    /// * The resource referenced by the policy.
    /// This member is required.
    public var definition: VerifiedPermissionsClientTypes.UpdatePolicyDefinition?
    /// Specifies the ID of the policy that you want to update. To find this value, you can use [ListPolicies](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ListPolicies.html).
    /// This member is required.
    public var policyId: Swift.String?
    /// Specifies the ID of the policy store that contains the policy that you want to update.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        definition: VerifiedPermissionsClientTypes.UpdatePolicyDefinition? = nil,
        policyId: Swift.String? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.definition = definition
        self.policyId = policyId
        self.policyStoreId = policyStoreId
    }
}

public struct UpdatePolicyOutput: Swift.Sendable {
    /// The action that a policy permits or forbids. For example, {"actions": [{"actionId": "ViewPhoto", "actionType": "PhotoFlash::Action"}, {"entityID": "SharePhoto", "entityType": "PhotoFlash::Action"}]}.
    public var actions: [VerifiedPermissionsClientTypes.ActionIdentifier]?
    /// The date and time that the policy was originally created.
    /// This member is required.
    public var createdDate: Foundation.Date?
    /// The effect of the decision that a policy returns to an authorization request. For example, "effect": "Permit".
    public var effect: VerifiedPermissionsClientTypes.PolicyEffect?
    /// The date and time that the policy was most recently updated.
    /// This member is required.
    public var lastUpdatedDate: Foundation.Date?
    /// The ID of the policy that was updated.
    /// This member is required.
    public var policyId: Swift.String?
    /// The ID of the policy store that contains the policy that was updated.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// The type of the policy that was updated.
    /// This member is required.
    public var policyType: VerifiedPermissionsClientTypes.PolicyType?
    /// The principal specified in the policy's scope. This element isn't included in the response when Principal isn't present in the policy content.
    public var principal: VerifiedPermissionsClientTypes.EntityIdentifier?
    /// The resource specified in the policy's scope. This element isn't included in the response when Resource isn't present in the policy content.
    public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

    public init(
        actions: [VerifiedPermissionsClientTypes.ActionIdentifier]? = nil,
        createdDate: Foundation.Date? = nil,
        effect: VerifiedPermissionsClientTypes.PolicyEffect? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        policyId: Swift.String? = nil,
        policyStoreId: Swift.String? = nil,
        policyType: VerifiedPermissionsClientTypes.PolicyType? = nil,
        principal: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
        resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
    )
    {
        self.actions = actions
        self.createdDate = createdDate
        self.effect = effect
        self.lastUpdatedDate = lastUpdatedDate
        self.policyId = policyId
        self.policyStoreId = policyStoreId
        self.policyType = policyType
        self.principal = principal
        self.resource = resource
    }
}

public struct UpdatePolicyTemplateInput: Swift.Sendable {
    /// Specifies a new description to apply to the policy template.
    public var description: Swift.String?
    /// Specifies the ID of the policy store that contains the policy template that you want to update.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// Specifies the ID of the policy template that you want to update.
    /// This member is required.
    public var policyTemplateId: Swift.String?
    /// Specifies new statement content written in Cedar policy language to replace the current body of the policy template. You can change only the following elements of the policy body:
    ///
    /// * The action referenced by the policy template.
    ///
    /// * Any conditional clauses, such as when or unless clauses.
    ///
    ///
    /// You can't change the following elements:
    ///
    /// * The effect (permit or forbid) of the policy template.
    ///
    /// * The principal referenced by the policy template.
    ///
    /// * The resource referenced by the policy template.
    /// This member is required.
    public var statement: Swift.String?

    public init(
        description: Swift.String? = nil,
        policyStoreId: Swift.String? = nil,
        policyTemplateId: Swift.String? = nil,
        statement: Swift.String? = nil
    )
    {
        self.description = description
        self.policyStoreId = policyStoreId
        self.policyTemplateId = policyTemplateId
        self.statement = statement
    }
}

extension UpdatePolicyTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePolicyTemplateInput(policyStoreId: \(Swift.String(describing: policyStoreId)), policyTemplateId: \(Swift.String(describing: policyTemplateId)), description: \"CONTENT_REDACTED\", statement: \"CONTENT_REDACTED\")"}
}

public struct UpdatePolicyTemplateOutput: Swift.Sendable {
    /// The date and time that the policy template was originally created.
    /// This member is required.
    public var createdDate: Foundation.Date?
    /// The date and time that the policy template was most recently updated.
    /// This member is required.
    public var lastUpdatedDate: Foundation.Date?
    /// The ID of the policy store that contains the updated policy template.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// The ID of the updated policy template.
    /// This member is required.
    public var policyTemplateId: Swift.String?

    public init(
        createdDate: Foundation.Date? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        policyStoreId: Swift.String? = nil,
        policyTemplateId: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.lastUpdatedDate = lastUpdatedDate
        self.policyStoreId = policyStoreId
        self.policyTemplateId = policyTemplateId
    }
}

extension VerifiedPermissionsClientTypes {

    /// Contains a list of principal types, resource types, and actions that can be specified in policies stored in the same policy store. If the validation mode for the policy store is set to STRICT, then policies that can't be validated by this schema are rejected by Verified Permissions and can't be stored in the policy store.
    public enum SchemaDefinition: Swift.Sendable {
        /// A JSON string representation of the schema supported by applications that use this policy store. To delete the schema, run [PutSchema](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_PutSchema.html) with {} for this parameter. For more information, see [Policy store schema](https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/schema.html) in the Amazon Verified Permissions User Guide.
        case cedarjson(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

public struct PutSchemaInput: Swift.Sendable {
    /// Specifies the definition of the schema to be stored. The schema definition must be written in Cedar schema JSON.
    /// This member is required.
    public var definition: VerifiedPermissionsClientTypes.SchemaDefinition?
    /// Specifies the ID of the policy store in which to place the schema.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        definition: VerifiedPermissionsClientTypes.SchemaDefinition? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.definition = definition
        self.policyStoreId = policyStoreId
    }
}

public struct PutSchemaOutput: Swift.Sendable {
    /// The date and time that the schema was originally created.
    /// This member is required.
    public var createdDate: Foundation.Date?
    /// The date and time that the schema was last updated.
    /// This member is required.
    public var lastUpdatedDate: Foundation.Date?
    /// Identifies the namespaces of the entities referenced by this schema.
    /// This member is required.
    public var namespaces: [Swift.String]?
    /// The unique ID of the policy store that contains the schema.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        createdDate: Foundation.Date? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        namespaces: [Swift.String]? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.lastUpdatedDate = lastUpdatedDate
        self.namespaces = namespaces
        self.policyStoreId = policyStoreId
    }
}

extension PutSchemaOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSchemaOutput(createdDate: \(Swift.String(describing: createdDate)), lastUpdatedDate: \(Swift.String(describing: lastUpdatedDate)), policyStoreId: \(Swift.String(describing: policyStoreId)), namespaces: \"CONTENT_REDACTED\")"}
}

public struct UpdatePolicyStoreInput: Swift.Sendable {
    /// Descriptive text that you can provide to help with identification of the current policy store.
    public var description: Swift.String?
    /// Specifies the ID of the policy store that you want to update
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// A structure that defines the validation settings that want to enable for the policy store.
    /// This member is required.
    public var validationSettings: VerifiedPermissionsClientTypes.ValidationSettings?

    public init(
        description: Swift.String? = nil,
        policyStoreId: Swift.String? = nil,
        validationSettings: VerifiedPermissionsClientTypes.ValidationSettings? = nil
    )
    {
        self.description = description
        self.policyStoreId = policyStoreId
        self.validationSettings = validationSettings
    }
}

extension UpdatePolicyStoreInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePolicyStoreInput(policyStoreId: \(Swift.String(describing: policyStoreId)), validationSettings: \(Swift.String(describing: validationSettings)), description: \"CONTENT_REDACTED\")"}
}

public struct UpdatePolicyStoreOutput: Swift.Sendable {
    /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the updated policy store.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time that the policy store was originally created.
    /// This member is required.
    public var createdDate: Foundation.Date?
    /// The date and time that the policy store was most recently updated.
    /// This member is required.
    public var lastUpdatedDate: Foundation.Date?
    /// The ID of the updated policy store.
    /// This member is required.
    public var policyStoreId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        lastUpdatedDate: Foundation.Date? = nil,
        policyStoreId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.createdDate = createdDate
        self.lastUpdatedDate = lastUpdatedDate
        self.policyStoreId = policyStoreId
    }
}

/// The request failed because it exceeded a throttling quota.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota code recognized by the Amazon Web Services Service Quotas service.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The code for the Amazon Web Services service that owns the quota.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.serviceCode = serviceCode
    }
}

extension VerifiedPermissionsClientTypes {

    /// Details about a field that failed policy validation.
    public struct ValidationExceptionField: Swift.Sendable {
        /// Describes the policy validation error.
        /// This member is required.
        public var message: Swift.String?
        /// The path to the specific element that Verified Permissions found to be not valid.
        /// This member is required.
        public var path: Swift.String?

        public init(
            message: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.message = message
            self.path = path
        }
    }
}

/// The request failed because one or more input parameters don't satisfy their constraint requirements. The output is provided as a list of fields and a reason for each field that isn't valid. The possible reasons include the following:
///
/// * UnrecognizedEntityType The policy includes an entity type that isn't found in the schema.
///
/// * UnrecognizedActionId The policy includes an action id that isn't found in the schema.
///
/// * InvalidActionApplication The policy includes an action that, according to the schema, doesn't support the specified principal and resource.
///
/// * UnexpectedType The policy included an operand that isn't a valid type for the specified operation.
///
/// * IncompatibleTypes The types of elements included in a set, or the types of expressions used in an if...then...else clause aren't compatible in this context.
///
/// * MissingAttribute The policy attempts to access a record or entity attribute that isn't specified in the schema. Test for the existence of the attribute first before attempting to access its value. For more information, see the [has (presence of attribute test) operator](https://docs.cedarpolicy.com/policies/syntax-operators.html#has-presence-of-attribute-test) in the Cedar Policy Language Guide.
///
/// * UnsafeOptionalAttributeAccess The policy attempts to access a record or entity attribute that is optional and isn't guaranteed to be present. Test for the existence of the attribute first before attempting to access its value. For more information, see the [has (presence of attribute test) operator](https://docs.cedarpolicy.com/policies/syntax-operators.html#has-presence-of-attribute-test) in the Cedar Policy Language Guide.
///
/// * ImpossiblePolicy Cedar has determined that a policy condition always evaluates to false. If the policy is always false, it can never apply to any query, and so it can never affect an authorization decision.
///
/// * WrongNumberArguments The policy references an extension type with the wrong number of arguments.
///
/// * FunctionArgumentValidationError Cedar couldn't parse the argument passed to an extension type. For example, a string that is to be parsed as an IPv4 address can contain only digits and the period character.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The list of fields that aren't valid.
        public internal(set) var fieldList: [VerifiedPermissionsClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [VerifiedPermissionsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
    }
}

extension VerifiedPermissionsClientTypes {

    /// The value of an attribute. Contains information about the runtime context for a request for which an authorization decision is made. This data type is used as a member of the [ContextDefinition](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_ContextDefinition.html) structure which is uses as a request parameter for the [IsAuthorized](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorized.html), [BatchIsAuthorized](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_BatchIsAuthorized.html), and [IsAuthorizedWithToken](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorizedWithToken.html) operations.
    public indirect enum AttributeValue: Swift.Sendable {
        /// An attribute value of [Boolean](https://docs.cedarpolicy.com/policies/syntax-datatypes.html#boolean) type. Example: {"boolean": true}
        case boolean(Swift.Bool)
        /// An attribute value of type [EntityIdentifier](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_EntityIdentifier.html). Example: "entityIdentifier": { "entityId": "<id>", "entityType": "<entity type>"}
        case entityidentifier(VerifiedPermissionsClientTypes.EntityIdentifier)
        /// An attribute value of [Long](https://docs.cedarpolicy.com/policies/syntax-datatypes.html#long) type. Example: {"long": 0}
        case long(Swift.Int)
        /// An attribute value of [String](https://docs.cedarpolicy.com/policies/syntax-datatypes.html#string) type. Example: {"string": "abc"}
        case string(Swift.String)
        /// An attribute value of [Set](https://docs.cedarpolicy.com/policies/syntax-datatypes.html#set) type. Example: {"set": [ {} ] }
        case `set`([VerifiedPermissionsClientTypes.AttributeValue])
        /// An attribute value of [Record](https://docs.cedarpolicy.com/policies/syntax-datatypes.html#record) type. Example: {"record": { "keyName": {} } }
        case record([Swift.String: VerifiedPermissionsClientTypes.AttributeValue])
        case sdkUnknown(Swift.String)
    }
}

extension VerifiedPermissionsClientTypes {

    /// Contains additional details about the context of the request. Verified Permissions evaluates this information in an authorization request as part of the when and unless clauses in a policy. This data type is used as a request parameter for the [IsAuthorized](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorized.html), [BatchIsAuthorized](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_BatchIsAuthorized.html), and [IsAuthorizedWithToken](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorizedWithToken.html) operations. Example: "context":{"contextMap":{"<KeyName1>":{"boolean":true},"<KeyName2>":{"long":1234}}}
    public indirect enum ContextDefinition: Swift.Sendable {
        /// An list of attributes that are needed to successfully evaluate an authorization request. Each attribute in this array must include a map of a data type and its value. Example: "contextMap":{"<KeyName1>":{"boolean":true},"<KeyName2>":{"long":1234}}
        case contextmap([Swift.String: VerifiedPermissionsClientTypes.AttributeValue])
        case sdkUnknown(Swift.String)
    }
}

extension VerifiedPermissionsClientTypes {

    /// Contains information about an entity that can be referenced in a Cedar policy. This data type is used as one of the fields in the [EntitiesDefinition](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_EntitiesDefinition.html) structure. { "identifier": { "entityType": "Photo", "entityId": "VacationPhoto94.jpg" }, "attributes": {}, "parents": [ { "entityType": "Album", "entityId": "alice_folder" } ] }
    public struct EntityItem: Swift.Sendable {
        /// A list of attributes for the entity.
        public var attributes: [Swift.String: VerifiedPermissionsClientTypes.AttributeValue]?
        /// The identifier of the entity.
        /// This member is required.
        public var identifier: VerifiedPermissionsClientTypes.EntityIdentifier?
        /// The parent entities in the hierarchy that contains the entity. A principal or resource entity can be defined with at most 99 transitive parents per authorization request. A transitive parent is an entity in the hierarchy of entities including all direct parents, and parents of parents. For example, a user can be a member of 91 groups if one of those groups is a member of eight groups, for a total of 100: one entity, 91 entity parents, and eight parents of parents.
        public var parents: [VerifiedPermissionsClientTypes.EntityIdentifier]?

        public init(
            attributes: [Swift.String: VerifiedPermissionsClientTypes.AttributeValue]? = nil,
            identifier: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
            parents: [VerifiedPermissionsClientTypes.EntityIdentifier]? = nil
        )
        {
            self.attributes = attributes
            self.identifier = identifier
            self.parents = parents
        }
    }
}

extension VerifiedPermissionsClientTypes {

    /// An authorization request that you include in a BatchIsAuthorized API request.
    public struct BatchIsAuthorizedInputItem: Swift.Sendable {
        /// Specifies the requested action to be authorized. For example, PhotoFlash::ReadPhoto.
        public var action: VerifiedPermissionsClientTypes.ActionIdentifier?
        /// Specifies additional context that can be used to make more granular authorization decisions.
        public var context: VerifiedPermissionsClientTypes.ContextDefinition?
        /// Specifies the principal for which the authorization decision is to be made.
        public var principal: VerifiedPermissionsClientTypes.EntityIdentifier?
        /// Specifies the resource that you want an authorization decision for. For example, PhotoFlash::Photo.
        public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

        public init(
            action: VerifiedPermissionsClientTypes.ActionIdentifier? = nil,
            context: VerifiedPermissionsClientTypes.ContextDefinition? = nil,
            principal: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
            resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
        )
        {
            self.action = action
            self.context = context
            self.principal = principal
            self.resource = resource
        }
    }
}

extension VerifiedPermissionsClientTypes {

    /// An authorization request that you include in a BatchIsAuthorizedWithToken API request.
    public struct BatchIsAuthorizedWithTokenInputItem: Swift.Sendable {
        /// Specifies the requested action to be authorized. For example, PhotoFlash::ReadPhoto.
        public var action: VerifiedPermissionsClientTypes.ActionIdentifier?
        /// Specifies additional context that can be used to make more granular authorization decisions.
        public var context: VerifiedPermissionsClientTypes.ContextDefinition?
        /// Specifies the resource that you want an authorization decision for. For example, PhotoFlash::Photo.
        public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

        public init(
            action: VerifiedPermissionsClientTypes.ActionIdentifier? = nil,
            context: VerifiedPermissionsClientTypes.ContextDefinition? = nil,
            resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
        )
        {
            self.action = action
            self.context = context
            self.resource = resource
        }
    }
}

extension VerifiedPermissionsClientTypes {

    /// The decision, based on policy evaluation, from an individual authorization request in a BatchIsAuthorized API request.
    public struct BatchIsAuthorizedOutputItem: Swift.Sendable {
        /// An authorization decision that indicates if the authorization request should be allowed or denied.
        /// This member is required.
        public var decision: VerifiedPermissionsClientTypes.Decision?
        /// The list of determining policies used to make the authorization decision. For example, if there are two matching policies, where one is a forbid and the other is a permit, then the forbid policy will be the determining policy. In the case of multiple matching permit policies then there would be multiple determining policies. In the case that no policies match, and hence the response is DENY, there would be no determining policies.
        /// This member is required.
        public var determiningPolicies: [VerifiedPermissionsClientTypes.DeterminingPolicyItem]?
        /// Errors that occurred while making an authorization decision. For example, a policy might reference an entity or attribute that doesn't exist in the request.
        /// This member is required.
        public var errors: [VerifiedPermissionsClientTypes.EvaluationErrorItem]?
        /// The authorization request that initiated the decision.
        /// This member is required.
        public var request: VerifiedPermissionsClientTypes.BatchIsAuthorizedInputItem?

        public init(
            decision: VerifiedPermissionsClientTypes.Decision? = nil,
            determiningPolicies: [VerifiedPermissionsClientTypes.DeterminingPolicyItem]? = nil,
            errors: [VerifiedPermissionsClientTypes.EvaluationErrorItem]? = nil,
            request: VerifiedPermissionsClientTypes.BatchIsAuthorizedInputItem? = nil
        )
        {
            self.decision = decision
            self.determiningPolicies = determiningPolicies
            self.errors = errors
            self.request = request
        }
    }
}

extension VerifiedPermissionsClientTypes.BatchIsAuthorizedOutputItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchIsAuthorizedOutputItem(decision: \(Swift.String(describing: decision)), determiningPolicies: \(Swift.String(describing: determiningPolicies)), request: \(Swift.String(describing: request)), errors: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// The decision, based on policy evaluation, from an individual authorization request in a BatchIsAuthorizedWithToken API request.
    public struct BatchIsAuthorizedWithTokenOutputItem: Swift.Sendable {
        /// An authorization decision that indicates if the authorization request should be allowed or denied.
        /// This member is required.
        public var decision: VerifiedPermissionsClientTypes.Decision?
        /// The list of determining policies used to make the authorization decision. For example, if there are two matching policies, where one is a forbid and the other is a permit, then the forbid policy will be the determining policy. In the case of multiple matching permit policies then there would be multiple determining policies. In the case that no policies match, and hence the response is DENY, there would be no determining policies.
        /// This member is required.
        public var determiningPolicies: [VerifiedPermissionsClientTypes.DeterminingPolicyItem]?
        /// Errors that occurred while making an authorization decision. For example, a policy might reference an entity or attribute that doesn't exist in the request.
        /// This member is required.
        public var errors: [VerifiedPermissionsClientTypes.EvaluationErrorItem]?
        /// The authorization request that initiated the decision.
        /// This member is required.
        public var request: VerifiedPermissionsClientTypes.BatchIsAuthorizedWithTokenInputItem?

        public init(
            decision: VerifiedPermissionsClientTypes.Decision? = nil,
            determiningPolicies: [VerifiedPermissionsClientTypes.DeterminingPolicyItem]? = nil,
            errors: [VerifiedPermissionsClientTypes.EvaluationErrorItem]? = nil,
            request: VerifiedPermissionsClientTypes.BatchIsAuthorizedWithTokenInputItem? = nil
        )
        {
            self.decision = decision
            self.determiningPolicies = determiningPolicies
            self.errors = errors
            self.request = request
        }
    }
}

extension VerifiedPermissionsClientTypes.BatchIsAuthorizedWithTokenOutputItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchIsAuthorizedWithTokenOutputItem(decision: \(Swift.String(describing: decision)), determiningPolicies: \(Swift.String(describing: determiningPolicies)), request: \(Swift.String(describing: request)), errors: \"CONTENT_REDACTED\")"}
}

extension VerifiedPermissionsClientTypes {

    /// Contains the list of entities to be considered during an authorization request. This includes all principals, resources, and actions required to successfully evaluate the request. This data type is used as a field in the response parameter for the [IsAuthorized](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorized.html) and [IsAuthorizedWithToken](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_IsAuthorizedWithToken.html) operations.
    public indirect enum EntitiesDefinition: Swift.Sendable {
        /// An array of entities that are needed to successfully evaluate an authorization request. Each entity in this array must include an identifier for the entity, the attributes of the entity, and a list of any parent entities.
        case entitylist([VerifiedPermissionsClientTypes.EntityItem])
        case sdkUnknown(Swift.String)
    }
}

public struct BatchIsAuthorizedOutput: Swift.Sendable {
    /// A series of Allow or Deny decisions for each request, and the policies that produced them.
    /// This member is required.
    public var results: [VerifiedPermissionsClientTypes.BatchIsAuthorizedOutputItem]?

    public init(
        results: [VerifiedPermissionsClientTypes.BatchIsAuthorizedOutputItem]? = nil
    )
    {
        self.results = results
    }
}

public struct BatchIsAuthorizedWithTokenOutput: Swift.Sendable {
    /// The identifier of the principal in the ID or access token.
    public var principal: VerifiedPermissionsClientTypes.EntityIdentifier?
    /// A series of Allow or Deny decisions for each request, and the policies that produced them.
    /// This member is required.
    public var results: [VerifiedPermissionsClientTypes.BatchIsAuthorizedWithTokenOutputItem]?

    public init(
        principal: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
        results: [VerifiedPermissionsClientTypes.BatchIsAuthorizedWithTokenOutputItem]? = nil
    )
    {
        self.principal = principal
        self.results = results
    }
}

public struct IsAuthorizedInput: Swift.Sendable {
    /// Specifies the requested action to be authorized. For example, is the principal authorized to perform this action on the resource?
    public var action: VerifiedPermissionsClientTypes.ActionIdentifier?
    /// Specifies additional context that can be used to make more granular authorization decisions.
    public var context: VerifiedPermissionsClientTypes.ContextDefinition?
    /// Specifies the list of resources and principals and their associated attributes that Verified Permissions can examine when evaluating the policies. You can include only principal and resource entities in this parameter; you can't include actions. You must specify actions in the schema.
    public var entities: VerifiedPermissionsClientTypes.EntitiesDefinition?
    /// Specifies the ID of the policy store. Policies in this policy store will be used to make an authorization decision for the input.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// Specifies the principal for which the authorization decision is to be made.
    public var principal: VerifiedPermissionsClientTypes.EntityIdentifier?
    /// Specifies the resource for which the authorization decision is to be made.
    public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

    public init(
        action: VerifiedPermissionsClientTypes.ActionIdentifier? = nil,
        context: VerifiedPermissionsClientTypes.ContextDefinition? = nil,
        entities: VerifiedPermissionsClientTypes.EntitiesDefinition? = nil,
        policyStoreId: Swift.String? = nil,
        principal: VerifiedPermissionsClientTypes.EntityIdentifier? = nil,
        resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
    )
    {
        self.action = action
        self.context = context
        self.entities = entities
        self.policyStoreId = policyStoreId
        self.principal = principal
        self.resource = resource
    }
}

public struct IsAuthorizedWithTokenInput: Swift.Sendable {
    /// Specifies an access token for the principal to be authorized. This token is provided to you by the identity provider (IdP) associated with the specified identity source. You must specify either an accessToken, an identityToken, or both. Must be an access token. Verified Permissions returns an error if the token_use claim in the submitted token isn't access.
    public var accessToken: Swift.String?
    /// Specifies the requested action to be authorized. Is the specified principal authorized to perform this action on the specified resource.
    public var action: VerifiedPermissionsClientTypes.ActionIdentifier?
    /// Specifies additional context that can be used to make more granular authorization decisions.
    public var context: VerifiedPermissionsClientTypes.ContextDefinition?
    /// Specifies the list of resources and their associated attributes that Verified Permissions can examine when evaluating the policies. You can't include principals in this parameter, only resource and action entities. This parameter can't include any entities of a type that matches the user or group entity types that you defined in your identity source.
    ///
    /// * The IsAuthorizedWithToken operation takes principal attributes from only the identityToken or accessToken passed to the operation.
    ///
    /// * For action entities, you can include only their Identifier and EntityType.
    public var entities: VerifiedPermissionsClientTypes.EntitiesDefinition?
    /// Specifies an identity token for the principal to be authorized. This token is provided to you by the identity provider (IdP) associated with the specified identity source. You must specify either an accessToken, an identityToken, or both. Must be an ID token. Verified Permissions returns an error if the token_use claim in the submitted token isn't id.
    public var identityToken: Swift.String?
    /// Specifies the ID of the policy store. Policies in this policy store will be used to make an authorization decision for the input.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// Specifies the resource for which the authorization decision is made. For example, is the principal allowed to perform the action on the resource?
    public var resource: VerifiedPermissionsClientTypes.EntityIdentifier?

    public init(
        accessToken: Swift.String? = nil,
        action: VerifiedPermissionsClientTypes.ActionIdentifier? = nil,
        context: VerifiedPermissionsClientTypes.ContextDefinition? = nil,
        entities: VerifiedPermissionsClientTypes.EntitiesDefinition? = nil,
        identityToken: Swift.String? = nil,
        policyStoreId: Swift.String? = nil,
        resource: VerifiedPermissionsClientTypes.EntityIdentifier? = nil
    )
    {
        self.accessToken = accessToken
        self.action = action
        self.context = context
        self.entities = entities
        self.identityToken = identityToken
        self.policyStoreId = policyStoreId
        self.resource = resource
    }
}

extension IsAuthorizedWithTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IsAuthorizedWithTokenInput(action: \(Swift.String(describing: action)), context: \(Swift.String(describing: context)), entities: \(Swift.String(describing: entities)), policyStoreId: \(Swift.String(describing: policyStoreId)), resource: \(Swift.String(describing: resource)), accessToken: \"CONTENT_REDACTED\", identityToken: \"CONTENT_REDACTED\")"}
}

public struct BatchIsAuthorizedInput: Swift.Sendable {
    /// Specifies the list of resources and principals and their associated attributes that Verified Permissions can examine when evaluating the policies. You can include only principal and resource entities in this parameter; you can't include actions. You must specify actions in the schema.
    public var entities: VerifiedPermissionsClientTypes.EntitiesDefinition?
    /// Specifies the ID of the policy store. Policies in this policy store will be used to make the authorization decisions for the input.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// An array of up to 30 requests that you want Verified Permissions to evaluate.
    /// This member is required.
    public var requests: [VerifiedPermissionsClientTypes.BatchIsAuthorizedInputItem]?

    public init(
        entities: VerifiedPermissionsClientTypes.EntitiesDefinition? = nil,
        policyStoreId: Swift.String? = nil,
        requests: [VerifiedPermissionsClientTypes.BatchIsAuthorizedInputItem]? = nil
    )
    {
        self.entities = entities
        self.policyStoreId = policyStoreId
        self.requests = requests
    }
}

public struct BatchIsAuthorizedWithTokenInput: Swift.Sendable {
    /// Specifies an access token for the principal that you want to authorize in each request. This token is provided to you by the identity provider (IdP) associated with the specified identity source. You must specify either an accessToken, an identityToken, or both. Must be an access token. Verified Permissions returns an error if the token_use claim in the submitted token isn't access.
    public var accessToken: Swift.String?
    /// Specifies the list of resources and their associated attributes that Verified Permissions can examine when evaluating the policies. You can't include principals in this parameter, only resource and action entities. This parameter can't include any entities of a type that matches the user or group entity types that you defined in your identity source.
    ///
    /// * The BatchIsAuthorizedWithToken operation takes principal attributes from only the identityToken or accessToken passed to the operation.
    ///
    /// * For action entities, you can include only their Identifier and EntityType.
    public var entities: VerifiedPermissionsClientTypes.EntitiesDefinition?
    /// Specifies an identity (ID) token for the principal that you want to authorize in each request. This token is provided to you by the identity provider (IdP) associated with the specified identity source. You must specify either an accessToken, an identityToken, or both. Must be an ID token. Verified Permissions returns an error if the token_use claim in the submitted token isn't id.
    public var identityToken: Swift.String?
    /// Specifies the ID of the policy store. Policies in this policy store will be used to make an authorization decision for the input.
    /// This member is required.
    public var policyStoreId: Swift.String?
    /// An array of up to 30 requests that you want Verified Permissions to evaluate.
    /// This member is required.
    public var requests: [VerifiedPermissionsClientTypes.BatchIsAuthorizedWithTokenInputItem]?

    public init(
        accessToken: Swift.String? = nil,
        entities: VerifiedPermissionsClientTypes.EntitiesDefinition? = nil,
        identityToken: Swift.String? = nil,
        policyStoreId: Swift.String? = nil,
        requests: [VerifiedPermissionsClientTypes.BatchIsAuthorizedWithTokenInputItem]? = nil
    )
    {
        self.accessToken = accessToken
        self.entities = entities
        self.identityToken = identityToken
        self.policyStoreId = policyStoreId
        self.requests = requests
    }
}

extension BatchIsAuthorizedWithTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchIsAuthorizedWithTokenInput(entities: \(Swift.String(describing: entities)), policyStoreId: \(Swift.String(describing: policyStoreId)), requests: \(Swift.String(describing: requests)), accessToken: \"CONTENT_REDACTED\", identityToken: \"CONTENT_REDACTED\")"}
}

extension BatchIsAuthorizedInput {

    static func urlPathProvider(_ value: BatchIsAuthorizedInput) -> Swift.String? {
        return "/"
    }
}

extension BatchIsAuthorizedWithTokenInput {

    static func urlPathProvider(_ value: BatchIsAuthorizedWithTokenInput) -> Swift.String? {
        return "/"
    }
}

extension CreateIdentitySourceInput {

    static func urlPathProvider(_ value: CreateIdentitySourceInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePolicyInput {

    static func urlPathProvider(_ value: CreatePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePolicyStoreInput {

    static func urlPathProvider(_ value: CreatePolicyStoreInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePolicyTemplateInput {

    static func urlPathProvider(_ value: CreatePolicyTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteIdentitySourceInput {

    static func urlPathProvider(_ value: DeleteIdentitySourceInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePolicyInput {

    static func urlPathProvider(_ value: DeletePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePolicyStoreInput {

    static func urlPathProvider(_ value: DeletePolicyStoreInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePolicyTemplateInput {

    static func urlPathProvider(_ value: DeletePolicyTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension GetIdentitySourceInput {

    static func urlPathProvider(_ value: GetIdentitySourceInput) -> Swift.String? {
        return "/"
    }
}

extension GetPolicyInput {

    static func urlPathProvider(_ value: GetPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetPolicyStoreInput {

    static func urlPathProvider(_ value: GetPolicyStoreInput) -> Swift.String? {
        return "/"
    }
}

extension GetPolicyTemplateInput {

    static func urlPathProvider(_ value: GetPolicyTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension GetSchemaInput {

    static func urlPathProvider(_ value: GetSchemaInput) -> Swift.String? {
        return "/"
    }
}

extension IsAuthorizedInput {

    static func urlPathProvider(_ value: IsAuthorizedInput) -> Swift.String? {
        return "/"
    }
}

extension IsAuthorizedWithTokenInput {

    static func urlPathProvider(_ value: IsAuthorizedWithTokenInput) -> Swift.String? {
        return "/"
    }
}

extension ListIdentitySourcesInput {

    static func urlPathProvider(_ value: ListIdentitySourcesInput) -> Swift.String? {
        return "/"
    }
}

extension ListPoliciesInput {

    static func urlPathProvider(_ value: ListPoliciesInput) -> Swift.String? {
        return "/"
    }
}

extension ListPolicyStoresInput {

    static func urlPathProvider(_ value: ListPolicyStoresInput) -> Swift.String? {
        return "/"
    }
}

extension ListPolicyTemplatesInput {

    static func urlPathProvider(_ value: ListPolicyTemplatesInput) -> Swift.String? {
        return "/"
    }
}

extension PutSchemaInput {

    static func urlPathProvider(_ value: PutSchemaInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateIdentitySourceInput {

    static func urlPathProvider(_ value: UpdateIdentitySourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePolicyInput {

    static func urlPathProvider(_ value: UpdatePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePolicyStoreInput {

    static func urlPathProvider(_ value: UpdatePolicyStoreInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePolicyTemplateInput {

    static func urlPathProvider(_ value: UpdatePolicyTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension BatchIsAuthorizedInput {

    static func write(value: BatchIsAuthorizedInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entities"].write(value.entities, with: VerifiedPermissionsClientTypes.EntitiesDefinition.write(value:to:))
        try writer["policyStoreId"].write(value.policyStoreId)
        try writer["requests"].writeList(value.requests, memberWritingClosure: VerifiedPermissionsClientTypes.BatchIsAuthorizedInputItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchIsAuthorizedWithTokenInput {

    static func write(value: BatchIsAuthorizedWithTokenInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessToken"].write(value.accessToken)
        try writer["entities"].write(value.entities, with: VerifiedPermissionsClientTypes.EntitiesDefinition.write(value:to:))
        try writer["identityToken"].write(value.identityToken)
        try writer["policyStoreId"].write(value.policyStoreId)
        try writer["requests"].writeList(value.requests, memberWritingClosure: VerifiedPermissionsClientTypes.BatchIsAuthorizedWithTokenInputItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateIdentitySourceInput {

    static func write(value: CreateIdentitySourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["configuration"].write(value.configuration, with: VerifiedPermissionsClientTypes.Configuration.write(value:to:))
        try writer["policyStoreId"].write(value.policyStoreId)
        try writer["principalEntityType"].write(value.principalEntityType)
    }
}

extension CreatePolicyInput {

    static func write(value: CreatePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["definition"].write(value.definition, with: VerifiedPermissionsClientTypes.PolicyDefinition.write(value:to:))
        try writer["policyStoreId"].write(value.policyStoreId)
    }
}

extension CreatePolicyStoreInput {

    static func write(value: CreatePolicyStoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["validationSettings"].write(value.validationSettings, with: VerifiedPermissionsClientTypes.ValidationSettings.write(value:to:))
    }
}

extension CreatePolicyTemplateInput {

    static func write(value: CreatePolicyTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["policyStoreId"].write(value.policyStoreId)
        try writer["statement"].write(value.statement)
    }
}

extension DeleteIdentitySourceInput {

    static func write(value: DeleteIdentitySourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identitySourceId"].write(value.identitySourceId)
        try writer["policyStoreId"].write(value.policyStoreId)
    }
}

extension DeletePolicyInput {

    static func write(value: DeletePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policyId"].write(value.policyId)
        try writer["policyStoreId"].write(value.policyStoreId)
    }
}

extension DeletePolicyStoreInput {

    static func write(value: DeletePolicyStoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policyStoreId"].write(value.policyStoreId)
    }
}

extension DeletePolicyTemplateInput {

    static func write(value: DeletePolicyTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policyStoreId"].write(value.policyStoreId)
        try writer["policyTemplateId"].write(value.policyTemplateId)
    }
}

extension GetIdentitySourceInput {

    static func write(value: GetIdentitySourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identitySourceId"].write(value.identitySourceId)
        try writer["policyStoreId"].write(value.policyStoreId)
    }
}

extension GetPolicyInput {

    static func write(value: GetPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policyId"].write(value.policyId)
        try writer["policyStoreId"].write(value.policyStoreId)
    }
}

extension GetPolicyStoreInput {

    static func write(value: GetPolicyStoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policyStoreId"].write(value.policyStoreId)
    }
}

extension GetPolicyTemplateInput {

    static func write(value: GetPolicyTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policyStoreId"].write(value.policyStoreId)
        try writer["policyTemplateId"].write(value.policyTemplateId)
    }
}

extension GetSchemaInput {

    static func write(value: GetSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policyStoreId"].write(value.policyStoreId)
    }
}

extension IsAuthorizedInput {

    static func write(value: IsAuthorizedInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: VerifiedPermissionsClientTypes.ActionIdentifier.write(value:to:))
        try writer["context"].write(value.context, with: VerifiedPermissionsClientTypes.ContextDefinition.write(value:to:))
        try writer["entities"].write(value.entities, with: VerifiedPermissionsClientTypes.EntitiesDefinition.write(value:to:))
        try writer["policyStoreId"].write(value.policyStoreId)
        try writer["principal"].write(value.principal, with: VerifiedPermissionsClientTypes.EntityIdentifier.write(value:to:))
        try writer["resource"].write(value.resource, with: VerifiedPermissionsClientTypes.EntityIdentifier.write(value:to:))
    }
}

extension IsAuthorizedWithTokenInput {

    static func write(value: IsAuthorizedWithTokenInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessToken"].write(value.accessToken)
        try writer["action"].write(value.action, with: VerifiedPermissionsClientTypes.ActionIdentifier.write(value:to:))
        try writer["context"].write(value.context, with: VerifiedPermissionsClientTypes.ContextDefinition.write(value:to:))
        try writer["entities"].write(value.entities, with: VerifiedPermissionsClientTypes.EntitiesDefinition.write(value:to:))
        try writer["identityToken"].write(value.identityToken)
        try writer["policyStoreId"].write(value.policyStoreId)
        try writer["resource"].write(value.resource, with: VerifiedPermissionsClientTypes.EntityIdentifier.write(value:to:))
    }
}

extension ListIdentitySourcesInput {

    static func write(value: ListIdentitySourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: VerifiedPermissionsClientTypes.IdentitySourceFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["policyStoreId"].write(value.policyStoreId)
    }
}

extension ListPoliciesInput {

    static func write(value: ListPoliciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: VerifiedPermissionsClientTypes.PolicyFilter.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["policyStoreId"].write(value.policyStoreId)
    }
}

extension ListPolicyStoresInput {

    static func write(value: ListPolicyStoresInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListPolicyTemplatesInput {

    static func write(value: ListPolicyTemplatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["policyStoreId"].write(value.policyStoreId)
    }
}

extension PutSchemaInput {

    static func write(value: PutSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["definition"].write(value.definition, with: VerifiedPermissionsClientTypes.SchemaDefinition.write(value:to:))
        try writer["policyStoreId"].write(value.policyStoreId)
    }
}

extension UpdateIdentitySourceInput {

    static func write(value: UpdateIdentitySourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identitySourceId"].write(value.identitySourceId)
        try writer["policyStoreId"].write(value.policyStoreId)
        try writer["principalEntityType"].write(value.principalEntityType)
        try writer["updateConfiguration"].write(value.updateConfiguration, with: VerifiedPermissionsClientTypes.UpdateConfiguration.write(value:to:))
    }
}

extension UpdatePolicyInput {

    static func write(value: UpdatePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["definition"].write(value.definition, with: VerifiedPermissionsClientTypes.UpdatePolicyDefinition.write(value:to:))
        try writer["policyId"].write(value.policyId)
        try writer["policyStoreId"].write(value.policyStoreId)
    }
}

extension UpdatePolicyStoreInput {

    static func write(value: UpdatePolicyStoreInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["policyStoreId"].write(value.policyStoreId)
        try writer["validationSettings"].write(value.validationSettings, with: VerifiedPermissionsClientTypes.ValidationSettings.write(value:to:))
    }
}

extension UpdatePolicyTemplateInput {

    static func write(value: UpdatePolicyTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["policyStoreId"].write(value.policyStoreId)
        try writer["policyTemplateId"].write(value.policyTemplateId)
        try writer["statement"].write(value.statement)
    }
}

extension BatchIsAuthorizedOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchIsAuthorizedOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchIsAuthorizedOutput()
        value.results = try reader["results"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.BatchIsAuthorizedOutputItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchIsAuthorizedWithTokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchIsAuthorizedWithTokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchIsAuthorizedWithTokenOutput()
        value.principal = try reader["principal"].readIfPresent(with: VerifiedPermissionsClientTypes.EntityIdentifier.read(from:))
        value.results = try reader["results"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.BatchIsAuthorizedWithTokenOutputItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CreateIdentitySourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIdentitySourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIdentitySourceOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.identitySourceId = try reader["identitySourceId"].readIfPresent() ?? ""
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.policyStoreId = try reader["policyStoreId"].readIfPresent() ?? ""
        return value
    }
}

extension CreatePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePolicyOutput()
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.ActionIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.effect = try reader["effect"].readIfPresent()
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.policyId = try reader["policyId"].readIfPresent() ?? ""
        value.policyStoreId = try reader["policyStoreId"].readIfPresent() ?? ""
        value.policyType = try reader["policyType"].readIfPresent() ?? .sdkUnknown("")
        value.principal = try reader["principal"].readIfPresent(with: VerifiedPermissionsClientTypes.EntityIdentifier.read(from:))
        value.resource = try reader["resource"].readIfPresent(with: VerifiedPermissionsClientTypes.EntityIdentifier.read(from:))
        return value
    }
}

extension CreatePolicyStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePolicyStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePolicyStoreOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.policyStoreId = try reader["policyStoreId"].readIfPresent() ?? ""
        return value
    }
}

extension CreatePolicyTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePolicyTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePolicyTemplateOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.policyStoreId = try reader["policyStoreId"].readIfPresent() ?? ""
        value.policyTemplateId = try reader["policyTemplateId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteIdentitySourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIdentitySourceOutput {
        return DeleteIdentitySourceOutput()
    }
}

extension DeletePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePolicyOutput {
        return DeletePolicyOutput()
    }
}

extension DeletePolicyStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePolicyStoreOutput {
        return DeletePolicyStoreOutput()
    }
}

extension DeletePolicyTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePolicyTemplateOutput {
        return DeletePolicyTemplateOutput()
    }
}

extension GetIdentitySourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIdentitySourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIdentitySourceOutput()
        value.configuration = try reader["configuration"].readIfPresent(with: VerifiedPermissionsClientTypes.ConfigurationDetail.read(from:))
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.details = try reader["details"].readIfPresent(with: VerifiedPermissionsClientTypes.IdentitySourceDetails.read(from:))
        value.identitySourceId = try reader["identitySourceId"].readIfPresent() ?? ""
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.policyStoreId = try reader["policyStoreId"].readIfPresent() ?? ""
        value.principalEntityType = try reader["principalEntityType"].readIfPresent() ?? ""
        return value
    }
}

extension GetPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPolicyOutput()
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.ActionIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.definition = try reader["definition"].readIfPresent(with: VerifiedPermissionsClientTypes.PolicyDefinitionDetail.read(from:))
        value.effect = try reader["effect"].readIfPresent()
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.policyId = try reader["policyId"].readIfPresent() ?? ""
        value.policyStoreId = try reader["policyStoreId"].readIfPresent() ?? ""
        value.policyType = try reader["policyType"].readIfPresent() ?? .sdkUnknown("")
        value.principal = try reader["principal"].readIfPresent(with: VerifiedPermissionsClientTypes.EntityIdentifier.read(from:))
        value.resource = try reader["resource"].readIfPresent(with: VerifiedPermissionsClientTypes.EntityIdentifier.read(from:))
        return value
    }
}

extension GetPolicyStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPolicyStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPolicyStoreOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.policyStoreId = try reader["policyStoreId"].readIfPresent() ?? ""
        value.validationSettings = try reader["validationSettings"].readIfPresent(with: VerifiedPermissionsClientTypes.ValidationSettings.read(from:))
        return value
    }
}

extension GetPolicyTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPolicyTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPolicyTemplateOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.policyStoreId = try reader["policyStoreId"].readIfPresent() ?? ""
        value.policyTemplateId = try reader["policyTemplateId"].readIfPresent() ?? ""
        value.statement = try reader["statement"].readIfPresent() ?? ""
        return value
    }
}

extension GetSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSchemaOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.namespaces = try reader["namespaces"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.policyStoreId = try reader["policyStoreId"].readIfPresent() ?? ""
        value.schema = try reader["schema"].readIfPresent() ?? ""
        return value
    }
}

extension IsAuthorizedOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> IsAuthorizedOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = IsAuthorizedOutput()
        value.decision = try reader["decision"].readIfPresent() ?? .sdkUnknown("")
        value.determiningPolicies = try reader["determiningPolicies"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.DeterminingPolicyItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.EvaluationErrorItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IsAuthorizedWithTokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> IsAuthorizedWithTokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = IsAuthorizedWithTokenOutput()
        value.decision = try reader["decision"].readIfPresent() ?? .sdkUnknown("")
        value.determiningPolicies = try reader["determiningPolicies"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.DeterminingPolicyItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.EvaluationErrorItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.principal = try reader["principal"].readIfPresent(with: VerifiedPermissionsClientTypes.EntityIdentifier.read(from:))
        return value
    }
}

extension ListIdentitySourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIdentitySourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIdentitySourcesOutput()
        value.identitySources = try reader["identitySources"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.IdentitySourceItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPoliciesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.policies = try reader["policies"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.PolicyItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListPolicyStoresOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPolicyStoresOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPolicyStoresOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.policyStores = try reader["policyStores"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.PolicyStoreItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListPolicyTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPolicyTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPolicyTemplatesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.policyTemplates = try reader["policyTemplates"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.PolicyTemplateItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PutSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutSchemaOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.namespaces = try reader["namespaces"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.policyStoreId = try reader["policyStoreId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateIdentitySourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIdentitySourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIdentitySourceOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.identitySourceId = try reader["identitySourceId"].readIfPresent() ?? ""
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.policyStoreId = try reader["policyStoreId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdatePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePolicyOutput()
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.ActionIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.effect = try reader["effect"].readIfPresent()
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.policyId = try reader["policyId"].readIfPresent() ?? ""
        value.policyStoreId = try reader["policyStoreId"].readIfPresent() ?? ""
        value.policyType = try reader["policyType"].readIfPresent() ?? .sdkUnknown("")
        value.principal = try reader["principal"].readIfPresent(with: VerifiedPermissionsClientTypes.EntityIdentifier.read(from:))
        value.resource = try reader["resource"].readIfPresent(with: VerifiedPermissionsClientTypes.EntityIdentifier.read(from:))
        return value
    }
}

extension UpdatePolicyStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePolicyStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePolicyStoreOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.policyStoreId = try reader["policyStoreId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdatePolicyTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePolicyTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePolicyTemplateOutput()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.policyStoreId = try reader["policyStoreId"].readIfPresent() ?? ""
        value.policyTemplateId = try reader["policyTemplateId"].readIfPresent() ?? ""
        return value
    }
}

func httpServiceError(baseError: AWSClientRuntime.AWSJSONError) throws -> Swift.Error? {
    switch baseError.code {
        case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
        case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
        case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
        case "ValidationException": return try ValidationException.makeError(baseError: baseError)
        default: return nil
    }
}

enum BatchIsAuthorizedOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchIsAuthorizedWithTokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIdentitySourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePolicyStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePolicyTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIdentitySourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePolicyStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePolicyTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIdentitySourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPolicyStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPolicyTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum IsAuthorizedOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum IsAuthorizedWithTokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIdentitySourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPolicyStoresOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPolicyTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIdentitySourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePolicyStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePolicyTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resources = try reader["resources"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.ResourceConflict.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension VerifiedPermissionsClientTypes.BatchIsAuthorizedOutputItem {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.BatchIsAuthorizedOutputItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.BatchIsAuthorizedOutputItem()
        value.request = try reader["request"].readIfPresent(with: VerifiedPermissionsClientTypes.BatchIsAuthorizedInputItem.read(from:))
        value.decision = try reader["decision"].readIfPresent() ?? .sdkUnknown("")
        value.determiningPolicies = try reader["determiningPolicies"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.DeterminingPolicyItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.EvaluationErrorItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension VerifiedPermissionsClientTypes.EvaluationErrorItem {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.EvaluationErrorItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.EvaluationErrorItem()
        value.errorDescription = try reader["errorDescription"].readIfPresent() ?? ""
        return value
    }
}

extension VerifiedPermissionsClientTypes.DeterminingPolicyItem {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.DeterminingPolicyItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.DeterminingPolicyItem()
        value.policyId = try reader["policyId"].readIfPresent() ?? ""
        return value
    }
}

extension VerifiedPermissionsClientTypes.BatchIsAuthorizedInputItem {

    static func write(value: VerifiedPermissionsClientTypes.BatchIsAuthorizedInputItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: VerifiedPermissionsClientTypes.ActionIdentifier.write(value:to:))
        try writer["context"].write(value.context, with: VerifiedPermissionsClientTypes.ContextDefinition.write(value:to:))
        try writer["principal"].write(value.principal, with: VerifiedPermissionsClientTypes.EntityIdentifier.write(value:to:))
        try writer["resource"].write(value.resource, with: VerifiedPermissionsClientTypes.EntityIdentifier.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.BatchIsAuthorizedInputItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.BatchIsAuthorizedInputItem()
        value.principal = try reader["principal"].readIfPresent(with: VerifiedPermissionsClientTypes.EntityIdentifier.read(from:))
        value.action = try reader["action"].readIfPresent(with: VerifiedPermissionsClientTypes.ActionIdentifier.read(from:))
        value.resource = try reader["resource"].readIfPresent(with: VerifiedPermissionsClientTypes.EntityIdentifier.read(from:))
        value.context = try reader["context"].readIfPresent(with: VerifiedPermissionsClientTypes.ContextDefinition.read(from:))
        return value
    }
}

extension VerifiedPermissionsClientTypes.ContextDefinition {

    static func write(value: VerifiedPermissionsClientTypes.ContextDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .contextmap(contextmap):
                try writer["contextMap"].writeMap(contextmap, valueWritingClosure: VerifiedPermissionsClientTypes.AttributeValue.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.ContextDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "contextMap":
                return .contextmap(try reader["contextMap"].readMap(valueReadingClosure: VerifiedPermissionsClientTypes.AttributeValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VerifiedPermissionsClientTypes.AttributeValue {

    static func write(value: VerifiedPermissionsClientTypes.AttributeValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .boolean(boolean):
                try writer["boolean"].write(boolean)
            case let .entityidentifier(entityidentifier):
                try writer["entityIdentifier"].write(entityidentifier, with: VerifiedPermissionsClientTypes.EntityIdentifier.write(value:to:))
            case let .long(long):
                try writer["long"].write(long)
            case let .record(record):
                try writer["record"].writeMap(record, valueWritingClosure: VerifiedPermissionsClientTypes.AttributeValue.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            case let .`set`(`set`):
                try writer["set"].writeList(`set`, memberWritingClosure: VerifiedPermissionsClientTypes.AttributeValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .string(string):
                try writer["string"].write(string)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.AttributeValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "boolean":
                return .boolean(try reader["boolean"].read())
            case "entityIdentifier":
                return .entityidentifier(try reader["entityIdentifier"].read(with: VerifiedPermissionsClientTypes.EntityIdentifier.read(from:)))
            case "long":
                return .long(try reader["long"].read())
            case "string":
                return .string(try reader["string"].read())
            case "set":
                return .`set`(try reader["set"].readList(memberReadingClosure: VerifiedPermissionsClientTypes.AttributeValue.read(from:), memberNodeInfo: "member", isFlattened: false))
            case "record":
                return .record(try reader["record"].readMap(valueReadingClosure: VerifiedPermissionsClientTypes.AttributeValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VerifiedPermissionsClientTypes.EntityIdentifier {

    static func write(value: VerifiedPermissionsClientTypes.EntityIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entityId"].write(value.entityId)
        try writer["entityType"].write(value.entityType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.EntityIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.EntityIdentifier()
        value.entityType = try reader["entityType"].readIfPresent() ?? ""
        value.entityId = try reader["entityId"].readIfPresent() ?? ""
        return value
    }
}

extension VerifiedPermissionsClientTypes.ActionIdentifier {

    static func write(value: VerifiedPermissionsClientTypes.ActionIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionId"].write(value.actionId)
        try writer["actionType"].write(value.actionType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.ActionIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.ActionIdentifier()
        value.actionType = try reader["actionType"].readIfPresent() ?? ""
        value.actionId = try reader["actionId"].readIfPresent() ?? ""
        return value
    }
}

extension VerifiedPermissionsClientTypes.BatchIsAuthorizedWithTokenOutputItem {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.BatchIsAuthorizedWithTokenOutputItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.BatchIsAuthorizedWithTokenOutputItem()
        value.request = try reader["request"].readIfPresent(with: VerifiedPermissionsClientTypes.BatchIsAuthorizedWithTokenInputItem.read(from:))
        value.decision = try reader["decision"].readIfPresent() ?? .sdkUnknown("")
        value.determiningPolicies = try reader["determiningPolicies"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.DeterminingPolicyItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.EvaluationErrorItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension VerifiedPermissionsClientTypes.BatchIsAuthorizedWithTokenInputItem {

    static func write(value: VerifiedPermissionsClientTypes.BatchIsAuthorizedWithTokenInputItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action, with: VerifiedPermissionsClientTypes.ActionIdentifier.write(value:to:))
        try writer["context"].write(value.context, with: VerifiedPermissionsClientTypes.ContextDefinition.write(value:to:))
        try writer["resource"].write(value.resource, with: VerifiedPermissionsClientTypes.EntityIdentifier.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.BatchIsAuthorizedWithTokenInputItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.BatchIsAuthorizedWithTokenInputItem()
        value.action = try reader["action"].readIfPresent(with: VerifiedPermissionsClientTypes.ActionIdentifier.read(from:))
        value.resource = try reader["resource"].readIfPresent(with: VerifiedPermissionsClientTypes.EntityIdentifier.read(from:))
        value.context = try reader["context"].readIfPresent(with: VerifiedPermissionsClientTypes.ContextDefinition.read(from:))
        return value
    }
}

extension VerifiedPermissionsClientTypes.IdentitySourceDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.IdentitySourceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.IdentitySourceDetails()
        value.clientIds = try reader["clientIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.userPoolArn = try reader["userPoolArn"].readIfPresent()
        value.discoveryUrl = try reader["discoveryUrl"].readIfPresent()
        value.openIdIssuer = try reader["openIdIssuer"].readIfPresent()
        return value
    }
}

extension VerifiedPermissionsClientTypes.ConfigurationDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.ConfigurationDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "cognitoUserPoolConfiguration":
                return .cognitouserpoolconfiguration(try reader["cognitoUserPoolConfiguration"].read(with: VerifiedPermissionsClientTypes.CognitoUserPoolConfigurationDetail.read(from:)))
            case "openIdConnectConfiguration":
                return .openidconnectconfiguration(try reader["openIdConnectConfiguration"].read(with: VerifiedPermissionsClientTypes.OpenIdConnectConfigurationDetail.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectConfigurationDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.OpenIdConnectConfigurationDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.OpenIdConnectConfigurationDetail()
        value.issuer = try reader["issuer"].readIfPresent() ?? ""
        value.entityIdPrefix = try reader["entityIdPrefix"].readIfPresent()
        value.groupConfiguration = try reader["groupConfiguration"].readIfPresent(with: VerifiedPermissionsClientTypes.OpenIdConnectGroupConfigurationDetail.read(from:))
        value.tokenSelection = try reader["tokenSelection"].readIfPresent(with: VerifiedPermissionsClientTypes.OpenIdConnectTokenSelectionDetail.read(from:))
        return value
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectTokenSelectionDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.OpenIdConnectTokenSelectionDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "accessTokenOnly":
                return .accesstokenonly(try reader["accessTokenOnly"].read(with: VerifiedPermissionsClientTypes.OpenIdConnectAccessTokenConfigurationDetail.read(from:)))
            case "identityTokenOnly":
                return .identitytokenonly(try reader["identityTokenOnly"].read(with: VerifiedPermissionsClientTypes.OpenIdConnectIdentityTokenConfigurationDetail.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectIdentityTokenConfigurationDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.OpenIdConnectIdentityTokenConfigurationDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.OpenIdConnectIdentityTokenConfigurationDetail()
        value.principalIdClaim = try reader["principalIdClaim"].readIfPresent() ?? "sub"
        value.clientIds = try reader["clientIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectAccessTokenConfigurationDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.OpenIdConnectAccessTokenConfigurationDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.OpenIdConnectAccessTokenConfigurationDetail()
        value.principalIdClaim = try reader["principalIdClaim"].readIfPresent() ?? "sub"
        value.audiences = try reader["audiences"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectGroupConfigurationDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.OpenIdConnectGroupConfigurationDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.OpenIdConnectGroupConfigurationDetail()
        value.groupClaim = try reader["groupClaim"].readIfPresent() ?? ""
        value.groupEntityType = try reader["groupEntityType"].readIfPresent() ?? ""
        return value
    }
}

extension VerifiedPermissionsClientTypes.CognitoUserPoolConfigurationDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.CognitoUserPoolConfigurationDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.CognitoUserPoolConfigurationDetail()
        value.userPoolArn = try reader["userPoolArn"].readIfPresent() ?? ""
        value.clientIds = try reader["clientIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.issuer = try reader["issuer"].readIfPresent() ?? ""
        value.groupConfiguration = try reader["groupConfiguration"].readIfPresent(with: VerifiedPermissionsClientTypes.CognitoGroupConfigurationDetail.read(from:))
        return value
    }
}

extension VerifiedPermissionsClientTypes.CognitoGroupConfigurationDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.CognitoGroupConfigurationDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.CognitoGroupConfigurationDetail()
        value.groupEntityType = try reader["groupEntityType"].readIfPresent()
        return value
    }
}

extension VerifiedPermissionsClientTypes.PolicyDefinitionDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.PolicyDefinitionDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "static":
                return .`static`(try reader["static"].read(with: VerifiedPermissionsClientTypes.StaticPolicyDefinitionDetail.read(from:)))
            case "templateLinked":
                return .templatelinked(try reader["templateLinked"].read(with: VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinitionDetail.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinitionDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinitionDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinitionDetail()
        value.policyTemplateId = try reader["policyTemplateId"].readIfPresent() ?? ""
        value.principal = try reader["principal"].readIfPresent(with: VerifiedPermissionsClientTypes.EntityIdentifier.read(from:))
        value.resource = try reader["resource"].readIfPresent(with: VerifiedPermissionsClientTypes.EntityIdentifier.read(from:))
        return value
    }
}

extension VerifiedPermissionsClientTypes.StaticPolicyDefinitionDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.StaticPolicyDefinitionDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.StaticPolicyDefinitionDetail()
        value.description = try reader["description"].readIfPresent()
        value.statement = try reader["statement"].readIfPresent() ?? ""
        return value
    }
}

extension VerifiedPermissionsClientTypes.ValidationSettings {

    static func write(value: VerifiedPermissionsClientTypes.ValidationSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mode"].write(value.mode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.ValidationSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.ValidationSettings()
        value.mode = try reader["mode"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension VerifiedPermissionsClientTypes.IdentitySourceItem {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.IdentitySourceItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.IdentitySourceItem()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.details = try reader["details"].readIfPresent(with: VerifiedPermissionsClientTypes.IdentitySourceItemDetails.read(from:))
        value.identitySourceId = try reader["identitySourceId"].readIfPresent() ?? ""
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.policyStoreId = try reader["policyStoreId"].readIfPresent() ?? ""
        value.principalEntityType = try reader["principalEntityType"].readIfPresent() ?? ""
        value.configuration = try reader["configuration"].readIfPresent(with: VerifiedPermissionsClientTypes.ConfigurationItem.read(from:))
        return value
    }
}

extension VerifiedPermissionsClientTypes.ConfigurationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.ConfigurationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "cognitoUserPoolConfiguration":
                return .cognitouserpoolconfiguration(try reader["cognitoUserPoolConfiguration"].read(with: VerifiedPermissionsClientTypes.CognitoUserPoolConfigurationItem.read(from:)))
            case "openIdConnectConfiguration":
                return .openidconnectconfiguration(try reader["openIdConnectConfiguration"].read(with: VerifiedPermissionsClientTypes.OpenIdConnectConfigurationItem.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectConfigurationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.OpenIdConnectConfigurationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.OpenIdConnectConfigurationItem()
        value.issuer = try reader["issuer"].readIfPresent() ?? ""
        value.entityIdPrefix = try reader["entityIdPrefix"].readIfPresent()
        value.groupConfiguration = try reader["groupConfiguration"].readIfPresent(with: VerifiedPermissionsClientTypes.OpenIdConnectGroupConfigurationItem.read(from:))
        value.tokenSelection = try reader["tokenSelection"].readIfPresent(with: VerifiedPermissionsClientTypes.OpenIdConnectTokenSelectionItem.read(from:))
        return value
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectTokenSelectionItem {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.OpenIdConnectTokenSelectionItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "accessTokenOnly":
                return .accesstokenonly(try reader["accessTokenOnly"].read(with: VerifiedPermissionsClientTypes.OpenIdConnectAccessTokenConfigurationItem.read(from:)))
            case "identityTokenOnly":
                return .identitytokenonly(try reader["identityTokenOnly"].read(with: VerifiedPermissionsClientTypes.OpenIdConnectIdentityTokenConfigurationItem.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectIdentityTokenConfigurationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.OpenIdConnectIdentityTokenConfigurationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.OpenIdConnectIdentityTokenConfigurationItem()
        value.principalIdClaim = try reader["principalIdClaim"].readIfPresent() ?? "sub"
        value.clientIds = try reader["clientIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectAccessTokenConfigurationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.OpenIdConnectAccessTokenConfigurationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.OpenIdConnectAccessTokenConfigurationItem()
        value.principalIdClaim = try reader["principalIdClaim"].readIfPresent() ?? "sub"
        value.audiences = try reader["audiences"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectGroupConfigurationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.OpenIdConnectGroupConfigurationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.OpenIdConnectGroupConfigurationItem()
        value.groupClaim = try reader["groupClaim"].readIfPresent() ?? ""
        value.groupEntityType = try reader["groupEntityType"].readIfPresent() ?? ""
        return value
    }
}

extension VerifiedPermissionsClientTypes.CognitoUserPoolConfigurationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.CognitoUserPoolConfigurationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.CognitoUserPoolConfigurationItem()
        value.userPoolArn = try reader["userPoolArn"].readIfPresent() ?? ""
        value.clientIds = try reader["clientIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.issuer = try reader["issuer"].readIfPresent() ?? ""
        value.groupConfiguration = try reader["groupConfiguration"].readIfPresent(with: VerifiedPermissionsClientTypes.CognitoGroupConfigurationItem.read(from:))
        return value
    }
}

extension VerifiedPermissionsClientTypes.CognitoGroupConfigurationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.CognitoGroupConfigurationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.CognitoGroupConfigurationItem()
        value.groupEntityType = try reader["groupEntityType"].readIfPresent()
        return value
    }
}

extension VerifiedPermissionsClientTypes.IdentitySourceItemDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.IdentitySourceItemDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.IdentitySourceItemDetails()
        value.clientIds = try reader["clientIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.userPoolArn = try reader["userPoolArn"].readIfPresent()
        value.discoveryUrl = try reader["discoveryUrl"].readIfPresent()
        value.openIdIssuer = try reader["openIdIssuer"].readIfPresent()
        return value
    }
}

extension VerifiedPermissionsClientTypes.PolicyItem {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.PolicyItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.PolicyItem()
        value.policyStoreId = try reader["policyStoreId"].readIfPresent() ?? ""
        value.policyId = try reader["policyId"].readIfPresent() ?? ""
        value.policyType = try reader["policyType"].readIfPresent() ?? .sdkUnknown("")
        value.principal = try reader["principal"].readIfPresent(with: VerifiedPermissionsClientTypes.EntityIdentifier.read(from:))
        value.resource = try reader["resource"].readIfPresent(with: VerifiedPermissionsClientTypes.EntityIdentifier.read(from:))
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: VerifiedPermissionsClientTypes.ActionIdentifier.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.definition = try reader["definition"].readIfPresent(with: VerifiedPermissionsClientTypes.PolicyDefinitionItem.read(from:))
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.effect = try reader["effect"].readIfPresent()
        return value
    }
}

extension VerifiedPermissionsClientTypes.PolicyDefinitionItem {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.PolicyDefinitionItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "static":
                return .`static`(try reader["static"].read(with: VerifiedPermissionsClientTypes.StaticPolicyDefinitionItem.read(from:)))
            case "templateLinked":
                return .templatelinked(try reader["templateLinked"].read(with: VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinitionItem.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinitionItem {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinitionItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinitionItem()
        value.policyTemplateId = try reader["policyTemplateId"].readIfPresent() ?? ""
        value.principal = try reader["principal"].readIfPresent(with: VerifiedPermissionsClientTypes.EntityIdentifier.read(from:))
        value.resource = try reader["resource"].readIfPresent(with: VerifiedPermissionsClientTypes.EntityIdentifier.read(from:))
        return value
    }
}

extension VerifiedPermissionsClientTypes.StaticPolicyDefinitionItem {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.StaticPolicyDefinitionItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.StaticPolicyDefinitionItem()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension VerifiedPermissionsClientTypes.PolicyStoreItem {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.PolicyStoreItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.PolicyStoreItem()
        value.policyStoreId = try reader["policyStoreId"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension VerifiedPermissionsClientTypes.PolicyTemplateItem {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.PolicyTemplateItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.PolicyTemplateItem()
        value.policyStoreId = try reader["policyStoreId"].readIfPresent() ?? ""
        value.policyTemplateId = try reader["policyTemplateId"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.createdDate = try reader["createdDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedDate = try reader["lastUpdatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension VerifiedPermissionsClientTypes.ResourceConflict {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.ResourceConflict {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.ResourceConflict()
        value.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension VerifiedPermissionsClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> VerifiedPermissionsClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VerifiedPermissionsClientTypes.ValidationExceptionField()
        value.path = try reader["path"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension VerifiedPermissionsClientTypes.EntitiesDefinition {

    static func write(value: VerifiedPermissionsClientTypes.EntitiesDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .entitylist(entitylist):
                try writer["entityList"].writeList(entitylist, memberWritingClosure: VerifiedPermissionsClientTypes.EntityItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension VerifiedPermissionsClientTypes.EntityItem {

    static func write(value: VerifiedPermissionsClientTypes.EntityItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: VerifiedPermissionsClientTypes.AttributeValue.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["identifier"].write(value.identifier, with: VerifiedPermissionsClientTypes.EntityIdentifier.write(value:to:))
        try writer["parents"].writeList(value.parents, memberWritingClosure: VerifiedPermissionsClientTypes.EntityIdentifier.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension VerifiedPermissionsClientTypes.Configuration {

    static func write(value: VerifiedPermissionsClientTypes.Configuration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .cognitouserpoolconfiguration(cognitouserpoolconfiguration):
                try writer["cognitoUserPoolConfiguration"].write(cognitouserpoolconfiguration, with: VerifiedPermissionsClientTypes.CognitoUserPoolConfiguration.write(value:to:))
            case let .openidconnectconfiguration(openidconnectconfiguration):
                try writer["openIdConnectConfiguration"].write(openidconnectconfiguration, with: VerifiedPermissionsClientTypes.OpenIdConnectConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectConfiguration {

    static func write(value: VerifiedPermissionsClientTypes.OpenIdConnectConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entityIdPrefix"].write(value.entityIdPrefix)
        try writer["groupConfiguration"].write(value.groupConfiguration, with: VerifiedPermissionsClientTypes.OpenIdConnectGroupConfiguration.write(value:to:))
        try writer["issuer"].write(value.issuer)
        try writer["tokenSelection"].write(value.tokenSelection, with: VerifiedPermissionsClientTypes.OpenIdConnectTokenSelection.write(value:to:))
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectTokenSelection {

    static func write(value: VerifiedPermissionsClientTypes.OpenIdConnectTokenSelection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .accesstokenonly(accesstokenonly):
                try writer["accessTokenOnly"].write(accesstokenonly, with: VerifiedPermissionsClientTypes.OpenIdConnectAccessTokenConfiguration.write(value:to:))
            case let .identitytokenonly(identitytokenonly):
                try writer["identityTokenOnly"].write(identitytokenonly, with: VerifiedPermissionsClientTypes.OpenIdConnectIdentityTokenConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectIdentityTokenConfiguration {

    static func write(value: VerifiedPermissionsClientTypes.OpenIdConnectIdentityTokenConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientIds"].writeList(value.clientIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["principalIdClaim"].write(value.principalIdClaim)
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectAccessTokenConfiguration {

    static func write(value: VerifiedPermissionsClientTypes.OpenIdConnectAccessTokenConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["audiences"].writeList(value.audiences, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["principalIdClaim"].write(value.principalIdClaim)
    }
}

extension VerifiedPermissionsClientTypes.OpenIdConnectGroupConfiguration {

    static func write(value: VerifiedPermissionsClientTypes.OpenIdConnectGroupConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["groupClaim"].write(value.groupClaim)
        try writer["groupEntityType"].write(value.groupEntityType)
    }
}

extension VerifiedPermissionsClientTypes.CognitoUserPoolConfiguration {

    static func write(value: VerifiedPermissionsClientTypes.CognitoUserPoolConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientIds"].writeList(value.clientIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["groupConfiguration"].write(value.groupConfiguration, with: VerifiedPermissionsClientTypes.CognitoGroupConfiguration.write(value:to:))
        try writer["userPoolArn"].write(value.userPoolArn)
    }
}

extension VerifiedPermissionsClientTypes.CognitoGroupConfiguration {

    static func write(value: VerifiedPermissionsClientTypes.CognitoGroupConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["groupEntityType"].write(value.groupEntityType)
    }
}

extension VerifiedPermissionsClientTypes.PolicyDefinition {

    static func write(value: VerifiedPermissionsClientTypes.PolicyDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .`static`(`static`):
                try writer["static"].write(`static`, with: VerifiedPermissionsClientTypes.StaticPolicyDefinition.write(value:to:))
            case let .templatelinked(templatelinked):
                try writer["templateLinked"].write(templatelinked, with: VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinition.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinition {

    static func write(value: VerifiedPermissionsClientTypes.TemplateLinkedPolicyDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policyTemplateId"].write(value.policyTemplateId)
        try writer["principal"].write(value.principal, with: VerifiedPermissionsClientTypes.EntityIdentifier.write(value:to:))
        try writer["resource"].write(value.resource, with: VerifiedPermissionsClientTypes.EntityIdentifier.write(value:to:))
    }
}

extension VerifiedPermissionsClientTypes.StaticPolicyDefinition {

    static func write(value: VerifiedPermissionsClientTypes.StaticPolicyDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["statement"].write(value.statement)
    }
}

extension VerifiedPermissionsClientTypes.IdentitySourceFilter {

    static func write(value: VerifiedPermissionsClientTypes.IdentitySourceFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["principalEntityType"].write(value.principalEntityType)
    }
}

extension VerifiedPermissionsClientTypes.PolicyFilter {

    static func write(value: VerifiedPermissionsClientTypes.PolicyFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["policyTemplateId"].write(value.policyTemplateId)
        try writer["policyType"].write(value.policyType)
        try writer["principal"].write(value.principal, with: VerifiedPermissionsClientTypes.EntityReference.write(value:to:))
        try writer["resource"].write(value.resource, with: VerifiedPermissionsClientTypes.EntityReference.write(value:to:))
    }
}

extension VerifiedPermissionsClientTypes.EntityReference {

    static func write(value: VerifiedPermissionsClientTypes.EntityReference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .identifier(identifier):
                try writer["identifier"].write(identifier, with: VerifiedPermissionsClientTypes.EntityIdentifier.write(value:to:))
            case let .unspecified(unspecified):
                try writer["unspecified"].write(unspecified)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension VerifiedPermissionsClientTypes.SchemaDefinition {

    static func write(value: VerifiedPermissionsClientTypes.SchemaDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .cedarjson(cedarjson):
                try writer["cedarJson"].write(cedarjson)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension VerifiedPermissionsClientTypes.UpdateConfiguration {

    static func write(value: VerifiedPermissionsClientTypes.UpdateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .cognitouserpoolconfiguration(cognitouserpoolconfiguration):
                try writer["cognitoUserPoolConfiguration"].write(cognitouserpoolconfiguration, with: VerifiedPermissionsClientTypes.UpdateCognitoUserPoolConfiguration.write(value:to:))
            case let .openidconnectconfiguration(openidconnectconfiguration):
                try writer["openIdConnectConfiguration"].write(openidconnectconfiguration, with: VerifiedPermissionsClientTypes.UpdateOpenIdConnectConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension VerifiedPermissionsClientTypes.UpdateOpenIdConnectConfiguration {

    static func write(value: VerifiedPermissionsClientTypes.UpdateOpenIdConnectConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entityIdPrefix"].write(value.entityIdPrefix)
        try writer["groupConfiguration"].write(value.groupConfiguration, with: VerifiedPermissionsClientTypes.UpdateOpenIdConnectGroupConfiguration.write(value:to:))
        try writer["issuer"].write(value.issuer)
        try writer["tokenSelection"].write(value.tokenSelection, with: VerifiedPermissionsClientTypes.UpdateOpenIdConnectTokenSelection.write(value:to:))
    }
}

extension VerifiedPermissionsClientTypes.UpdateOpenIdConnectTokenSelection {

    static func write(value: VerifiedPermissionsClientTypes.UpdateOpenIdConnectTokenSelection?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .accesstokenonly(accesstokenonly):
                try writer["accessTokenOnly"].write(accesstokenonly, with: VerifiedPermissionsClientTypes.UpdateOpenIdConnectAccessTokenConfiguration.write(value:to:))
            case let .identitytokenonly(identitytokenonly):
                try writer["identityTokenOnly"].write(identitytokenonly, with: VerifiedPermissionsClientTypes.UpdateOpenIdConnectIdentityTokenConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension VerifiedPermissionsClientTypes.UpdateOpenIdConnectIdentityTokenConfiguration {

    static func write(value: VerifiedPermissionsClientTypes.UpdateOpenIdConnectIdentityTokenConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientIds"].writeList(value.clientIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["principalIdClaim"].write(value.principalIdClaim)
    }
}

extension VerifiedPermissionsClientTypes.UpdateOpenIdConnectAccessTokenConfiguration {

    static func write(value: VerifiedPermissionsClientTypes.UpdateOpenIdConnectAccessTokenConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["audiences"].writeList(value.audiences, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["principalIdClaim"].write(value.principalIdClaim)
    }
}

extension VerifiedPermissionsClientTypes.UpdateOpenIdConnectGroupConfiguration {

    static func write(value: VerifiedPermissionsClientTypes.UpdateOpenIdConnectGroupConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["groupClaim"].write(value.groupClaim)
        try writer["groupEntityType"].write(value.groupEntityType)
    }
}

extension VerifiedPermissionsClientTypes.UpdateCognitoUserPoolConfiguration {

    static func write(value: VerifiedPermissionsClientTypes.UpdateCognitoUserPoolConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientIds"].writeList(value.clientIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["groupConfiguration"].write(value.groupConfiguration, with: VerifiedPermissionsClientTypes.UpdateCognitoGroupConfiguration.write(value:to:))
        try writer["userPoolArn"].write(value.userPoolArn)
    }
}

extension VerifiedPermissionsClientTypes.UpdateCognitoGroupConfiguration {

    static func write(value: VerifiedPermissionsClientTypes.UpdateCognitoGroupConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["groupEntityType"].write(value.groupEntityType)
    }
}

extension VerifiedPermissionsClientTypes.UpdatePolicyDefinition {

    static func write(value: VerifiedPermissionsClientTypes.UpdatePolicyDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .`static`(`static`):
                try writer["static"].write(`static`, with: VerifiedPermissionsClientTypes.UpdateStaticPolicyDefinition.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension VerifiedPermissionsClientTypes.UpdateStaticPolicyDefinition {

    static func write(value: VerifiedPermissionsClientTypes.UpdateStaticPolicyDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["statement"].write(value.statement)
    }
}

public enum VerifiedPermissionsClientTypes {}
