//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox


public struct DeleteDomainOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFraudsterOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteSpeakerOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteWatchlistOutput: Swift.Sendable {

    public init() { }
}

/// You do not have sufficient permissions to perform this action. Check the error message and try again.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension VoiceIDClientTypes {

    public enum ConflictType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case anotherActiveStream
        case cannotChangeSpeakerAfterEnrollment
        case cannotDeleteNonEmptyWatchlist
        case concurrentChanges
        case domainLockedFromEncryptionUpdates
        case domainNotActive
        case enrollmentAlreadyExists
        case fraudsterMustBelongToAtLeastOneWatchlist
        case speakerNotSet
        case speakerOptedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictType] {
            return [
                .anotherActiveStream,
                .cannotChangeSpeakerAfterEnrollment,
                .cannotDeleteNonEmptyWatchlist,
                .concurrentChanges,
                .domainLockedFromEncryptionUpdates,
                .domainNotActive,
                .enrollmentAlreadyExists,
                .fraudsterMustBelongToAtLeastOneWatchlist,
                .speakerNotSet,
                .speakerOptedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .anotherActiveStream: return "ANOTHER_ACTIVE_STREAM"
            case .cannotChangeSpeakerAfterEnrollment: return "CANNOT_CHANGE_SPEAKER_AFTER_ENROLLMENT"
            case .cannotDeleteNonEmptyWatchlist: return "CANNOT_DELETE_NON_EMPTY_WATCHLIST"
            case .concurrentChanges: return "CONCURRENT_CHANGES"
            case .domainLockedFromEncryptionUpdates: return "DOMAIN_LOCKED_FROM_ENCRYPTION_UPDATES"
            case .domainNotActive: return "DOMAIN_NOT_ACTIVE"
            case .enrollmentAlreadyExists: return "ENROLLMENT_ALREADY_EXISTS"
            case .fraudsterMustBelongToAtLeastOneWatchlist: return "FRAUDSTER_MUST_BELONG_TO_AT_LEAST_ONE_WATCHLIST"
            case .speakerNotSet: return "SPEAKER_NOT_SET"
            case .speakerOptedOut: return "SPEAKER_OPTED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request failed due to a conflict. Check the ConflictType and error message for more details.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The type of conflict which caused a ConflictException. Possible types and the corresponding error messages are as follows:
        ///
        /// * DOMAIN_NOT_ACTIVE: The domain is not active.
        ///
        /// * CANNOT_CHANGE_SPEAKER_AFTER_ENROLLMENT: You cannot change the speaker ID after an enrollment has been requested.
        ///
        /// * ENROLLMENT_ALREADY_EXISTS: There is already an enrollment for this session.
        ///
        /// * SPEAKER_NOT_SET: You must set the speaker ID before requesting an enrollment.
        ///
        /// * SPEAKER_OPTED_OUT: You cannot request an enrollment for an opted out speaker.
        ///
        /// * CONCURRENT_CHANGES: The request could not be processed as the resource was modified by another request during execution.
        public internal(set) var conflictType: VoiceIDClientTypes.ConflictType? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        conflictType: VoiceIDClientTypes.ConflictType? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.conflictType = conflictType
        self.properties.message = message
    }
}

/// The request failed due to an unknown error on the server side.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension VoiceIDClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case batchJob
        case complianceConsent
        case domain
        case fraudster
        case session
        case speaker
        case watchlist
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .batchJob,
                .complianceConsent,
                .domain,
                .fraudster,
                .session,
                .speaker,
                .watchlist
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .batchJob: return "BATCH_JOB"
            case .complianceConsent: return "COMPLIANCE_CONSENT"
            case .domain: return "DOMAIN"
            case .fraudster: return "FRAUDSTER"
            case .session: return "SESSION"
            case .speaker: return "SPEAKER"
            case .watchlist: return "WATCHLIST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The specified resource cannot be found. Check the ResourceType and error message for more details.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The type of resource which cannot not be found. Possible types are BATCH_JOB, COMPLIANCE_CONSENT, DOMAIN, FRAUDSTER, SESSION and SPEAKER.
        public internal(set) var resourceType: VoiceIDClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: VoiceIDClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

/// The request exceeded the service quota. Refer to [Voice ID Service Quotas](https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html#voiceid-quotas) and try your request again.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling. Please slow down your request rate. Refer to [ Amazon Connect Voice ID Service API throttling quotas ](https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html##voiceid-api-quotas) and try your request again.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request failed one or more validations; check the error message for more details.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateFraudsterInput: Swift.Sendable {
    /// The identifier of the domain that contains the fraudster.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the fraudster to be associated with the watchlist.
    /// This member is required.
    public var fraudsterId: Swift.String?
    /// The identifier of the watchlist you want to associate with the fraudster.
    /// This member is required.
    public var watchlistId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        fraudsterId: Swift.String? = nil,
        watchlistId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.fraudsterId = fraudsterId
        self.watchlistId = watchlistId
    }
}

extension AssociateFraudsterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateFraudsterInput(domainId: \(Swift.String(describing: domainId)), watchlistId: \(Swift.String(describing: watchlistId)), fraudsterId: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {

    /// Contains all the information about a fraudster.
    public struct Fraudster: Swift.Sendable {
        /// The timestamp of when Voice ID identified the fraudster.
        public var createdAt: Foundation.Date?
        /// The identifier of the domain that contains the fraudster.
        public var domainId: Swift.String?
        /// The service-generated identifier for the fraudster.
        public var generatedFraudsterId: Swift.String?
        /// The identifier of the watchlists the fraudster is a part of.
        public var watchlistIds: [Swift.String]?

        public init(
            createdAt: Foundation.Date? = nil,
            domainId: Swift.String? = nil,
            generatedFraudsterId: Swift.String? = nil,
            watchlistIds: [Swift.String]? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.generatedFraudsterId = generatedFraudsterId
            self.watchlistIds = watchlistIds
        }
    }
}

public struct AssociateFraudsterOutput: Swift.Sendable {
    /// Contains all the information about a fraudster.
    public var fraudster: VoiceIDClientTypes.Fraudster?

    public init(
        fraudster: VoiceIDClientTypes.Fraudster? = nil
    )
    {
        self.fraudster = fraudster
    }
}

extension VoiceIDClientTypes {

    /// The configuration used to authenticate a speaker during a session.
    public struct AuthenticationConfiguration: Swift.Sendable {
        /// The minimum threshold needed to successfully authenticate a speaker.
        /// This member is required.
        public var acceptanceThreshold: Swift.Int?

        public init(
            acceptanceThreshold: Swift.Int? = nil
        )
        {
            self.acceptanceThreshold = acceptanceThreshold
        }
    }
}

extension VoiceIDClientTypes {

    public enum AuthenticationDecision: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accept
        case notEnoughSpeech
        case reject
        case speakerExpired
        case speakerIdNotProvided
        case speakerNotEnrolled
        case speakerOptedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationDecision] {
            return [
                .accept,
                .notEnoughSpeech,
                .reject,
                .speakerExpired,
                .speakerIdNotProvided,
                .speakerNotEnrolled,
                .speakerOptedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accept: return "ACCEPT"
            case .notEnoughSpeech: return "NOT_ENOUGH_SPEECH"
            case .reject: return "REJECT"
            case .speakerExpired: return "SPEAKER_EXPIRED"
            case .speakerIdNotProvided: return "SPEAKER_ID_NOT_PROVIDED"
            case .speakerNotEnrolled: return "SPEAKER_NOT_ENROLLED"
            case .speakerOptedOut: return "SPEAKER_OPTED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VoiceIDClientTypes {

    /// The authentication result produced by Voice ID, processed against the current session state and streamed audio of the speaker.
    public struct AuthenticationResult: Swift.Sendable {
        /// A timestamp of when audio aggregation ended for this authentication result.
        public var audioAggregationEndedAt: Foundation.Date?
        /// A timestamp of when audio aggregation started for this authentication result.
        public var audioAggregationStartedAt: Foundation.Date?
        /// The unique identifier for this authentication result. Because there can be multiple authentications for a given session, this field helps to identify if the returned result is from a previous streaming activity or a new result. Note that in absence of any new streaming activity, AcceptanceThreshold changes, or SpeakerId changes, Voice ID always returns cached Authentication Result for this API.
        public var authenticationResultId: Swift.String?
        /// The AuthenticationConfiguration used to generate this authentication result.
        public var configuration: VoiceIDClientTypes.AuthenticationConfiguration?
        /// The client-provided identifier for the speaker whose authentication result is produced. Only present if a SpeakerId is provided for the session.
        public var customerSpeakerId: Swift.String?
        /// The authentication decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.
        public var decision: VoiceIDClientTypes.AuthenticationDecision?
        /// The service-generated identifier for the speaker whose authentication result is produced.
        public var generatedSpeakerId: Swift.String?
        /// The authentication score for the speaker whose authentication result is produced. This value is only present if the authentication decision is either ACCEPT or REJECT.
        public var score: Swift.Int?

        public init(
            audioAggregationEndedAt: Foundation.Date? = nil,
            audioAggregationStartedAt: Foundation.Date? = nil,
            authenticationResultId: Swift.String? = nil,
            configuration: VoiceIDClientTypes.AuthenticationConfiguration? = nil,
            customerSpeakerId: Swift.String? = nil,
            decision: VoiceIDClientTypes.AuthenticationDecision? = nil,
            generatedSpeakerId: Swift.String? = nil,
            score: Swift.Int? = nil
        )
        {
            self.audioAggregationEndedAt = audioAggregationEndedAt
            self.audioAggregationStartedAt = audioAggregationStartedAt
            self.authenticationResultId = authenticationResultId
            self.configuration = configuration
            self.customerSpeakerId = customerSpeakerId
            self.decision = decision
            self.generatedSpeakerId = generatedSpeakerId
            self.score = score
        }
    }
}

extension VoiceIDClientTypes.AuthenticationResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthenticationResult(audioAggregationEndedAt: \(Swift.String(describing: audioAggregationEndedAt)), audioAggregationStartedAt: \(Swift.String(describing: audioAggregationStartedAt)), authenticationResultId: \(Swift.String(describing: authenticationResultId)), configuration: \(Swift.String(describing: configuration)), decision: \(Swift.String(describing: decision)), generatedSpeakerId: \(Swift.String(describing: generatedSpeakerId)), score: \(Swift.String(describing: score)), customerSpeakerId: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {

    /// The configuration containing information about the customer managed key used for encrypting customer data.
    public struct ServerSideEncryptionConfiguration: Swift.Sendable {
        /// The identifier of the KMS key to use to encrypt data stored by Voice ID. Voice ID doesn't support asymmetric customer managed keys.
        /// This member is required.
        public var kmsKeyId: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
        }
    }
}

extension VoiceIDClientTypes {

    /// The tags used to organize, track, or control access for this resource. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    public struct Tag: Swift.Sendable {
        /// The first part of a key:value pair that forms a tag associated with a given resource. For example, in the tag 'Department':'Sales', the key is 'Department'.
        /// This member is required.
        public var key: Swift.String?
        /// The second part of a key:value pair that forms a tag associated with a given resource. For example, in the tag 'Department':'Sales', the value is 'Sales'.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension VoiceIDClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

public struct CreateDomainInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// A brief description of this domain.
    public var description: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration, containing the KMS key identifier, to be used by Voice ID for the server-side encryption of your data. Refer to [ Amazon Connect Voice ID encryption at rest](https://docs.aws.amazon.com/connect/latest/adminguide/encryption-at-rest.html#encryption-at-rest-voiceid) for more details on how the KMS key is used.
    /// This member is required.
    public var serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration?
    /// A list of tags you want added to the domain.
    public var tags: [VoiceIDClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration? = nil,
        tags: [VoiceIDClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
        self.tags = tags
    }
}

extension CreateDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDomainInput(clientToken: \(Swift.String(describing: clientToken)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {

    public enum DomainStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case pending
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .active,
                .pending,
                .suspended
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .pending: return "PENDING"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VoiceIDClientTypes {

    public enum ServerSideEncryptionUpdateStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerSideEncryptionUpdateStatus] {
            return [
                .completed,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VoiceIDClientTypes {

    /// Details about the most recent server-side encryption configuration update. When the server-side encryption configuration is changed, dependency on the old KMS key is removed through an asynchronous process. When this update is complete, the domainâ€™s data can only be accessed using the new KMS key.
    public struct ServerSideEncryptionUpdateDetails: Swift.Sendable {
        /// Message explaining the current UpdateStatus. When the UpdateStatus is FAILED, this message explains the cause of the failure.
        public var message: Swift.String?
        /// The previous KMS key ID the domain was encrypted with, before ServerSideEncryptionConfiguration was updated to a new KMS key ID.
        public var oldKmsKeyId: Swift.String?
        /// Status of the server-side encryption update. During an update, if there is an issue with the domain's current or old KMS key ID, such as an inaccessible or disabled key, then the status is FAILED. In order to resolve this, the key needs to be made accessible, and then an UpdateDomain call with the existing server-side encryption configuration will re-attempt this update process.
        public var updateStatus: VoiceIDClientTypes.ServerSideEncryptionUpdateStatus?

        public init(
            message: Swift.String? = nil,
            oldKmsKeyId: Swift.String? = nil,
            updateStatus: VoiceIDClientTypes.ServerSideEncryptionUpdateStatus? = nil
        )
        {
            self.message = message
            self.oldKmsKeyId = oldKmsKeyId
            self.updateStatus = updateStatus
        }
    }
}

extension VoiceIDClientTypes {

    /// Details of the watchlists in a domain.
    public struct WatchlistDetails: Swift.Sendable {
        /// The identifier of the default watchlist.
        /// This member is required.
        public var defaultWatchlistId: Swift.String?

        public init(
            defaultWatchlistId: Swift.String? = nil
        )
        {
            self.defaultWatchlistId = defaultWatchlistId
        }
    }
}

extension VoiceIDClientTypes {

    /// Contains all the information about a domain.
    public struct Domain: Swift.Sendable {
        /// The Amazon Resource Name (ARN) for the domain.
        public var arn: Swift.String?
        /// The timestamp of when the domain was created.
        public var createdAt: Foundation.Date?
        /// The description of the domain.
        public var description: Swift.String?
        /// The identifier of the domain.
        public var domainId: Swift.String?
        /// The current status of the domain.
        public var domainStatus: VoiceIDClientTypes.DomainStatus?
        /// The name for the domain.
        public var name: Swift.String?
        /// The server-side encryption configuration containing the KMS key identifier you want Voice ID to use to encrypt your data.
        public var serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration?
        /// Details about the most recent server-side encryption configuration update. When the server-side encryption configuration is changed, dependency on the old KMS key is removed through an asynchronous process. When this update is complete, the domain's data can only be accessed using the new KMS key.
        public var serverSideEncryptionUpdateDetails: VoiceIDClientTypes.ServerSideEncryptionUpdateDetails?
        /// The timestamp of when the domain was last update.
        public var updatedAt: Foundation.Date?
        /// The watchlist details of a domain. Contains the default watchlist ID of the domain.
        public var watchlistDetails: VoiceIDClientTypes.WatchlistDetails?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            domainStatus: VoiceIDClientTypes.DomainStatus? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration? = nil,
            serverSideEncryptionUpdateDetails: VoiceIDClientTypes.ServerSideEncryptionUpdateDetails? = nil,
            updatedAt: Foundation.Date? = nil,
            watchlistDetails: VoiceIDClientTypes.WatchlistDetails? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.domainStatus = domainStatus
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.serverSideEncryptionUpdateDetails = serverSideEncryptionUpdateDetails
            self.updatedAt = updatedAt
            self.watchlistDetails = watchlistDetails
        }
    }
}

extension VoiceIDClientTypes.Domain: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Domain(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), domainStatus: \(Swift.String(describing: domainStatus)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), serverSideEncryptionUpdateDetails: \(Swift.String(describing: serverSideEncryptionUpdateDetails)), updatedAt: \(Swift.String(describing: updatedAt)), watchlistDetails: \(Swift.String(describing: watchlistDetails)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateDomainOutput: Swift.Sendable {
    /// Information about the newly created domain.
    public var domain: VoiceIDClientTypes.Domain?

    public init(
        domain: VoiceIDClientTypes.Domain? = nil
    )
    {
        self.domain = domain
    }
}

public struct CreateWatchlistInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// A brief description of this watchlist.
    public var description: Swift.String?
    /// The identifier of the domain that contains the watchlist.
    /// This member is required.
    public var domainId: Swift.String?
    /// The name of the watchlist.
    /// This member is required.
    public var name: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.domainId = domainId
        self.name = name
    }
}

extension CreateWatchlistInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWatchlistInput(clientToken: \(Swift.String(describing: clientToken)), domainId: \(Swift.String(describing: domainId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {

    /// Contains all the information about a watchlist.
    public struct Watchlist: Swift.Sendable {
        /// The timestamp of when the watchlist was created.
        public var createdAt: Foundation.Date?
        /// Whether the specified watchlist is the default watchlist of a domain.
        public var defaultWatchlist: Swift.Bool
        /// The description of the watchlist.
        public var description: Swift.String?
        /// The identifier of the domain that contains the watchlist.
        public var domainId: Swift.String?
        /// The name for the watchlist.
        public var name: Swift.String?
        /// The timestamp of when the watchlist was updated.
        public var updatedAt: Foundation.Date?
        /// The identifier of the watchlist.
        public var watchlistId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            defaultWatchlist: Swift.Bool = false,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            name: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            watchlistId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.defaultWatchlist = defaultWatchlist
            self.description = description
            self.domainId = domainId
            self.name = name
            self.updatedAt = updatedAt
            self.watchlistId = watchlistId
        }
    }
}

extension VoiceIDClientTypes.Watchlist: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Watchlist(createdAt: \(Swift.String(describing: createdAt)), defaultWatchlist: \(Swift.String(describing: defaultWatchlist)), domainId: \(Swift.String(describing: domainId)), updatedAt: \(Swift.String(describing: updatedAt)), watchlistId: \(Swift.String(describing: watchlistId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateWatchlistOutput: Swift.Sendable {
    /// Information about the newly created watchlist.
    public var watchlist: VoiceIDClientTypes.Watchlist?

    public init(
        watchlist: VoiceIDClientTypes.Watchlist? = nil
    )
    {
        self.watchlist = watchlist
    }
}

public struct DeleteDomainInput: Swift.Sendable {
    /// The identifier of the domain you want to delete.
    /// This member is required.
    public var domainId: Swift.String?

    public init(
        domainId: Swift.String? = nil
    )
    {
        self.domainId = domainId
    }
}

public struct DeleteFraudsterInput: Swift.Sendable {
    /// The identifier of the domain that contains the fraudster.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the fraudster you want to delete.
    /// This member is required.
    public var fraudsterId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        fraudsterId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.fraudsterId = fraudsterId
    }
}

extension DeleteFraudsterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFraudsterInput(domainId: \(Swift.String(describing: domainId)), fraudsterId: \"CONTENT_REDACTED\")"}
}

public struct DeleteSpeakerInput: Swift.Sendable {
    /// The identifier of the domain that contains the speaker.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker you want to delete.
    /// This member is required.
    public var speakerId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        speakerId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.speakerId = speakerId
    }
}

extension DeleteSpeakerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSpeakerInput(domainId: \(Swift.String(describing: domainId)), speakerId: \"CONTENT_REDACTED\")"}
}

public struct DeleteWatchlistInput: Swift.Sendable {
    /// The identifier of the domain that contains the watchlist.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the watchlist to be deleted.
    /// This member is required.
    public var watchlistId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        watchlistId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.watchlistId = watchlistId
    }
}

public struct DescribeDomainInput: Swift.Sendable {
    /// The identifier of the domain that you are describing.
    /// This member is required.
    public var domainId: Swift.String?

    public init(
        domainId: Swift.String? = nil
    )
    {
        self.domainId = domainId
    }
}

public struct DescribeDomainOutput: Swift.Sendable {
    /// Information about the specified domain.
    public var domain: VoiceIDClientTypes.Domain?

    public init(
        domain: VoiceIDClientTypes.Domain? = nil
    )
    {
        self.domain = domain
    }
}

public struct DescribeFraudsterInput: Swift.Sendable {
    /// The identifier of the domain that contains the fraudster.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the fraudster you are describing.
    /// This member is required.
    public var fraudsterId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        fraudsterId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.fraudsterId = fraudsterId
    }
}

extension DescribeFraudsterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFraudsterInput(domainId: \(Swift.String(describing: domainId)), fraudsterId: \"CONTENT_REDACTED\")"}
}

public struct DescribeFraudsterOutput: Swift.Sendable {
    /// Information about the specified fraudster.
    public var fraudster: VoiceIDClientTypes.Fraudster?

    public init(
        fraudster: VoiceIDClientTypes.Fraudster? = nil
    )
    {
        self.fraudster = fraudster
    }
}

public struct DescribeFraudsterRegistrationJobInput: Swift.Sendable {
    /// The identifier of the domain that contains the fraudster registration job.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the fraudster registration job you are describing.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobId = jobId
    }
}

extension VoiceIDClientTypes {

    /// Contains error details for a failed batch job.
    public struct FailureDetails: Swift.Sendable {
        /// A description of the error that caused the batch job failure.
        public var message: Swift.String?
        /// An HTTP status code representing the nature of the error.
        public var statusCode: Swift.Int?

        public init(
            message: Swift.String? = nil,
            statusCode: Swift.Int? = nil
        )
        {
            self.message = message
            self.statusCode = statusCode
        }
    }
}

extension VoiceIDClientTypes {

    /// The configuration containing input file information for a batch job.
    public struct InputDataConfig: Swift.Sendable {
        /// The S3 location for the input manifest file that contains the list of individual enrollment or registration job requests.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            s3Uri: Swift.String? = nil
        )
        {
            self.s3Uri = s3Uri
        }
    }
}

extension VoiceIDClientTypes {

    /// Indicates the completion progress for a batch job.
    public struct JobProgress: Swift.Sendable {
        /// Shows the completed percentage of enrollment or registration requests listed in the input file.
        public var percentComplete: Swift.Int?

        public init(
            percentComplete: Swift.Int? = nil
        )
        {
            self.percentComplete = percentComplete
        }
    }
}

extension VoiceIDClientTypes {

    public enum FraudsterRegistrationJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case completedWithErrors
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudsterRegistrationJobStatus] {
            return [
                .completed,
                .completedWithErrors,
                .failed,
                .inProgress,
                .submitted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VoiceIDClientTypes {

    /// The configuration containing output file information for a batch job.
    public struct OutputDataConfig: Swift.Sendable {
        /// The identifier of the KMS key you want Voice ID to use to encrypt the output file of a speaker enrollment job/fraudster registration job.
        public var kmsKeyId: Swift.String?
        /// The S3 path of the folder where Voice ID writes the job output file. It has a *.out extension. For example, if the input file name is input-file.json and the output folder path is s3://output-bucket/output-folder, the full output file path is s3://output-bucket/output-folder/job-Id/input-file.json.out.
        /// This member is required.
        public var s3Uri: Swift.String?

        public init(
            kmsKeyId: Swift.String? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.s3Uri = s3Uri
        }
    }
}

extension VoiceIDClientTypes {

    public enum DuplicateRegistrationAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case registerAsNew
        case skip
        case sdkUnknown(Swift.String)

        public static var allCases: [DuplicateRegistrationAction] {
            return [
                .registerAsNew,
                .skip
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .registerAsNew: return "REGISTER_AS_NEW"
            case .skip: return "SKIP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VoiceIDClientTypes {

    /// The registration configuration to be used during the batch fraudster registration job.
    public struct RegistrationConfig: Swift.Sendable {
        /// The action to take when a fraudster is identified as a duplicate. The default action is SKIP, which skips registering the duplicate fraudster. Setting the value to REGISTER_AS_NEW always registers a new fraudster into the specified domain.
        public var duplicateRegistrationAction: VoiceIDClientTypes.DuplicateRegistrationAction?
        /// The minimum similarity score between the new and old fraudsters in order to consider the new fraudster a duplicate.
        public var fraudsterSimilarityThreshold: Swift.Int?
        /// The identifiers of watchlists that a fraudster is registered to. If a watchlist isn't provided, the fraudsters are registered to the default watchlist.
        public var watchlistIds: [Swift.String]?

        public init(
            duplicateRegistrationAction: VoiceIDClientTypes.DuplicateRegistrationAction? = nil,
            fraudsterSimilarityThreshold: Swift.Int? = nil,
            watchlistIds: [Swift.String]? = nil
        )
        {
            self.duplicateRegistrationAction = duplicateRegistrationAction
            self.fraudsterSimilarityThreshold = fraudsterSimilarityThreshold
            self.watchlistIds = watchlistIds
        }
    }
}

extension VoiceIDClientTypes {

    /// Contains all the information about a fraudster registration job.
    public struct FraudsterRegistrationJob: Swift.Sendable {
        /// A timestamp of when the fraudster registration job was created.
        public var createdAt: Foundation.Date?
        /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file.
        public var dataAccessRoleArn: Swift.String?
        /// The identifier of the domain that contains the fraudster registration job.
        public var domainId: Swift.String?
        /// A timestamp of when the fraudster registration job ended.
        public var endedAt: Foundation.Date?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual registration requests that failed.
        public var failureDetails: VoiceIDClientTypes.FailureDetails?
        /// The input data config containing an S3 URI for the input manifest file that contains the list of fraudster registration job requests.
        public var inputDataConfig: VoiceIDClientTypes.InputDataConfig?
        /// The service-generated identifier for the fraudster registration job.
        public var jobId: Swift.String?
        /// The client-provided name for the fraudster registration job.
        public var jobName: Swift.String?
        /// Shows the completed percentage of registration requests listed in the input file.
        public var jobProgress: VoiceIDClientTypes.JobProgress?
        /// The current status of the fraudster registration job.
        public var jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus?
        /// The output data config containing the S3 location where you want Voice ID to write your job output file; you must also include a KMS key ID in order to encrypt the file.
        public var outputDataConfig: VoiceIDClientTypes.OutputDataConfig?
        /// The registration config containing details such as the action to take when a duplicate fraudster is detected, and the similarity threshold to use for detecting a duplicate fraudster.
        public var registrationConfig: VoiceIDClientTypes.RegistrationConfig?

        public init(
            createdAt: Foundation.Date? = nil,
            dataAccessRoleArn: Swift.String? = nil,
            domainId: Swift.String? = nil,
            endedAt: Foundation.Date? = nil,
            failureDetails: VoiceIDClientTypes.FailureDetails? = nil,
            inputDataConfig: VoiceIDClientTypes.InputDataConfig? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIDClientTypes.JobProgress? = nil,
            jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus? = nil,
            outputDataConfig: VoiceIDClientTypes.OutputDataConfig? = nil,
            registrationConfig: VoiceIDClientTypes.RegistrationConfig? = nil
        )
        {
            self.createdAt = createdAt
            self.dataAccessRoleArn = dataAccessRoleArn
            self.domainId = domainId
            self.endedAt = endedAt
            self.failureDetails = failureDetails
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
            self.outputDataConfig = outputDataConfig
            self.registrationConfig = registrationConfig
        }
    }
}

extension VoiceIDClientTypes.FraudsterRegistrationJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FraudsterRegistrationJob(createdAt: \(Swift.String(describing: createdAt)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), domainId: \(Swift.String(describing: domainId)), endedAt: \(Swift.String(describing: endedAt)), failureDetails: \(Swift.String(describing: failureDetails)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobId: \(Swift.String(describing: jobId)), jobProgress: \(Swift.String(describing: jobProgress)), jobStatus: \(Swift.String(describing: jobStatus)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), registrationConfig: \(Swift.String(describing: registrationConfig)), jobName: \"CONTENT_REDACTED\")"}
}

public struct DescribeFraudsterRegistrationJobOutput: Swift.Sendable {
    /// Contains details about the specified fraudster registration job.
    public var job: VoiceIDClientTypes.FraudsterRegistrationJob?

    public init(
        job: VoiceIDClientTypes.FraudsterRegistrationJob? = nil
    )
    {
        self.job = job
    }
}

public struct DescribeSpeakerInput: Swift.Sendable {
    /// The identifier of the domain that contains the speaker.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker you are describing.
    /// This member is required.
    public var speakerId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        speakerId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.speakerId = speakerId
    }
}

extension DescribeSpeakerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeSpeakerInput(domainId: \(Swift.String(describing: domainId)), speakerId: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {

    public enum SpeakerStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enrolled
        case expired
        case optedOut
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [SpeakerStatus] {
            return [
                .enrolled,
                .expired,
                .optedOut,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enrolled: return "ENROLLED"
            case .expired: return "EXPIRED"
            case .optedOut: return "OPTED_OUT"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VoiceIDClientTypes {

    /// Contains all the information about a speaker.
    public struct Speaker: Swift.Sendable {
        /// A timestamp of when the speaker was created.
        public var createdAt: Foundation.Date?
        /// The client-provided identifier for the speaker.
        public var customerSpeakerId: Swift.String?
        /// The identifier of the domain that contains the speaker.
        public var domainId: Swift.String?
        /// The service-generated identifier for the speaker.
        public var generatedSpeakerId: Swift.String?
        /// The timestamp of when the speaker was last accessed for enrollment, re-enrollment or a successful authentication. This timestamp is accurate to one hour.
        public var lastAccessedAt: Foundation.Date?
        /// The current status of the speaker.
        public var status: VoiceIDClientTypes.SpeakerStatus?
        /// A timestamp of the speaker's last update.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            customerSpeakerId: Swift.String? = nil,
            domainId: Swift.String? = nil,
            generatedSpeakerId: Swift.String? = nil,
            lastAccessedAt: Foundation.Date? = nil,
            status: VoiceIDClientTypes.SpeakerStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.customerSpeakerId = customerSpeakerId
            self.domainId = domainId
            self.generatedSpeakerId = generatedSpeakerId
            self.lastAccessedAt = lastAccessedAt
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

extension VoiceIDClientTypes.Speaker: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Speaker(createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), generatedSpeakerId: \(Swift.String(describing: generatedSpeakerId)), lastAccessedAt: \(Swift.String(describing: lastAccessedAt)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), customerSpeakerId: \"CONTENT_REDACTED\")"}
}

public struct DescribeSpeakerOutput: Swift.Sendable {
    /// Information about the specified speaker.
    public var speaker: VoiceIDClientTypes.Speaker?

    public init(
        speaker: VoiceIDClientTypes.Speaker? = nil
    )
    {
        self.speaker = speaker
    }
}

public struct DescribeSpeakerEnrollmentJobInput: Swift.Sendable {
    /// The identifier of the domain that contains the speaker enrollment job.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker enrollment job you are describing.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobId = jobId
    }
}

extension VoiceIDClientTypes {

    public enum ExistingEnrollmentAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case overwrite
        case skip
        case sdkUnknown(Swift.String)

        public static var allCases: [ExistingEnrollmentAction] {
            return [
                .overwrite,
                .skip
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .overwrite: return "OVERWRITE"
            case .skip: return "SKIP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VoiceIDClientTypes {

    public enum FraudDetectionAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fail
        case ignore
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudDetectionAction] {
            return [
                .fail,
                .ignore
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .ignore: return "IGNORE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VoiceIDClientTypes {

    /// The fraud detection configuration to be used during the batch speaker enrollment job.
    public struct EnrollmentJobFraudDetectionConfig: Swift.Sendable {
        /// The action to take when the given speaker is flagged by the fraud detection system. The default value is FAIL, which fails the speaker enrollment. Changing this value to IGNORE results in the speaker being enrolled even if they are flagged by the fraud detection system.
        public var fraudDetectionAction: VoiceIDClientTypes.FraudDetectionAction?
        /// Threshold value for determining whether the speaker is a high risk to be fraudulent. If the detected risk score calculated by Voice ID is greater than or equal to the threshold, the speaker is considered a fraudster.
        public var riskThreshold: Swift.Int?
        /// The identifier of watchlists against which fraud detection is performed.
        public var watchlistIds: [Swift.String]?

        public init(
            fraudDetectionAction: VoiceIDClientTypes.FraudDetectionAction? = nil,
            riskThreshold: Swift.Int? = nil,
            watchlistIds: [Swift.String]? = nil
        )
        {
            self.fraudDetectionAction = fraudDetectionAction
            self.riskThreshold = riskThreshold
            self.watchlistIds = watchlistIds
        }
    }
}

extension VoiceIDClientTypes {

    /// Contains configurations defining enrollment behavior for the batch job.
    public struct EnrollmentConfig: Swift.Sendable {
        /// The action to take when the specified speaker is already enrolled in the specified domain. The default value is SKIP, which skips the enrollment for the existing speaker. Setting the value to OVERWRITE replaces the existing voice prints and enrollment audio stored for that speaker with new data generated from the latest audio.
        public var existingEnrollmentAction: VoiceIDClientTypes.ExistingEnrollmentAction?
        /// The fraud detection configuration to use for the speaker enrollment job.
        public var fraudDetectionConfig: VoiceIDClientTypes.EnrollmentJobFraudDetectionConfig?

        public init(
            existingEnrollmentAction: VoiceIDClientTypes.ExistingEnrollmentAction? = nil,
            fraudDetectionConfig: VoiceIDClientTypes.EnrollmentJobFraudDetectionConfig? = nil
        )
        {
            self.existingEnrollmentAction = existingEnrollmentAction
            self.fraudDetectionConfig = fraudDetectionConfig
        }
    }
}

extension VoiceIDClientTypes {

    public enum SpeakerEnrollmentJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case completedWithErrors
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [SpeakerEnrollmentJobStatus] {
            return [
                .completed,
                .completedWithErrors,
                .failed,
                .inProgress,
                .submitted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VoiceIDClientTypes {

    /// Contains all the information about a speaker enrollment job.
    public struct SpeakerEnrollmentJob: Swift.Sendable {
        /// A timestamp of when the speaker enrollment job was created.
        public var createdAt: Foundation.Date?
        /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file.
        public var dataAccessRoleArn: Swift.String?
        /// The identifier of the domain that contains the speaker enrollment job.
        public var domainId: Swift.String?
        /// A timestamp of when the speaker enrollment job ended.
        public var endedAt: Foundation.Date?
        /// The configuration that defines the action to take when the speaker is already enrolled in Voice ID, and the FraudDetectionConfig to use.
        public var enrollmentConfig: VoiceIDClientTypes.EnrollmentConfig?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual registration requests that failed.
        public var failureDetails: VoiceIDClientTypes.FailureDetails?
        /// The input data config containing an S3 URI for the input manifest file that contains the list of speaker enrollment job requests.
        public var inputDataConfig: VoiceIDClientTypes.InputDataConfig?
        /// The service-generated identifier for the speaker enrollment job.
        public var jobId: Swift.String?
        /// The client-provided name for the speaker enrollment job.
        public var jobName: Swift.String?
        /// Provides details on job progress. This field shows the completed percentage of registration requests listed in the input file.
        public var jobProgress: VoiceIDClientTypes.JobProgress?
        /// The current status of the speaker enrollment job.
        public var jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus?
        /// The output data config containing the S3 location where Voice ID writes the job output file; you must also include a KMS key ID to encrypt the file.
        public var outputDataConfig: VoiceIDClientTypes.OutputDataConfig?

        public init(
            createdAt: Foundation.Date? = nil,
            dataAccessRoleArn: Swift.String? = nil,
            domainId: Swift.String? = nil,
            endedAt: Foundation.Date? = nil,
            enrollmentConfig: VoiceIDClientTypes.EnrollmentConfig? = nil,
            failureDetails: VoiceIDClientTypes.FailureDetails? = nil,
            inputDataConfig: VoiceIDClientTypes.InputDataConfig? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIDClientTypes.JobProgress? = nil,
            jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus? = nil,
            outputDataConfig: VoiceIDClientTypes.OutputDataConfig? = nil
        )
        {
            self.createdAt = createdAt
            self.dataAccessRoleArn = dataAccessRoleArn
            self.domainId = domainId
            self.endedAt = endedAt
            self.enrollmentConfig = enrollmentConfig
            self.failureDetails = failureDetails
            self.inputDataConfig = inputDataConfig
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
            self.outputDataConfig = outputDataConfig
        }
    }
}

extension VoiceIDClientTypes.SpeakerEnrollmentJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SpeakerEnrollmentJob(createdAt: \(Swift.String(describing: createdAt)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), domainId: \(Swift.String(describing: domainId)), endedAt: \(Swift.String(describing: endedAt)), enrollmentConfig: \(Swift.String(describing: enrollmentConfig)), failureDetails: \(Swift.String(describing: failureDetails)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), jobId: \(Swift.String(describing: jobId)), jobProgress: \(Swift.String(describing: jobProgress)), jobStatus: \(Swift.String(describing: jobStatus)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), jobName: \"CONTENT_REDACTED\")"}
}

public struct DescribeSpeakerEnrollmentJobOutput: Swift.Sendable {
    /// Contains details about the specified speaker enrollment job.
    public var job: VoiceIDClientTypes.SpeakerEnrollmentJob?

    public init(
        job: VoiceIDClientTypes.SpeakerEnrollmentJob? = nil
    )
    {
        self.job = job
    }
}

public struct DescribeWatchlistInput: Swift.Sendable {
    /// The identifier of the domain that contains the watchlist.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the watchlist that you are describing.
    /// This member is required.
    public var watchlistId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        watchlistId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.watchlistId = watchlistId
    }
}

public struct DescribeWatchlistOutput: Swift.Sendable {
    /// Information about the specified watchlist.
    public var watchlist: VoiceIDClientTypes.Watchlist?

    public init(
        watchlist: VoiceIDClientTypes.Watchlist? = nil
    )
    {
        self.watchlist = watchlist
    }
}

public struct DisassociateFraudsterInput: Swift.Sendable {
    /// The identifier of the domain that contains the fraudster.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the fraudster to be disassociated from the watchlist.
    /// This member is required.
    public var fraudsterId: Swift.String?
    /// The identifier of the watchlist that you want to disassociate from the fraudster.
    /// This member is required.
    public var watchlistId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        fraudsterId: Swift.String? = nil,
        watchlistId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.fraudsterId = fraudsterId
        self.watchlistId = watchlistId
    }
}

extension DisassociateFraudsterInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateFraudsterInput(domainId: \(Swift.String(describing: domainId)), watchlistId: \(Swift.String(describing: watchlistId)), fraudsterId: \"CONTENT_REDACTED\")"}
}

public struct DisassociateFraudsterOutput: Swift.Sendable {
    /// Contains all the information about a fraudster.
    public var fraudster: VoiceIDClientTypes.Fraudster?

    public init(
        fraudster: VoiceIDClientTypes.Fraudster? = nil
    )
    {
        self.fraudster = fraudster
    }
}

public struct ListDomainsInput: Swift.Sendable {
    /// The maximum number of results that are returned per call. You can use NextToken to obtain more pages of results. The default is 100; the maximum allowed page size is also 100.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension VoiceIDClientTypes {

    /// Contains a summary of information about a domain.
    public struct DomainSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) for the domain.
        public var arn: Swift.String?
        /// The timestamp of when the domain was created.
        public var createdAt: Foundation.Date?
        /// The description of the domain.
        public var description: Swift.String?
        /// The identifier of the domain.
        public var domainId: Swift.String?
        /// The current status of the domain.
        public var domainStatus: VoiceIDClientTypes.DomainStatus?
        /// The client-provided name for the domain.
        public var name: Swift.String?
        /// The server-side encryption configuration containing the KMS key identifier you want Voice ID to use to encrypt your data.
        public var serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration?
        /// Details about the most recent server-side encryption configuration update. When the server-side encryption configuration is changed, dependency on the old KMS key is removed through an asynchronous process. When this update is complete, the domain's data can only be accessed using the new KMS key.
        public var serverSideEncryptionUpdateDetails: VoiceIDClientTypes.ServerSideEncryptionUpdateDetails?
        /// The timestamp of when the domain was last updated.
        public var updatedAt: Foundation.Date?
        /// Provides information about watchlistDetails and DefaultWatchlistID.
        public var watchlistDetails: VoiceIDClientTypes.WatchlistDetails?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            domainStatus: VoiceIDClientTypes.DomainStatus? = nil,
            name: Swift.String? = nil,
            serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration? = nil,
            serverSideEncryptionUpdateDetails: VoiceIDClientTypes.ServerSideEncryptionUpdateDetails? = nil,
            updatedAt: Foundation.Date? = nil,
            watchlistDetails: VoiceIDClientTypes.WatchlistDetails? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.domainId = domainId
            self.domainStatus = domainStatus
            self.name = name
            self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
            self.serverSideEncryptionUpdateDetails = serverSideEncryptionUpdateDetails
            self.updatedAt = updatedAt
            self.watchlistDetails = watchlistDetails
        }
    }
}

extension VoiceIDClientTypes.DomainSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DomainSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), domainStatus: \(Swift.String(describing: domainStatus)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), serverSideEncryptionUpdateDetails: \(Swift.String(describing: serverSideEncryptionUpdateDetails)), updatedAt: \(Swift.String(describing: updatedAt)), watchlistDetails: \(Swift.String(describing: watchlistDetails)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListDomainsOutput: Swift.Sendable {
    /// A list containing details about each domain in the Amazon Web Services account.
    public var domainSummaries: [VoiceIDClientTypes.DomainSummary]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        domainSummaries: [VoiceIDClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainSummaries = domainSummaries
        self.nextToken = nextToken
    }
}

public struct UpdateDomainInput: Swift.Sendable {
    /// A brief description about this domain.
    public var description: Swift.String?
    /// The identifier of the domain to be updated.
    /// This member is required.
    public var domainId: Swift.String?
    /// The name of the domain.
    /// This member is required.
    public var name: Swift.String?
    /// The configuration, containing the KMS key identifier, to be used by Voice ID for the server-side encryption of your data. Changing the domain's associated KMS key immediately triggers an asynchronous process to remove dependency on the old KMS key, such that the domain's data can only be accessed using the new KMS key. The domain's ServerSideEncryptionUpdateDetails contains the details for this process.
    /// This member is required.
    public var serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        name: Swift.String? = nil,
        serverSideEncryptionConfiguration: VoiceIDClientTypes.ServerSideEncryptionConfiguration? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.name = name
        self.serverSideEncryptionConfiguration = serverSideEncryptionConfiguration
    }
}

extension UpdateDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDomainInput(domainId: \(Swift.String(describing: domainId)), serverSideEncryptionConfiguration: \(Swift.String(describing: serverSideEncryptionConfiguration)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateDomainOutput: Swift.Sendable {
    /// Details about the updated domain
    public var domain: VoiceIDClientTypes.Domain?

    public init(
        domain: VoiceIDClientTypes.Domain? = nil
    )
    {
        self.domain = domain
    }
}

public struct EvaluateSessionInput: Swift.Sendable {
    /// The identifier of the domain where the session started.
    /// This member is required.
    public var domainId: Swift.String?
    /// The session identifier, or name of the session, that you want to evaluate. In Voice ID integration, this is the Contact-Id.
    /// This member is required.
    public var sessionNameOrId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        sessionNameOrId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.sessionNameOrId = sessionNameOrId
    }
}

extension VoiceIDClientTypes {

    /// The configuration used for performing fraud detection over a speaker during a session.
    public struct FraudDetectionConfiguration: Swift.Sendable {
        /// Threshold value for determining whether the speaker is a fraudster. If the detected risk score calculated by Voice ID is higher than the threshold, the speaker is considered a fraudster.
        public var riskThreshold: Swift.Int?
        /// The identifier of the watchlist against which fraud detection is performed.
        public var watchlistId: Swift.String?

        public init(
            riskThreshold: Swift.Int? = nil,
            watchlistId: Swift.String? = nil
        )
        {
            self.riskThreshold = riskThreshold
            self.watchlistId = watchlistId
        }
    }
}

extension VoiceIDClientTypes {

    public enum FraudDetectionDecision: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case highRisk
        case lowRisk
        case notEnoughSpeech
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudDetectionDecision] {
            return [
                .highRisk,
                .lowRisk,
                .notEnoughSpeech
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .highRisk: return "HIGH_RISK"
            case .lowRisk: return "LOW_RISK"
            case .notEnoughSpeech: return "NOT_ENOUGH_SPEECH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VoiceIDClientTypes {

    public enum FraudDetectionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case knownFraudster
        case voiceSpoofing
        case sdkUnknown(Swift.String)

        public static var allCases: [FraudDetectionReason] {
            return [
                .knownFraudster,
                .voiceSpoofing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .knownFraudster: return "KNOWN_FRAUDSTER"
            case .voiceSpoofing: return "VOICE_SPOOFING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension VoiceIDClientTypes {

    /// Contains details produced as a result of performing known fraudster risk analysis on a speaker.
    public struct KnownFraudsterRisk: Swift.Sendable {
        /// The identifier of the fraudster that is the closest match to the speaker. If there are no fraudsters registered in a given domain, or if there are no fraudsters with a non-zero RiskScore, this value is null.
        public var generatedFraudsterId: Swift.String?
        /// The score indicating the likelihood the speaker is a known fraudster.
        /// This member is required.
        public var riskScore: Swift.Int?

        public init(
            generatedFraudsterId: Swift.String? = nil,
            riskScore: Swift.Int? = nil
        )
        {
            self.generatedFraudsterId = generatedFraudsterId
            self.riskScore = riskScore
        }
    }
}

extension VoiceIDClientTypes {

    /// The details resulting from 'Voice Spoofing Risk' analysis of the speaker.
    public struct VoiceSpoofingRisk: Swift.Sendable {
        /// The score indicating the likelihood of speakerâ€™s voice being spoofed.
        /// This member is required.
        public var riskScore: Swift.Int?

        public init(
            riskScore: Swift.Int? = nil
        )
        {
            self.riskScore = riskScore
        }
    }
}

extension VoiceIDClientTypes {

    /// Details regarding various fraud risk analyses performed against the current session state and streamed audio of the speaker.
    public struct FraudRiskDetails: Swift.Sendable {
        /// The details resulting from 'Known Fraudster Risk' analysis of the speaker.
        /// This member is required.
        public var knownFraudsterRisk: VoiceIDClientTypes.KnownFraudsterRisk?
        /// The details resulting from 'Voice Spoofing Risk' analysis of the speaker.
        /// This member is required.
        public var voiceSpoofingRisk: VoiceIDClientTypes.VoiceSpoofingRisk?

        public init(
            knownFraudsterRisk: VoiceIDClientTypes.KnownFraudsterRisk? = nil,
            voiceSpoofingRisk: VoiceIDClientTypes.VoiceSpoofingRisk? = nil
        )
        {
            self.knownFraudsterRisk = knownFraudsterRisk
            self.voiceSpoofingRisk = voiceSpoofingRisk
        }
    }
}

extension VoiceIDClientTypes {

    /// The fraud detection result produced by Voice ID, processed against the current session state and streamed audio of the speaker.
    public struct FraudDetectionResult: Swift.Sendable {
        /// A timestamp of when audio aggregation ended for this fraud detection result.
        public var audioAggregationEndedAt: Foundation.Date?
        /// A timestamp of when audio aggregation started for this fraud detection result.
        public var audioAggregationStartedAt: Foundation.Date?
        /// The FraudDetectionConfiguration used to generate this fraud detection result.
        public var configuration: VoiceIDClientTypes.FraudDetectionConfiguration?
        /// The fraud detection decision produced by Voice ID, processed against the current session state and streamed audio of the speaker.
        public var decision: VoiceIDClientTypes.FraudDetectionDecision?
        /// The unique identifier for this fraud detection result. Given there can be multiple fraud detections for a given session, this field helps in identifying if the returned result is from previous streaming activity or a new result. Note that in the absence of any new streaming activity or risk threshold changes, Voice ID always returns cached Fraud Detection result for this API.
        public var fraudDetectionResultId: Swift.String?
        /// The reason speaker was flagged by the fraud detection system. This is only be populated if fraud detection Decision is HIGH_RISK, and the following possible values: KNOWN_FRAUDSTER and VOICE_SPOOFING.
        public var reasons: [VoiceIDClientTypes.FraudDetectionReason]?
        /// Details about each risk analyzed for this speaker. Currently, this contains KnownFraudsterRisk and VoiceSpoofingRisk details.
        public var riskDetails: VoiceIDClientTypes.FraudRiskDetails?

        public init(
            audioAggregationEndedAt: Foundation.Date? = nil,
            audioAggregationStartedAt: Foundation.Date? = nil,
            configuration: VoiceIDClientTypes.FraudDetectionConfiguration? = nil,
            decision: VoiceIDClientTypes.FraudDetectionDecision? = nil,
            fraudDetectionResultId: Swift.String? = nil,
            reasons: [VoiceIDClientTypes.FraudDetectionReason]? = nil,
            riskDetails: VoiceIDClientTypes.FraudRiskDetails? = nil
        )
        {
            self.audioAggregationEndedAt = audioAggregationEndedAt
            self.audioAggregationStartedAt = audioAggregationStartedAt
            self.configuration = configuration
            self.decision = decision
            self.fraudDetectionResultId = fraudDetectionResultId
            self.reasons = reasons
            self.riskDetails = riskDetails
        }
    }
}

extension VoiceIDClientTypes {

    public enum StreamingStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ended
        case ongoing
        case pendingConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingStatus] {
            return [
                .ended,
                .ongoing,
                .pendingConfiguration
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ended: return "ENDED"
            case .ongoing: return "ONGOING"
            case .pendingConfiguration: return "PENDING_CONFIGURATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct EvaluateSessionOutput: Swift.Sendable {
    /// Details resulting from the authentication process, such as authentication decision and authentication score.
    public var authenticationResult: VoiceIDClientTypes.AuthenticationResult?
    /// The identifier of the domain that contains the session.
    public var domainId: Swift.String?
    /// Details resulting from the fraud detection process, such as fraud detection decision and risk score.
    public var fraudDetectionResult: VoiceIDClientTypes.FraudDetectionResult?
    /// The service-generated identifier of the session.
    public var sessionId: Swift.String?
    /// The client-provided name of the session.
    public var sessionName: Swift.String?
    /// The current status of audio streaming for this session. This field is useful to infer next steps when the Authentication or Fraud Detection results are empty or the decision is NOT_ENOUGH_SPEECH. In this situation, if the StreamingStatus is ONGOING/PENDING_CONFIGURATION, it can mean that the client should call the API again later, after Voice ID has enough audio to produce a result. If the decision remains NOT_ENOUGH_SPEECH even after StreamingStatus is ENDED, it means that the previously streamed session did not have enough speech to perform evaluation, and a new streaming session is needed to try again.
    public var streamingStatus: VoiceIDClientTypes.StreamingStatus?

    public init(
        authenticationResult: VoiceIDClientTypes.AuthenticationResult? = nil,
        domainId: Swift.String? = nil,
        fraudDetectionResult: VoiceIDClientTypes.FraudDetectionResult? = nil,
        sessionId: Swift.String? = nil,
        sessionName: Swift.String? = nil,
        streamingStatus: VoiceIDClientTypes.StreamingStatus? = nil
    )
    {
        self.authenticationResult = authenticationResult
        self.domainId = domainId
        self.fraudDetectionResult = fraudDetectionResult
        self.sessionId = sessionId
        self.sessionName = sessionName
        self.streamingStatus = streamingStatus
    }
}

extension VoiceIDClientTypes {

    /// Contains a summary of information about a fraudster registration job.
    public struct FraudsterRegistrationJobSummary: Swift.Sendable {
        /// A timestamp of when the fraudster registration job was created.
        public var createdAt: Foundation.Date?
        /// The identifier of the domain that contains the fraudster registration job.
        public var domainId: Swift.String?
        /// A timestamp of when the fraudster registration job ended.
        public var endedAt: Foundation.Date?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual registration requests that failed.
        public var failureDetails: VoiceIDClientTypes.FailureDetails?
        /// The service-generated identifier for the fraudster registration job.
        public var jobId: Swift.String?
        /// The client-provided name for the fraudster registration job.
        public var jobName: Swift.String?
        /// Shows the completed percentage of registration requests listed in the input file.
        public var jobProgress: VoiceIDClientTypes.JobProgress?
        /// The current status of the fraudster registration job.
        public var jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus?

        public init(
            createdAt: Foundation.Date? = nil,
            domainId: Swift.String? = nil,
            endedAt: Foundation.Date? = nil,
            failureDetails: VoiceIDClientTypes.FailureDetails? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIDClientTypes.JobProgress? = nil,
            jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.endedAt = endedAt
            self.failureDetails = failureDetails
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
        }
    }
}

extension VoiceIDClientTypes.FraudsterRegistrationJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FraudsterRegistrationJobSummary(createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), endedAt: \(Swift.String(describing: endedAt)), failureDetails: \(Swift.String(describing: failureDetails)), jobId: \(Swift.String(describing: jobId)), jobProgress: \(Swift.String(describing: jobProgress)), jobStatus: \(Swift.String(describing: jobStatus)), jobName: \"CONTENT_REDACTED\")"}
}

extension VoiceIDClientTypes {

    /// Contains a summary of information about a fraudster.
    public struct FraudsterSummary: Swift.Sendable {
        /// The timestamp of when the fraudster summary was created.
        public var createdAt: Foundation.Date?
        /// The identifier of the domain that contains the fraudster summary.
        public var domainId: Swift.String?
        /// The service-generated identifier for the fraudster.
        public var generatedFraudsterId: Swift.String?
        /// The identifier of the watchlists the fraudster is a part of.
        public var watchlistIds: [Swift.String]?

        public init(
            createdAt: Foundation.Date? = nil,
            domainId: Swift.String? = nil,
            generatedFraudsterId: Swift.String? = nil,
            watchlistIds: [Swift.String]? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.generatedFraudsterId = generatedFraudsterId
            self.watchlistIds = watchlistIds
        }
    }
}

public struct ListFraudsterRegistrationJobsInput: Swift.Sendable {
    /// The identifier of the domain that contains the fraudster registration Jobs.
    /// This member is required.
    public var domainId: Swift.String?
    /// Provides the status of your fraudster registration job.
    public var jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus?
    /// The maximum number of results that are returned per call. You can use NextToken to obtain more pages of results. The default is 100; the maximum allowed page size is also 100.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        jobStatus: VoiceIDClientTypes.FraudsterRegistrationJobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFraudsterRegistrationJobsOutput: Swift.Sendable {
    /// A list containing details about each specified fraudster registration job.
    public var jobSummaries: [VoiceIDClientTypes.FraudsterRegistrationJobSummary]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        jobSummaries: [VoiceIDClientTypes.FraudsterRegistrationJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

public struct ListFraudstersInput: Swift.Sendable {
    /// The identifier of the domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results that are returned per call. You can use NextToken to obtain more pages of results. The default is 100; the maximum allowed page size is also 100.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?
    /// The identifier of the watchlist. If provided, all fraudsters in the watchlist are listed. If not provided, all fraudsters in the domain are listed.
    public var watchlistId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        watchlistId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.watchlistId = watchlistId
    }
}

public struct ListFraudstersOutput: Swift.Sendable {
    /// A list that contains details about each fraudster in the Amazon Web Services account.
    public var fraudsterSummaries: [VoiceIDClientTypes.FraudsterSummary]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        fraudsterSummaries: [VoiceIDClientTypes.FraudsterSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fraudsterSummaries = fraudsterSummaries
        self.nextToken = nextToken
    }
}

public struct ListSpeakerEnrollmentJobsInput: Swift.Sendable {
    /// The identifier of the domain that contains the speaker enrollment jobs.
    /// This member is required.
    public var domainId: Swift.String?
    /// Provides the status of your speaker enrollment Job.
    public var jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus?
    /// The maximum number of results that are returned per call. You can use NextToken to obtain more pages of results. The default is 100; the maximum allowed page size is also 100.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.jobStatus = jobStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension VoiceIDClientTypes {

    /// Contains a summary of information about a speaker enrollment job.
    public struct SpeakerEnrollmentJobSummary: Swift.Sendable {
        /// A timestamp of when of the speaker enrollment job was created.
        public var createdAt: Foundation.Date?
        /// The identifier of the domain that contains the speaker enrollment job.
        public var domainId: Swift.String?
        /// A timestamp of when the speaker enrollment job ended.
        public var endedAt: Foundation.Date?
        /// Contains details that are populated when an entire batch job fails. In cases of individual registration job failures, the batch job as a whole doesn't fail; it is completed with a JobStatus of COMPLETED_WITH_ERRORS. You can use the job output file to identify the individual registration requests that failed.
        public var failureDetails: VoiceIDClientTypes.FailureDetails?
        /// The service-generated identifier for the speaker enrollment job.
        public var jobId: Swift.String?
        /// The client-provided name for the speaker enrollment job.
        public var jobName: Swift.String?
        /// Provides details regarding job progress. This field shows the completed percentage of enrollment requests listed in the input file.
        public var jobProgress: VoiceIDClientTypes.JobProgress?
        /// The current status of the speaker enrollment job.
        public var jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus?

        public init(
            createdAt: Foundation.Date? = nil,
            domainId: Swift.String? = nil,
            endedAt: Foundation.Date? = nil,
            failureDetails: VoiceIDClientTypes.FailureDetails? = nil,
            jobId: Swift.String? = nil,
            jobName: Swift.String? = nil,
            jobProgress: VoiceIDClientTypes.JobProgress? = nil,
            jobStatus: VoiceIDClientTypes.SpeakerEnrollmentJobStatus? = nil
        )
        {
            self.createdAt = createdAt
            self.domainId = domainId
            self.endedAt = endedAt
            self.failureDetails = failureDetails
            self.jobId = jobId
            self.jobName = jobName
            self.jobProgress = jobProgress
            self.jobStatus = jobStatus
        }
    }
}

extension VoiceIDClientTypes.SpeakerEnrollmentJobSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SpeakerEnrollmentJobSummary(createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), endedAt: \(Swift.String(describing: endedAt)), failureDetails: \(Swift.String(describing: failureDetails)), jobId: \(Swift.String(describing: jobId)), jobProgress: \(Swift.String(describing: jobProgress)), jobStatus: \(Swift.String(describing: jobStatus)), jobName: \"CONTENT_REDACTED\")"}
}

public struct ListSpeakerEnrollmentJobsOutput: Swift.Sendable {
    /// A list containing details about each specified speaker enrollment job.
    public var jobSummaries: [VoiceIDClientTypes.SpeakerEnrollmentJobSummary]?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        jobSummaries: [VoiceIDClientTypes.SpeakerEnrollmentJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

public struct ListSpeakersInput: Swift.Sendable {
    /// The identifier of the domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results that are returned per call. You can use NextToken to obtain more pages of results. The default is 100; the maximum allowed page size is also 100.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension VoiceIDClientTypes {

    /// Contains a summary of information about a speaker.
    public struct SpeakerSummary: Swift.Sendable {
        /// A timestamp showing the speaker's creation time.
        public var createdAt: Foundation.Date?
        /// The client-provided identifier for the speaker.
        public var customerSpeakerId: Swift.String?
        /// The identifier of the domain that contains the speaker.
        public var domainId: Swift.String?
        /// The service-generated identifier for the speaker.
        public var generatedSpeakerId: Swift.String?
        /// The timestamp when the speaker was last accessed for enrollment, re-enrollment or a successful authentication. This timestamp is accurate to one hour.
        public var lastAccessedAt: Foundation.Date?
        /// The current status of the speaker.
        public var status: VoiceIDClientTypes.SpeakerStatus?
        /// A timestamp showing the speaker's last update.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            customerSpeakerId: Swift.String? = nil,
            domainId: Swift.String? = nil,
            generatedSpeakerId: Swift.String? = nil,
            lastAccessedAt: Foundation.Date? = nil,
            status: VoiceIDClientTypes.SpeakerStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.customerSpeakerId = customerSpeakerId
            self.domainId = domainId
            self.generatedSpeakerId = generatedSpeakerId
            self.lastAccessedAt = lastAccessedAt
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

extension VoiceIDClientTypes.SpeakerSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SpeakerSummary(createdAt: \(Swift.String(describing: createdAt)), domainId: \(Swift.String(describing: domainId)), generatedSpeakerId: \(Swift.String(describing: generatedSpeakerId)), lastAccessedAt: \(Swift.String(describing: lastAccessedAt)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), customerSpeakerId: \"CONTENT_REDACTED\")"}
}

public struct ListSpeakersOutput: Swift.Sendable {
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?
    /// A list containing details about each speaker in the Amazon Web Services account.
    public var speakerSummaries: [VoiceIDClientTypes.SpeakerSummary]?

    public init(
        nextToken: Swift.String? = nil,
        speakerSummaries: [VoiceIDClientTypes.SpeakerSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.speakerSummaries = speakerSummaries
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Voice ID resource for which you want to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The list of tags associated with the specified resource.
    public var tags: [VoiceIDClientTypes.Tag]?

    public init(
        tags: [VoiceIDClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListWatchlistsInput: Swift.Sendable {
    /// The identifier of the domain.
    /// This member is required.
    public var domainId: Swift.String?
    /// The maximum number of results that are returned per call. You can use NextToken to obtain more pages of results. The default is 100; the maximum allowed page size is also 100.
    public var maxResults: Swift.Int?
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension VoiceIDClientTypes {

    /// Contains a summary of information about a watchlist.
    public struct WatchlistSummary: Swift.Sendable {
        /// The timestamp of when the watchlist was created.
        public var createdAt: Foundation.Date?
        /// Whether the specified watchlist is the default watchlist of a domain.
        public var defaultWatchlist: Swift.Bool
        /// The description of the watchlist.
        public var description: Swift.String?
        /// The identifier of the domain that contains the watchlist.
        public var domainId: Swift.String?
        /// The name for the watchlist.
        public var name: Swift.String?
        /// The timestamp of when the watchlist was last updated.
        public var updatedAt: Foundation.Date?
        /// The identifier of the watchlist.
        public var watchlistId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            defaultWatchlist: Swift.Bool = false,
            description: Swift.String? = nil,
            domainId: Swift.String? = nil,
            name: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            watchlistId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.defaultWatchlist = defaultWatchlist
            self.description = description
            self.domainId = domainId
            self.name = name
            self.updatedAt = updatedAt
            self.watchlistId = watchlistId
        }
    }
}

extension VoiceIDClientTypes.WatchlistSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WatchlistSummary(createdAt: \(Swift.String(describing: createdAt)), defaultWatchlist: \(Swift.String(describing: defaultWatchlist)), domainId: \(Swift.String(describing: domainId)), updatedAt: \(Swift.String(describing: updatedAt)), watchlistId: \(Swift.String(describing: watchlistId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct ListWatchlistsOutput: Swift.Sendable {
    /// If NextToken is returned, there are more results available. The value of NextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?
    /// A list that contains details about each watchlist in the Amazon Web Services account.
    public var watchlistSummaries: [VoiceIDClientTypes.WatchlistSummary]?

    public init(
        nextToken: Swift.String? = nil,
        watchlistSummaries: [VoiceIDClientTypes.WatchlistSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.watchlistSummaries = watchlistSummaries
    }
}

public struct OptOutSpeakerInput: Swift.Sendable {
    /// The identifier of the domain that contains the speaker.
    /// This member is required.
    public var domainId: Swift.String?
    /// The identifier of the speaker you want opted-out.
    /// This member is required.
    public var speakerId: Swift.String?

    public init(
        domainId: Swift.String? = nil,
        speakerId: Swift.String? = nil
    )
    {
        self.domainId = domainId
        self.speakerId = speakerId
    }
}

extension OptOutSpeakerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptOutSpeakerInput(domainId: \(Swift.String(describing: domainId)), speakerId: \"CONTENT_REDACTED\")"}
}

public struct OptOutSpeakerOutput: Swift.Sendable {
    /// Details about the opted-out speaker.
    public var speaker: VoiceIDClientTypes.Speaker?

    public init(
        speaker: VoiceIDClientTypes.Speaker? = nil
    )
    {
        self.speaker = speaker
    }
}

public struct StartFraudsterRegistrationJobInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the Job output file. Refer to the [Create and edit a fraudster watchlist](https://docs.aws.amazon.com/connect/latest/adminguide/voiceid-fraudster-watchlist.html) documentation for the permissions needed in this role.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The identifier of the domain that contains the fraudster registration job and in which the fraudsters are registered.
    /// This member is required.
    public var domainId: Swift.String?
    /// The input data config containing an S3 URI for the input manifest file that contains the list of fraudster registration requests.
    /// This member is required.
    public var inputDataConfig: VoiceIDClientTypes.InputDataConfig?
    /// The name of the new fraudster registration job.
    public var jobName: Swift.String?
    /// The output data config containing the S3 location where Voice ID writes the job output file; you must also include a KMS key ID to encrypt the file.
    /// This member is required.
    public var outputDataConfig: VoiceIDClientTypes.OutputDataConfig?
    /// The registration config containing details such as the action to take when a duplicate fraudster is detected, and the similarity threshold to use for detecting a duplicate fraudster.
    public var registrationConfig: VoiceIDClientTypes.RegistrationConfig?

    public init(
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        domainId: Swift.String? = nil,
        inputDataConfig: VoiceIDClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: VoiceIDClientTypes.OutputDataConfig? = nil,
        registrationConfig: VoiceIDClientTypes.RegistrationConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.domainId = domainId
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
        self.registrationConfig = registrationConfig
    }
}

extension StartFraudsterRegistrationJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartFraudsterRegistrationJobInput(clientToken: \(Swift.String(describing: clientToken)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), domainId: \(Swift.String(describing: domainId)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), registrationConfig: \(Swift.String(describing: registrationConfig)), jobName: \"CONTENT_REDACTED\")"}
}

public struct StartFraudsterRegistrationJobOutput: Swift.Sendable {
    /// Details about the started fraudster registration job.
    public var job: VoiceIDClientTypes.FraudsterRegistrationJob?

    public init(
        job: VoiceIDClientTypes.FraudsterRegistrationJob? = nil
    )
    {
        self.job = job
    }
}

public struct StartSpeakerEnrollmentJobInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The IAM role Amazon Resource Name (ARN) that grants Voice ID permissions to access customer's buckets to read the input manifest file and write the job output file. Refer to [Batch enrollment using audio data from prior calls](https://docs.aws.amazon.com/connect/latest/adminguide/voiceid-batch-enrollment.html) for the permissions needed in this role.
    /// This member is required.
    public var dataAccessRoleArn: Swift.String?
    /// The identifier of the domain that contains the speaker enrollment job and in which the speakers are enrolled.
    /// This member is required.
    public var domainId: Swift.String?
    /// The enrollment config that contains details such as the action to take when a speaker is already enrolled in Voice ID or when a speaker is identified as a fraudster.
    public var enrollmentConfig: VoiceIDClientTypes.EnrollmentConfig?
    /// The input data config containing the S3 location for the input manifest file that contains the list of speaker enrollment requests.
    /// This member is required.
    public var inputDataConfig: VoiceIDClientTypes.InputDataConfig?
    /// A name for your speaker enrollment job.
    public var jobName: Swift.String?
    /// The output data config containing the S3 location where Voice ID writes the job output file; you must also include a KMS key ID to encrypt the file.
    /// This member is required.
    public var outputDataConfig: VoiceIDClientTypes.OutputDataConfig?

    public init(
        clientToken: Swift.String? = nil,
        dataAccessRoleArn: Swift.String? = nil,
        domainId: Swift.String? = nil,
        enrollmentConfig: VoiceIDClientTypes.EnrollmentConfig? = nil,
        inputDataConfig: VoiceIDClientTypes.InputDataConfig? = nil,
        jobName: Swift.String? = nil,
        outputDataConfig: VoiceIDClientTypes.OutputDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.domainId = domainId
        self.enrollmentConfig = enrollmentConfig
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
    }
}

extension StartSpeakerEnrollmentJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSpeakerEnrollmentJobInput(clientToken: \(Swift.String(describing: clientToken)), dataAccessRoleArn: \(Swift.String(describing: dataAccessRoleArn)), domainId: \(Swift.String(describing: domainId)), enrollmentConfig: \(Swift.String(describing: enrollmentConfig)), inputDataConfig: \(Swift.String(describing: inputDataConfig)), outputDataConfig: \(Swift.String(describing: outputDataConfig)), jobName: \"CONTENT_REDACTED\")"}
}

public struct StartSpeakerEnrollmentJobOutput: Swift.Sendable {
    /// Details about the started speaker enrollment job.
    public var job: VoiceIDClientTypes.SpeakerEnrollmentJob?

    public init(
        job: VoiceIDClientTypes.SpeakerEnrollmentJob? = nil
    )
    {
        self.job = job
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Voice ID resource you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tags to assign to the specified resource.
    /// This member is required.
    public var tags: [VoiceIDClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [VoiceIDClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Voice ID resource you want to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys you want to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateWatchlistInput: Swift.Sendable {
    /// A brief description about this watchlist.
    public var description: Swift.String?
    /// The identifier of the domain that contains the watchlist.
    /// This member is required.
    public var domainId: Swift.String?
    /// The name of the watchlist.
    public var name: Swift.String?
    /// The identifier of the watchlist to be updated.
    /// This member is required.
    public var watchlistId: Swift.String?

    public init(
        description: Swift.String? = nil,
        domainId: Swift.String? = nil,
        name: Swift.String? = nil,
        watchlistId: Swift.String? = nil
    )
    {
        self.description = description
        self.domainId = domainId
        self.name = name
        self.watchlistId = watchlistId
    }
}

extension UpdateWatchlistInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWatchlistInput(domainId: \(Swift.String(describing: domainId)), watchlistId: \(Swift.String(describing: watchlistId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateWatchlistOutput: Swift.Sendable {
    /// Details about the updated watchlist.
    public var watchlist: VoiceIDClientTypes.Watchlist?

    public init(
        watchlist: VoiceIDClientTypes.Watchlist? = nil
    )
    {
        self.watchlist = watchlist
    }
}

extension AssociateFraudsterInput {

    static func urlPathProvider(_ value: AssociateFraudsterInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDomainInput {

    static func urlPathProvider(_ value: CreateDomainInput) -> Swift.String? {
        return "/"
    }
}

extension CreateWatchlistInput {

    static func urlPathProvider(_ value: CreateWatchlistInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDomainInput {

    static func urlPathProvider(_ value: DeleteDomainInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteFraudsterInput {

    static func urlPathProvider(_ value: DeleteFraudsterInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSpeakerInput {

    static func urlPathProvider(_ value: DeleteSpeakerInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteWatchlistInput {

    static func urlPathProvider(_ value: DeleteWatchlistInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDomainInput {

    static func urlPathProvider(_ value: DescribeDomainInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeFraudsterInput {

    static func urlPathProvider(_ value: DescribeFraudsterInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeFraudsterRegistrationJobInput {

    static func urlPathProvider(_ value: DescribeFraudsterRegistrationJobInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSpeakerInput {

    static func urlPathProvider(_ value: DescribeSpeakerInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSpeakerEnrollmentJobInput {

    static func urlPathProvider(_ value: DescribeSpeakerEnrollmentJobInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeWatchlistInput {

    static func urlPathProvider(_ value: DescribeWatchlistInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateFraudsterInput {

    static func urlPathProvider(_ value: DisassociateFraudsterInput) -> Swift.String? {
        return "/"
    }
}

extension EvaluateSessionInput {

    static func urlPathProvider(_ value: EvaluateSessionInput) -> Swift.String? {
        return "/"
    }
}

extension ListDomainsInput {

    static func urlPathProvider(_ value: ListDomainsInput) -> Swift.String? {
        return "/"
    }
}

extension ListFraudsterRegistrationJobsInput {

    static func urlPathProvider(_ value: ListFraudsterRegistrationJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListFraudstersInput {

    static func urlPathProvider(_ value: ListFraudstersInput) -> Swift.String? {
        return "/"
    }
}

extension ListSpeakerEnrollmentJobsInput {

    static func urlPathProvider(_ value: ListSpeakerEnrollmentJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListSpeakersInput {

    static func urlPathProvider(_ value: ListSpeakersInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListWatchlistsInput {

    static func urlPathProvider(_ value: ListWatchlistsInput) -> Swift.String? {
        return "/"
    }
}

extension OptOutSpeakerInput {

    static func urlPathProvider(_ value: OptOutSpeakerInput) -> Swift.String? {
        return "/"
    }
}

extension StartFraudsterRegistrationJobInput {

    static func urlPathProvider(_ value: StartFraudsterRegistrationJobInput) -> Swift.String? {
        return "/"
    }
}

extension StartSpeakerEnrollmentJobInput {

    static func urlPathProvider(_ value: StartSpeakerEnrollmentJobInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDomainInput {

    static func urlPathProvider(_ value: UpdateDomainInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateWatchlistInput {

    static func urlPathProvider(_ value: UpdateWatchlistInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateFraudsterInput {

    static func write(value: AssociateFraudsterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainId"].write(value.domainId)
        try writer["FraudsterId"].write(value.fraudsterId)
        try writer["WatchlistId"].write(value.watchlistId)
    }
}

extension CreateDomainInput {

    static func write(value: CreateDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["ServerSideEncryptionConfiguration"].write(value.serverSideEncryptionConfiguration, with: VoiceIDClientTypes.ServerSideEncryptionConfiguration.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: VoiceIDClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateWatchlistInput {

    static func write(value: CreateWatchlistInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["DomainId"].write(value.domainId)
        try writer["Name"].write(value.name)
    }
}

extension DeleteDomainInput {

    static func write(value: DeleteDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainId"].write(value.domainId)
    }
}

extension DeleteFraudsterInput {

    static func write(value: DeleteFraudsterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainId"].write(value.domainId)
        try writer["FraudsterId"].write(value.fraudsterId)
    }
}

extension DeleteSpeakerInput {

    static func write(value: DeleteSpeakerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainId"].write(value.domainId)
        try writer["SpeakerId"].write(value.speakerId)
    }
}

extension DeleteWatchlistInput {

    static func write(value: DeleteWatchlistInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainId"].write(value.domainId)
        try writer["WatchlistId"].write(value.watchlistId)
    }
}

extension DescribeDomainInput {

    static func write(value: DescribeDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainId"].write(value.domainId)
    }
}

extension DescribeFraudsterInput {

    static func write(value: DescribeFraudsterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainId"].write(value.domainId)
        try writer["FraudsterId"].write(value.fraudsterId)
    }
}

extension DescribeFraudsterRegistrationJobInput {

    static func write(value: DescribeFraudsterRegistrationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainId"].write(value.domainId)
        try writer["JobId"].write(value.jobId)
    }
}

extension DescribeSpeakerInput {

    static func write(value: DescribeSpeakerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainId"].write(value.domainId)
        try writer["SpeakerId"].write(value.speakerId)
    }
}

extension DescribeSpeakerEnrollmentJobInput {

    static func write(value: DescribeSpeakerEnrollmentJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainId"].write(value.domainId)
        try writer["JobId"].write(value.jobId)
    }
}

extension DescribeWatchlistInput {

    static func write(value: DescribeWatchlistInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainId"].write(value.domainId)
        try writer["WatchlistId"].write(value.watchlistId)
    }
}

extension DisassociateFraudsterInput {

    static func write(value: DisassociateFraudsterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainId"].write(value.domainId)
        try writer["FraudsterId"].write(value.fraudsterId)
        try writer["WatchlistId"].write(value.watchlistId)
    }
}

extension EvaluateSessionInput {

    static func write(value: EvaluateSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainId"].write(value.domainId)
        try writer["SessionNameOrId"].write(value.sessionNameOrId)
    }
}

extension ListDomainsInput {

    static func write(value: ListDomainsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListFraudsterRegistrationJobsInput {

    static func write(value: ListFraudsterRegistrationJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainId"].write(value.domainId)
        try writer["JobStatus"].write(value.jobStatus)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListFraudstersInput {

    static func write(value: ListFraudstersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainId"].write(value.domainId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["WatchlistId"].write(value.watchlistId)
    }
}

extension ListSpeakerEnrollmentJobsInput {

    static func write(value: ListSpeakerEnrollmentJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainId"].write(value.domainId)
        try writer["JobStatus"].write(value.jobStatus)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListSpeakersInput {

    static func write(value: ListSpeakersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainId"].write(value.domainId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension ListWatchlistsInput {

    static func write(value: ListWatchlistsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainId"].write(value.domainId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension OptOutSpeakerInput {

    static func write(value: OptOutSpeakerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DomainId"].write(value.domainId)
        try writer["SpeakerId"].write(value.speakerId)
    }
}

extension StartFraudsterRegistrationJobInput {

    static func write(value: StartFraudsterRegistrationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DataAccessRoleArn"].write(value.dataAccessRoleArn)
        try writer["DomainId"].write(value.domainId)
        try writer["InputDataConfig"].write(value.inputDataConfig, with: VoiceIDClientTypes.InputDataConfig.write(value:to:))
        try writer["JobName"].write(value.jobName)
        try writer["OutputDataConfig"].write(value.outputDataConfig, with: VoiceIDClientTypes.OutputDataConfig.write(value:to:))
        try writer["RegistrationConfig"].write(value.registrationConfig, with: VoiceIDClientTypes.RegistrationConfig.write(value:to:))
    }
}

extension StartSpeakerEnrollmentJobInput {

    static func write(value: StartSpeakerEnrollmentJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DataAccessRoleArn"].write(value.dataAccessRoleArn)
        try writer["DomainId"].write(value.domainId)
        try writer["EnrollmentConfig"].write(value.enrollmentConfig, with: VoiceIDClientTypes.EnrollmentConfig.write(value:to:))
        try writer["InputDataConfig"].write(value.inputDataConfig, with: VoiceIDClientTypes.InputDataConfig.write(value:to:))
        try writer["JobName"].write(value.jobName)
        try writer["OutputDataConfig"].write(value.outputDataConfig, with: VoiceIDClientTypes.OutputDataConfig.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: VoiceIDClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDomainInput {

    static func write(value: UpdateDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["DomainId"].write(value.domainId)
        try writer["Name"].write(value.name)
        try writer["ServerSideEncryptionConfiguration"].write(value.serverSideEncryptionConfiguration, with: VoiceIDClientTypes.ServerSideEncryptionConfiguration.write(value:to:))
    }
}

extension UpdateWatchlistInput {

    static func write(value: UpdateWatchlistInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["DomainId"].write(value.domainId)
        try writer["Name"].write(value.name)
        try writer["WatchlistId"].write(value.watchlistId)
    }
}

extension AssociateFraudsterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateFraudsterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateFraudsterOutput()
        value.fraudster = try reader["Fraudster"].readIfPresent(with: VoiceIDClientTypes.Fraudster.read(from:))
        return value
    }
}

extension CreateDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDomainOutput()
        value.domain = try reader["Domain"].readIfPresent(with: VoiceIDClientTypes.Domain.read(from:))
        return value
    }
}

extension CreateWatchlistOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWatchlistOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWatchlistOutput()
        value.watchlist = try reader["Watchlist"].readIfPresent(with: VoiceIDClientTypes.Watchlist.read(from:))
        return value
    }
}

extension DeleteDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDomainOutput {
        return DeleteDomainOutput()
    }
}

extension DeleteFraudsterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFraudsterOutput {
        return DeleteFraudsterOutput()
    }
}

extension DeleteSpeakerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSpeakerOutput {
        return DeleteSpeakerOutput()
    }
}

extension DeleteWatchlistOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWatchlistOutput {
        return DeleteWatchlistOutput()
    }
}

extension DescribeDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDomainOutput()
        value.domain = try reader["Domain"].readIfPresent(with: VoiceIDClientTypes.Domain.read(from:))
        return value
    }
}

extension DescribeFraudsterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFraudsterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFraudsterOutput()
        value.fraudster = try reader["Fraudster"].readIfPresent(with: VoiceIDClientTypes.Fraudster.read(from:))
        return value
    }
}

extension DescribeFraudsterRegistrationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFraudsterRegistrationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFraudsterRegistrationJobOutput()
        value.job = try reader["Job"].readIfPresent(with: VoiceIDClientTypes.FraudsterRegistrationJob.read(from:))
        return value
    }
}

extension DescribeSpeakerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSpeakerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSpeakerOutput()
        value.speaker = try reader["Speaker"].readIfPresent(with: VoiceIDClientTypes.Speaker.read(from:))
        return value
    }
}

extension DescribeSpeakerEnrollmentJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSpeakerEnrollmentJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSpeakerEnrollmentJobOutput()
        value.job = try reader["Job"].readIfPresent(with: VoiceIDClientTypes.SpeakerEnrollmentJob.read(from:))
        return value
    }
}

extension DescribeWatchlistOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWatchlistOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWatchlistOutput()
        value.watchlist = try reader["Watchlist"].readIfPresent(with: VoiceIDClientTypes.Watchlist.read(from:))
        return value
    }
}

extension DisassociateFraudsterOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateFraudsterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateFraudsterOutput()
        value.fraudster = try reader["Fraudster"].readIfPresent(with: VoiceIDClientTypes.Fraudster.read(from:))
        return value
    }
}

extension EvaluateSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EvaluateSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EvaluateSessionOutput()
        value.authenticationResult = try reader["AuthenticationResult"].readIfPresent(with: VoiceIDClientTypes.AuthenticationResult.read(from:))
        value.domainId = try reader["DomainId"].readIfPresent()
        value.fraudDetectionResult = try reader["FraudDetectionResult"].readIfPresent(with: VoiceIDClientTypes.FraudDetectionResult.read(from:))
        value.sessionId = try reader["SessionId"].readIfPresent()
        value.sessionName = try reader["SessionName"].readIfPresent()
        value.streamingStatus = try reader["StreamingStatus"].readIfPresent()
        return value
    }
}

extension ListDomainsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDomainsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDomainsOutput()
        value.domainSummaries = try reader["DomainSummaries"].readListIfPresent(memberReadingClosure: VoiceIDClientTypes.DomainSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListFraudsterRegistrationJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFraudsterRegistrationJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFraudsterRegistrationJobsOutput()
        value.jobSummaries = try reader["JobSummaries"].readListIfPresent(memberReadingClosure: VoiceIDClientTypes.FraudsterRegistrationJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListFraudstersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFraudstersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFraudstersOutput()
        value.fraudsterSummaries = try reader["FraudsterSummaries"].readListIfPresent(memberReadingClosure: VoiceIDClientTypes.FraudsterSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListSpeakerEnrollmentJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSpeakerEnrollmentJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSpeakerEnrollmentJobsOutput()
        value.jobSummaries = try reader["JobSummaries"].readListIfPresent(memberReadingClosure: VoiceIDClientTypes.SpeakerEnrollmentJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListSpeakersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSpeakersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSpeakersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.speakerSummaries = try reader["SpeakerSummaries"].readListIfPresent(memberReadingClosure: VoiceIDClientTypes.SpeakerSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: VoiceIDClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWatchlistsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWatchlistsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWatchlistsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.watchlistSummaries = try reader["WatchlistSummaries"].readListIfPresent(memberReadingClosure: VoiceIDClientTypes.WatchlistSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OptOutSpeakerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> OptOutSpeakerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = OptOutSpeakerOutput()
        value.speaker = try reader["Speaker"].readIfPresent(with: VoiceIDClientTypes.Speaker.read(from:))
        return value
    }
}

extension StartFraudsterRegistrationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartFraudsterRegistrationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartFraudsterRegistrationJobOutput()
        value.job = try reader["Job"].readIfPresent(with: VoiceIDClientTypes.FraudsterRegistrationJob.read(from:))
        return value
    }
}

extension StartSpeakerEnrollmentJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartSpeakerEnrollmentJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartSpeakerEnrollmentJobOutput()
        value.job = try reader["Job"].readIfPresent(with: VoiceIDClientTypes.SpeakerEnrollmentJob.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDomainOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDomainOutput()
        value.domain = try reader["Domain"].readIfPresent(with: VoiceIDClientTypes.Domain.read(from:))
        return value
    }
}

extension UpdateWatchlistOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWatchlistOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateWatchlistOutput()
        value.watchlist = try reader["Watchlist"].readIfPresent(with: VoiceIDClientTypes.Watchlist.read(from:))
        return value
    }
}

enum AssociateFraudsterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWatchlistOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFraudsterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSpeakerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWatchlistOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFraudsterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFraudsterRegistrationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSpeakerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSpeakerEnrollmentJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWatchlistOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateFraudsterOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EvaluateSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDomainsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFraudsterRegistrationJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFraudstersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSpeakerEnrollmentJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSpeakersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWatchlistsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum OptOutSpeakerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartFraudsterRegistrationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartSpeakerEnrollmentJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWatchlistOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.conflictType = try reader["ConflictType"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension VoiceIDClientTypes.Fraudster {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.Fraudster {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.Fraudster()
        value.domainId = try reader["DomainId"].readIfPresent()
        value.generatedFraudsterId = try reader["GeneratedFraudsterId"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.watchlistIds = try reader["WatchlistIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension VoiceIDClientTypes.Domain {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.Domain {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.Domain()
        value.domainId = try reader["DomainId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.domainStatus = try reader["DomainStatus"].readIfPresent()
        value.serverSideEncryptionConfiguration = try reader["ServerSideEncryptionConfiguration"].readIfPresent(with: VoiceIDClientTypes.ServerSideEncryptionConfiguration.read(from:))
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.serverSideEncryptionUpdateDetails = try reader["ServerSideEncryptionUpdateDetails"].readIfPresent(with: VoiceIDClientTypes.ServerSideEncryptionUpdateDetails.read(from:))
        value.watchlistDetails = try reader["WatchlistDetails"].readIfPresent(with: VoiceIDClientTypes.WatchlistDetails.read(from:))
        return value
    }
}

extension VoiceIDClientTypes.WatchlistDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.WatchlistDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.WatchlistDetails()
        value.defaultWatchlistId = try reader["DefaultWatchlistId"].readIfPresent() ?? ""
        return value
    }
}

extension VoiceIDClientTypes.ServerSideEncryptionUpdateDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.ServerSideEncryptionUpdateDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.ServerSideEncryptionUpdateDetails()
        value.oldKmsKeyId = try reader["OldKmsKeyId"].readIfPresent()
        value.updateStatus = try reader["UpdateStatus"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension VoiceIDClientTypes.ServerSideEncryptionConfiguration {

    static func write(value: VoiceIDClientTypes.ServerSideEncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KmsKeyId"].write(value.kmsKeyId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.ServerSideEncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.ServerSideEncryptionConfiguration()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent() ?? ""
        return value
    }
}

extension VoiceIDClientTypes.Watchlist {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.Watchlist {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.Watchlist()
        value.domainId = try reader["DomainId"].readIfPresent()
        value.watchlistId = try reader["WatchlistId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.defaultWatchlist = try reader["DefaultWatchlist"].readIfPresent() ?? false
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension VoiceIDClientTypes.FraudsterRegistrationJob {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.FraudsterRegistrationJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.FraudsterRegistrationJob()
        value.jobName = try reader["JobName"].readIfPresent()
        value.jobId = try reader["JobId"].readIfPresent()
        value.jobStatus = try reader["JobStatus"].readIfPresent()
        value.domainId = try reader["DomainId"].readIfPresent()
        value.dataAccessRoleArn = try reader["DataAccessRoleArn"].readIfPresent()
        value.registrationConfig = try reader["RegistrationConfig"].readIfPresent(with: VoiceIDClientTypes.RegistrationConfig.read(from:))
        value.inputDataConfig = try reader["InputDataConfig"].readIfPresent(with: VoiceIDClientTypes.InputDataConfig.read(from:))
        value.outputDataConfig = try reader["OutputDataConfig"].readIfPresent(with: VoiceIDClientTypes.OutputDataConfig.read(from:))
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endedAt = try reader["EndedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureDetails = try reader["FailureDetails"].readIfPresent(with: VoiceIDClientTypes.FailureDetails.read(from:))
        value.jobProgress = try reader["JobProgress"].readIfPresent(with: VoiceIDClientTypes.JobProgress.read(from:))
        return value
    }
}

extension VoiceIDClientTypes.JobProgress {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.JobProgress {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.JobProgress()
        value.percentComplete = try reader["PercentComplete"].readIfPresent()
        return value
    }
}

extension VoiceIDClientTypes.FailureDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.FailureDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.FailureDetails()
        value.statusCode = try reader["StatusCode"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension VoiceIDClientTypes.OutputDataConfig {

    static func write(value: VoiceIDClientTypes.OutputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["S3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.OutputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.OutputDataConfig()
        value.s3Uri = try reader["S3Uri"].readIfPresent() ?? ""
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        return value
    }
}

extension VoiceIDClientTypes.InputDataConfig {

    static func write(value: VoiceIDClientTypes.InputDataConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.InputDataConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.InputDataConfig()
        value.s3Uri = try reader["S3Uri"].readIfPresent() ?? ""
        return value
    }
}

extension VoiceIDClientTypes.RegistrationConfig {

    static func write(value: VoiceIDClientTypes.RegistrationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DuplicateRegistrationAction"].write(value.duplicateRegistrationAction)
        try writer["FraudsterSimilarityThreshold"].write(value.fraudsterSimilarityThreshold)
        try writer["WatchlistIds"].writeList(value.watchlistIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.RegistrationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.RegistrationConfig()
        value.duplicateRegistrationAction = try reader["DuplicateRegistrationAction"].readIfPresent()
        value.fraudsterSimilarityThreshold = try reader["FraudsterSimilarityThreshold"].readIfPresent()
        value.watchlistIds = try reader["WatchlistIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension VoiceIDClientTypes.Speaker {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.Speaker {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.Speaker()
        value.domainId = try reader["DomainId"].readIfPresent()
        value.customerSpeakerId = try reader["CustomerSpeakerId"].readIfPresent()
        value.generatedSpeakerId = try reader["GeneratedSpeakerId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastAccessedAt = try reader["LastAccessedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension VoiceIDClientTypes.SpeakerEnrollmentJob {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.SpeakerEnrollmentJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.SpeakerEnrollmentJob()
        value.jobName = try reader["JobName"].readIfPresent()
        value.jobId = try reader["JobId"].readIfPresent()
        value.jobStatus = try reader["JobStatus"].readIfPresent()
        value.domainId = try reader["DomainId"].readIfPresent()
        value.dataAccessRoleArn = try reader["DataAccessRoleArn"].readIfPresent()
        value.enrollmentConfig = try reader["EnrollmentConfig"].readIfPresent(with: VoiceIDClientTypes.EnrollmentConfig.read(from:))
        value.inputDataConfig = try reader["InputDataConfig"].readIfPresent(with: VoiceIDClientTypes.InputDataConfig.read(from:))
        value.outputDataConfig = try reader["OutputDataConfig"].readIfPresent(with: VoiceIDClientTypes.OutputDataConfig.read(from:))
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endedAt = try reader["EndedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureDetails = try reader["FailureDetails"].readIfPresent(with: VoiceIDClientTypes.FailureDetails.read(from:))
        value.jobProgress = try reader["JobProgress"].readIfPresent(with: VoiceIDClientTypes.JobProgress.read(from:))
        return value
    }
}

extension VoiceIDClientTypes.EnrollmentConfig {

    static func write(value: VoiceIDClientTypes.EnrollmentConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExistingEnrollmentAction"].write(value.existingEnrollmentAction)
        try writer["FraudDetectionConfig"].write(value.fraudDetectionConfig, with: VoiceIDClientTypes.EnrollmentJobFraudDetectionConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.EnrollmentConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.EnrollmentConfig()
        value.existingEnrollmentAction = try reader["ExistingEnrollmentAction"].readIfPresent()
        value.fraudDetectionConfig = try reader["FraudDetectionConfig"].readIfPresent(with: VoiceIDClientTypes.EnrollmentJobFraudDetectionConfig.read(from:))
        return value
    }
}

extension VoiceIDClientTypes.EnrollmentJobFraudDetectionConfig {

    static func write(value: VoiceIDClientTypes.EnrollmentJobFraudDetectionConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FraudDetectionAction"].write(value.fraudDetectionAction)
        try writer["RiskThreshold"].write(value.riskThreshold)
        try writer["WatchlistIds"].writeList(value.watchlistIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.EnrollmentJobFraudDetectionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.EnrollmentJobFraudDetectionConfig()
        value.fraudDetectionAction = try reader["FraudDetectionAction"].readIfPresent()
        value.riskThreshold = try reader["RiskThreshold"].readIfPresent()
        value.watchlistIds = try reader["WatchlistIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension VoiceIDClientTypes.AuthenticationResult {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.AuthenticationResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.AuthenticationResult()
        value.authenticationResultId = try reader["AuthenticationResultId"].readIfPresent()
        value.audioAggregationStartedAt = try reader["AudioAggregationStartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.audioAggregationEndedAt = try reader["AudioAggregationEndedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.customerSpeakerId = try reader["CustomerSpeakerId"].readIfPresent()
        value.generatedSpeakerId = try reader["GeneratedSpeakerId"].readIfPresent()
        value.decision = try reader["Decision"].readIfPresent()
        value.score = try reader["Score"].readIfPresent()
        value.configuration = try reader["Configuration"].readIfPresent(with: VoiceIDClientTypes.AuthenticationConfiguration.read(from:))
        return value
    }
}

extension VoiceIDClientTypes.AuthenticationConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.AuthenticationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.AuthenticationConfiguration()
        value.acceptanceThreshold = try reader["AcceptanceThreshold"].readIfPresent() ?? 0
        return value
    }
}

extension VoiceIDClientTypes.FraudDetectionResult {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.FraudDetectionResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.FraudDetectionResult()
        value.fraudDetectionResultId = try reader["FraudDetectionResultId"].readIfPresent()
        value.audioAggregationStartedAt = try reader["AudioAggregationStartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.audioAggregationEndedAt = try reader["AudioAggregationEndedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.configuration = try reader["Configuration"].readIfPresent(with: VoiceIDClientTypes.FraudDetectionConfiguration.read(from:))
        value.decision = try reader["Decision"].readIfPresent()
        value.reasons = try reader["Reasons"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<VoiceIDClientTypes.FraudDetectionReason>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.riskDetails = try reader["RiskDetails"].readIfPresent(with: VoiceIDClientTypes.FraudRiskDetails.read(from:))
        return value
    }
}

extension VoiceIDClientTypes.FraudRiskDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.FraudRiskDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.FraudRiskDetails()
        value.knownFraudsterRisk = try reader["KnownFraudsterRisk"].readIfPresent(with: VoiceIDClientTypes.KnownFraudsterRisk.read(from:))
        value.voiceSpoofingRisk = try reader["VoiceSpoofingRisk"].readIfPresent(with: VoiceIDClientTypes.VoiceSpoofingRisk.read(from:))
        return value
    }
}

extension VoiceIDClientTypes.VoiceSpoofingRisk {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.VoiceSpoofingRisk {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.VoiceSpoofingRisk()
        value.riskScore = try reader["RiskScore"].readIfPresent() ?? 0
        return value
    }
}

extension VoiceIDClientTypes.KnownFraudsterRisk {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.KnownFraudsterRisk {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.KnownFraudsterRisk()
        value.riskScore = try reader["RiskScore"].readIfPresent() ?? 0
        value.generatedFraudsterId = try reader["GeneratedFraudsterId"].readIfPresent()
        return value
    }
}

extension VoiceIDClientTypes.FraudDetectionConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.FraudDetectionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.FraudDetectionConfiguration()
        value.riskThreshold = try reader["RiskThreshold"].readIfPresent()
        value.watchlistId = try reader["WatchlistId"].readIfPresent()
        return value
    }
}

extension VoiceIDClientTypes.DomainSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.DomainSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.DomainSummary()
        value.domainId = try reader["DomainId"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.domainStatus = try reader["DomainStatus"].readIfPresent()
        value.serverSideEncryptionConfiguration = try reader["ServerSideEncryptionConfiguration"].readIfPresent(with: VoiceIDClientTypes.ServerSideEncryptionConfiguration.read(from:))
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.serverSideEncryptionUpdateDetails = try reader["ServerSideEncryptionUpdateDetails"].readIfPresent(with: VoiceIDClientTypes.ServerSideEncryptionUpdateDetails.read(from:))
        value.watchlistDetails = try reader["WatchlistDetails"].readIfPresent(with: VoiceIDClientTypes.WatchlistDetails.read(from:))
        return value
    }
}

extension VoiceIDClientTypes.FraudsterRegistrationJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.FraudsterRegistrationJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.FraudsterRegistrationJobSummary()
        value.jobName = try reader["JobName"].readIfPresent()
        value.jobId = try reader["JobId"].readIfPresent()
        value.jobStatus = try reader["JobStatus"].readIfPresent()
        value.domainId = try reader["DomainId"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endedAt = try reader["EndedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureDetails = try reader["FailureDetails"].readIfPresent(with: VoiceIDClientTypes.FailureDetails.read(from:))
        value.jobProgress = try reader["JobProgress"].readIfPresent(with: VoiceIDClientTypes.JobProgress.read(from:))
        return value
    }
}

extension VoiceIDClientTypes.FraudsterSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.FraudsterSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.FraudsterSummary()
        value.domainId = try reader["DomainId"].readIfPresent()
        value.generatedFraudsterId = try reader["GeneratedFraudsterId"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.watchlistIds = try reader["WatchlistIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension VoiceIDClientTypes.SpeakerEnrollmentJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.SpeakerEnrollmentJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.SpeakerEnrollmentJobSummary()
        value.jobName = try reader["JobName"].readIfPresent()
        value.jobId = try reader["JobId"].readIfPresent()
        value.jobStatus = try reader["JobStatus"].readIfPresent()
        value.domainId = try reader["DomainId"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endedAt = try reader["EndedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureDetails = try reader["FailureDetails"].readIfPresent(with: VoiceIDClientTypes.FailureDetails.read(from:))
        value.jobProgress = try reader["JobProgress"].readIfPresent(with: VoiceIDClientTypes.JobProgress.read(from:))
        return value
    }
}

extension VoiceIDClientTypes.SpeakerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.SpeakerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.SpeakerSummary()
        value.domainId = try reader["DomainId"].readIfPresent()
        value.customerSpeakerId = try reader["CustomerSpeakerId"].readIfPresent()
        value.generatedSpeakerId = try reader["GeneratedSpeakerId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastAccessedAt = try reader["LastAccessedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension VoiceIDClientTypes.Tag {

    static func write(value: VoiceIDClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension VoiceIDClientTypes.WatchlistSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> VoiceIDClientTypes.WatchlistSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = VoiceIDClientTypes.WatchlistSummary()
        value.domainId = try reader["DomainId"].readIfPresent()
        value.watchlistId = try reader["WatchlistId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.defaultWatchlist = try reader["DefaultWatchlist"].readIfPresent() ?? false
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

public enum VoiceIDClientTypes {}
