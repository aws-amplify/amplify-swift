//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension ElasticTranscoderClient {
    /// Paginate over `[ListJobsByPipelineOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListJobsByPipelineInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListJobsByPipelineOutput`
    public func listJobsByPipelinePaginated(input: ListJobsByPipelineInput) -> ClientRuntime.PaginatorSequence<ListJobsByPipelineInput, ListJobsByPipelineOutput> {
        return ClientRuntime.PaginatorSequence<ListJobsByPipelineInput, ListJobsByPipelineOutput>(input: input, inputKey: \.pageToken, outputKey: \.nextPageToken, paginationFunction: self.listJobsByPipeline(input:))
    }
}

extension ListJobsByPipelineInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListJobsByPipelineInput {
        return ListJobsByPipelineInput(
            ascending: self.ascending,
            pageToken: token,
            pipelineId: self.pipelineId
        )}
}

extension PaginatorSequence where OperationStackInput == ListJobsByPipelineInput, OperationStackOutput == ListJobsByPipelineOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listJobsByPipelinePaginated`
    /// to access the nested member `[ElasticTranscoderClientTypes.Job]`
    /// - Returns: `[ElasticTranscoderClientTypes.Job]`
    public func jobs() async throws -> [ElasticTranscoderClientTypes.Job] {
        return try await self.asyncCompactMap { item in item.jobs }
    }
}
extension ElasticTranscoderClient {
    /// Paginate over `[ListJobsByStatusOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListJobsByStatusInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListJobsByStatusOutput`
    public func listJobsByStatusPaginated(input: ListJobsByStatusInput) -> ClientRuntime.PaginatorSequence<ListJobsByStatusInput, ListJobsByStatusOutput> {
        return ClientRuntime.PaginatorSequence<ListJobsByStatusInput, ListJobsByStatusOutput>(input: input, inputKey: \.pageToken, outputKey: \.nextPageToken, paginationFunction: self.listJobsByStatus(input:))
    }
}

extension ListJobsByStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListJobsByStatusInput {
        return ListJobsByStatusInput(
            ascending: self.ascending,
            pageToken: token,
            status: self.status
        )}
}

extension PaginatorSequence where OperationStackInput == ListJobsByStatusInput, OperationStackOutput == ListJobsByStatusOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listJobsByStatusPaginated`
    /// to access the nested member `[ElasticTranscoderClientTypes.Job]`
    /// - Returns: `[ElasticTranscoderClientTypes.Job]`
    public func jobs() async throws -> [ElasticTranscoderClientTypes.Job] {
        return try await self.asyncCompactMap { item in item.jobs }
    }
}
extension ElasticTranscoderClient {
    /// Paginate over `[ListPipelinesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPipelinesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPipelinesOutput`
    public func listPipelinesPaginated(input: ListPipelinesInput) -> ClientRuntime.PaginatorSequence<ListPipelinesInput, ListPipelinesOutput> {
        return ClientRuntime.PaginatorSequence<ListPipelinesInput, ListPipelinesOutput>(input: input, inputKey: \.pageToken, outputKey: \.nextPageToken, paginationFunction: self.listPipelines(input:))
    }
}

extension ListPipelinesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPipelinesInput {
        return ListPipelinesInput(
            ascending: self.ascending,
            pageToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListPipelinesInput, OperationStackOutput == ListPipelinesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPipelinesPaginated`
    /// to access the nested member `[ElasticTranscoderClientTypes.Pipeline]`
    /// - Returns: `[ElasticTranscoderClientTypes.Pipeline]`
    public func pipelines() async throws -> [ElasticTranscoderClientTypes.Pipeline] {
        return try await self.asyncCompactMap { item in item.pipelines }
    }
}
extension ElasticTranscoderClient {
    /// Paginate over `[ListPresetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPresetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPresetsOutput`
    public func listPresetsPaginated(input: ListPresetsInput) -> ClientRuntime.PaginatorSequence<ListPresetsInput, ListPresetsOutput> {
        return ClientRuntime.PaginatorSequence<ListPresetsInput, ListPresetsOutput>(input: input, inputKey: \.pageToken, outputKey: \.nextPageToken, paginationFunction: self.listPresets(input:))
    }
}

extension ListPresetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPresetsInput {
        return ListPresetsInput(
            ascending: self.ascending,
            pageToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListPresetsInput, OperationStackOutput == ListPresetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPresetsPaginated`
    /// to access the nested member `[ElasticTranscoderClientTypes.Preset]`
    /// - Returns: `[ElasticTranscoderClientTypes.Preset]`
    public func presets() async throws -> [ElasticTranscoderClientTypes.Preset] {
        return try await self.asyncCompactMap { item in item.presets }
    }
}
