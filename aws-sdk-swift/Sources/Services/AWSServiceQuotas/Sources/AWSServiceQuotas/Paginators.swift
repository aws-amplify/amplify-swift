//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension ServiceQuotasClient {
    /// Paginate over `[ListAWSDefaultServiceQuotasOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAWSDefaultServiceQuotasInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAWSDefaultServiceQuotasOutput`
    public func listAWSDefaultServiceQuotasPaginated(input: ListAWSDefaultServiceQuotasInput) -> ClientRuntime.PaginatorSequence<ListAWSDefaultServiceQuotasInput, ListAWSDefaultServiceQuotasOutput> {
        return ClientRuntime.PaginatorSequence<ListAWSDefaultServiceQuotasInput, ListAWSDefaultServiceQuotasOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAWSDefaultServiceQuotas(input:))
    }
}

extension ListAWSDefaultServiceQuotasInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAWSDefaultServiceQuotasInput {
        return ListAWSDefaultServiceQuotasInput(
            maxResults: self.maxResults,
            nextToken: token,
            serviceCode: self.serviceCode
        )}
}

extension PaginatorSequence where OperationStackInput == ListAWSDefaultServiceQuotasInput, OperationStackOutput == ListAWSDefaultServiceQuotasOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAWSDefaultServiceQuotasPaginated`
    /// to access the nested member `[ServiceQuotasClientTypes.ServiceQuota]`
    /// - Returns: `[ServiceQuotasClientTypes.ServiceQuota]`
    public func quotas() async throws -> [ServiceQuotasClientTypes.ServiceQuota] {
        return try await self.asyncCompactMap { item in item.quotas }
    }
}
extension ServiceQuotasClient {
    /// Paginate over `[ListRequestedServiceQuotaChangeHistoryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRequestedServiceQuotaChangeHistoryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRequestedServiceQuotaChangeHistoryOutput`
    public func listRequestedServiceQuotaChangeHistoryPaginated(input: ListRequestedServiceQuotaChangeHistoryInput) -> ClientRuntime.PaginatorSequence<ListRequestedServiceQuotaChangeHistoryInput, ListRequestedServiceQuotaChangeHistoryOutput> {
        return ClientRuntime.PaginatorSequence<ListRequestedServiceQuotaChangeHistoryInput, ListRequestedServiceQuotaChangeHistoryOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRequestedServiceQuotaChangeHistory(input:))
    }
}

extension ListRequestedServiceQuotaChangeHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRequestedServiceQuotaChangeHistoryInput {
        return ListRequestedServiceQuotaChangeHistoryInput(
            maxResults: self.maxResults,
            nextToken: token,
            quotaRequestedAtLevel: self.quotaRequestedAtLevel,
            serviceCode: self.serviceCode,
            status: self.status
        )}
}

extension PaginatorSequence where OperationStackInput == ListRequestedServiceQuotaChangeHistoryInput, OperationStackOutput == ListRequestedServiceQuotaChangeHistoryOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRequestedServiceQuotaChangeHistoryPaginated`
    /// to access the nested member `[ServiceQuotasClientTypes.RequestedServiceQuotaChange]`
    /// - Returns: `[ServiceQuotasClientTypes.RequestedServiceQuotaChange]`
    public func requestedQuotas() async throws -> [ServiceQuotasClientTypes.RequestedServiceQuotaChange] {
        return try await self.asyncCompactMap { item in item.requestedQuotas }
    }
}
extension ServiceQuotasClient {
    /// Paginate over `[ListRequestedServiceQuotaChangeHistoryByQuotaOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRequestedServiceQuotaChangeHistoryByQuotaInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRequestedServiceQuotaChangeHistoryByQuotaOutput`
    public func listRequestedServiceQuotaChangeHistoryByQuotaPaginated(input: ListRequestedServiceQuotaChangeHistoryByQuotaInput) -> ClientRuntime.PaginatorSequence<ListRequestedServiceQuotaChangeHistoryByQuotaInput, ListRequestedServiceQuotaChangeHistoryByQuotaOutput> {
        return ClientRuntime.PaginatorSequence<ListRequestedServiceQuotaChangeHistoryByQuotaInput, ListRequestedServiceQuotaChangeHistoryByQuotaOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRequestedServiceQuotaChangeHistoryByQuota(input:))
    }
}

extension ListRequestedServiceQuotaChangeHistoryByQuotaInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRequestedServiceQuotaChangeHistoryByQuotaInput {
        return ListRequestedServiceQuotaChangeHistoryByQuotaInput(
            maxResults: self.maxResults,
            nextToken: token,
            quotaCode: self.quotaCode,
            quotaRequestedAtLevel: self.quotaRequestedAtLevel,
            serviceCode: self.serviceCode,
            status: self.status
        )}
}

extension PaginatorSequence where OperationStackInput == ListRequestedServiceQuotaChangeHistoryByQuotaInput, OperationStackOutput == ListRequestedServiceQuotaChangeHistoryByQuotaOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRequestedServiceQuotaChangeHistoryByQuotaPaginated`
    /// to access the nested member `[ServiceQuotasClientTypes.RequestedServiceQuotaChange]`
    /// - Returns: `[ServiceQuotasClientTypes.RequestedServiceQuotaChange]`
    public func requestedQuotas() async throws -> [ServiceQuotasClientTypes.RequestedServiceQuotaChange] {
        return try await self.asyncCompactMap { item in item.requestedQuotas }
    }
}
extension ServiceQuotasClient {
    /// Paginate over `[ListServiceQuotaIncreaseRequestsInTemplateOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListServiceQuotaIncreaseRequestsInTemplateInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListServiceQuotaIncreaseRequestsInTemplateOutput`
    public func listServiceQuotaIncreaseRequestsInTemplatePaginated(input: ListServiceQuotaIncreaseRequestsInTemplateInput) -> ClientRuntime.PaginatorSequence<ListServiceQuotaIncreaseRequestsInTemplateInput, ListServiceQuotaIncreaseRequestsInTemplateOutput> {
        return ClientRuntime.PaginatorSequence<ListServiceQuotaIncreaseRequestsInTemplateInput, ListServiceQuotaIncreaseRequestsInTemplateOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listServiceQuotaIncreaseRequestsInTemplate(input:))
    }
}

extension ListServiceQuotaIncreaseRequestsInTemplateInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListServiceQuotaIncreaseRequestsInTemplateInput {
        return ListServiceQuotaIncreaseRequestsInTemplateInput(
            awsRegion: self.awsRegion,
            maxResults: self.maxResults,
            nextToken: token,
            serviceCode: self.serviceCode
        )}
}

extension PaginatorSequence where OperationStackInput == ListServiceQuotaIncreaseRequestsInTemplateInput, OperationStackOutput == ListServiceQuotaIncreaseRequestsInTemplateOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listServiceQuotaIncreaseRequestsInTemplatePaginated`
    /// to access the nested member `[ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]`
    /// - Returns: `[ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate]`
    public func serviceQuotaIncreaseRequestInTemplateList() async throws -> [ServiceQuotasClientTypes.ServiceQuotaIncreaseRequestInTemplate] {
        return try await self.asyncCompactMap { item in item.serviceQuotaIncreaseRequestInTemplateList }
    }
}
extension ServiceQuotasClient {
    /// Paginate over `[ListServiceQuotasOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListServiceQuotasInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListServiceQuotasOutput`
    public func listServiceQuotasPaginated(input: ListServiceQuotasInput) -> ClientRuntime.PaginatorSequence<ListServiceQuotasInput, ListServiceQuotasOutput> {
        return ClientRuntime.PaginatorSequence<ListServiceQuotasInput, ListServiceQuotasOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listServiceQuotas(input:))
    }
}

extension ListServiceQuotasInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListServiceQuotasInput {
        return ListServiceQuotasInput(
            maxResults: self.maxResults,
            nextToken: token,
            quotaAppliedAtLevel: self.quotaAppliedAtLevel,
            quotaCode: self.quotaCode,
            serviceCode: self.serviceCode
        )}
}

extension PaginatorSequence where OperationStackInput == ListServiceQuotasInput, OperationStackOutput == ListServiceQuotasOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listServiceQuotasPaginated`
    /// to access the nested member `[ServiceQuotasClientTypes.ServiceQuota]`
    /// - Returns: `[ServiceQuotasClientTypes.ServiceQuota]`
    public func quotas() async throws -> [ServiceQuotasClientTypes.ServiceQuota] {
        return try await self.asyncCompactMap { item in item.quotas }
    }
}
extension ServiceQuotasClient {
    /// Paginate over `[ListServicesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListServicesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListServicesOutput`
    public func listServicesPaginated(input: ListServicesInput) -> ClientRuntime.PaginatorSequence<ListServicesInput, ListServicesOutput> {
        return ClientRuntime.PaginatorSequence<ListServicesInput, ListServicesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listServices(input:))
    }
}

extension ListServicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListServicesInput {
        return ListServicesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListServicesInput, OperationStackOutput == ListServicesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listServicesPaginated`
    /// to access the nested member `[ServiceQuotasClientTypes.ServiceInfo]`
    /// - Returns: `[ServiceQuotasClientTypes.ServiceInfo]`
    public func services() async throws -> [ServiceQuotasClientTypes.ServiceInfo] {
        return try await self.asyncCompactMap { item in item.services }
    }
}
