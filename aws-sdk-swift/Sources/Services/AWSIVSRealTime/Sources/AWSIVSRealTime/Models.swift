//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

///
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// User does not have sufficient access to perform this action.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

///
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Updating or deleting a resource can cause an inconsistent state.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

///
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Unexpected error during processing of request.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

///
public struct PendingVerification: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Your account is pending verification.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PendingVerification" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

///
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Request references a resource which does not exist.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

///
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Request would cause a service quota to be exceeded.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

///
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

extension IVSRealTimeClientTypes {

    /// Settings for video.
    public struct Video: Swift.Sendable {
        /// Bitrate for generated output, in bps. Default: 2500000.
        public var bitrate: Swift.Int?
        /// Video frame rate, in fps. Default: 30.
        public var framerate: Swift.Float?
        /// Video-resolution height. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 720.
        public var height: Swift.Int?
        /// Video-resolution width. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 1280.
        public var width: Swift.Int?

        public init(
            bitrate: Swift.Int? = nil,
            framerate: Swift.Float? = nil,
            height: Swift.Int? = nil,
            width: Swift.Int? = nil
        )
        {
            self.bitrate = bitrate
            self.framerate = framerate
            self.height = height
            self.width = width
        }
    }
}

public struct CreateEncoderConfigurationInput: Swift.Sendable {
    /// Optional name to identify the resource.
    public var name: Swift.String?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    public var tags: [Swift.String: Swift.String]?
    /// Video configuration. Default: video resolution 1280x720, bitrate 2500 kbps, 30 fps.
    public var video: IVSRealTimeClientTypes.Video?

    public init(
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        video: IVSRealTimeClientTypes.Video? = nil
    )
    {
        self.name = name
        self.tags = tags
        self.video = video
    }
}

extension IVSRealTimeClientTypes {

    /// Settings for transcoding.
    public struct EncoderConfiguration: Swift.Sendable {
        /// ARN of the EncoderConfiguration resource.
        /// This member is required.
        public var arn: Swift.String?
        /// Optional name to identify the resource.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?
        /// Video configuration. Default: video resolution 1280x720, bitrate 2500 kbps, 30 fps
        public var video: IVSRealTimeClientTypes.Video?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            video: IVSRealTimeClientTypes.Video? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.tags = tags
            self.video = video
        }
    }
}

public struct CreateEncoderConfigurationOutput: Swift.Sendable {
    /// The EncoderConfiguration that was created.
    public var encoderConfiguration: IVSRealTimeClientTypes.EncoderConfiguration?

    public init(
        encoderConfiguration: IVSRealTimeClientTypes.EncoderConfiguration? = nil
    )
    {
        self.encoderConfiguration = encoderConfiguration
    }
}

extension IVSRealTimeClientTypes {

    public enum IngestProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case rtmp
        case rtmps
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestProtocol] {
            return [
                .rtmp,
                .rtmps
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .rtmp: return "RTMP"
            case .rtmps: return "RTMPS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateIngestConfigurationInput: Swift.Sendable {
    /// Application-provided attributes to store in the IngestConfiguration and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
    public var attributes: [Swift.String: Swift.String]?
    /// Type of ingest protocol that the user employs to broadcast. If this is set to RTMP, insecureIngest must be set to true.
    /// This member is required.
    public var ingestProtocol: IVSRealTimeClientTypes.IngestProtocol?
    /// Whether the stage allows insecure RTMP ingest. This must be set to true, if ingestProtocol is set to RTMP. Default: false.
    public var insecureIngest: Swift.Bool?
    /// Optional name that can be specified for the IngestConfiguration being created.
    public var name: Swift.String?
    /// ARN of the stage with which the IngestConfiguration is associated.
    public var stageArn: Swift.String?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    public var tags: [Swift.String: Swift.String]?
    /// Customer-assigned name to help identify the participant using the IngestConfiguration; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
    public var userId: Swift.String?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        ingestProtocol: IVSRealTimeClientTypes.IngestProtocol? = nil,
        insecureIngest: Swift.Bool? = false,
        name: Swift.String? = nil,
        stageArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.ingestProtocol = ingestProtocol
        self.insecureIngest = insecureIngest
        self.name = name
        self.stageArn = stageArn
        self.tags = tags
        self.userId = userId
    }
}

extension IVSRealTimeClientTypes {

    public enum IngestConfigurationState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestConfigurationState] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes {

    /// Object specifying an ingest configuration.
    public struct IngestConfiguration: Swift.Sendable {
        /// Ingest configuration ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// Application-provided attributes to to store in the IngestConfiguration and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var attributes: [Swift.String: Swift.String]?
        /// Type of ingest protocol that the user employs for broadcasting.
        /// This member is required.
        public var ingestProtocol: IVSRealTimeClientTypes.IngestProtocol?
        /// Ingest name
        public var name: Swift.String?
        /// ID of the participant within the stage.
        /// This member is required.
        public var participantId: Swift.String?
        /// ARN of the stage with which the IngestConfiguration is associated.
        /// This member is required.
        public var stageArn: Swift.String?
        /// State of the ingest configuration. It is ACTIVE if a publisher currently is publishing to the stage associated with the ingest configuration.
        /// This member is required.
        public var state: IVSRealTimeClientTypes.IngestConfigurationState?
        /// Ingest-key value for the RTMP(S) protocol.
        /// This member is required.
        public var streamKey: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?
        /// Customer-assigned name to help identify the participant using the IngestConfiguration; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var userId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            attributes: [Swift.String: Swift.String]? = nil,
            ingestProtocol: IVSRealTimeClientTypes.IngestProtocol? = nil,
            name: Swift.String? = nil,
            participantId: Swift.String? = nil,
            stageArn: Swift.String? = nil,
            state: IVSRealTimeClientTypes.IngestConfigurationState? = nil,
            streamKey: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            userId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.attributes = attributes
            self.ingestProtocol = ingestProtocol
            self.name = name
            self.participantId = participantId
            self.stageArn = stageArn
            self.state = state
            self.streamKey = streamKey
            self.tags = tags
            self.userId = userId
        }
    }
}

extension IVSRealTimeClientTypes.IngestConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IngestConfiguration(arn: \(Swift.String(describing: arn)), attributes: \(Swift.String(describing: attributes)), ingestProtocol: \(Swift.String(describing: ingestProtocol)), name: \(Swift.String(describing: name)), participantId: \(Swift.String(describing: participantId)), stageArn: \(Swift.String(describing: stageArn)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)), userId: \(Swift.String(describing: userId)), streamKey: \"CONTENT_REDACTED\")"}
}

public struct CreateIngestConfigurationOutput: Swift.Sendable {
    /// The IngestConfiguration that was created.
    public var ingestConfiguration: IVSRealTimeClientTypes.IngestConfiguration?

    public init(
        ingestConfiguration: IVSRealTimeClientTypes.IngestConfiguration? = nil
    )
    {
        self.ingestConfiguration = ingestConfiguration
    }
}

extension IVSRealTimeClientTypes {

    public enum ParticipantTokenCapability: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case publish
        case subscribe
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantTokenCapability] {
            return [
                .publish,
                .subscribe
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .publish: return "PUBLISH"
            case .subscribe: return "SUBSCRIBE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateParticipantTokenInput: Swift.Sendable {
    /// Application-provided attributes to encode into the token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
    public var attributes: [Swift.String: Swift.String]?
    /// Set of capabilities that the user is allowed to perform in the stage. Default: PUBLISH, SUBSCRIBE.
    public var capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]?
    /// Duration (in minutes), after which the token expires. Default: 720 (12 hours).
    public var duration: Swift.Int?
    /// ARN of the stage to which this token is scoped.
    /// This member is required.
    public var stageArn: Swift.String?
    /// Name that can be specified to help identify the token. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
    public var userId: Swift.String?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]? = nil,
        duration: Swift.Int? = nil,
        stageArn: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.capabilities = capabilities
        self.duration = duration
        self.stageArn = stageArn
        self.userId = userId
    }
}

extension IVSRealTimeClientTypes {

    /// Object specifying a participant token in a stage. Important: Treat tokens as opaque; i.e., do not build functionality based on token contents. The format of tokens could change in the future.
    public struct ParticipantToken: Swift.Sendable {
        /// Application-provided attributes to encode into the token and attach to a stage. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var attributes: [Swift.String: Swift.String]?
        /// Set of capabilities that the user is allowed to perform in the stage.
        public var capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]?
        /// Duration (in minutes), after which the participant token expires. Default: 720 (12 hours).
        public var duration: Swift.Int?
        /// ISO 8601 timestamp (returned as a string) for when this token expires.
        public var expirationTime: Foundation.Date?
        /// Unique identifier for this participant token, assigned by IVS.
        public var participantId: Swift.String?
        /// The issued client token, encrypted.
        public var token: Swift.String?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var userId: Swift.String?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]? = nil,
            duration: Swift.Int? = nil,
            expirationTime: Foundation.Date? = nil,
            participantId: Swift.String? = nil,
            token: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.expirationTime = expirationTime
            self.participantId = participantId
            self.token = token
            self.userId = userId
        }
    }
}

extension IVSRealTimeClientTypes.ParticipantToken: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParticipantToken(attributes: \(Swift.String(describing: attributes)), capabilities: \(Swift.String(describing: capabilities)), duration: \(Swift.String(describing: duration)), expirationTime: \(Swift.String(describing: expirationTime)), participantId: \(Swift.String(describing: participantId)), userId: \(Swift.String(describing: userId)), token: \"CONTENT_REDACTED\")"}
}

public struct CreateParticipantTokenOutput: Swift.Sendable {
    /// The participant token that was created.
    public var participantToken: IVSRealTimeClientTypes.ParticipantToken?

    public init(
        participantToken: IVSRealTimeClientTypes.ParticipantToken? = nil
    )
    {
        self.participantToken = participantToken
    }
}

extension IVSRealTimeClientTypes {

    public enum ParticipantRecordingMediaType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case audioOnly
        case audioVideo
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantRecordingMediaType] {
            return [
                .audioOnly,
                .audioVideo
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .audioOnly: return "AUDIO_ONLY"
            case .audioVideo: return "AUDIO_VIDEO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes {

    /// Object specifying a configuration for individual participant recording.
    public struct AutoParticipantRecordingConfiguration: Swift.Sendable {
        /// Types of media to be recorded. Default: AUDIO_VIDEO.
        public var mediaTypes: [IVSRealTimeClientTypes.ParticipantRecordingMediaType]?
        /// ARN of the [StorageConfiguration] resource to use for individual participant recording. Default: "" (empty string, no storage configuration is specified). Individual participant recording cannot be started unless a storage configuration is specified, when a [Stage] is created or updated.
        /// This member is required.
        public var storageConfigurationArn: Swift.String?

        public init(
            mediaTypes: [IVSRealTimeClientTypes.ParticipantRecordingMediaType]? = nil,
            storageConfigurationArn: Swift.String? = nil
        )
        {
            self.mediaTypes = mediaTypes
            self.storageConfigurationArn = storageConfigurationArn
        }
    }
}

extension IVSRealTimeClientTypes {

    /// Object specifying a participant token configuration in a stage.
    public struct ParticipantTokenConfiguration: Swift.Sendable {
        /// Application-provided attributes to encode into the corresponding participant token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var attributes: [Swift.String: Swift.String]?
        /// Set of capabilities that the user is allowed to perform in the stage.
        public var capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]?
        /// Duration (in minutes), after which the corresponding participant token expires. Default: 720 (12 hours).
        public var duration: Swift.Int?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var userId: Swift.String?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            capabilities: [IVSRealTimeClientTypes.ParticipantTokenCapability]? = nil,
            duration: Swift.Int? = nil,
            userId: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.capabilities = capabilities
            self.duration = duration
            self.userId = userId
        }
    }
}

public struct CreateStageInput: Swift.Sendable {
    /// Configuration object for individual participant recording, to attach to the new stage.
    public var autoParticipantRecordingConfiguration: IVSRealTimeClientTypes.AutoParticipantRecordingConfiguration?
    /// Optional name that can be specified for the stage being created.
    public var name: Swift.String?
    /// Array of participant token configuration objects to attach to the new stage.
    public var participantTokenConfigurations: [IVSRealTimeClientTypes.ParticipantTokenConfiguration]?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    public var tags: [Swift.String: Swift.String]?

    public init(
        autoParticipantRecordingConfiguration: IVSRealTimeClientTypes.AutoParticipantRecordingConfiguration? = nil,
        name: Swift.String? = nil,
        participantTokenConfigurations: [IVSRealTimeClientTypes.ParticipantTokenConfiguration]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.autoParticipantRecordingConfiguration = autoParticipantRecordingConfiguration
        self.name = name
        self.participantTokenConfigurations = participantTokenConfigurations
        self.tags = tags
    }
}

extension IVSRealTimeClientTypes {

    /// Summary information about various endpoints for a stage. We recommend that you cache these values at stage creation; the values can be cached for up to 14 days.
    public struct StageEndpoints: Swift.Sendable {
        /// Events endpoint.
        public var events: Swift.String?
        /// The endpoint to be used for IVS real-time streaming using the RTMP protocol.
        public var rtmp: Swift.String?
        /// The endpoint to be used for IVS real-time streaming using the RTMPS protocol.
        public var rtmps: Swift.String?
        /// The endpoint to be used for IVS real-time streaming using the WHIP protocol.
        public var whip: Swift.String?

        public init(
            events: Swift.String? = nil,
            rtmp: Swift.String? = nil,
            rtmps: Swift.String? = nil,
            whip: Swift.String? = nil
        )
        {
            self.events = events
            self.rtmp = rtmp
            self.rtmps = rtmps
            self.whip = whip
        }
    }
}

extension IVSRealTimeClientTypes {

    /// Object specifying a stage.
    public struct Stage: Swift.Sendable {
        /// ID of the active session within the stage.
        public var activeSessionId: Swift.String?
        /// Stage ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// Configuration object for individual participant recording, attached to the stage.
        public var autoParticipantRecordingConfiguration: IVSRealTimeClientTypes.AutoParticipantRecordingConfiguration?
        /// Summary information about various endpoints for a stage.
        public var endpoints: IVSRealTimeClientTypes.StageEndpoints?
        /// Stage name.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?

        public init(
            activeSessionId: Swift.String? = nil,
            arn: Swift.String? = nil,
            autoParticipantRecordingConfiguration: IVSRealTimeClientTypes.AutoParticipantRecordingConfiguration? = nil,
            endpoints: IVSRealTimeClientTypes.StageEndpoints? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.activeSessionId = activeSessionId
            self.arn = arn
            self.autoParticipantRecordingConfiguration = autoParticipantRecordingConfiguration
            self.endpoints = endpoints
            self.name = name
            self.tags = tags
        }
    }
}

public struct CreateStageOutput: Swift.Sendable {
    /// Participant tokens attached to the stage. These correspond to the participants in the request.
    public var participantTokens: [IVSRealTimeClientTypes.ParticipantToken]?
    /// The stage that was created.
    public var stage: IVSRealTimeClientTypes.Stage?

    public init(
        participantTokens: [IVSRealTimeClientTypes.ParticipantToken]? = nil,
        stage: IVSRealTimeClientTypes.Stage? = nil
    )
    {
        self.participantTokens = participantTokens
        self.stage = stage
    }
}

extension IVSRealTimeClientTypes {

    /// A complex type that describes an S3 location where recorded videos will be stored.
    public struct S3StorageConfiguration: Swift.Sendable {
        /// Location (S3 bucket name) where recorded videos will be stored. Note that the StorageConfiguration and S3 bucket must be in the same region as the Composition.
        /// This member is required.
        public var bucketName: Swift.String?

        public init(
            bucketName: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
        }
    }
}

public struct CreateStorageConfigurationInput: Swift.Sendable {
    /// Storage configuration name. The value does not need to be unique.
    public var name: Swift.String?
    /// A complex type that contains a storage configuration for where recorded video will be stored.
    /// This member is required.
    public var s3: IVSRealTimeClientTypes.S3StorageConfiguration?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    public var tags: [Swift.String: Swift.String]?

    public init(
        name: Swift.String? = nil,
        s3: IVSRealTimeClientTypes.S3StorageConfiguration? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.name = name
        self.s3 = s3
        self.tags = tags
    }
}

extension IVSRealTimeClientTypes {

    /// A complex type that describes a location where recorded videos will be stored.
    public struct StorageConfiguration: Swift.Sendable {
        /// ARN of the storage configuration.
        /// This member is required.
        public var arn: Swift.String?
        /// Name of the storage configuration.
        public var name: Swift.String?
        /// An S3 destination configuration where recorded videos will be stored.
        public var s3: IVSRealTimeClientTypes.S3StorageConfiguration?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            s3: IVSRealTimeClientTypes.S3StorageConfiguration? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.s3 = s3
            self.tags = tags
        }
    }
}

public struct CreateStorageConfigurationOutput: Swift.Sendable {
    /// The StorageConfiguration that was created.
    public var storageConfiguration: IVSRealTimeClientTypes.StorageConfiguration?

    public init(
        storageConfiguration: IVSRealTimeClientTypes.StorageConfiguration? = nil
    )
    {
        self.storageConfiguration = storageConfiguration
    }
}

public struct DeleteEncoderConfigurationInput: Swift.Sendable {
    /// ARN of the EncoderConfiguration.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteEncoderConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteIngestConfigurationInput: Swift.Sendable {
    /// ARN of the IngestConfiguration.
    /// This member is required.
    public var arn: Swift.String?
    /// Optional field to force deletion of the IngestConfiguration. If this is set to true when a participant is actively publishing, the participant is disconnected from the stage, followed by deletion of the IngestConfiguration. Default: false.
    public var force: Swift.Bool?

    public init(
        arn: Swift.String? = nil,
        force: Swift.Bool? = false
    )
    {
        self.arn = arn
        self.force = force
    }
}

public struct DeleteIngestConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeletePublicKeyInput: Swift.Sendable {
    /// ARN of the public key to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeletePublicKeyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteStageInput: Swift.Sendable {
    /// ARN of the stage to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteStageOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteStorageConfigurationInput: Swift.Sendable {
    /// ARN of the storage configuration to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteStorageConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DisconnectParticipantInput: Swift.Sendable {
    /// Identifier of the participant to be disconnected. IVS assigns this; it is returned by [CreateParticipantToken] (for streams using WebRTC ingest) or [CreateIngestConfiguration] (for streams using RTMP ingest).
    /// This member is required.
    public var participantId: Swift.String?
    /// Description of why this participant is being disconnected.
    public var reason: Swift.String?
    /// ARN of the stage to which the participant is attached.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        participantId: Swift.String? = nil,
        reason: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.participantId = participantId
        self.reason = reason
        self.stageArn = stageArn
    }
}

public struct DisconnectParticipantOutput: Swift.Sendable {

    public init() { }
}

public struct GetCompositionInput: Swift.Sendable {
    /// ARN of the Composition resource.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension IVSRealTimeClientTypes {

    /// Object specifying a channel as a destination.
    public struct ChannelDestinationConfiguration: Swift.Sendable {
        /// ARN of the channel to use for broadcasting. The channel and stage resources must be in the same AWS account and region. The channel must be offline (not broadcasting).
        /// This member is required.
        public var channelArn: Swift.String?
        /// ARN of the [EncoderConfiguration] resource. The encoder configuration and stage resources must be in the same AWS account and region.
        public var encoderConfigurationArn: Swift.String?

        public init(
            channelArn: Swift.String? = nil,
            encoderConfigurationArn: Swift.String? = nil
        )
        {
            self.channelArn = channelArn
            self.encoderConfigurationArn = encoderConfigurationArn
        }
    }
}

extension IVSRealTimeClientTypes {

    public enum RecordingConfigurationFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hls
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordingConfigurationFormat] {
            return [
                .hls
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hls: return "HLS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes {

    /// An object representing a configuration to record a stage stream.
    public struct RecordingConfiguration: Swift.Sendable {
        /// The recording format for storing a recording in Amazon S3.
        public var format: IVSRealTimeClientTypes.RecordingConfigurationFormat?

        public init(
            format: IVSRealTimeClientTypes.RecordingConfigurationFormat? = nil
        )
        {
            self.format = format
        }
    }
}

extension IVSRealTimeClientTypes {

    /// A complex type that describes an S3 location where recorded videos will be stored.
    public struct S3DestinationConfiguration: Swift.Sendable {
        /// ARNs of the [EncoderConfiguration] resource. The encoder configuration and stage resources must be in the same AWS account and region.
        /// This member is required.
        public var encoderConfigurationArns: [Swift.String]?
        /// Array of maps, each of the form string:string (key:value). This is an optional customer specification, currently used only to specify the recording format for storing a recording in Amazon S3.
        public var recordingConfiguration: IVSRealTimeClientTypes.RecordingConfiguration?
        /// ARN of the [StorageConfiguration] where recorded videos will be stored.
        /// This member is required.
        public var storageConfigurationArn: Swift.String?

        public init(
            encoderConfigurationArns: [Swift.String]? = nil,
            recordingConfiguration: IVSRealTimeClientTypes.RecordingConfiguration? = nil,
            storageConfigurationArn: Swift.String? = nil
        )
        {
            self.encoderConfigurationArns = encoderConfigurationArns
            self.recordingConfiguration = recordingConfiguration
            self.storageConfigurationArn = storageConfigurationArn
        }
    }
}

extension IVSRealTimeClientTypes {

    /// Complex data type that defines destination-configuration objects.
    public struct DestinationConfiguration: Swift.Sendable {
        /// An IVS channel to be used for broadcasting, for server-side composition. Either a channel or an s3 must be specified.
        public var channel: IVSRealTimeClientTypes.ChannelDestinationConfiguration?
        /// Name that can be specified to help identify the destination.
        public var name: Swift.String?
        /// An S3 storage configuration to be used for recording video data. Either a channel or an s3 must be specified.
        public var s3: IVSRealTimeClientTypes.S3DestinationConfiguration?

        public init(
            channel: IVSRealTimeClientTypes.ChannelDestinationConfiguration? = nil,
            name: Swift.String? = nil,
            s3: IVSRealTimeClientTypes.S3DestinationConfiguration? = nil
        )
        {
            self.channel = channel
            self.name = name
            self.s3 = s3
        }
    }
}

extension IVSRealTimeClientTypes {

    /// Complex data type that defines S3Detail objects.
    public struct S3Detail: Swift.Sendable {
        /// The S3 bucket prefix under which the recording is stored.
        /// This member is required.
        public var recordingPrefix: Swift.String?

        public init(
            recordingPrefix: Swift.String? = nil
        )
        {
            self.recordingPrefix = recordingPrefix
        }
    }
}

extension IVSRealTimeClientTypes {

    /// Complex data type that defines destination-detail objects.
    public struct DestinationDetail: Swift.Sendable {
        /// An S3 detail object to return information about the S3 destination.
        public var s3: IVSRealTimeClientTypes.S3Detail?

        public init(
            s3: IVSRealTimeClientTypes.S3Detail? = nil
        )
        {
            self.s3 = s3
        }
    }
}

extension IVSRealTimeClientTypes {

    public enum DestinationState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case failed
        case reconnecting
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationState] {
            return [
                .active,
                .failed,
                .reconnecting,
                .starting,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .failed: return "FAILED"
            case .reconnecting: return "RECONNECTING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes {

    /// Object specifying the status of a Destination.
    public struct Destination: Swift.Sendable {
        /// Configuration used to create this destination.
        /// This member is required.
        public var configuration: IVSRealTimeClientTypes.DestinationConfiguration?
        /// Optional details regarding the status of the destination.
        public var detail: IVSRealTimeClientTypes.DestinationDetail?
        /// UTC time of the destination end. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var endTime: Foundation.Date?
        /// Unique identifier for this destination, assigned by IVS.
        /// This member is required.
        public var id: Swift.String?
        /// UTC time of the destination start. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: Foundation.Date?
        /// State of the Composition Destination.
        /// This member is required.
        public var state: IVSRealTimeClientTypes.DestinationState?

        public init(
            configuration: IVSRealTimeClientTypes.DestinationConfiguration? = nil,
            detail: IVSRealTimeClientTypes.DestinationDetail? = nil,
            endTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            state: IVSRealTimeClientTypes.DestinationState? = nil
        )
        {
            self.configuration = configuration
            self.detail = detail
            self.endTime = endTime
            self.id = id
            self.startTime = startTime
            self.state = state
        }
    }
}

extension IVSRealTimeClientTypes {

    public enum VideoAspectRatio: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case portrait
        case square
        case video
        case sdkUnknown(Swift.String)

        public static var allCases: [VideoAspectRatio] {
            return [
                .auto,
                .portrait,
                .square,
                .video
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .portrait: return "PORTRAIT"
            case .square: return "SQUARE"
            case .video: return "VIDEO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes {

    public enum VideoFillMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contain
        case cover
        case fill
        case sdkUnknown(Swift.String)

        public static var allCases: [VideoFillMode] {
            return [
                .contain,
                .cover,
                .fill
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contain: return "CONTAIN"
            case .cover: return "COVER"
            case .fill: return "FILL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes {

    /// Configuration information specific to Grid layout, for server-side composition. See "Layouts" in [Server-Side Composition](https://docs.aws.amazon.com/ivs/latest/RealTimeUserGuide/server-side-composition.html).
    public struct GridConfiguration: Swift.Sendable {
        /// This attribute name identifies the featured slot. A participant with this attribute set to "true" (as a string value) in [ParticipantTokenConfiguration] is placed in the featured slot. Default: "" (no featured participant).
        public var featuredParticipantAttribute: Swift.String?
        /// Specifies the spacing between participant tiles in pixels. Default: 2.
        public var gridGap: Swift.Int
        /// Determines whether to omit participants with stopped video in the composition. Default: false.
        public var omitStoppedVideo: Swift.Bool
        /// Sets the non-featured participant display mode, to control the aspect ratio of video tiles. VIDEO is 16:9, SQUARE is 1:1, and PORTRAIT is 3:4. Default: VIDEO.
        public var videoAspectRatio: IVSRealTimeClientTypes.VideoAspectRatio?
        /// Defines how video content fits within the participant tile: FILL (stretched), COVER (cropped), or CONTAIN (letterboxed). When not set, videoFillMode defaults to COVER fill mode for participants in the grid and to CONTAIN fill mode for featured participants.
        public var videoFillMode: IVSRealTimeClientTypes.VideoFillMode?

        public init(
            featuredParticipantAttribute: Swift.String? = nil,
            gridGap: Swift.Int = 0,
            omitStoppedVideo: Swift.Bool = false,
            videoAspectRatio: IVSRealTimeClientTypes.VideoAspectRatio? = nil,
            videoFillMode: IVSRealTimeClientTypes.VideoFillMode? = nil
        )
        {
            self.featuredParticipantAttribute = featuredParticipantAttribute
            self.gridGap = gridGap
            self.omitStoppedVideo = omitStoppedVideo
            self.videoAspectRatio = videoAspectRatio
            self.videoFillMode = videoFillMode
        }
    }
}

extension IVSRealTimeClientTypes {

    public enum PipBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `dynamic`
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [PipBehavior] {
            return [
                .dynamic,
                .static
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dynamic: return "DYNAMIC"
            case .static: return "STATIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes {

    public enum PipPosition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bottomLeft
        case bottomRight
        case topLeft
        case topRight
        case sdkUnknown(Swift.String)

        public static var allCases: [PipPosition] {
            return [
                .bottomLeft,
                .bottomRight,
                .topLeft,
                .topRight
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bottomLeft: return "BOTTOM_LEFT"
            case .bottomRight: return "BOTTOM_RIGHT"
            case .topLeft: return "TOP_LEFT"
            case .topRight: return "TOP_RIGHT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes {

    /// Configuration information specific to Picture-in-Picture (PiP) layout, for [server-side composition](https://docs.aws.amazon.com/ivs/latest/RealTimeUserGuide/server-side-composition.html).
    public struct PipConfiguration: Swift.Sendable {
        /// This attribute name identifies the featured slot. A participant with this attribute set to "true" (as a string value) in [ParticipantTokenConfiguration] is placed in the featured slot. Default: "" (no featured participant).
        public var featuredParticipantAttribute: Swift.String?
        /// Specifies the spacing between participant tiles in pixels. Default: 0.
        public var gridGap: Swift.Int
        /// Determines whether to omit participants with stopped video in the composition. Default: false.
        public var omitStoppedVideo: Swift.Bool
        /// Defines PiP behavior when all participants have left: STATIC (maintains original position/size) or DYNAMIC (expands to full composition). Default: STATIC.
        public var pipBehavior: IVSRealTimeClientTypes.PipBehavior?
        /// Specifies the height of the PiP window in pixels. When this is not set explicitly, pipHeight’s value will be based on the size of the composition and the aspect ratio of the participant’s video.
        public var pipHeight: Swift.Int?
        /// Sets the PiP window’s offset position in pixels from the closest edges determined by PipPosition. Default: 0.
        public var pipOffset: Swift.Int
        /// Specifies the participant for the PiP window. A participant with this attribute set to "true" (as a string value) in [ParticipantTokenConfiguration] is placed in the PiP slot. Default: "" (no PiP participant).
        public var pipParticipantAttribute: Swift.String?
        /// Determines the corner position of the PiP window. Default: BOTTOM_RIGHT.
        public var pipPosition: IVSRealTimeClientTypes.PipPosition?
        /// Specifies the width of the PiP window in pixels. When this is not set explicitly, pipWidth’s value will be based on the size of the composition and the aspect ratio of the participant’s video.
        public var pipWidth: Swift.Int?
        /// Defines how video content fits within the participant tile: FILL (stretched), COVER (cropped), or CONTAIN (letterboxed). Default: COVER.
        public var videoFillMode: IVSRealTimeClientTypes.VideoFillMode?

        public init(
            featuredParticipantAttribute: Swift.String? = nil,
            gridGap: Swift.Int = 0,
            omitStoppedVideo: Swift.Bool = false,
            pipBehavior: IVSRealTimeClientTypes.PipBehavior? = nil,
            pipHeight: Swift.Int? = nil,
            pipOffset: Swift.Int = 0,
            pipParticipantAttribute: Swift.String? = nil,
            pipPosition: IVSRealTimeClientTypes.PipPosition? = nil,
            pipWidth: Swift.Int? = nil,
            videoFillMode: IVSRealTimeClientTypes.VideoFillMode? = nil
        )
        {
            self.featuredParticipantAttribute = featuredParticipantAttribute
            self.gridGap = gridGap
            self.omitStoppedVideo = omitStoppedVideo
            self.pipBehavior = pipBehavior
            self.pipHeight = pipHeight
            self.pipOffset = pipOffset
            self.pipParticipantAttribute = pipParticipantAttribute
            self.pipPosition = pipPosition
            self.pipWidth = pipWidth
            self.videoFillMode = videoFillMode
        }
    }
}

extension IVSRealTimeClientTypes {

    /// Configuration information of supported layouts for server-side composition.
    public struct LayoutConfiguration: Swift.Sendable {
        /// Configuration related to grid layout. Default: Grid layout.
        public var grid: IVSRealTimeClientTypes.GridConfiguration?
        /// Configuration related to PiP layout.
        public var pip: IVSRealTimeClientTypes.PipConfiguration?

        public init(
            grid: IVSRealTimeClientTypes.GridConfiguration? = nil,
            pip: IVSRealTimeClientTypes.PipConfiguration? = nil
        )
        {
            self.grid = grid
            self.pip = pip
        }
    }
}

extension IVSRealTimeClientTypes {

    public enum CompositionState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case failed
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [CompositionState] {
            return [
                .active,
                .failed,
                .starting,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .failed: return "FAILED"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes {

    /// Object specifying a Composition resource.
    public struct Composition: Swift.Sendable {
        /// ARN of the Composition resource.
        /// This member is required.
        public var arn: Swift.String?
        /// Array of Destination objects. A Composition can contain either one destination (channel or s3) or two (one channel and one s3).
        /// This member is required.
        public var destinations: [IVSRealTimeClientTypes.Destination]?
        /// UTC time of the Composition end. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var endTime: Foundation.Date?
        /// Layout object to configure composition parameters.
        /// This member is required.
        public var layout: IVSRealTimeClientTypes.LayoutConfiguration?
        /// ARN of the stage used as input
        /// This member is required.
        public var stageArn: Swift.String?
        /// UTC time of the Composition start. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: Foundation.Date?
        /// State of the Composition.
        /// This member is required.
        public var state: IVSRealTimeClientTypes.CompositionState?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            destinations: [IVSRealTimeClientTypes.Destination]? = nil,
            endTime: Foundation.Date? = nil,
            layout: IVSRealTimeClientTypes.LayoutConfiguration? = nil,
            stageArn: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            state: IVSRealTimeClientTypes.CompositionState? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.destinations = destinations
            self.endTime = endTime
            self.layout = layout
            self.stageArn = stageArn
            self.startTime = startTime
            self.state = state
            self.tags = tags
        }
    }
}

public struct GetCompositionOutput: Swift.Sendable {
    /// The Composition that was returned.
    public var composition: IVSRealTimeClientTypes.Composition?

    public init(
        composition: IVSRealTimeClientTypes.Composition? = nil
    )
    {
        self.composition = composition
    }
}

public struct GetEncoderConfigurationInput: Swift.Sendable {
    /// ARN of the EncoderConfiguration resource.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetEncoderConfigurationOutput: Swift.Sendable {
    /// The EncoderConfiguration that was returned.
    public var encoderConfiguration: IVSRealTimeClientTypes.EncoderConfiguration?

    public init(
        encoderConfiguration: IVSRealTimeClientTypes.EncoderConfiguration? = nil
    )
    {
        self.encoderConfiguration = encoderConfiguration
    }
}

public struct GetIngestConfigurationInput: Swift.Sendable {
    /// ARN of the ingest for which the information is to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetIngestConfigurationOutput: Swift.Sendable {
    /// The IngestConfiguration that was returned.
    public var ingestConfiguration: IVSRealTimeClientTypes.IngestConfiguration?

    public init(
        ingestConfiguration: IVSRealTimeClientTypes.IngestConfiguration? = nil
    )
    {
        self.ingestConfiguration = ingestConfiguration
    }
}

public struct GetParticipantInput: Swift.Sendable {
    /// Unique identifier for the participant. This is assigned by IVS and returned by [CreateParticipantToken].
    /// This member is required.
    public var participantId: Swift.String?
    /// ID of a session within the stage.
    /// This member is required.
    public var sessionId: Swift.String?
    /// Stage ARN.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        participantId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.participantId = participantId
        self.sessionId = sessionId
        self.stageArn = stageArn
    }
}

extension IVSRealTimeClientTypes {

    public enum ParticipantProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case rtmp
        case rtmps
        case unknown
        case whip
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantProtocol] {
            return [
                .rtmp,
                .rtmps,
                .unknown,
                .whip
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .rtmp: return "RTMP"
            case .rtmps: return "RTMPS"
            case .unknown: return "UNKNOWN"
            case .whip: return "WHIP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes {

    public enum ParticipantRecordingState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case disabled
        case failed
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantRecordingState] {
            return [
                .active,
                .disabled,
                .failed,
                .starting,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .disabled: return "DISABLED"
            case .failed: return "FAILED"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes {

    public enum ParticipantState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connected
        case disconnected
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantState] {
            return [
                .connected,
                .disconnected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .disconnected: return "DISCONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes {

    /// Object describing a participant that has joined a stage.
    public struct Participant: Swift.Sendable {
        /// Application-provided attributes to encode into the token and attach to a stage. Map keys and values can contain UTF-8 encoded text. The maximum length of this field is 1 KB total. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var attributes: [Swift.String: Swift.String]?
        /// The participant’s browser.
        public var browserName: Swift.String?
        /// The participant’s browser version.
        public var browserVersion: Swift.String?
        /// ISO 8601 timestamp (returned as a string) when the participant first joined the stage session.
        public var firstJoinTime: Foundation.Date?
        /// The participant’s Internet Service Provider.
        public var ispName: Swift.String?
        /// The participant’s operating system.
        public var osName: Swift.String?
        /// The participant’s operating system version.
        public var osVersion: Swift.String?
        /// Unique identifier for this participant, assigned by IVS.
        public var participantId: Swift.String?
        /// Type of ingest protocol that the participant employs for broadcasting.
        public var `protocol`: IVSRealTimeClientTypes.ParticipantProtocol?
        /// Whether the participant ever published to the stage session.
        public var published: Swift.Bool
        /// Name of the S3 bucket to where the participant is being recorded, if individual participant recording is enabled, or "" (empty string), if recording is not enabled.
        public var recordingS3BucketName: Swift.String?
        /// S3 prefix of the S3 bucket where the participant is being recorded, if individual participant recording is enabled, or "" (empty string), if recording is not enabled.
        public var recordingS3Prefix: Swift.String?
        /// The participant’s recording state.
        public var recordingState: IVSRealTimeClientTypes.ParticipantRecordingState?
        /// The participant’s SDK version.
        public var sdkVersion: Swift.String?
        /// Whether the participant is connected to or disconnected from the stage.
        public var state: IVSRealTimeClientTypes.ParticipantState?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var userId: Swift.String?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            browserName: Swift.String? = nil,
            browserVersion: Swift.String? = nil,
            firstJoinTime: Foundation.Date? = nil,
            ispName: Swift.String? = nil,
            osName: Swift.String? = nil,
            osVersion: Swift.String? = nil,
            participantId: Swift.String? = nil,
            `protocol`: IVSRealTimeClientTypes.ParticipantProtocol? = nil,
            published: Swift.Bool = false,
            recordingS3BucketName: Swift.String? = nil,
            recordingS3Prefix: Swift.String? = nil,
            recordingState: IVSRealTimeClientTypes.ParticipantRecordingState? = nil,
            sdkVersion: Swift.String? = nil,
            state: IVSRealTimeClientTypes.ParticipantState? = nil,
            userId: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.browserName = browserName
            self.browserVersion = browserVersion
            self.firstJoinTime = firstJoinTime
            self.ispName = ispName
            self.osName = osName
            self.osVersion = osVersion
            self.participantId = participantId
            self.`protocol` = `protocol`
            self.published = published
            self.recordingS3BucketName = recordingS3BucketName
            self.recordingS3Prefix = recordingS3Prefix
            self.recordingState = recordingState
            self.sdkVersion = sdkVersion
            self.state = state
            self.userId = userId
        }
    }
}

public struct GetParticipantOutput: Swift.Sendable {
    /// The participant that is returned.
    public var participant: IVSRealTimeClientTypes.Participant?

    public init(
        participant: IVSRealTimeClientTypes.Participant? = nil
    )
    {
        self.participant = participant
    }
}

public struct GetPublicKeyInput: Swift.Sendable {
    /// ARN of the public key for which the information is to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension IVSRealTimeClientTypes {

    /// Object specifying a public key used to sign stage participant tokens.
    public struct PublicKey: Swift.Sendable {
        /// Public key ARN.
        public var arn: Swift.String?
        /// The public key fingerprint, a short string used to identify or verify the full public key.
        public var fingerprint: Swift.String?
        /// Public key name.
        public var name: Swift.String?
        /// Public key material.
        public var publicKeyMaterial: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            fingerprint: Swift.String? = nil,
            name: Swift.String? = nil,
            publicKeyMaterial: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.fingerprint = fingerprint
            self.name = name
            self.publicKeyMaterial = publicKeyMaterial
            self.tags = tags
        }
    }
}

public struct GetPublicKeyOutput: Swift.Sendable {
    /// The public key that is returned.
    public var publicKey: IVSRealTimeClientTypes.PublicKey?

    public init(
        publicKey: IVSRealTimeClientTypes.PublicKey? = nil
    )
    {
        self.publicKey = publicKey
    }
}

public struct GetStageInput: Swift.Sendable {
    /// ARN of the stage for which the information is to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetStageOutput: Swift.Sendable {
    /// The stage that is returned.
    public var stage: IVSRealTimeClientTypes.Stage?

    public init(
        stage: IVSRealTimeClientTypes.Stage? = nil
    )
    {
        self.stage = stage
    }
}

public struct GetStageSessionInput: Swift.Sendable {
    /// ID of a session within the stage.
    /// This member is required.
    public var sessionId: Swift.String?
    /// ARN of the stage for which the information is to be retrieved.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        sessionId: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
        self.stageArn = stageArn
    }
}

extension IVSRealTimeClientTypes {

    /// A stage session begins when the first participant joins a stage and ends after the last participant leaves the stage. A stage session helps with debugging stages by grouping events and participants into shorter periods of time (i.e., a session), which is helpful when stages are used over long periods of time.
    public struct StageSession: Swift.Sendable {
        /// ISO 8601 timestamp (returned as a string) when the stage session ended. This is null if the stage is active.
        public var endTime: Foundation.Date?
        /// ID of the session within the stage.
        public var sessionId: Swift.String?
        /// ISO 8601 timestamp (returned as a string) when this stage session began.
        public var startTime: Foundation.Date?

        public init(
            endTime: Foundation.Date? = nil,
            sessionId: Swift.String? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.endTime = endTime
            self.sessionId = sessionId
            self.startTime = startTime
        }
    }
}

public struct GetStageSessionOutput: Swift.Sendable {
    /// The stage session that is returned.
    public var stageSession: IVSRealTimeClientTypes.StageSession?

    public init(
        stageSession: IVSRealTimeClientTypes.StageSession? = nil
    )
    {
        self.stageSession = stageSession
    }
}

public struct GetStorageConfigurationInput: Swift.Sendable {
    /// ARN of the storage configuration to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetStorageConfigurationOutput: Swift.Sendable {
    /// The StorageConfiguration that was returned.
    public var storageConfiguration: IVSRealTimeClientTypes.StorageConfiguration?

    public init(
        storageConfiguration: IVSRealTimeClientTypes.StorageConfiguration? = nil
    )
    {
        self.storageConfiguration = storageConfiguration
    }
}

public struct ImportPublicKeyInput: Swift.Sendable {
    /// Name of the public key to be imported.
    public var name: Swift.String?
    /// The content of the public key to be imported.
    /// This member is required.
    public var publicKeyMaterial: Swift.String?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    public var tags: [Swift.String: Swift.String]?

    public init(
        name: Swift.String? = nil,
        publicKeyMaterial: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.name = name
        self.publicKeyMaterial = publicKeyMaterial
        self.tags = tags
    }
}

public struct ImportPublicKeyOutput: Swift.Sendable {
    /// The public key that was imported.
    public var publicKey: IVSRealTimeClientTypes.PublicKey?

    public init(
        publicKey: IVSRealTimeClientTypes.PublicKey? = nil
    )
    {
        self.publicKey = publicKey
    }
}

public struct ListCompositionsInput: Swift.Sendable {
    /// Filters the Composition list to match the specified EncoderConfiguration attached to at least one of its output.
    public var filterByEncoderConfigurationArn: Swift.String?
    /// Filters the Composition list to match the specified Stage ARN.
    public var filterByStageArn: Swift.String?
    /// Maximum number of results to return. Default: 100.
    public var maxResults: Swift.Int?
    /// The first Composition to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        filterByEncoderConfigurationArn: Swift.String? = nil,
        filterByStageArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterByEncoderConfigurationArn = filterByEncoderConfigurationArn
        self.filterByStageArn = filterByStageArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IVSRealTimeClientTypes {

    /// Summary information about a Destination.
    public struct DestinationSummary: Swift.Sendable {
        /// UTC time of the destination end. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var endTime: Foundation.Date?
        /// Unique identifier for this destination, assigned by IVS.
        /// This member is required.
        public var id: Swift.String?
        /// UTC time of the destination start. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: Foundation.Date?
        /// State of the Composition Destination.
        /// This member is required.
        public var state: IVSRealTimeClientTypes.DestinationState?

        public init(
            endTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            state: IVSRealTimeClientTypes.DestinationState? = nil
        )
        {
            self.endTime = endTime
            self.id = id
            self.startTime = startTime
            self.state = state
        }
    }
}

extension IVSRealTimeClientTypes {

    /// Summary information about a Composition.
    public struct CompositionSummary: Swift.Sendable {
        /// ARN of the Composition resource.
        /// This member is required.
        public var arn: Swift.String?
        /// Array of Destination objects.
        /// This member is required.
        public var destinations: [IVSRealTimeClientTypes.DestinationSummary]?
        /// UTC time of the Composition end. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var endTime: Foundation.Date?
        /// ARN of the attached stage.
        /// This member is required.
        public var stageArn: Swift.String?
        /// UTC time of the Composition start. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: Foundation.Date?
        /// State of the Composition resource.
        /// This member is required.
        public var state: IVSRealTimeClientTypes.CompositionState?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            destinations: [IVSRealTimeClientTypes.DestinationSummary]? = nil,
            endTime: Foundation.Date? = nil,
            stageArn: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            state: IVSRealTimeClientTypes.CompositionState? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.destinations = destinations
            self.endTime = endTime
            self.stageArn = stageArn
            self.startTime = startTime
            self.state = state
            self.tags = tags
        }
    }
}

public struct ListCompositionsOutput: Swift.Sendable {
    /// List of the matching Compositions (summary information only).
    /// This member is required.
    public var compositions: [IVSRealTimeClientTypes.CompositionSummary]?
    /// If there are more compositions than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init(
        compositions: [IVSRealTimeClientTypes.CompositionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.compositions = compositions
        self.nextToken = nextToken
    }
}

public struct ListEncoderConfigurationsInput: Swift.Sendable {
    /// Maximum number of results to return. Default: 100.
    public var maxResults: Swift.Int?
    /// The first encoder configuration to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IVSRealTimeClientTypes {

    /// Summary information about an EncoderConfiguration.
    public struct EncoderConfigurationSummary: Swift.Sendable {
        /// ARN of the EncoderConfiguration resource.
        /// This member is required.
        public var arn: Swift.String?
        /// Optional name to identify the resource.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.tags = tags
        }
    }
}

public struct ListEncoderConfigurationsOutput: Swift.Sendable {
    /// List of the matching EncoderConfigurations (summary information only).
    /// This member is required.
    public var encoderConfigurations: [IVSRealTimeClientTypes.EncoderConfigurationSummary]?
    /// If there are more encoder configurations than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init(
        encoderConfigurations: [IVSRealTimeClientTypes.EncoderConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.encoderConfigurations = encoderConfigurations
        self.nextToken = nextToken
    }
}

public struct ListIngestConfigurationsInput: Swift.Sendable {
    /// Filters the response list to match the specified stage ARN. Only one filter (by stage ARN or by state) can be used at a time.
    public var filterByStageArn: Swift.String?
    /// Filters the response list to match the specified state. Only one filter (by stage ARN or by state) can be used at a time.
    public var filterByState: IVSRealTimeClientTypes.IngestConfigurationState?
    /// Maximum number of results to return. Default: 50.
    public var maxResults: Swift.Int?
    /// The first IngestConfiguration to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        filterByStageArn: Swift.String? = nil,
        filterByState: IVSRealTimeClientTypes.IngestConfigurationState? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterByStageArn = filterByStageArn
        self.filterByState = filterByState
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IVSRealTimeClientTypes {

    /// Summary information about an IngestConfiguration.
    public struct IngestConfigurationSummary: Swift.Sendable {
        /// Ingest configuration ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// Type of ingest protocol that the user employs for broadcasting.
        /// This member is required.
        public var ingestProtocol: IVSRealTimeClientTypes.IngestProtocol?
        /// Ingest name.
        public var name: Swift.String?
        /// ID of the participant within the stage.
        /// This member is required.
        public var participantId: Swift.String?
        /// ARN of the stage with which the IngestConfiguration is associated.
        /// This member is required.
        public var stageArn: Swift.String?
        /// State of the ingest configuration. It is ACTIVE if a publisher currently is publishing to the stage associated with the ingest configuration.
        /// This member is required.
        public var state: IVSRealTimeClientTypes.IngestConfigurationState?
        /// Customer-assigned name to help identify the participant using the IngestConfiguration; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var userId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            ingestProtocol: IVSRealTimeClientTypes.IngestProtocol? = nil,
            name: Swift.String? = nil,
            participantId: Swift.String? = nil,
            stageArn: Swift.String? = nil,
            state: IVSRealTimeClientTypes.IngestConfigurationState? = nil,
            userId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.ingestProtocol = ingestProtocol
            self.name = name
            self.participantId = participantId
            self.stageArn = stageArn
            self.state = state
            self.userId = userId
        }
    }
}

public struct ListIngestConfigurationsOutput: Swift.Sendable {
    /// List of the matching ingest configurations (summary information only).
    /// This member is required.
    public var ingestConfigurations: [IVSRealTimeClientTypes.IngestConfigurationSummary]?
    /// If there are more IngestConfigurations than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init(
        ingestConfigurations: [IVSRealTimeClientTypes.IngestConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ingestConfigurations = ingestConfigurations
        self.nextToken = nextToken
    }
}

public struct ListParticipantEventsInput: Swift.Sendable {
    /// Maximum number of results to return. Default: 50.
    public var maxResults: Swift.Int?
    /// The first participant event to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?
    /// Unique identifier for this participant. This is assigned by IVS and returned by [CreateParticipantToken].
    /// This member is required.
    public var participantId: Swift.String?
    /// ID of a session within the stage.
    /// This member is required.
    public var sessionId: Swift.String?
    /// Stage ARN.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        participantId: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.participantId = participantId
        self.sessionId = sessionId
        self.stageArn = stageArn
    }
}

extension IVSRealTimeClientTypes {

    public enum EventErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bitrateExceeded
        case bFramePresent
        case insufficientCapabilities
        case internalServerException
        case invalidAudioCodec
        case invalidInput
        case invalidProtocol
        case invalidStreamKey
        case invalidVideoCodec
        case publisherNotFound
        case quotaExceeded
        case resolutionExceeded
        case reuseOfStreamKey
        case streamDurationExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [EventErrorCode] {
            return [
                .bitrateExceeded,
                .bFramePresent,
                .insufficientCapabilities,
                .internalServerException,
                .invalidAudioCodec,
                .invalidInput,
                .invalidProtocol,
                .invalidStreamKey,
                .invalidVideoCodec,
                .publisherNotFound,
                .quotaExceeded,
                .resolutionExceeded,
                .reuseOfStreamKey,
                .streamDurationExceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bitrateExceeded: return "BITRATE_EXCEEDED"
            case .bFramePresent: return "B_FRAME_PRESENT"
            case .insufficientCapabilities: return "INSUFFICIENT_CAPABILITIES"
            case .internalServerException: return "INTERNAL_SERVER_EXCEPTION"
            case .invalidAudioCodec: return "INVALID_AUDIO_CODEC"
            case .invalidInput: return "INVALID_INPUT"
            case .invalidProtocol: return "INVALID_PROTOCOL"
            case .invalidStreamKey: return "INVALID_STREAM_KEY"
            case .invalidVideoCodec: return "INVALID_VIDEO_CODEC"
            case .publisherNotFound: return "PUBLISHER_NOT_FOUND"
            case .quotaExceeded: return "QUOTA_EXCEEDED"
            case .resolutionExceeded: return "RESOLUTION_EXCEEDED"
            case .reuseOfStreamKey: return "REUSE_OF_STREAM_KEY"
            case .streamDurationExceeded: return "STREAM_DURATION_EXCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes {

    public enum EventName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case joined
        case joinError
        case `left`
        case publishError
        case publishStarted
        case publishStopped
        case subscribeError
        case subscribeStarted
        case subscribeStopped
        case sdkUnknown(Swift.String)

        public static var allCases: [EventName] {
            return [
                .joined,
                .joinError,
                .left,
                .publishError,
                .publishStarted,
                .publishStopped,
                .subscribeError,
                .subscribeStarted,
                .subscribeStopped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .joined: return "JOINED"
            case .joinError: return "JOIN_ERROR"
            case .left: return "LEFT"
            case .publishError: return "PUBLISH_ERROR"
            case .publishStarted: return "PUBLISH_STARTED"
            case .publishStopped: return "PUBLISH_STOPPED"
            case .subscribeError: return "SUBSCRIBE_ERROR"
            case .subscribeStarted: return "SUBSCRIBE_STARTED"
            case .subscribeStopped: return "SUBSCRIBE_STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IVSRealTimeClientTypes {

    /// An occurrence during a stage session.
    public struct Event: Swift.Sendable {
        /// If the event is an error event, the error code is provided to give insight into the specific error that occurred. If the event is not an error event, this field is null.
        ///
        /// * B_FRAME_PRESENT — The participant's stream includes B-frames. For details, see [ IVS RTMP Publishing](https://docs.aws.amazon.com/ivs/latest/RealTimeUserGuide/rt-rtmp-publishing.html).
        ///
        /// * BITRATE_EXCEEDED — The participant exceeded the maximum supported bitrate. For details, see [ Service Quotas](https://docs.aws.amazon.com/ivs/latest/RealTimeUserGuide/service-quotas.html).
        ///
        /// * INSUFFICIENT_CAPABILITIES — The participant tried to take an action that the participant’s token is not allowed to do. For details on participant capabilities, see the capabilities field in [CreateParticipantToken].
        ///
        /// * INTERNAL_SERVER_EXCEPTION — The participant failed to publish to the stage due to an internal server error.
        ///
        /// * INVALID_AUDIO_CODEC — The participant is using an invalid audio codec. For details, see [ Stream Ingest](https://docs.aws.amazon.com/ivs/latest/RealTimeUserGuide/rt-stream-ingest.html).
        ///
        /// * INVALID_INPUT — The participant is using an invalid input stream.
        ///
        /// * INVALID_PROTOCOL — The participant's IngestConfiguration resource is configured for RTMPS but they tried streaming with RTMP. For details, see [ IVS RTMP Publishing](https://docs.aws.amazon.com/ivs/latest/RealTimeUserGuide/rt-rtmp-publishing.html).
        ///
        /// * INVALID_STREAM_KEY — The participant is using an invalid stream key. For details, see [ IVS RTMP Publishing](https://docs.aws.amazon.com/ivs/latest/RealTimeUserGuide/rt-rtmp-publishing.html).
        ///
        /// * INVALID_VIDEO_CODEC — The participant is using an invalid video codec. For details, see [ Stream Ingest](https://docs.aws.amazon.com/ivs/latest/RealTimeUserGuide/rt-stream-ingest.html).
        ///
        /// * PUBLISHER_NOT_FOUND — The participant tried to subscribe to a publisher that doesn’t exist.
        ///
        /// * QUOTA_EXCEEDED — The number of participants who want to publish/subscribe to a stage exceeds the quota. For details, see [ Service Quotas](https://docs.aws.amazon.com/ivs/latest/RealTimeUserGuide/service-quotas.html).
        ///
        /// * RESOLUTION_EXCEEDED — The participant exceeded the maximum supported resolution. For details, see [ Service Quotas](https://docs.aws.amazon.com/ivs/latest/RealTimeUserGuide/service-quotas.html).
        ///
        /// * REUSE_OF_STREAM_KEY — The participant tried to use a stream key that is associated with another active stage session.
        ///
        /// * STREAM_DURATION_EXCEEDED — The participant exceeded the maximum allowed stream duration. For details, see [ Service Quotas](https://docs.aws.amazon.com/ivs/latest/RealTimeUserGuide/service-quotas.html).
        public var errorCode: IVSRealTimeClientTypes.EventErrorCode?
        /// ISO 8601 timestamp (returned as a string) for when the event occurred.
        public var eventTime: Foundation.Date?
        /// The name of the event.
        public var name: IVSRealTimeClientTypes.EventName?
        /// Unique identifier for the participant who triggered the event. This is assigned by IVS.
        public var participantId: Swift.String?
        /// Unique identifier for the remote participant. For a subscribe event, this is the publisher. For a publish or join event, this is null. This is assigned by IVS.
        public var remoteParticipantId: Swift.String?

        public init(
            errorCode: IVSRealTimeClientTypes.EventErrorCode? = nil,
            eventTime: Foundation.Date? = nil,
            name: IVSRealTimeClientTypes.EventName? = nil,
            participantId: Swift.String? = nil,
            remoteParticipantId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.eventTime = eventTime
            self.name = name
            self.participantId = participantId
            self.remoteParticipantId = remoteParticipantId
        }
    }
}

public struct ListParticipantEventsOutput: Swift.Sendable {
    /// List of the matching events.
    /// This member is required.
    public var events: [IVSRealTimeClientTypes.Event]?
    /// If there are more events than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init(
        events: [IVSRealTimeClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

extension IVSRealTimeClientTypes {

    public enum ParticipantRecordingFilterByRecordingState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case failed
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantRecordingFilterByRecordingState] {
            return [
                .active,
                .failed,
                .starting,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .failed: return "FAILED"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListParticipantsInput: Swift.Sendable {
    /// Filters the response list to only show participants who published during the stage session. Only one of filterByUserId, filterByPublished, filterByState, or filterByRecordingState can be provided per request.
    public var filterByPublished: Swift.Bool?
    /// Filters the response list to only show participants with the specified recording state. Only one of filterByUserId, filterByPublished, filterByState, or filterByRecordingState can be provided per request.
    public var filterByRecordingState: IVSRealTimeClientTypes.ParticipantRecordingFilterByRecordingState?
    /// Filters the response list to only show participants in the specified state. Only one of filterByUserId, filterByPublished, filterByState, or filterByRecordingState can be provided per request.
    public var filterByState: IVSRealTimeClientTypes.ParticipantState?
    /// Filters the response list to match the specified user ID. Only one of filterByUserId, filterByPublished, filterByState, or filterByRecordingState can be provided per request. A userId is a customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems.
    public var filterByUserId: Swift.String?
    /// Maximum number of results to return. Default: 50.
    public var maxResults: Swift.Int?
    /// The first participant to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?
    /// ID of the session within the stage.
    /// This member is required.
    public var sessionId: Swift.String?
    /// Stage ARN.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        filterByPublished: Swift.Bool? = false,
        filterByRecordingState: IVSRealTimeClientTypes.ParticipantRecordingFilterByRecordingState? = nil,
        filterByState: IVSRealTimeClientTypes.ParticipantState? = nil,
        filterByUserId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.filterByPublished = filterByPublished
        self.filterByRecordingState = filterByRecordingState
        self.filterByState = filterByState
        self.filterByUserId = filterByUserId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sessionId = sessionId
        self.stageArn = stageArn
    }
}

extension IVSRealTimeClientTypes {

    /// Summary object describing a participant that has joined a stage.
    public struct ParticipantSummary: Swift.Sendable {
        /// ISO 8601 timestamp (returned as a string) when the participant first joined the stage session.
        public var firstJoinTime: Foundation.Date?
        /// Unique identifier for this participant, assigned by IVS.
        public var participantId: Swift.String?
        /// Whether the participant ever published to the stage session.
        public var published: Swift.Bool
        /// The participant’s recording state.
        public var recordingState: IVSRealTimeClientTypes.ParticipantRecordingState?
        /// Whether the participant is connected to or disconnected from the stage.
        public var state: IVSRealTimeClientTypes.ParticipantState?
        /// Customer-assigned name to help identify the token; this can be used to link a participant to a user in the customer’s own systems. This can be any UTF-8 encoded text. This field is exposed to all stage participants and should not be used for personally identifying, confidential, or sensitive information.
        public var userId: Swift.String?

        public init(
            firstJoinTime: Foundation.Date? = nil,
            participantId: Swift.String? = nil,
            published: Swift.Bool = false,
            recordingState: IVSRealTimeClientTypes.ParticipantRecordingState? = nil,
            state: IVSRealTimeClientTypes.ParticipantState? = nil,
            userId: Swift.String? = nil
        )
        {
            self.firstJoinTime = firstJoinTime
            self.participantId = participantId
            self.published = published
            self.recordingState = recordingState
            self.state = state
            self.userId = userId
        }
    }
}

public struct ListParticipantsOutput: Swift.Sendable {
    /// If there are more participants than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching participants (summary information only).
    /// This member is required.
    public var participants: [IVSRealTimeClientTypes.ParticipantSummary]?

    public init(
        nextToken: Swift.String? = nil,
        participants: [IVSRealTimeClientTypes.ParticipantSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.participants = participants
    }
}

public struct ListPublicKeysInput: Swift.Sendable {
    /// Maximum number of results to return. Default: 50.
    public var maxResults: Swift.Int?
    /// The first public key to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IVSRealTimeClientTypes {

    /// Summary information about a public key.
    public struct PublicKeySummary: Swift.Sendable {
        /// Public key ARN.
        public var arn: Swift.String?
        /// Public key name.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.tags = tags
        }
    }
}

public struct ListPublicKeysOutput: Swift.Sendable {
    /// If there are more public keys than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching public keys (summary information only).
    /// This member is required.
    public var publicKeys: [IVSRealTimeClientTypes.PublicKeySummary]?

    public init(
        nextToken: Swift.String? = nil,
        publicKeys: [IVSRealTimeClientTypes.PublicKeySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.publicKeys = publicKeys
    }
}

public struct ListStagesInput: Swift.Sendable {
    /// Maximum number of results to return. Default: 50.
    public var maxResults: Swift.Int?
    /// The first stage to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IVSRealTimeClientTypes {

    /// Summary information about a stage.
    public struct StageSummary: Swift.Sendable {
        /// ID of the active session within the stage.
        public var activeSessionId: Swift.String?
        /// Stage ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// Stage name.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?

        public init(
            activeSessionId: Swift.String? = nil,
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.activeSessionId = activeSessionId
            self.arn = arn
            self.name = name
            self.tags = tags
        }
    }
}

public struct ListStagesOutput: Swift.Sendable {
    /// If there are more stages than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching stages (summary information only).
    /// This member is required.
    public var stages: [IVSRealTimeClientTypes.StageSummary]?

    public init(
        nextToken: Swift.String? = nil,
        stages: [IVSRealTimeClientTypes.StageSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.stages = stages
    }
}

public struct ListStageSessionsInput: Swift.Sendable {
    /// Maximum number of results to return. Default: 50.
    public var maxResults: Swift.Int?
    /// The first stage session to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?
    /// Stage ARN.
    /// This member is required.
    public var stageArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stageArn = stageArn
    }
}

extension IVSRealTimeClientTypes {

    /// Summary information about a stage session.
    public struct StageSessionSummary: Swift.Sendable {
        /// ISO 8601 timestamp (returned as a string) when the stage session ended. This is null if the stage is active.
        public var endTime: Foundation.Date?
        /// ID of the session within the stage.
        public var sessionId: Swift.String?
        /// ISO 8601 timestamp (returned as a string) when this stage session began.
        public var startTime: Foundation.Date?

        public init(
            endTime: Foundation.Date? = nil,
            sessionId: Swift.String? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.endTime = endTime
            self.sessionId = sessionId
            self.startTime = startTime
        }
    }
}

public struct ListStageSessionsOutput: Swift.Sendable {
    /// If there are more stage sessions than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of matching stage sessions.
    /// This member is required.
    public var stageSessions: [IVSRealTimeClientTypes.StageSessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        stageSessions: [IVSRealTimeClientTypes.StageSessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.stageSessions = stageSessions
    }
}

public struct ListStorageConfigurationsInput: Swift.Sendable {
    /// Maximum number of storage configurations to return. Default: your service quota or 100, whichever is smaller.
    public var maxResults: Swift.Int?
    /// The first storage configuration to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IVSRealTimeClientTypes {

    /// Summary information about a storage configuration.
    public struct StorageConfigurationSummary: Swift.Sendable {
        /// ARN of the storage configuration.
        /// This member is required.
        public var arn: Swift.String?
        /// Name of the storage configuration.
        public var name: Swift.String?
        /// An S3 destination configuration where recorded videos will be stored.
        public var s3: IVSRealTimeClientTypes.S3StorageConfiguration?
        /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            s3: IVSRealTimeClientTypes.S3StorageConfiguration? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.s3 = s3
            self.tags = tags
        }
    }
}

public struct ListStorageConfigurationsOutput: Swift.Sendable {
    /// If there are more storage configurations than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching storage configurations.
    /// This member is required.
    public var storageConfigurations: [IVSRealTimeClientTypes.StorageConfigurationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        storageConfigurations: [IVSRealTimeClientTypes.StorageConfigurationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.storageConfigurations = storageConfigurations
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource to be retrieved. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct StartCompositionInput: Swift.Sendable {
    /// Array of destination configuration.
    /// This member is required.
    public var destinations: [IVSRealTimeClientTypes.DestinationConfiguration]?
    /// Idempotency token.
    public var idempotencyToken: Swift.String?
    /// Layout object to configure composition parameters.
    public var layout: IVSRealTimeClientTypes.LayoutConfiguration?
    /// ARN of the stage to be used for compositing.
    /// This member is required.
    public var stageArn: Swift.String?
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    public var tags: [Swift.String: Swift.String]?

    public init(
        destinations: [IVSRealTimeClientTypes.DestinationConfiguration]? = nil,
        idempotencyToken: Swift.String? = nil,
        layout: IVSRealTimeClientTypes.LayoutConfiguration? = nil,
        stageArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.destinations = destinations
        self.idempotencyToken = idempotencyToken
        self.layout = layout
        self.stageArn = stageArn
        self.tags = tags
    }
}

public struct StartCompositionOutput: Swift.Sendable {
    /// The Composition that was created.
    public var composition: IVSRealTimeClientTypes.Composition?

    public init(
        composition: IVSRealTimeClientTypes.Composition? = nil
    )
    {
        self.composition = composition
    }
}

public struct StopCompositionInput: Swift.Sendable {
    /// ARN of the Composition.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct StopCompositionOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the resource to be tagged. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be added or updated. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the resource to be untagged. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be removed. Array of maps, each of the form string:string (key:value). See [Best practices and strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html) in Tagging AWS Resources and Tag Editor for details, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no constraints on tags beyond what is documented there.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateIngestConfigurationInput: Swift.Sendable {
    /// ARN of the IngestConfiguration, for which the related stage ARN needs to be updated.
    /// This member is required.
    public var arn: Swift.String?
    /// Stage ARN that needs to be updated.
    public var stageArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        stageArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.stageArn = stageArn
    }
}

public struct UpdateIngestConfigurationOutput: Swift.Sendable {
    /// The updated IngestConfiguration.
    public var ingestConfiguration: IVSRealTimeClientTypes.IngestConfiguration?

    public init(
        ingestConfiguration: IVSRealTimeClientTypes.IngestConfiguration? = nil
    )
    {
        self.ingestConfiguration = ingestConfiguration
    }
}

public struct UpdateStageInput: Swift.Sendable {
    /// ARN of the stage to be updated.
    /// This member is required.
    public var arn: Swift.String?
    /// Configuration object for individual participant recording, to attach to the stage. Note that this cannot be updated while recording is active.
    public var autoParticipantRecordingConfiguration: IVSRealTimeClientTypes.AutoParticipantRecordingConfiguration?
    /// Name of the stage to be updated.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        autoParticipantRecordingConfiguration: IVSRealTimeClientTypes.AutoParticipantRecordingConfiguration? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.autoParticipantRecordingConfiguration = autoParticipantRecordingConfiguration
        self.name = name
    }
}

public struct UpdateStageOutput: Swift.Sendable {
    /// The updated stage.
    public var stage: IVSRealTimeClientTypes.Stage?

    public init(
        stage: IVSRealTimeClientTypes.Stage? = nil
    )
    {
        self.stage = stage
    }
}

extension CreateEncoderConfigurationInput {

    static func urlPathProvider(_ value: CreateEncoderConfigurationInput) -> Swift.String? {
        return "/CreateEncoderConfiguration"
    }
}

extension CreateIngestConfigurationInput {

    static func urlPathProvider(_ value: CreateIngestConfigurationInput) -> Swift.String? {
        return "/CreateIngestConfiguration"
    }
}

extension CreateParticipantTokenInput {

    static func urlPathProvider(_ value: CreateParticipantTokenInput) -> Swift.String? {
        return "/CreateParticipantToken"
    }
}

extension CreateStageInput {

    static func urlPathProvider(_ value: CreateStageInput) -> Swift.String? {
        return "/CreateStage"
    }
}

extension CreateStorageConfigurationInput {

    static func urlPathProvider(_ value: CreateStorageConfigurationInput) -> Swift.String? {
        return "/CreateStorageConfiguration"
    }
}

extension DeleteEncoderConfigurationInput {

    static func urlPathProvider(_ value: DeleteEncoderConfigurationInput) -> Swift.String? {
        return "/DeleteEncoderConfiguration"
    }
}

extension DeleteIngestConfigurationInput {

    static func urlPathProvider(_ value: DeleteIngestConfigurationInput) -> Swift.String? {
        return "/DeleteIngestConfiguration"
    }
}

extension DeletePublicKeyInput {

    static func urlPathProvider(_ value: DeletePublicKeyInput) -> Swift.String? {
        return "/DeletePublicKey"
    }
}

extension DeleteStageInput {

    static func urlPathProvider(_ value: DeleteStageInput) -> Swift.String? {
        return "/DeleteStage"
    }
}

extension DeleteStorageConfigurationInput {

    static func urlPathProvider(_ value: DeleteStorageConfigurationInput) -> Swift.String? {
        return "/DeleteStorageConfiguration"
    }
}

extension DisconnectParticipantInput {

    static func urlPathProvider(_ value: DisconnectParticipantInput) -> Swift.String? {
        return "/DisconnectParticipant"
    }
}

extension GetCompositionInput {

    static func urlPathProvider(_ value: GetCompositionInput) -> Swift.String? {
        return "/GetComposition"
    }
}

extension GetEncoderConfigurationInput {

    static func urlPathProvider(_ value: GetEncoderConfigurationInput) -> Swift.String? {
        return "/GetEncoderConfiguration"
    }
}

extension GetIngestConfigurationInput {

    static func urlPathProvider(_ value: GetIngestConfigurationInput) -> Swift.String? {
        return "/GetIngestConfiguration"
    }
}

extension GetParticipantInput {

    static func urlPathProvider(_ value: GetParticipantInput) -> Swift.String? {
        return "/GetParticipant"
    }
}

extension GetPublicKeyInput {

    static func urlPathProvider(_ value: GetPublicKeyInput) -> Swift.String? {
        return "/GetPublicKey"
    }
}

extension GetStageInput {

    static func urlPathProvider(_ value: GetStageInput) -> Swift.String? {
        return "/GetStage"
    }
}

extension GetStageSessionInput {

    static func urlPathProvider(_ value: GetStageSessionInput) -> Swift.String? {
        return "/GetStageSession"
    }
}

extension GetStorageConfigurationInput {

    static func urlPathProvider(_ value: GetStorageConfigurationInput) -> Swift.String? {
        return "/GetStorageConfiguration"
    }
}

extension ImportPublicKeyInput {

    static func urlPathProvider(_ value: ImportPublicKeyInput) -> Swift.String? {
        return "/ImportPublicKey"
    }
}

extension ListCompositionsInput {

    static func urlPathProvider(_ value: ListCompositionsInput) -> Swift.String? {
        return "/ListCompositions"
    }
}

extension ListEncoderConfigurationsInput {

    static func urlPathProvider(_ value: ListEncoderConfigurationsInput) -> Swift.String? {
        return "/ListEncoderConfigurations"
    }
}

extension ListIngestConfigurationsInput {

    static func urlPathProvider(_ value: ListIngestConfigurationsInput) -> Swift.String? {
        return "/ListIngestConfigurations"
    }
}

extension ListParticipantEventsInput {

    static func urlPathProvider(_ value: ListParticipantEventsInput) -> Swift.String? {
        return "/ListParticipantEvents"
    }
}

extension ListParticipantsInput {

    static func urlPathProvider(_ value: ListParticipantsInput) -> Swift.String? {
        return "/ListParticipants"
    }
}

extension ListPublicKeysInput {

    static func urlPathProvider(_ value: ListPublicKeysInput) -> Swift.String? {
        return "/ListPublicKeys"
    }
}

extension ListStagesInput {

    static func urlPathProvider(_ value: ListStagesInput) -> Swift.String? {
        return "/ListStages"
    }
}

extension ListStageSessionsInput {

    static func urlPathProvider(_ value: ListStageSessionsInput) -> Swift.String? {
        return "/ListStageSessions"
    }
}

extension ListStorageConfigurationsInput {

    static func urlPathProvider(_ value: ListStorageConfigurationsInput) -> Swift.String? {
        return "/ListStorageConfigurations"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension StartCompositionInput {

    static func urlPathProvider(_ value: StartCompositionInput) -> Swift.String? {
        return "/StartComposition"
    }
}

extension StopCompositionInput {

    static func urlPathProvider(_ value: StopCompositionInput) -> Swift.String? {
        return "/StopComposition"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateIngestConfigurationInput {

    static func urlPathProvider(_ value: UpdateIngestConfigurationInput) -> Swift.String? {
        return "/UpdateIngestConfiguration"
    }
}

extension UpdateStageInput {

    static func urlPathProvider(_ value: UpdateStageInput) -> Swift.String? {
        return "/UpdateStage"
    }
}

extension CreateEncoderConfigurationInput {

    static func write(value: CreateEncoderConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["video"].write(value.video, with: IVSRealTimeClientTypes.Video.write(value:to:))
    }
}

extension CreateIngestConfigurationInput {

    static func write(value: CreateIngestConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ingestProtocol"].write(value.ingestProtocol)
        try writer["insecureIngest"].write(value.insecureIngest)
        try writer["name"].write(value.name)
        try writer["stageArn"].write(value.stageArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["userId"].write(value.userId)
    }
}

extension CreateParticipantTokenInput {

    static func write(value: CreateParticipantTokenInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["capabilities"].writeList(value.capabilities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<IVSRealTimeClientTypes.ParticipantTokenCapability>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["duration"].write(value.duration)
        try writer["stageArn"].write(value.stageArn)
        try writer["userId"].write(value.userId)
    }
}

extension CreateStageInput {

    static func write(value: CreateStageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autoParticipantRecordingConfiguration"].write(value.autoParticipantRecordingConfiguration, with: IVSRealTimeClientTypes.AutoParticipantRecordingConfiguration.write(value:to:))
        try writer["name"].write(value.name)
        try writer["participantTokenConfigurations"].writeList(value.participantTokenConfigurations, memberWritingClosure: IVSRealTimeClientTypes.ParticipantTokenConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateStorageConfigurationInput {

    static func write(value: CreateStorageConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["s3"].write(value.s3, with: IVSRealTimeClientTypes.S3StorageConfiguration.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension DeleteEncoderConfigurationInput {

    static func write(value: DeleteEncoderConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension DeleteIngestConfigurationInput {

    static func write(value: DeleteIngestConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["force"].write(value.force)
    }
}

extension DeletePublicKeyInput {

    static func write(value: DeletePublicKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension DeleteStageInput {

    static func write(value: DeleteStageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension DeleteStorageConfigurationInput {

    static func write(value: DeleteStorageConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension DisconnectParticipantInput {

    static func write(value: DisconnectParticipantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["participantId"].write(value.participantId)
        try writer["reason"].write(value.reason)
        try writer["stageArn"].write(value.stageArn)
    }
}

extension GetCompositionInput {

    static func write(value: GetCompositionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetEncoderConfigurationInput {

    static func write(value: GetEncoderConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetIngestConfigurationInput {

    static func write(value: GetIngestConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetParticipantInput {

    static func write(value: GetParticipantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["participantId"].write(value.participantId)
        try writer["sessionId"].write(value.sessionId)
        try writer["stageArn"].write(value.stageArn)
    }
}

extension GetPublicKeyInput {

    static func write(value: GetPublicKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetStageInput {

    static func write(value: GetStageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetStageSessionInput {

    static func write(value: GetStageSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sessionId"].write(value.sessionId)
        try writer["stageArn"].write(value.stageArn)
    }
}

extension GetStorageConfigurationInput {

    static func write(value: GetStorageConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension ImportPublicKeyInput {

    static func write(value: ImportPublicKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["publicKeyMaterial"].write(value.publicKeyMaterial)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListCompositionsInput {

    static func write(value: ListCompositionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterByEncoderConfigurationArn"].write(value.filterByEncoderConfigurationArn)
        try writer["filterByStageArn"].write(value.filterByStageArn)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListEncoderConfigurationsInput {

    static func write(value: ListEncoderConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListIngestConfigurationsInput {

    static func write(value: ListIngestConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterByStageArn"].write(value.filterByStageArn)
        try writer["filterByState"].write(value.filterByState)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListParticipantEventsInput {

    static func write(value: ListParticipantEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["participantId"].write(value.participantId)
        try writer["sessionId"].write(value.sessionId)
        try writer["stageArn"].write(value.stageArn)
    }
}

extension ListParticipantsInput {

    static func write(value: ListParticipantsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterByPublished"].write(value.filterByPublished)
        try writer["filterByRecordingState"].write(value.filterByRecordingState)
        try writer["filterByState"].write(value.filterByState)
        try writer["filterByUserId"].write(value.filterByUserId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["sessionId"].write(value.sessionId)
        try writer["stageArn"].write(value.stageArn)
    }
}

extension ListPublicKeysInput {

    static func write(value: ListPublicKeysInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListStagesInput {

    static func write(value: ListStagesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListStageSessionsInput {

    static func write(value: ListStageSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["stageArn"].write(value.stageArn)
    }
}

extension ListStorageConfigurationsInput {

    static func write(value: ListStorageConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension StartCompositionInput {

    static func write(value: StartCompositionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinations"].writeList(value.destinations, memberWritingClosure: IVSRealTimeClientTypes.DestinationConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["idempotencyToken"].write(value.idempotencyToken)
        try writer["layout"].write(value.layout, with: IVSRealTimeClientTypes.LayoutConfiguration.write(value:to:))
        try writer["stageArn"].write(value.stageArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension StopCompositionInput {

    static func write(value: StopCompositionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateIngestConfigurationInput {

    static func write(value: UpdateIngestConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["stageArn"].write(value.stageArn)
    }
}

extension UpdateStageInput {

    static func write(value: UpdateStageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["autoParticipantRecordingConfiguration"].write(value.autoParticipantRecordingConfiguration, with: IVSRealTimeClientTypes.AutoParticipantRecordingConfiguration.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension CreateEncoderConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEncoderConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEncoderConfigurationOutput()
        value.encoderConfiguration = try reader["encoderConfiguration"].readIfPresent(with: IVSRealTimeClientTypes.EncoderConfiguration.read(from:))
        return value
    }
}

extension CreateIngestConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIngestConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIngestConfigurationOutput()
        value.ingestConfiguration = try reader["ingestConfiguration"].readIfPresent(with: IVSRealTimeClientTypes.IngestConfiguration.read(from:))
        return value
    }
}

extension CreateParticipantTokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateParticipantTokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateParticipantTokenOutput()
        value.participantToken = try reader["participantToken"].readIfPresent(with: IVSRealTimeClientTypes.ParticipantToken.read(from:))
        return value
    }
}

extension CreateStageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStageOutput()
        value.participantTokens = try reader["participantTokens"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.ParticipantToken.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.stage = try reader["stage"].readIfPresent(with: IVSRealTimeClientTypes.Stage.read(from:))
        return value
    }
}

extension CreateStorageConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStorageConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStorageConfigurationOutput()
        value.storageConfiguration = try reader["storageConfiguration"].readIfPresent(with: IVSRealTimeClientTypes.StorageConfiguration.read(from:))
        return value
    }
}

extension DeleteEncoderConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEncoderConfigurationOutput {
        return DeleteEncoderConfigurationOutput()
    }
}

extension DeleteIngestConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIngestConfigurationOutput {
        return DeleteIngestConfigurationOutput()
    }
}

extension DeletePublicKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePublicKeyOutput {
        return DeletePublicKeyOutput()
    }
}

extension DeleteStageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStageOutput {
        return DeleteStageOutput()
    }
}

extension DeleteStorageConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStorageConfigurationOutput {
        return DeleteStorageConfigurationOutput()
    }
}

extension DisconnectParticipantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisconnectParticipantOutput {
        return DisconnectParticipantOutput()
    }
}

extension GetCompositionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCompositionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCompositionOutput()
        value.composition = try reader["composition"].readIfPresent(with: IVSRealTimeClientTypes.Composition.read(from:))
        return value
    }
}

extension GetEncoderConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEncoderConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEncoderConfigurationOutput()
        value.encoderConfiguration = try reader["encoderConfiguration"].readIfPresent(with: IVSRealTimeClientTypes.EncoderConfiguration.read(from:))
        return value
    }
}

extension GetIngestConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIngestConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIngestConfigurationOutput()
        value.ingestConfiguration = try reader["ingestConfiguration"].readIfPresent(with: IVSRealTimeClientTypes.IngestConfiguration.read(from:))
        return value
    }
}

extension GetParticipantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetParticipantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetParticipantOutput()
        value.participant = try reader["participant"].readIfPresent(with: IVSRealTimeClientTypes.Participant.read(from:))
        return value
    }
}

extension GetPublicKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPublicKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPublicKeyOutput()
        value.publicKey = try reader["publicKey"].readIfPresent(with: IVSRealTimeClientTypes.PublicKey.read(from:))
        return value
    }
}

extension GetStageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStageOutput()
        value.stage = try reader["stage"].readIfPresent(with: IVSRealTimeClientTypes.Stage.read(from:))
        return value
    }
}

extension GetStageSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStageSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStageSessionOutput()
        value.stageSession = try reader["stageSession"].readIfPresent(with: IVSRealTimeClientTypes.StageSession.read(from:))
        return value
    }
}

extension GetStorageConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStorageConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStorageConfigurationOutput()
        value.storageConfiguration = try reader["storageConfiguration"].readIfPresent(with: IVSRealTimeClientTypes.StorageConfiguration.read(from:))
        return value
    }
}

extension ImportPublicKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportPublicKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportPublicKeyOutput()
        value.publicKey = try reader["publicKey"].readIfPresent(with: IVSRealTimeClientTypes.PublicKey.read(from:))
        return value
    }
}

extension ListCompositionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCompositionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCompositionsOutput()
        value.compositions = try reader["compositions"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.CompositionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEncoderConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEncoderConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEncoderConfigurationsOutput()
        value.encoderConfigurations = try reader["encoderConfigurations"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.EncoderConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListIngestConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIngestConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIngestConfigurationsOutput()
        value.ingestConfigurations = try reader["ingestConfigurations"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.IngestConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListParticipantEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListParticipantEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListParticipantEventsOutput()
        value.events = try reader["events"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.Event.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListParticipantsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListParticipantsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListParticipantsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.participants = try reader["participants"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.ParticipantSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListPublicKeysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPublicKeysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPublicKeysOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.publicKeys = try reader["publicKeys"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.PublicKeySummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListStagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStagesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.stages = try reader["stages"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.StageSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListStageSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStageSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStageSessionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.stageSessions = try reader["stageSessions"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.StageSessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListStorageConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStorageConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStorageConfigurationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.storageConfigurations = try reader["storageConfigurations"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.StorageConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension StartCompositionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartCompositionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartCompositionOutput()
        value.composition = try reader["composition"].readIfPresent(with: IVSRealTimeClientTypes.Composition.read(from:))
        return value
    }
}

extension StopCompositionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopCompositionOutput {
        return StopCompositionOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateIngestConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIngestConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIngestConfigurationOutput()
        value.ingestConfiguration = try reader["ingestConfiguration"].readIfPresent(with: IVSRealTimeClientTypes.IngestConfiguration.read(from:))
        return value
    }
}

extension UpdateStageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateStageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateStageOutput()
        value.stage = try reader["stage"].readIfPresent(with: IVSRealTimeClientTypes.Stage.read(from:))
        return value
    }
}

enum CreateEncoderConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIngestConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateParticipantTokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStorageConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEncoderConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIngestConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePublicKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStorageConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisconnectParticipantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCompositionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEncoderConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIngestConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetParticipantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPublicKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStageSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStorageConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportPublicKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCompositionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEncoderConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIngestConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListParticipantEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListParticipantsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPublicKeysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStageSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStorageConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartCompositionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopCompositionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIngestConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateStageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "PendingVerification": return try PendingVerification.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PendingVerification {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PendingVerification {
        let reader = baseError.errorBodyReader
        var value = PendingVerification()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.exceptionMessage = try reader["exceptionMessage"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IVSRealTimeClientTypes.EncoderConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.EncoderConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.EncoderConfiguration()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.video = try reader["video"].readIfPresent(with: IVSRealTimeClientTypes.Video.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IVSRealTimeClientTypes.Video {

    static func write(value: IVSRealTimeClientTypes.Video?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bitrate"].write(value.bitrate)
        try writer["framerate"].write(value.framerate)
        try writer["height"].write(value.height)
        try writer["width"].write(value.width)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.Video {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.Video()
        value.width = try reader["width"].readIfPresent()
        value.height = try reader["height"].readIfPresent()
        value.framerate = try reader["framerate"].readIfPresent()
        value.bitrate = try reader["bitrate"].readIfPresent()
        return value
    }
}

extension IVSRealTimeClientTypes.IngestConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.IngestConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.IngestConfiguration()
        value.name = try reader["name"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.ingestProtocol = try reader["ingestProtocol"].readIfPresent() ?? .sdkUnknown("")
        value.streamKey = try reader["streamKey"].readIfPresent() ?? ""
        value.stageArn = try reader["stageArn"].readIfPresent() ?? ""
        value.participantId = try reader["participantId"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.userId = try reader["userId"].readIfPresent()
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IVSRealTimeClientTypes.ParticipantToken {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.ParticipantToken {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.ParticipantToken()
        value.participantId = try reader["participantId"].readIfPresent()
        value.token = try reader["token"].readIfPresent()
        value.userId = try reader["userId"].readIfPresent()
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.duration = try reader["duration"].readIfPresent()
        value.capabilities = try reader["capabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<IVSRealTimeClientTypes.ParticipantTokenCapability>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.expirationTime = try reader["expirationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension IVSRealTimeClientTypes.Stage {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.Stage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.Stage()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.activeSessionId = try reader["activeSessionId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.autoParticipantRecordingConfiguration = try reader["autoParticipantRecordingConfiguration"].readIfPresent(with: IVSRealTimeClientTypes.AutoParticipantRecordingConfiguration.read(from:))
        value.endpoints = try reader["endpoints"].readIfPresent(with: IVSRealTimeClientTypes.StageEndpoints.read(from:))
        return value
    }
}

extension IVSRealTimeClientTypes.StageEndpoints {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.StageEndpoints {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.StageEndpoints()
        value.events = try reader["events"].readIfPresent()
        value.whip = try reader["whip"].readIfPresent()
        value.rtmp = try reader["rtmp"].readIfPresent()
        value.rtmps = try reader["rtmps"].readIfPresent()
        return value
    }
}

extension IVSRealTimeClientTypes.AutoParticipantRecordingConfiguration {

    static func write(value: IVSRealTimeClientTypes.AutoParticipantRecordingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mediaTypes"].writeList(value.mediaTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<IVSRealTimeClientTypes.ParticipantRecordingMediaType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["storageConfigurationArn"].write(value.storageConfigurationArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.AutoParticipantRecordingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.AutoParticipantRecordingConfiguration()
        value.storageConfigurationArn = try reader["storageConfigurationArn"].readIfPresent() ?? ""
        value.mediaTypes = try reader["mediaTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<IVSRealTimeClientTypes.ParticipantRecordingMediaType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IVSRealTimeClientTypes.StorageConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.StorageConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.StorageConfiguration()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.s3 = try reader["s3"].readIfPresent(with: IVSRealTimeClientTypes.S3StorageConfiguration.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IVSRealTimeClientTypes.S3StorageConfiguration {

    static func write(value: IVSRealTimeClientTypes.S3StorageConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.S3StorageConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.S3StorageConfiguration()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        return value
    }
}

extension IVSRealTimeClientTypes.Composition {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.Composition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.Composition()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.stageArn = try reader["stageArn"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.layout = try reader["layout"].readIfPresent(with: IVSRealTimeClientTypes.LayoutConfiguration.read(from:))
        value.destinations = try reader["destinations"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.Destination.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension IVSRealTimeClientTypes.Destination {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.Destination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.Destination()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.configuration = try reader["configuration"].readIfPresent(with: IVSRealTimeClientTypes.DestinationConfiguration.read(from:))
        value.detail = try reader["detail"].readIfPresent(with: IVSRealTimeClientTypes.DestinationDetail.read(from:))
        return value
    }
}

extension IVSRealTimeClientTypes.DestinationDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.DestinationDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.DestinationDetail()
        value.s3 = try reader["s3"].readIfPresent(with: IVSRealTimeClientTypes.S3Detail.read(from:))
        return value
    }
}

extension IVSRealTimeClientTypes.S3Detail {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.S3Detail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.S3Detail()
        value.recordingPrefix = try reader["recordingPrefix"].readIfPresent() ?? ""
        return value
    }
}

extension IVSRealTimeClientTypes.DestinationConfiguration {

    static func write(value: IVSRealTimeClientTypes.DestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channel"].write(value.channel, with: IVSRealTimeClientTypes.ChannelDestinationConfiguration.write(value:to:))
        try writer["name"].write(value.name)
        try writer["s3"].write(value.s3, with: IVSRealTimeClientTypes.S3DestinationConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.DestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.DestinationConfiguration()
        value.name = try reader["name"].readIfPresent()
        value.channel = try reader["channel"].readIfPresent(with: IVSRealTimeClientTypes.ChannelDestinationConfiguration.read(from:))
        value.s3 = try reader["s3"].readIfPresent(with: IVSRealTimeClientTypes.S3DestinationConfiguration.read(from:))
        return value
    }
}

extension IVSRealTimeClientTypes.S3DestinationConfiguration {

    static func write(value: IVSRealTimeClientTypes.S3DestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encoderConfigurationArns"].writeList(value.encoderConfigurationArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["recordingConfiguration"].write(value.recordingConfiguration, with: IVSRealTimeClientTypes.RecordingConfiguration.write(value:to:))
        try writer["storageConfigurationArn"].write(value.storageConfigurationArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.S3DestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.S3DestinationConfiguration()
        value.storageConfigurationArn = try reader["storageConfigurationArn"].readIfPresent() ?? ""
        value.encoderConfigurationArns = try reader["encoderConfigurationArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.recordingConfiguration = try reader["recordingConfiguration"].readIfPresent(with: IVSRealTimeClientTypes.RecordingConfiguration.read(from:))
        return value
    }
}

extension IVSRealTimeClientTypes.RecordingConfiguration {

    static func write(value: IVSRealTimeClientTypes.RecordingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["format"].write(value.format)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.RecordingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.RecordingConfiguration()
        value.format = try reader["format"].readIfPresent()
        return value
    }
}

extension IVSRealTimeClientTypes.ChannelDestinationConfiguration {

    static func write(value: IVSRealTimeClientTypes.ChannelDestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channelArn"].write(value.channelArn)
        try writer["encoderConfigurationArn"].write(value.encoderConfigurationArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.ChannelDestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.ChannelDestinationConfiguration()
        value.channelArn = try reader["channelArn"].readIfPresent() ?? ""
        value.encoderConfigurationArn = try reader["encoderConfigurationArn"].readIfPresent()
        return value
    }
}

extension IVSRealTimeClientTypes.LayoutConfiguration {

    static func write(value: IVSRealTimeClientTypes.LayoutConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["grid"].write(value.grid, with: IVSRealTimeClientTypes.GridConfiguration.write(value:to:))
        try writer["pip"].write(value.pip, with: IVSRealTimeClientTypes.PipConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.LayoutConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.LayoutConfiguration()
        value.grid = try reader["grid"].readIfPresent(with: IVSRealTimeClientTypes.GridConfiguration.read(from:))
        value.pip = try reader["pip"].readIfPresent(with: IVSRealTimeClientTypes.PipConfiguration.read(from:))
        return value
    }
}

extension IVSRealTimeClientTypes.PipConfiguration {

    static func write(value: IVSRealTimeClientTypes.PipConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["featuredParticipantAttribute"].write(value.featuredParticipantAttribute)
        try writer["gridGap"].write(value.gridGap)
        try writer["omitStoppedVideo"].write(value.omitStoppedVideo)
        try writer["pipBehavior"].write(value.pipBehavior)
        try writer["pipHeight"].write(value.pipHeight)
        try writer["pipOffset"].write(value.pipOffset)
        try writer["pipParticipantAttribute"].write(value.pipParticipantAttribute)
        try writer["pipPosition"].write(value.pipPosition)
        try writer["pipWidth"].write(value.pipWidth)
        try writer["videoFillMode"].write(value.videoFillMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.PipConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.PipConfiguration()
        value.featuredParticipantAttribute = try reader["featuredParticipantAttribute"].readIfPresent()
        value.omitStoppedVideo = try reader["omitStoppedVideo"].readIfPresent() ?? false
        value.videoFillMode = try reader["videoFillMode"].readIfPresent()
        value.gridGap = try reader["gridGap"].readIfPresent() ?? 0
        value.pipParticipantAttribute = try reader["pipParticipantAttribute"].readIfPresent()
        value.pipBehavior = try reader["pipBehavior"].readIfPresent()
        value.pipOffset = try reader["pipOffset"].readIfPresent() ?? 0
        value.pipPosition = try reader["pipPosition"].readIfPresent()
        value.pipWidth = try reader["pipWidth"].readIfPresent()
        value.pipHeight = try reader["pipHeight"].readIfPresent()
        return value
    }
}

extension IVSRealTimeClientTypes.GridConfiguration {

    static func write(value: IVSRealTimeClientTypes.GridConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["featuredParticipantAttribute"].write(value.featuredParticipantAttribute)
        try writer["gridGap"].write(value.gridGap)
        try writer["omitStoppedVideo"].write(value.omitStoppedVideo)
        try writer["videoAspectRatio"].write(value.videoAspectRatio)
        try writer["videoFillMode"].write(value.videoFillMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.GridConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.GridConfiguration()
        value.featuredParticipantAttribute = try reader["featuredParticipantAttribute"].readIfPresent()
        value.omitStoppedVideo = try reader["omitStoppedVideo"].readIfPresent() ?? false
        value.videoAspectRatio = try reader["videoAspectRatio"].readIfPresent()
        value.videoFillMode = try reader["videoFillMode"].readIfPresent()
        value.gridGap = try reader["gridGap"].readIfPresent() ?? 0
        return value
    }
}

extension IVSRealTimeClientTypes.Participant {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.Participant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.Participant()
        value.participantId = try reader["participantId"].readIfPresent()
        value.userId = try reader["userId"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.firstJoinTime = try reader["firstJoinTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.published = try reader["published"].readIfPresent() ?? false
        value.ispName = try reader["ispName"].readIfPresent()
        value.osName = try reader["osName"].readIfPresent()
        value.osVersion = try reader["osVersion"].readIfPresent()
        value.browserName = try reader["browserName"].readIfPresent()
        value.browserVersion = try reader["browserVersion"].readIfPresent()
        value.sdkVersion = try reader["sdkVersion"].readIfPresent()
        value.recordingS3BucketName = try reader["recordingS3BucketName"].readIfPresent()
        value.recordingS3Prefix = try reader["recordingS3Prefix"].readIfPresent()
        value.recordingState = try reader["recordingState"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        return value
    }
}

extension IVSRealTimeClientTypes.PublicKey {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.PublicKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.PublicKey()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.publicKeyMaterial = try reader["publicKeyMaterial"].readIfPresent()
        value.fingerprint = try reader["fingerprint"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IVSRealTimeClientTypes.StageSession {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.StageSession {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.StageSession()
        value.sessionId = try reader["sessionId"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension IVSRealTimeClientTypes.CompositionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.CompositionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.CompositionSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.stageArn = try reader["stageArn"].readIfPresent() ?? ""
        value.destinations = try reader["destinations"].readListIfPresent(memberReadingClosure: IVSRealTimeClientTypes.DestinationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension IVSRealTimeClientTypes.DestinationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.DestinationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.DestinationSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension IVSRealTimeClientTypes.EncoderConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.EncoderConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.EncoderConfigurationSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IVSRealTimeClientTypes.IngestConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.IngestConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.IngestConfigurationSummary()
        value.name = try reader["name"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.ingestProtocol = try reader["ingestProtocol"].readIfPresent() ?? .sdkUnknown("")
        value.stageArn = try reader["stageArn"].readIfPresent() ?? ""
        value.participantId = try reader["participantId"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.userId = try reader["userId"].readIfPresent()
        return value
    }
}

extension IVSRealTimeClientTypes.Event {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.Event {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.Event()
        value.name = try reader["name"].readIfPresent()
        value.participantId = try reader["participantId"].readIfPresent()
        value.eventTime = try reader["eventTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.remoteParticipantId = try reader["remoteParticipantId"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        return value
    }
}

extension IVSRealTimeClientTypes.ParticipantSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.ParticipantSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.ParticipantSummary()
        value.participantId = try reader["participantId"].readIfPresent()
        value.userId = try reader["userId"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.firstJoinTime = try reader["firstJoinTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.published = try reader["published"].readIfPresent() ?? false
        value.recordingState = try reader["recordingState"].readIfPresent()
        return value
    }
}

extension IVSRealTimeClientTypes.PublicKeySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.PublicKeySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.PublicKeySummary()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IVSRealTimeClientTypes.StageSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.StageSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.StageSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.activeSessionId = try reader["activeSessionId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IVSRealTimeClientTypes.StageSessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.StageSessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.StageSessionSummary()
        value.sessionId = try reader["sessionId"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension IVSRealTimeClientTypes.StorageConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IVSRealTimeClientTypes.StorageConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IVSRealTimeClientTypes.StorageConfigurationSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.s3 = try reader["s3"].readIfPresent(with: IVSRealTimeClientTypes.S3StorageConfiguration.read(from:))
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IVSRealTimeClientTypes.ParticipantTokenConfiguration {

    static func write(value: IVSRealTimeClientTypes.ParticipantTokenConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["capabilities"].writeList(value.capabilities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<IVSRealTimeClientTypes.ParticipantTokenCapability>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["duration"].write(value.duration)
        try writer["userId"].write(value.userId)
    }
}

public enum IVSRealTimeClientTypes {}
