//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension DeviceFarmClient {
    /// Paginate over `[GetOfferingStatusOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetOfferingStatusInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetOfferingStatusOutput`
    public func getOfferingStatusPaginated(input: GetOfferingStatusInput) -> ClientRuntime.PaginatorSequence<GetOfferingStatusInput, GetOfferingStatusOutput> {
        return ClientRuntime.PaginatorSequence<GetOfferingStatusInput, GetOfferingStatusOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getOfferingStatus(input:))
    }
}

extension GetOfferingStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetOfferingStatusInput {
        return GetOfferingStatusInput(
            nextToken: token
        )}
}
extension DeviceFarmClient {
    /// Paginate over `[ListArtifactsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListArtifactsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListArtifactsOutput`
    public func listArtifactsPaginated(input: ListArtifactsInput) -> ClientRuntime.PaginatorSequence<ListArtifactsInput, ListArtifactsOutput> {
        return ClientRuntime.PaginatorSequence<ListArtifactsInput, ListArtifactsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listArtifacts(input:))
    }
}

extension ListArtifactsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListArtifactsInput {
        return ListArtifactsInput(
            arn: self.arn,
            nextToken: token,
            type: self.type
        )}
}

extension PaginatorSequence where OperationStackInput == ListArtifactsInput, OperationStackOutput == ListArtifactsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listArtifactsPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Artifact]`
    /// - Returns: `[DeviceFarmClientTypes.Artifact]`
    public func artifacts() async throws -> [DeviceFarmClientTypes.Artifact] {
        return try await self.asyncCompactMap { item in item.artifacts }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListDevicePoolsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDevicePoolsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDevicePoolsOutput`
    public func listDevicePoolsPaginated(input: ListDevicePoolsInput) -> ClientRuntime.PaginatorSequence<ListDevicePoolsInput, ListDevicePoolsOutput> {
        return ClientRuntime.PaginatorSequence<ListDevicePoolsInput, ListDevicePoolsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDevicePools(input:))
    }
}

extension ListDevicePoolsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDevicePoolsInput {
        return ListDevicePoolsInput(
            arn: self.arn,
            nextToken: token,
            type: self.type
        )}
}

extension PaginatorSequence where OperationStackInput == ListDevicePoolsInput, OperationStackOutput == ListDevicePoolsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDevicePoolsPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.DevicePool]`
    /// - Returns: `[DeviceFarmClientTypes.DevicePool]`
    public func devicePools() async throws -> [DeviceFarmClientTypes.DevicePool] {
        return try await self.asyncCompactMap { item in item.devicePools }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListDevicesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDevicesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDevicesOutput`
    public func listDevicesPaginated(input: ListDevicesInput) -> ClientRuntime.PaginatorSequence<ListDevicesInput, ListDevicesOutput> {
        return ClientRuntime.PaginatorSequence<ListDevicesInput, ListDevicesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDevices(input:))
    }
}

extension ListDevicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDevicesInput {
        return ListDevicesInput(
            arn: self.arn,
            filters: self.filters,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDevicesInput, OperationStackOutput == ListDevicesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDevicesPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Device]`
    /// - Returns: `[DeviceFarmClientTypes.Device]`
    public func devices() async throws -> [DeviceFarmClientTypes.Device] {
        return try await self.asyncCompactMap { item in item.devices }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListJobsOutput`
    public func listJobsPaginated(input: ListJobsInput) -> ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listJobs(input:))
    }
}

extension ListJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListJobsInput {
        return ListJobsInput(
            arn: self.arn,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListJobsInput, OperationStackOutput == ListJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listJobsPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Job]`
    /// - Returns: `[DeviceFarmClientTypes.Job]`
    public func jobs() async throws -> [DeviceFarmClientTypes.Job] {
        return try await self.asyncCompactMap { item in item.jobs }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListOfferingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOfferingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOfferingsOutput`
    public func listOfferingsPaginated(input: ListOfferingsInput) -> ClientRuntime.PaginatorSequence<ListOfferingsInput, ListOfferingsOutput> {
        return ClientRuntime.PaginatorSequence<ListOfferingsInput, ListOfferingsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listOfferings(input:))
    }
}

extension ListOfferingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOfferingsInput {
        return ListOfferingsInput(
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListOfferingsInput, OperationStackOutput == ListOfferingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOfferingsPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Offering]`
    /// - Returns: `[DeviceFarmClientTypes.Offering]`
    public func offerings() async throws -> [DeviceFarmClientTypes.Offering] {
        return try await self.asyncCompactMap { item in item.offerings }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListOfferingTransactionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOfferingTransactionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOfferingTransactionsOutput`
    public func listOfferingTransactionsPaginated(input: ListOfferingTransactionsInput) -> ClientRuntime.PaginatorSequence<ListOfferingTransactionsInput, ListOfferingTransactionsOutput> {
        return ClientRuntime.PaginatorSequence<ListOfferingTransactionsInput, ListOfferingTransactionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listOfferingTransactions(input:))
    }
}

extension ListOfferingTransactionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOfferingTransactionsInput {
        return ListOfferingTransactionsInput(
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListOfferingTransactionsInput, OperationStackOutput == ListOfferingTransactionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOfferingTransactionsPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.OfferingTransaction]`
    /// - Returns: `[DeviceFarmClientTypes.OfferingTransaction]`
    public func offeringTransactions() async throws -> [DeviceFarmClientTypes.OfferingTransaction] {
        return try await self.asyncCompactMap { item in item.offeringTransactions }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListProjectsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProjectsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProjectsOutput`
    public func listProjectsPaginated(input: ListProjectsInput) -> ClientRuntime.PaginatorSequence<ListProjectsInput, ListProjectsOutput> {
        return ClientRuntime.PaginatorSequence<ListProjectsInput, ListProjectsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listProjects(input:))
    }
}

extension ListProjectsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProjectsInput {
        return ListProjectsInput(
            arn: self.arn,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListProjectsInput, OperationStackOutput == ListProjectsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listProjectsPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Project]`
    /// - Returns: `[DeviceFarmClientTypes.Project]`
    public func projects() async throws -> [DeviceFarmClientTypes.Project] {
        return try await self.asyncCompactMap { item in item.projects }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRunsOutput`
    public func listRunsPaginated(input: ListRunsInput) -> ClientRuntime.PaginatorSequence<ListRunsInput, ListRunsOutput> {
        return ClientRuntime.PaginatorSequence<ListRunsInput, ListRunsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRuns(input:))
    }
}

extension ListRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRunsInput {
        return ListRunsInput(
            arn: self.arn,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListRunsInput, OperationStackOutput == ListRunsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRunsPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Run]`
    /// - Returns: `[DeviceFarmClientTypes.Run]`
    public func runs() async throws -> [DeviceFarmClientTypes.Run] {
        return try await self.asyncCompactMap { item in item.runs }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListSamplesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSamplesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSamplesOutput`
    public func listSamplesPaginated(input: ListSamplesInput) -> ClientRuntime.PaginatorSequence<ListSamplesInput, ListSamplesOutput> {
        return ClientRuntime.PaginatorSequence<ListSamplesInput, ListSamplesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSamples(input:))
    }
}

extension ListSamplesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSamplesInput {
        return ListSamplesInput(
            arn: self.arn,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListSamplesInput, OperationStackOutput == ListSamplesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSamplesPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Sample]`
    /// - Returns: `[DeviceFarmClientTypes.Sample]`
    public func samples() async throws -> [DeviceFarmClientTypes.Sample] {
        return try await self.asyncCompactMap { item in item.samples }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListSuitesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSuitesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSuitesOutput`
    public func listSuitesPaginated(input: ListSuitesInput) -> ClientRuntime.PaginatorSequence<ListSuitesInput, ListSuitesOutput> {
        return ClientRuntime.PaginatorSequence<ListSuitesInput, ListSuitesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSuites(input:))
    }
}

extension ListSuitesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSuitesInput {
        return ListSuitesInput(
            arn: self.arn,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListSuitesInput, OperationStackOutput == ListSuitesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSuitesPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Suite]`
    /// - Returns: `[DeviceFarmClientTypes.Suite]`
    public func suites() async throws -> [DeviceFarmClientTypes.Suite] {
        return try await self.asyncCompactMap { item in item.suites }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListTestGridProjectsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTestGridProjectsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTestGridProjectsOutput`
    public func listTestGridProjectsPaginated(input: ListTestGridProjectsInput) -> ClientRuntime.PaginatorSequence<ListTestGridProjectsInput, ListTestGridProjectsOutput> {
        return ClientRuntime.PaginatorSequence<ListTestGridProjectsInput, ListTestGridProjectsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTestGridProjects(input:))
    }
}

extension ListTestGridProjectsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTestGridProjectsInput {
        return ListTestGridProjectsInput(
            maxResult: self.maxResult,
            nextToken: token
        )}
}
extension DeviceFarmClient {
    /// Paginate over `[ListTestGridSessionActionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTestGridSessionActionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTestGridSessionActionsOutput`
    public func listTestGridSessionActionsPaginated(input: ListTestGridSessionActionsInput) -> ClientRuntime.PaginatorSequence<ListTestGridSessionActionsInput, ListTestGridSessionActionsOutput> {
        return ClientRuntime.PaginatorSequence<ListTestGridSessionActionsInput, ListTestGridSessionActionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTestGridSessionActions(input:))
    }
}

extension ListTestGridSessionActionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTestGridSessionActionsInput {
        return ListTestGridSessionActionsInput(
            maxResult: self.maxResult,
            nextToken: token,
            sessionArn: self.sessionArn
        )}
}
extension DeviceFarmClient {
    /// Paginate over `[ListTestGridSessionArtifactsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTestGridSessionArtifactsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTestGridSessionArtifactsOutput`
    public func listTestGridSessionArtifactsPaginated(input: ListTestGridSessionArtifactsInput) -> ClientRuntime.PaginatorSequence<ListTestGridSessionArtifactsInput, ListTestGridSessionArtifactsOutput> {
        return ClientRuntime.PaginatorSequence<ListTestGridSessionArtifactsInput, ListTestGridSessionArtifactsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTestGridSessionArtifacts(input:))
    }
}

extension ListTestGridSessionArtifactsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTestGridSessionArtifactsInput {
        return ListTestGridSessionArtifactsInput(
            maxResult: self.maxResult,
            nextToken: token,
            sessionArn: self.sessionArn,
            type: self.type
        )}
}
extension DeviceFarmClient {
    /// Paginate over `[ListTestGridSessionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTestGridSessionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTestGridSessionsOutput`
    public func listTestGridSessionsPaginated(input: ListTestGridSessionsInput) -> ClientRuntime.PaginatorSequence<ListTestGridSessionsInput, ListTestGridSessionsOutput> {
        return ClientRuntime.PaginatorSequence<ListTestGridSessionsInput, ListTestGridSessionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTestGridSessions(input:))
    }
}

extension ListTestGridSessionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTestGridSessionsInput {
        return ListTestGridSessionsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            endTimeAfter: self.endTimeAfter,
            endTimeBefore: self.endTimeBefore,
            maxResult: self.maxResult,
            nextToken: token,
            projectArn: self.projectArn,
            status: self.status
        )}
}
extension DeviceFarmClient {
    /// Paginate over `[ListTestsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTestsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTestsOutput`
    public func listTestsPaginated(input: ListTestsInput) -> ClientRuntime.PaginatorSequence<ListTestsInput, ListTestsOutput> {
        return ClientRuntime.PaginatorSequence<ListTestsInput, ListTestsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTests(input:))
    }
}

extension ListTestsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTestsInput {
        return ListTestsInput(
            arn: self.arn,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListTestsInput, OperationStackOutput == ListTestsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTestsPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Test]`
    /// - Returns: `[DeviceFarmClientTypes.Test]`
    public func tests() async throws -> [DeviceFarmClientTypes.Test] {
        return try await self.asyncCompactMap { item in item.tests }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListUniqueProblemsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUniqueProblemsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUniqueProblemsOutput`
    public func listUniqueProblemsPaginated(input: ListUniqueProblemsInput) -> ClientRuntime.PaginatorSequence<ListUniqueProblemsInput, ListUniqueProblemsOutput> {
        return ClientRuntime.PaginatorSequence<ListUniqueProblemsInput, ListUniqueProblemsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listUniqueProblems(input:))
    }
}

extension ListUniqueProblemsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUniqueProblemsInput {
        return ListUniqueProblemsInput(
            arn: self.arn,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListUniqueProblemsInput, OperationStackOutput == ListUniqueProblemsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listUniqueProblemsPaginated`
    /// to access the nested member `[(String, [DeviceFarmClientTypes.UniqueProblem])]`
    /// - Returns: `[(String, [DeviceFarmClientTypes.UniqueProblem])]`
    public func uniqueProblems() async throws -> [(String, [DeviceFarmClientTypes.UniqueProblem])] {
        return try await self.asyncCompactMap { item in item.uniqueProblems?.map { ($0, $1) } }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListUploadsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUploadsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUploadsOutput`
    public func listUploadsPaginated(input: ListUploadsInput) -> ClientRuntime.PaginatorSequence<ListUploadsInput, ListUploadsOutput> {
        return ClientRuntime.PaginatorSequence<ListUploadsInput, ListUploadsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listUploads(input:))
    }
}

extension ListUploadsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUploadsInput {
        return ListUploadsInput(
            arn: self.arn,
            nextToken: token,
            type: self.type
        )}
}

extension PaginatorSequence where OperationStackInput == ListUploadsInput, OperationStackOutput == ListUploadsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listUploadsPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Upload]`
    /// - Returns: `[DeviceFarmClientTypes.Upload]`
    public func uploads() async throws -> [DeviceFarmClientTypes.Upload] {
        return try await self.asyncCompactMap { item in item.uploads }
    }
}
