//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension PanoramaClient {
    /// Paginate over `[ListApplicationInstanceDependenciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListApplicationInstanceDependenciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListApplicationInstanceDependenciesOutput`
    public func listApplicationInstanceDependenciesPaginated(input: ListApplicationInstanceDependenciesInput) -> ClientRuntime.PaginatorSequence<ListApplicationInstanceDependenciesInput, ListApplicationInstanceDependenciesOutput> {
        return ClientRuntime.PaginatorSequence<ListApplicationInstanceDependenciesInput, ListApplicationInstanceDependenciesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listApplicationInstanceDependencies(input:))
    }
}

extension ListApplicationInstanceDependenciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListApplicationInstanceDependenciesInput {
        return ListApplicationInstanceDependenciesInput(
            applicationInstanceId: self.applicationInstanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension PanoramaClient {
    /// Paginate over `[ListApplicationInstanceNodeInstancesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListApplicationInstanceNodeInstancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListApplicationInstanceNodeInstancesOutput`
    public func listApplicationInstanceNodeInstancesPaginated(input: ListApplicationInstanceNodeInstancesInput) -> ClientRuntime.PaginatorSequence<ListApplicationInstanceNodeInstancesInput, ListApplicationInstanceNodeInstancesOutput> {
        return ClientRuntime.PaginatorSequence<ListApplicationInstanceNodeInstancesInput, ListApplicationInstanceNodeInstancesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listApplicationInstanceNodeInstances(input:))
    }
}

extension ListApplicationInstanceNodeInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListApplicationInstanceNodeInstancesInput {
        return ListApplicationInstanceNodeInstancesInput(
            applicationInstanceId: self.applicationInstanceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension PanoramaClient {
    /// Paginate over `[ListApplicationInstancesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListApplicationInstancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListApplicationInstancesOutput`
    public func listApplicationInstancesPaginated(input: ListApplicationInstancesInput) -> ClientRuntime.PaginatorSequence<ListApplicationInstancesInput, ListApplicationInstancesOutput> {
        return ClientRuntime.PaginatorSequence<ListApplicationInstancesInput, ListApplicationInstancesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listApplicationInstances(input:))
    }
}

extension ListApplicationInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListApplicationInstancesInput {
        return ListApplicationInstancesInput(
            deviceId: self.deviceId,
            maxResults: self.maxResults,
            nextToken: token,
            statusFilter: self.statusFilter
        )}
}
extension PanoramaClient {
    /// Paginate over `[ListDevicesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDevicesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDevicesOutput`
    public func listDevicesPaginated(input: ListDevicesInput) -> ClientRuntime.PaginatorSequence<ListDevicesInput, ListDevicesOutput> {
        return ClientRuntime.PaginatorSequence<ListDevicesInput, ListDevicesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDevices(input:))
    }
}

extension ListDevicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDevicesInput {
        return ListDevicesInput(
            deviceAggregatedStatusFilter: self.deviceAggregatedStatusFilter,
            maxResults: self.maxResults,
            nameFilter: self.nameFilter,
            nextToken: token,
            sortBy: self.sortBy,
            sortOrder: self.sortOrder
        )}
}
extension PanoramaClient {
    /// Paginate over `[ListDevicesJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDevicesJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDevicesJobsOutput`
    public func listDevicesJobsPaginated(input: ListDevicesJobsInput) -> ClientRuntime.PaginatorSequence<ListDevicesJobsInput, ListDevicesJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListDevicesJobsInput, ListDevicesJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDevicesJobs(input:))
    }
}

extension ListDevicesJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDevicesJobsInput {
        return ListDevicesJobsInput(
            deviceId: self.deviceId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension PanoramaClient {
    /// Paginate over `[ListNodeFromTemplateJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListNodeFromTemplateJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListNodeFromTemplateJobsOutput`
    public func listNodeFromTemplateJobsPaginated(input: ListNodeFromTemplateJobsInput) -> ClientRuntime.PaginatorSequence<ListNodeFromTemplateJobsInput, ListNodeFromTemplateJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListNodeFromTemplateJobsInput, ListNodeFromTemplateJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listNodeFromTemplateJobs(input:))
    }
}

extension ListNodeFromTemplateJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNodeFromTemplateJobsInput {
        return ListNodeFromTemplateJobsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension PanoramaClient {
    /// Paginate over `[ListNodesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListNodesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListNodesOutput`
    public func listNodesPaginated(input: ListNodesInput) -> ClientRuntime.PaginatorSequence<ListNodesInput, ListNodesOutput> {
        return ClientRuntime.PaginatorSequence<ListNodesInput, ListNodesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listNodes(input:))
    }
}

extension ListNodesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListNodesInput {
        return ListNodesInput(
            category: self.category,
            maxResults: self.maxResults,
            nextToken: token,
            ownerAccount: self.ownerAccount,
            packageName: self.packageName,
            packageVersion: self.packageVersion,
            patchVersion: self.patchVersion
        )}
}
extension PanoramaClient {
    /// Paginate over `[ListPackageImportJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPackageImportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPackageImportJobsOutput`
    public func listPackageImportJobsPaginated(input: ListPackageImportJobsInput) -> ClientRuntime.PaginatorSequence<ListPackageImportJobsInput, ListPackageImportJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListPackageImportJobsInput, ListPackageImportJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPackageImportJobs(input:))
    }
}

extension ListPackageImportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPackageImportJobsInput {
        return ListPackageImportJobsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension PanoramaClient {
    /// Paginate over `[ListPackagesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPackagesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPackagesOutput`
    public func listPackagesPaginated(input: ListPackagesInput) -> ClientRuntime.PaginatorSequence<ListPackagesInput, ListPackagesOutput> {
        return ClientRuntime.PaginatorSequence<ListPackagesInput, ListPackagesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPackages(input:))
    }
}

extension ListPackagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPackagesInput {
        return ListPackagesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
