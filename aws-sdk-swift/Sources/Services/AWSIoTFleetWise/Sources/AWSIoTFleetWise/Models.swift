//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You don't have sufficient permission to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IoTFleetWiseClientTypes {

    public enum NodeDataType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case boolean
        case booleanArray
        case double
        case doubleArray
        case float
        case floatArray
        case int16
        case int16Array
        case int32
        case int32Array
        case int64
        case int64Array
        case int8
        case int8Array
        case string
        case stringArray
        case `struct`
        case structArray
        case uint16
        case uint16Array
        case uint32
        case uint32Array
        case uint64
        case uint64Array
        case uint8
        case uint8Array
        case unixTimestamp
        case unixTimestampArray
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeDataType] {
            return [
                .boolean,
                .booleanArray,
                .double,
                .doubleArray,
                .float,
                .floatArray,
                .int16,
                .int16Array,
                .int32,
                .int32Array,
                .int64,
                .int64Array,
                .int8,
                .int8Array,
                .string,
                .stringArray,
                .struct,
                .structArray,
                .uint16,
                .uint16Array,
                .uint32,
                .uint32Array,
                .uint64,
                .uint64Array,
                .uint8,
                .uint8Array,
                .unixTimestamp,
                .unixTimestampArray,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .booleanArray: return "BOOLEAN_ARRAY"
            case .double: return "DOUBLE"
            case .doubleArray: return "DOUBLE_ARRAY"
            case .float: return "FLOAT"
            case .floatArray: return "FLOAT_ARRAY"
            case .int16: return "INT16"
            case .int16Array: return "INT16_ARRAY"
            case .int32: return "INT32"
            case .int32Array: return "INT32_ARRAY"
            case .int64: return "INT64"
            case .int64Array: return "INT64_ARRAY"
            case .int8: return "INT8"
            case .int8Array: return "INT8_ARRAY"
            case .string: return "STRING"
            case .stringArray: return "STRING_ARRAY"
            case .struct: return "STRUCT"
            case .structArray: return "STRUCT_ARRAY"
            case .uint16: return "UINT16"
            case .uint16Array: return "UINT16_ARRAY"
            case .uint32: return "UINT32"
            case .uint32Array: return "UINT32_ARRAY"
            case .uint64: return "UINT64"
            case .uint64Array: return "UINT64_ARRAY"
            case .uint8: return "UINT8"
            case .uint8Array: return "UINT8_ARRAY"
            case .unixTimestamp: return "UNIX_TIMESTAMP"
            case .unixTimestampArray: return "UNIX_TIMESTAMP_ARRAY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// A signal that represents a vehicle device such as the engine, heater, and door locks. Data from an actuator reports the state of a certain vehicle device. Updating actuator data can change the state of a device. For example, you can turn on or off the heater by updating its actuator data.
    public struct Actuator: Swift.Sendable {
        /// A list of possible values an actuator can take.
        public var allowedValues: [Swift.String]?
        /// A specified value for the actuator.
        @available(*, deprecated, message: "assignedValue is no longer in use")
        public var assignedValue: Swift.String?
        /// A comment in addition to the description.
        public var comment: Swift.String?
        /// The specified data type of the actuator.
        /// This member is required.
        public var dataType: IoTFleetWiseClientTypes.NodeDataType?
        /// The deprecation message for the node or the branch that was moved or deleted.
        public var deprecationMessage: Swift.String?
        /// A brief description of the actuator.
        public var description: Swift.String?
        /// The fully qualified name of the actuator. For example, the fully qualified name of an actuator might be Vehicle.Front.Left.Door.Lock.
        /// This member is required.
        public var fullyQualifiedName: Swift.String?
        /// The specified possible maximum value of an actuator.
        public var max: Swift.Double?
        /// The specified possible minimum value of an actuator.
        public var min: Swift.Double?
        /// The fully qualified name of the struct node for the actuator if the data type of the actuator is Struct or StructArray. For example, the struct fully qualified name of an actuator might be Vehicle.Door.LockStruct.
        public var structFullyQualifiedName: Swift.String?
        /// The scientific unit for the actuator.
        public var unit: Swift.String?

        public init(
            allowedValues: [Swift.String]? = nil,
            assignedValue: Swift.String? = nil,
            comment: Swift.String? = nil,
            dataType: IoTFleetWiseClientTypes.NodeDataType? = nil,
            deprecationMessage: Swift.String? = nil,
            description: Swift.String? = nil,
            fullyQualifiedName: Swift.String? = nil,
            max: Swift.Double? = nil,
            min: Swift.Double? = nil,
            structFullyQualifiedName: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.assignedValue = assignedValue
            self.comment = comment
            self.dataType = dataType
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.max = max
            self.min = min
            self.structFullyQualifiedName = structFullyQualifiedName
            self.unit = unit
        }
    }
}

/// The request couldn't be completed because the server temporarily failed.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying the command.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// A service quota was exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that was exceeded.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that was exceeded.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The resource wasn't found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that wasn't found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that wasn't found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request couldn't be completed due to throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota identifier of the applied throttling rules for this request.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds to wait before retrying the command.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
        /// The code for the service that couldn't be completed due to throttling.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension IoTFleetWiseClientTypes {

    /// A validation error due to mismatch between the expected data type, length, or pattern of the parameter and the input.
    public struct ValidationExceptionField: Swift.Sendable {
        /// A message about the validation error.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the parameter field with the validation error.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension IoTFleetWiseClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The list of fields that fail to satisfy the constraints specified by an Amazon Web Services service.
        public internal(set) var fieldList: [IoTFleetWiseClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason the input failed to satisfy the constraints specified by an Amazon Web Services service.
        public internal(set) var reason: IoTFleetWiseClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [IoTFleetWiseClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: IoTFleetWiseClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct AssociateVehicleFleetInput: Swift.Sendable {
    /// The ID of a fleet.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The unique ID of the vehicle to associate with the fleet.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init(
        fleetId: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.fleetId = fleetId
        self.vehicleName = vehicleName
    }
}

public struct AssociateVehicleFleetOutput: Swift.Sendable {

    public init() { }
}

extension IoTFleetWiseClientTypes {

    /// A signal that represents static information about the vehicle, such as engine type or manufacturing date.
    public struct Attribute: Swift.Sendable {
        /// A list of possible values an attribute can be assigned.
        public var allowedValues: [Swift.String]?
        /// A specified value for the attribute.
        @available(*, deprecated, message: "assignedValue is no longer in use")
        public var assignedValue: Swift.String?
        /// A comment in addition to the description.
        public var comment: Swift.String?
        /// The specified data type of the attribute.
        /// This member is required.
        public var dataType: IoTFleetWiseClientTypes.NodeDataType?
        /// The default value of the attribute.
        public var defaultValue: Swift.String?
        /// The deprecation message for the node or the branch that was moved or deleted.
        public var deprecationMessage: Swift.String?
        /// A brief description of the attribute.
        public var description: Swift.String?
        /// The fully qualified name of the attribute. For example, the fully qualified name of an attribute might be Vehicle.Body.Engine.Type.
        /// This member is required.
        public var fullyQualifiedName: Swift.String?
        /// The specified possible maximum value of the attribute.
        public var max: Swift.Double?
        /// The specified possible minimum value of the attribute.
        public var min: Swift.Double?
        /// The scientific unit for the attribute.
        public var unit: Swift.String?

        public init(
            allowedValues: [Swift.String]? = nil,
            assignedValue: Swift.String? = nil,
            comment: Swift.String? = nil,
            dataType: IoTFleetWiseClientTypes.NodeDataType? = nil,
            defaultValue: Swift.String? = nil,
            deprecationMessage: Swift.String? = nil,
            description: Swift.String? = nil,
            fullyQualifiedName: Swift.String? = nil,
            max: Swift.Double? = nil,
            min: Swift.Double? = nil,
            unit: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.assignedValue = assignedValue
            self.comment = comment
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.max = max
            self.min = min
            self.unit = unit
        }
    }
}

extension IoTFleetWiseClientTypes {

    public enum VehicleAssociationBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createIotThing
        case validateIotThingExists
        case sdkUnknown(Swift.String)

        public static var allCases: [VehicleAssociationBehavior] {
            return [
                .createIotThing,
                .validateIotThingExists
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createIotThing: return "CreateIotThing"
            case .validateIotThingExists: return "ValidateIotThingExists"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// A set of key/value pairs that are used to manage the resource.
    public struct Tag: Swift.Sendable {
        /// The tag's key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag's value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// Information about the vehicle to create.
    public struct CreateVehicleRequestItem: Swift.Sendable {
        /// An option to create a new Amazon Web Services IoT thing when creating a vehicle, or to validate an existing thing as a vehicle.
        public var associationBehavior: IoTFleetWiseClientTypes.VehicleAssociationBehavior?
        /// Static information about a vehicle in a key-value pair. For example: "engine Type" : "v6"
        public var attributes: [Swift.String: Swift.String]?
        /// The Amazon Resource Name (ARN) of a decoder manifest associated with the vehicle to create.
        /// This member is required.
        public var decoderManifestArn: Swift.String?
        /// The ARN of the vehicle model (model manifest) to create the vehicle from.
        /// This member is required.
        public var modelManifestArn: Swift.String?
        /// Metadata which can be used to manage the vehicle.
        public var tags: [IoTFleetWiseClientTypes.Tag]?
        /// The unique ID of the vehicle to create.
        /// This member is required.
        public var vehicleName: Swift.String?

        public init(
            associationBehavior: IoTFleetWiseClientTypes.VehicleAssociationBehavior? = nil,
            attributes: [Swift.String: Swift.String]? = nil,
            decoderManifestArn: Swift.String? = nil,
            modelManifestArn: Swift.String? = nil,
            tags: [IoTFleetWiseClientTypes.Tag]? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.associationBehavior = associationBehavior
            self.attributes = attributes
            self.decoderManifestArn = decoderManifestArn
            self.modelManifestArn = modelManifestArn
            self.tags = tags
            self.vehicleName = vehicleName
        }
    }
}

public struct BatchCreateVehicleInput: Swift.Sendable {
    /// A list of information about each vehicle to create. For more information, see the API data type.
    /// This member is required.
    public var vehicles: [IoTFleetWiseClientTypes.CreateVehicleRequestItem]?

    public init(
        vehicles: [IoTFleetWiseClientTypes.CreateVehicleRequestItem]? = nil
    )
    {
        self.vehicles = vehicles
    }
}

extension IoTFleetWiseClientTypes {

    /// An HTTP error resulting from creating a vehicle.
    public struct CreateVehicleError: Swift.Sendable {
        /// An HTTP error code.
        public var code: Swift.String?
        /// A description of the HTTP error.
        public var message: Swift.String?
        /// The ID of the vehicle with the error.
        public var vehicleName: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.vehicleName = vehicleName
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// Information about a created vehicle.
    public struct CreateVehicleResponseItem: Swift.Sendable {
        /// The ARN of the created vehicle.
        public var arn: Swift.String?
        /// The ARN of a created or validated Amazon Web Services IoT thing.
        public var thingArn: Swift.String?
        /// The unique ID of the vehicle to create.
        public var vehicleName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            thingArn: Swift.String? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.thingArn = thingArn
            self.vehicleName = vehicleName
        }
    }
}

public struct BatchCreateVehicleOutput: Swift.Sendable {
    /// A list of information about creation errors, or an empty list if there aren't any errors.
    public var errors: [IoTFleetWiseClientTypes.CreateVehicleError]?
    /// A list of information about a batch of created vehicles. For more information, see the API data type.
    public var vehicles: [IoTFleetWiseClientTypes.CreateVehicleResponseItem]?

    public init(
        errors: [IoTFleetWiseClientTypes.CreateVehicleError]? = nil,
        vehicles: [IoTFleetWiseClientTypes.CreateVehicleResponseItem]? = nil
    )
    {
        self.errors = errors
        self.vehicles = vehicles
    }
}

extension IoTFleetWiseClientTypes {

    public enum UpdateMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case merge
        case overwrite
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateMode] {
            return [
                .merge,
                .overwrite
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .merge: return "Merge"
            case .overwrite: return "Overwrite"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// Information about the vehicle to update.
    public struct UpdateVehicleRequestItem: Swift.Sendable {
        /// The method the specified attributes will update the existing attributes on the vehicle. UseOverwite to replace the vehicle attributes with the specified attributes. Or use Merge to combine all attributes. This is required if attributes are present in the input.
        public var attributeUpdateMode: IoTFleetWiseClientTypes.UpdateMode?
        /// Static information about a vehicle in a key-value pair. For example: "engineType" : "1.3 L R2"
        public var attributes: [Swift.String: Swift.String]?
        /// The ARN of the signal decoder manifest associated with the vehicle to update.
        public var decoderManifestArn: Swift.String?
        /// The ARN of the vehicle model (model manifest) associated with the vehicle to update.
        public var modelManifestArn: Swift.String?
        /// The unique ID of the vehicle to update.
        /// This member is required.
        public var vehicleName: Swift.String?

        public init(
            attributeUpdateMode: IoTFleetWiseClientTypes.UpdateMode? = nil,
            attributes: [Swift.String: Swift.String]? = nil,
            decoderManifestArn: Swift.String? = nil,
            modelManifestArn: Swift.String? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.attributeUpdateMode = attributeUpdateMode
            self.attributes = attributes
            self.decoderManifestArn = decoderManifestArn
            self.modelManifestArn = modelManifestArn
            self.vehicleName = vehicleName
        }
    }
}

public struct BatchUpdateVehicleInput: Swift.Sendable {
    /// A list of information about the vehicles to update. For more information, see the API data type.
    /// This member is required.
    public var vehicles: [IoTFleetWiseClientTypes.UpdateVehicleRequestItem]?

    public init(
        vehicles: [IoTFleetWiseClientTypes.UpdateVehicleRequestItem]? = nil
    )
    {
        self.vehicles = vehicles
    }
}

extension IoTFleetWiseClientTypes {

    /// An HTTP error resulting from updating the description for a vehicle.
    public struct UpdateVehicleError: Swift.Sendable {
        /// The relevant HTTP error code (400+).
        public var code: Swift.Int
        /// A message associated with the error.
        public var message: Swift.String?
        /// The ID of the vehicle with the error.
        public var vehicleName: Swift.String?

        public init(
            code: Swift.Int = 0,
            message: Swift.String? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.vehicleName = vehicleName
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// Information about the updated vehicle.
    public struct UpdateVehicleResponseItem: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the updated vehicle.
        public var arn: Swift.String?
        /// The unique ID of the updated vehicle.
        public var vehicleName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.vehicleName = vehicleName
        }
    }
}

public struct BatchUpdateVehicleOutput: Swift.Sendable {
    /// A list of information about errors returned while updating a batch of vehicles, or, if there aren't any errors, an empty list.
    public var errors: [IoTFleetWiseClientTypes.UpdateVehicleError]?
    /// A list of information about the batch of updated vehicles. This list contains only unique IDs for the vehicles that were updated.
    public var vehicles: [IoTFleetWiseClientTypes.UpdateVehicleResponseItem]?

    public init(
        errors: [IoTFleetWiseClientTypes.UpdateVehicleError]? = nil,
        vehicles: [IoTFleetWiseClientTypes.UpdateVehicleResponseItem]? = nil
    )
    {
        self.errors = errors
        self.vehicles = vehicles
    }
}

extension IoTFleetWiseClientTypes {

    /// A group of signals that are defined in a hierarchical structure.
    public struct Branch: Swift.Sendable {
        /// A comment in addition to the description.
        public var comment: Swift.String?
        /// The deprecation message for the node or the branch that was moved or deleted.
        public var deprecationMessage: Swift.String?
        /// A brief description of the branch.
        public var description: Swift.String?
        /// The fully qualified name of the branch. For example, the fully qualified name of a branch might be Vehicle.Body.Engine.
        /// This member is required.
        public var fullyQualifiedName: Swift.String?

        public init(
            comment: Swift.String? = nil,
            deprecationMessage: Swift.String? = nil,
            description: Swift.String? = nil,
            fullyQualifiedName: Swift.String? = nil
        )
        {
            self.comment = comment
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
        }
    }
}

/// The request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resource on which there are conflicting operations.
        /// This member is required.
        public internal(set) var resource: Swift.String? = nil
        /// The type of resource on which there are conflicting operations..
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resource: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resource = resource
        self.properties.resourceType = resourceType
    }
}

extension IoTFleetWiseClientTypes {

    public enum TriggerMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case always
        case risingEdge
        case sdkUnknown(Swift.String)

        public static var allCases: [TriggerMode] {
            return [
                .always,
                .risingEdge
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .always: return "ALWAYS"
            case .risingEdge: return "RISING_EDGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// Information about a collection scheme that uses a simple logical expression to recognize what data to collect.
    public struct ConditionBasedCollectionScheme: Swift.Sendable {
        /// Specifies the version of the conditional expression language.
        public var conditionLanguageVersion: Swift.Int?
        /// The logical expression used to recognize what data to collect. For example, $variable.`Vehicle.OutsideAirTemperature` >= 105.0.
        /// This member is required.
        public var expression: Swift.String?
        /// The minimum duration of time between two triggering events to collect data, in milliseconds. If a signal changes often, you might want to collect data at a slower rate.
        public var minimumTriggerIntervalMs: Swift.Int?
        /// Whether to collect data for all triggering events (ALWAYS). Specify (RISING_EDGE), or specify only when the condition first evaluates to false. For example, triggering on "AirbagDeployed"; Users aren't interested on triggering when the airbag is already exploded; they only care about the change from not deployed => deployed.
        public var triggerMode: IoTFleetWiseClientTypes.TriggerMode?

        public init(
            conditionLanguageVersion: Swift.Int? = nil,
            expression: Swift.String? = nil,
            minimumTriggerIntervalMs: Swift.Int? = nil,
            triggerMode: IoTFleetWiseClientTypes.TriggerMode? = nil
        )
        {
            self.conditionLanguageVersion = conditionLanguageVersion
            self.expression = expression
            self.minimumTriggerIntervalMs = minimumTriggerIntervalMs
            self.triggerMode = triggerMode
        }
    }
}

extension IoTFleetWiseClientTypes.ConditionBasedCollectionScheme: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConditionBasedCollectionScheme(conditionLanguageVersion: \(Swift.String(describing: conditionLanguageVersion)), minimumTriggerIntervalMs: \(Swift.String(describing: minimumTriggerIntervalMs)), triggerMode: \(Swift.String(describing: triggerMode)), expression: \"CONTENT_REDACTED\")"}
}

extension IoTFleetWiseClientTypes {

    /// Information about a collection scheme that uses a time period to decide how often to collect data.
    public struct TimeBasedCollectionScheme: Swift.Sendable {
        /// The time period (in milliseconds) to decide how often to collect data. For example, if the time period is 60000, the Edge Agent software collects data once every minute.
        /// This member is required.
        public var periodMs: Swift.Int?

        public init(
            periodMs: Swift.Int? = nil
        )
        {
            self.periodMs = periodMs
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// Specifies what data to collect and how often or when to collect it.
    public enum CollectionScheme: Swift.Sendable {
        /// Information about a collection scheme that uses a time period to decide how often to collect data.
        case timebasedcollectionscheme(IoTFleetWiseClientTypes.TimeBasedCollectionScheme)
        /// Information about a collection scheme that uses a simple logical expression to recognize what data to collect.
        case conditionbasedcollectionscheme(IoTFleetWiseClientTypes.ConditionBasedCollectionScheme)
        case sdkUnknown(Swift.String)
    }
}

extension IoTFleetWiseClientTypes {

    public enum Compression: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case off
        case snappy
        case sdkUnknown(Swift.String)

        public static var allCases: [Compression] {
            return [
                .off,
                .snappy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .snappy: return "SNAPPY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetWiseClientTypes {

    public enum DataFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [DataFormat] {
            return [
                .json,
                .parquet
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .parquet: return "PARQUET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetWiseClientTypes {

    public enum StorageCompressionFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gzip
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageCompressionFormat] {
            return [
                .gzip,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gzip: return "GZIP"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// The Amazon S3 bucket where the Amazon Web Services IoT FleetWise campaign sends data. Amazon S3 is an object storage service that stores data as objects within buckets. For more information, see [Creating, configuring, and working with Amazon S3 buckets](https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-buckets-s3.html) in the Amazon Simple Storage Service User Guide.
    public struct S3Config: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Amazon S3 bucket.
        /// This member is required.
        public var bucketArn: Swift.String?
        /// Specify the format that files are saved in the Amazon S3 bucket. You can save files in an Apache Parquet or JSON format.
        ///
        /// * Parquet - Store data in a columnar storage file format. Parquet is optimal for fast data retrieval and can reduce costs. This option is selected by default.
        ///
        /// * JSON - Store data in a standard text-based JSON file format.
        public var dataFormat: IoTFleetWiseClientTypes.DataFormat?
        /// (Optional) Enter an S3 bucket prefix. The prefix is the string of characters after the bucket name and before the object name. You can use the prefix to organize data stored in Amazon S3 buckets. For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html) in the Amazon Simple Storage Service User Guide. By default, Amazon Web Services IoT FleetWise sets the prefix processed-data/year=YY/month=MM/date=DD/hour=HH/ (in UTC) to data it delivers to Amazon S3. You can enter a prefix to append it to this default prefix. For example, if you enter the prefix vehicles, the prefix will be vehicles/processed-data/year=YY/month=MM/date=DD/hour=HH/.
        public var `prefix`: Swift.String?
        /// By default, stored data is compressed as a .gzip file. Compressed files have a reduced file size, which can optimize the cost of data storage.
        public var storageCompressionFormat: IoTFleetWiseClientTypes.StorageCompressionFormat?

        public init(
            bucketArn: Swift.String? = nil,
            dataFormat: IoTFleetWiseClientTypes.DataFormat? = nil,
            `prefix`: Swift.String? = nil,
            storageCompressionFormat: IoTFleetWiseClientTypes.StorageCompressionFormat? = nil
        )
        {
            self.bucketArn = bucketArn
            self.dataFormat = dataFormat
            self.`prefix` = `prefix`
            self.storageCompressionFormat = storageCompressionFormat
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// The Amazon Timestream table where the Amazon Web Services IoT FleetWise campaign sends data. Timestream stores and organizes data to optimize query processing time and to reduce storage costs. For more information, see [Data modeling](https://docs.aws.amazon.com/timestream/latest/developerguide/data-modeling.html) in the Amazon Timestream Developer Guide.
    public struct TimestreamConfig: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the task execution role that grants Amazon Web Services IoT FleetWise permission to deliver data to the Amazon Timestream table.
        /// This member is required.
        public var executionRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon Timestream table.
        /// This member is required.
        public var timestreamTableArn: Swift.String?

        public init(
            executionRoleArn: Swift.String? = nil,
            timestreamTableArn: Swift.String? = nil
        )
        {
            self.executionRoleArn = executionRoleArn
            self.timestreamTableArn = timestreamTableArn
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// The destination where the Amazon Web Services IoT FleetWise campaign sends data. You can send data to be stored in Amazon S3 or Amazon Timestream.
    public enum DataDestinationConfig: Swift.Sendable {
        /// The Amazon S3 bucket where the Amazon Web Services IoT FleetWise campaign sends data.
        case s3config(IoTFleetWiseClientTypes.S3Config)
        /// The Amazon Timestream table where the campaign sends data.
        case timestreamconfig(IoTFleetWiseClientTypes.TimestreamConfig)
        case sdkUnknown(Swift.String)
    }
}

extension IoTFleetWiseClientTypes {

    public enum DiagnosticsMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case off
        case sendActiveDtcs
        case sdkUnknown(Swift.String)

        public static var allCases: [DiagnosticsMode] {
            return [
                .off,
                .sendActiveDtcs
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .sendActiveDtcs: return "SEND_ACTIVE_DTCS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// Information about a signal.
    public struct SignalInformation: Swift.Sendable {
        /// The maximum number of samples to collect.
        public var maxSampleCount: Swift.Int?
        /// The minimum duration of time (in milliseconds) between two triggering events to collect data. If a signal changes often, you might want to collect data at a slower rate.
        public var minimumSamplingIntervalMs: Swift.Int?
        /// The name of the signal.
        /// This member is required.
        public var name: Swift.String?

        public init(
            maxSampleCount: Swift.Int? = nil,
            minimumSamplingIntervalMs: Swift.Int? = nil,
            name: Swift.String? = nil
        )
        {
            self.maxSampleCount = maxSampleCount
            self.minimumSamplingIntervalMs = minimumSamplingIntervalMs
            self.name = name
        }
    }
}

extension IoTFleetWiseClientTypes {

    public enum SpoolingMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case off
        case toDisk
        case sdkUnknown(Swift.String)

        public static var allCases: [SpoolingMode] {
            return [
                .off,
                .toDisk
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .off: return "OFF"
            case .toDisk: return "TO_DISK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateCampaignInput: Swift.Sendable {
    /// The data collection scheme associated with the campaign. You can specify a scheme that collects data based on time or an event.
    /// This member is required.
    public var collectionScheme: IoTFleetWiseClientTypes.CollectionScheme?
    /// (Optional) Whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If you don't want to compress the signals, use OFF. If it's not specified, SNAPPY is used. Default: SNAPPY
    public var compression: IoTFleetWiseClientTypes.Compression?
    /// The destination where the campaign sends data. You can choose to send data to be stored in Amazon S3 or Amazon Timestream. Amazon S3 optimizes the cost of data storage and provides additional mechanisms to use vehicle data, such as data lakes, centralized data storage, data processing pipelines, and analytics. Amazon Web Services IoT FleetWise supports at-least-once file delivery to S3. Your vehicle data is stored on multiple Amazon Web Services IoT FleetWise servers for redundancy and high availability. You can use Amazon Timestream to access and analyze time series data, and Timestream to query vehicle data so that you can identify trends and patterns.
    public var dataDestinationConfigs: [IoTFleetWiseClientTypes.DataDestinationConfig]?
    /// (Optional) A list of vehicle attributes to associate with a campaign. Enrich the data with specified vehicle attributes. For example, add make and model to the campaign, and Amazon Web Services IoT FleetWise will associate the data with those attributes as dimensions in Amazon Timestream. You can then query the data against make and model. Default: An empty array
    public var dataExtraDimensions: [Swift.String]?
    /// An optional description of the campaign to help identify its purpose.
    public var description: Swift.String?
    /// (Optional) Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise. If you want to send diagnostic trouble codes, use SEND_ACTIVE_DTCS. If it's not specified, OFF is used. Default: OFF
    public var diagnosticsMode: IoTFleetWiseClientTypes.DiagnosticsMode?
    /// (Optional) The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data isn't collected after the campaign expires. Default: 253402214400 (December 31, 9999, 00:00:00 UTC)
    public var expiryTime: Foundation.Date?
    /// The name of the campaign to create.
    /// This member is required.
    public var name: Swift.String?
    /// (Optional) How long (in milliseconds) to collect raw data after a triggering event initiates the collection. If it's not specified, 0 is used. Default: 0
    public var postTriggerCollectionDuration: Swift.Int?
    /// (Optional) A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns. If it's not specified, 0 is used. Default: 0
    @available(*, deprecated, message: "priority is no longer used or needed as input")
    public var priority: Swift.Int?
    /// The Amazon Resource Name (ARN) of the signal catalog to associate with the campaign.
    /// This member is required.
    public var signalCatalogArn: Swift.String?
    /// (Optional) A list of information about signals to collect.
    public var signalsToCollect: [IoTFleetWiseClientTypes.SignalInformation]?
    /// (Optional) Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise. If you want to store collected data when a vehicle loses connection with the cloud, use TO_DISK. If it's not specified, OFF is used. Default: OFF
    public var spoolingMode: IoTFleetWiseClientTypes.SpoolingMode?
    /// (Optional) The time, in milliseconds, to deliver a campaign after it was approved. If it's not specified, 0 is used. Default: 0
    public var startTime: Foundation.Date?
    /// Metadata that can be used to manage the campaign.
    public var tags: [IoTFleetWiseClientTypes.Tag]?
    /// The ARN of the vehicle or fleet to deploy a campaign to.
    /// This member is required.
    public var targetArn: Swift.String?

    public init(
        collectionScheme: IoTFleetWiseClientTypes.CollectionScheme? = nil,
        compression: IoTFleetWiseClientTypes.Compression? = nil,
        dataDestinationConfigs: [IoTFleetWiseClientTypes.DataDestinationConfig]? = nil,
        dataExtraDimensions: [Swift.String]? = nil,
        description: Swift.String? = nil,
        diagnosticsMode: IoTFleetWiseClientTypes.DiagnosticsMode? = nil,
        expiryTime: Foundation.Date? = nil,
        name: Swift.String? = nil,
        postTriggerCollectionDuration: Swift.Int? = nil,
        priority: Swift.Int? = nil,
        signalCatalogArn: Swift.String? = nil,
        signalsToCollect: [IoTFleetWiseClientTypes.SignalInformation]? = nil,
        spoolingMode: IoTFleetWiseClientTypes.SpoolingMode? = nil,
        startTime: Foundation.Date? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.collectionScheme = collectionScheme
        self.compression = compression
        self.dataDestinationConfigs = dataDestinationConfigs
        self.dataExtraDimensions = dataExtraDimensions
        self.description = description
        self.diagnosticsMode = diagnosticsMode
        self.expiryTime = expiryTime
        self.name = name
        self.postTriggerCollectionDuration = postTriggerCollectionDuration
        self.priority = priority
        self.signalCatalogArn = signalCatalogArn
        self.signalsToCollect = signalsToCollect
        self.spoolingMode = spoolingMode
        self.startTime = startTime
        self.tags = tags
        self.targetArn = targetArn
    }
}

extension CreateCampaignInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCampaignInput(collectionScheme: \(Swift.String(describing: collectionScheme)), compression: \(Swift.String(describing: compression)), dataDestinationConfigs: \(Swift.String(describing: dataDestinationConfigs)), description: \(Swift.String(describing: description)), diagnosticsMode: \(Swift.String(describing: diagnosticsMode)), expiryTime: \(Swift.String(describing: expiryTime)), name: \(Swift.String(describing: name)), postTriggerCollectionDuration: \(Swift.String(describing: postTriggerCollectionDuration)), priority: \(Swift.String(describing: priority)), signalCatalogArn: \(Swift.String(describing: signalCatalogArn)), spoolingMode: \(Swift.String(describing: spoolingMode)), startTime: \(Swift.String(describing: startTime)), tags: \(Swift.String(describing: tags)), targetArn: \(Swift.String(describing: targetArn)), dataExtraDimensions: \"CONTENT_REDACTED\", signalsToCollect: \"CONTENT_REDACTED\")"}
}

public struct CreateCampaignOutput: Swift.Sendable {
    /// The ARN of the created campaign.
    public var arn: Swift.String?
    /// The name of the created campaign.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

public struct DeleteCampaignInput: Swift.Sendable {
    /// The name of the campaign to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteCampaignOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the deleted campaign. The ARN isnt returned if a campaign doesnt exist.
    public var arn: Swift.String?
    /// The name of the deleted campaign.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

public struct GetCampaignInput: Swift.Sendable {
    /// The name of the campaign to retrieve information about.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension IoTFleetWiseClientTypes {

    public enum CampaignStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case running
        case suspended
        case waitingForApproval
        case sdkUnknown(Swift.String)

        public static var allCases: [CampaignStatus] {
            return [
                .creating,
                .running,
                .suspended,
                .waitingForApproval
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .running: return "RUNNING"
            case .suspended: return "SUSPENDED"
            case .waitingForApproval: return "WAITING_FOR_APPROVAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetCampaignOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the campaign.
    public var arn: Swift.String?
    /// Information about the data collection scheme associated with the campaign.
    public var collectionScheme: IoTFleetWiseClientTypes.CollectionScheme?
    /// Whether to compress signals before transmitting data to Amazon Web Services IoT FleetWise. If OFF is specified, the signals aren't compressed. If it's not specified, SNAPPY is used.
    public var compression: IoTFleetWiseClientTypes.Compression?
    /// The time the campaign was created in seconds since epoch (January 1, 1970 at midnight UTC time).
    public var creationTime: Foundation.Date?
    /// The destination where the campaign sends data. You can choose to send data to be stored in Amazon S3 or Amazon Timestream. Amazon S3 optimizes the cost of data storage and provides additional mechanisms to use vehicle data, such as data lakes, centralized data storage, data processing pipelines, and analytics. You can use Amazon Timestream to access and analyze time series data, and Timestream to query vehicle data so that you can identify trends and patterns.
    public var dataDestinationConfigs: [IoTFleetWiseClientTypes.DataDestinationConfig]?
    /// A list of vehicle attributes associated with the campaign.
    public var dataExtraDimensions: [Swift.String]?
    /// The description of the campaign.
    public var description: Swift.String?
    /// Option for a vehicle to send diagnostic trouble codes to Amazon Web Services IoT FleetWise.
    public var diagnosticsMode: IoTFleetWiseClientTypes.DiagnosticsMode?
    /// The time the campaign expires, in seconds since epoch (January 1, 1970 at midnight UTC time). Vehicle data won't be collected after the campaign expires.
    public var expiryTime: Foundation.Date?
    /// The last time the campaign was modified.
    public var lastModificationTime: Foundation.Date?
    /// The name of the campaign.
    public var name: Swift.String?
    /// How long (in seconds) to collect raw data after a triggering event initiates the collection.
    public var postTriggerCollectionDuration: Swift.Int?
    /// A number indicating the priority of one campaign over another campaign for a certain vehicle or fleet. A campaign with the lowest value is deployed to vehicles before any other campaigns.
    public var priority: Swift.Int?
    /// The ARN of a signal catalog.
    public var signalCatalogArn: Swift.String?
    /// Information about a list of signals to collect data on.
    public var signalsToCollect: [IoTFleetWiseClientTypes.SignalInformation]?
    /// Whether to store collected data after a vehicle lost a connection with the cloud. After a connection is re-established, the data is automatically forwarded to Amazon Web Services IoT FleetWise.
    public var spoolingMode: IoTFleetWiseClientTypes.SpoolingMode?
    /// The time, in milliseconds, to deliver a campaign after it was approved.
    public var startTime: Foundation.Date?
    /// The state of the campaign. The status can be one of: CREATING, WAITING_FOR_APPROVAL, RUNNING, and SUSPENDED.
    public var status: IoTFleetWiseClientTypes.CampaignStatus?
    /// The ARN of the vehicle or the fleet targeted by the campaign.
    public var targetArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        collectionScheme: IoTFleetWiseClientTypes.CollectionScheme? = nil,
        compression: IoTFleetWiseClientTypes.Compression? = nil,
        creationTime: Foundation.Date? = nil,
        dataDestinationConfigs: [IoTFleetWiseClientTypes.DataDestinationConfig]? = nil,
        dataExtraDimensions: [Swift.String]? = nil,
        description: Swift.String? = nil,
        diagnosticsMode: IoTFleetWiseClientTypes.DiagnosticsMode? = nil,
        expiryTime: Foundation.Date? = nil,
        lastModificationTime: Foundation.Date? = nil,
        name: Swift.String? = nil,
        postTriggerCollectionDuration: Swift.Int? = nil,
        priority: Swift.Int? = nil,
        signalCatalogArn: Swift.String? = nil,
        signalsToCollect: [IoTFleetWiseClientTypes.SignalInformation]? = nil,
        spoolingMode: IoTFleetWiseClientTypes.SpoolingMode? = nil,
        startTime: Foundation.Date? = nil,
        status: IoTFleetWiseClientTypes.CampaignStatus? = nil,
        targetArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.collectionScheme = collectionScheme
        self.compression = compression
        self.creationTime = creationTime
        self.dataDestinationConfigs = dataDestinationConfigs
        self.dataExtraDimensions = dataExtraDimensions
        self.description = description
        self.diagnosticsMode = diagnosticsMode
        self.expiryTime = expiryTime
        self.lastModificationTime = lastModificationTime
        self.name = name
        self.postTriggerCollectionDuration = postTriggerCollectionDuration
        self.priority = priority
        self.signalCatalogArn = signalCatalogArn
        self.signalsToCollect = signalsToCollect
        self.spoolingMode = spoolingMode
        self.startTime = startTime
        self.status = status
        self.targetArn = targetArn
    }
}

extension GetCampaignOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCampaignOutput(arn: \(Swift.String(describing: arn)), collectionScheme: \(Swift.String(describing: collectionScheme)), compression: \(Swift.String(describing: compression)), creationTime: \(Swift.String(describing: creationTime)), dataDestinationConfigs: \(Swift.String(describing: dataDestinationConfigs)), description: \(Swift.String(describing: description)), diagnosticsMode: \(Swift.String(describing: diagnosticsMode)), expiryTime: \(Swift.String(describing: expiryTime)), lastModificationTime: \(Swift.String(describing: lastModificationTime)), name: \(Swift.String(describing: name)), postTriggerCollectionDuration: \(Swift.String(describing: postTriggerCollectionDuration)), priority: \(Swift.String(describing: priority)), signalCatalogArn: \(Swift.String(describing: signalCatalogArn)), spoolingMode: \(Swift.String(describing: spoolingMode)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), targetArn: \(Swift.String(describing: targetArn)), dataExtraDimensions: \"CONTENT_REDACTED\", signalsToCollect: \"CONTENT_REDACTED\")"}
}

public struct ListCampaignsInput: Swift.Sendable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?
    /// Optional parameter to filter the results by the status of each created campaign in your account. The status can be one of: CREATING, WAITING_FOR_APPROVAL, RUNNING, or SUSPENDED.
    public var status: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension IoTFleetWiseClientTypes {

    /// Information about a campaign. You can use the API operation to return this information about multiple created campaigns.
    public struct CampaignSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of a campaign.
        public var arn: Swift.String?
        /// The time the campaign was created.
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The description of the campaign.
        public var description: Swift.String?
        /// The last time the campaign was modified.
        /// This member is required.
        public var lastModificationTime: Foundation.Date?
        /// The name of a campaign.
        public var name: Swift.String?
        /// The ARN of the signal catalog associated with the campaign.
        public var signalCatalogArn: Swift.String?
        /// The state of a campaign. The status can be one of the following:
        ///
        /// * CREATING - Amazon Web Services IoT FleetWise is processing your request to create the campaign.
        ///
        /// * WAITING_FOR_APPROVAL - After a campaign is created, it enters the WAITING_FOR_APPROVAL state. To allow Amazon Web Services IoT FleetWise to deploy the campaign to the target vehicle or fleet, use the API operation to approve the campaign.
        ///
        /// * RUNNING - The campaign is active.
        ///
        /// * SUSPENDED - The campaign is suspended. To resume the campaign, use the API operation.
        public var status: IoTFleetWiseClientTypes.CampaignStatus?
        /// The ARN of a vehicle or fleet to which the campaign is deployed.
        public var targetArn: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastModificationTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            signalCatalogArn: Swift.String? = nil,
            status: IoTFleetWiseClientTypes.CampaignStatus? = nil,
            targetArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.name = name
            self.signalCatalogArn = signalCatalogArn
            self.status = status
            self.targetArn = targetArn
        }
    }
}

public struct ListCampaignsOutput: Swift.Sendable {
    /// A summary of information about each campaign.
    public var campaignSummaries: [IoTFleetWiseClientTypes.CampaignSummary]?
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        campaignSummaries: [IoTFleetWiseClientTypes.CampaignSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.campaignSummaries = campaignSummaries
        self.nextToken = nextToken
    }
}

extension IoTFleetWiseClientTypes {

    public enum UpdateCampaignAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approve
        case resume
        case suspend
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateCampaignAction] {
            return [
                .approve,
                .resume,
                .suspend,
                .update
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approve: return "APPROVE"
            case .resume: return "RESUME"
            case .suspend: return "SUSPEND"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateCampaignInput: Swift.Sendable {
    /// Specifies how to update a campaign. The action can be one of the following:
    ///
    /// * APPROVE - To approve delivering a data collection scheme to vehicles.
    ///
    /// * SUSPEND - To suspend collecting signal data. The campaign is deleted from vehicles and all vehicles in the suspended campaign will stop sending data.
    ///
    /// * RESUME - To reactivate the SUSPEND campaign. The campaign is redeployed to all vehicles and the vehicles will resume sending data.
    ///
    /// * UPDATE - To update a campaign.
    /// This member is required.
    public var action: IoTFleetWiseClientTypes.UpdateCampaignAction?
    /// A list of vehicle attributes to associate with a signal. Default: An empty array
    public var dataExtraDimensions: [Swift.String]?
    /// The description of the campaign.
    public var description: Swift.String?
    /// The name of the campaign to update.
    /// This member is required.
    public var name: Swift.String?

    public init(
        action: IoTFleetWiseClientTypes.UpdateCampaignAction? = nil,
        dataExtraDimensions: [Swift.String]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.action = action
        self.dataExtraDimensions = dataExtraDimensions
        self.description = description
        self.name = name
    }
}

extension UpdateCampaignInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateCampaignInput(action: \(Swift.String(describing: action)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), dataExtraDimensions: \"CONTENT_REDACTED\")"}
}

public struct UpdateCampaignOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the campaign.
    public var arn: Swift.String?
    /// The name of the updated campaign.
    public var name: Swift.String?
    /// The state of a campaign. The status can be one of:
    ///
    /// * CREATING - Amazon Web Services IoT FleetWise is processing your request to create the campaign.
    ///
    /// * WAITING_FOR_APPROVAL - After a campaign is created, it enters the WAITING_FOR_APPROVAL state. To allow Amazon Web Services IoT FleetWise to deploy the campaign to the target vehicle or fleet, use the API operation to approve the campaign.
    ///
    /// * RUNNING - The campaign is active.
    ///
    /// * SUSPENDED - The campaign is suspended. To resume the campaign, use the API operation.
    public var status: IoTFleetWiseClientTypes.CampaignStatus?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        status: IoTFleetWiseClientTypes.CampaignStatus? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.status = status
    }
}

extension IoTFleetWiseClientTypes {

    /// Configurations used to create a decoder manifest.
    public struct CanDbcDefinition: Swift.Sendable {
        /// A list of DBC files. You can upload only one DBC file for each network interface and specify up to five (inclusive) files in the list. The DBC file can be a maximum size of 200 MB.
        /// This member is required.
        public var canDbcFiles: [Foundation.Data]?
        /// Contains information about a network interface.
        /// This member is required.
        public var networkInterface: Swift.String?
        /// Pairs every signal specified in your vehicle model with a signal decoder.
        public var signalsMap: [Swift.String: Swift.String]?

        public init(
            canDbcFiles: [Foundation.Data]? = nil,
            networkInterface: Swift.String? = nil,
            signalsMap: [Swift.String: Swift.String]? = nil
        )
        {
            self.canDbcFiles = canDbcFiles
            self.networkInterface = networkInterface
            self.signalsMap = signalsMap
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// A single controller area network (CAN) device interface.
    public struct CanInterface: Swift.Sendable {
        /// The unique name of the interface.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the communication protocol for the interface.
        public var protocolName: Swift.String?
        /// The version of the communication protocol for the interface.
        public var protocolVersion: Swift.String?

        public init(
            name: Swift.String? = nil,
            protocolName: Swift.String? = nil,
            protocolVersion: Swift.String? = nil
        )
        {
            self.name = name
            self.protocolName = protocolName
            self.protocolVersion = protocolVersion
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// Information about a single controller area network (CAN) signal and the messages it receives and transmits.
    public struct CanSignal: Swift.Sendable {
        /// A multiplier used to decode the CAN message.
        /// This member is required.
        public var factor: Swift.Double?
        /// Whether the byte ordering of a CAN message is big-endian.
        /// This member is required.
        public var isBigEndian: Swift.Bool
        /// Whether the message data is specified as a signed value.
        /// This member is required.
        public var isSigned: Swift.Bool
        /// How many bytes of data are in the message.
        /// This member is required.
        public var length: Swift.Int
        /// The ID of the message.
        /// This member is required.
        public var messageId: Swift.Int
        /// The name of the signal.
        public var name: Swift.String?
        /// The offset used to calculate the signal value. Combined with factor, the calculation is value = raw_value * factor + offset.
        /// This member is required.
        public var offset: Swift.Double?
        /// Indicates the beginning of the CAN signal. This should always be the least significant bit (LSB). This value might be different from the value in a DBC file. For little endian signals, startBit is the same value as in the DBC file. For big endian signals in a DBC file, the start bit is the most significant bit (MSB). You will have to calculate the LSB instead and pass it as the startBit.
        /// This member is required.
        public var startBit: Swift.Int

        public init(
            factor: Swift.Double? = nil,
            isBigEndian: Swift.Bool = false,
            isSigned: Swift.Bool = false,
            length: Swift.Int = 0,
            messageId: Swift.Int = 0,
            name: Swift.String? = nil,
            offset: Swift.Double? = nil,
            startBit: Swift.Int = 0
        )
        {
            self.factor = factor
            self.isBigEndian = isBigEndian
            self.isSigned = isSigned
            self.length = length
            self.messageId = messageId
            self.name = name
            self.offset = offset
            self.startBit = startBit
        }
    }
}

extension IoTFleetWiseClientTypes {

    public enum LogType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [LogType] {
            return [
                .error,
                .off
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// The log delivery option to send data to Amazon CloudWatch Logs.
    public struct CloudWatchLogDeliveryOptions: Swift.Sendable {
        /// The Amazon CloudWatch Logs group the operation sends data to.
        public var logGroupName: Swift.String?
        /// The type of log to send data to Amazon CloudWatch Logs.
        /// This member is required.
        public var logType: IoTFleetWiseClientTypes.LogType?

        public init(
            logGroupName: Swift.String? = nil,
            logType: IoTFleetWiseClientTypes.LogType? = nil
        )
        {
            self.logGroupName = logGroupName
            self.logType = logType
        }
    }
}

extension IoTFleetWiseClientTypes {

    public enum NetworkInterfaceFailureReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canNetworkInterfaceInfoIsNull
        case conflictingNetworkInterface
        case duplicateInterface
        case networkInterfaceToAddAlreadyExists
        case networkInterfaceToRemoveAssociatedWithSignals
        case obdNetworkInterfaceInfoIsNull
        case vehicleMiddlewareNetworkInterfaceInfoIsNull
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkInterfaceFailureReason] {
            return [
                .canNetworkInterfaceInfoIsNull,
                .conflictingNetworkInterface,
                .duplicateInterface,
                .networkInterfaceToAddAlreadyExists,
                .networkInterfaceToRemoveAssociatedWithSignals,
                .obdNetworkInterfaceInfoIsNull,
                .vehicleMiddlewareNetworkInterfaceInfoIsNull
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canNetworkInterfaceInfoIsNull: return "CAN_NETWORK_INTERFACE_INFO_IS_NULL"
            case .conflictingNetworkInterface: return "CONFLICTING_NETWORK_INTERFACE"
            case .duplicateInterface: return "DUPLICATE_NETWORK_INTERFACE"
            case .networkInterfaceToAddAlreadyExists: return "NETWORK_INTERFACE_TO_ADD_ALREADY_EXISTS"
            case .networkInterfaceToRemoveAssociatedWithSignals: return "NETWORK_INTERFACE_TO_REMOVE_ASSOCIATED_WITH_SIGNALS"
            case .obdNetworkInterfaceInfoIsNull: return "OBD_NETWORK_INTERFACE_INFO_IS_NULL"
            case .vehicleMiddlewareNetworkInterfaceInfoIsNull: return "VEHICLE_MIDDLEWARE_NETWORK_INTERFACE_INFO_IS_NULL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// A reason a vehicle network interface isn't valid.
    public struct InvalidNetworkInterface: Swift.Sendable {
        /// The ID of the interface that isn't valid.
        public var interfaceId: Swift.String?
        /// A message about why the interface isn't valid.
        public var reason: IoTFleetWiseClientTypes.NetworkInterfaceFailureReason?

        public init(
            interfaceId: Swift.String? = nil,
            reason: IoTFleetWiseClientTypes.NetworkInterfaceFailureReason? = nil
        )
        {
            self.interfaceId = interfaceId
            self.reason = reason
        }
    }
}

extension IoTFleetWiseClientTypes {

    public enum SignalDecoderFailureReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canSignalInfoIsNull
        case conflictingSignal
        case duplicateSignal
        case emptyMessageSignal
        case messageSignalInfoIsNull
        case networkInterfaceTypeIncompatibleWithSignalDecoderType
        case noDecoderInfoForSignalInModel
        case noSignalInCatalogForDecoderSignal
        case obdSignalInfoIsNull
        case signalDecoderIncompatibleWithSignalCatalog
        case signalDecoderTypeIncompatibleWithMessageSignalType
        case signalNotAssociatedWithNetworkInterface
        case signalNotInModel
        case signalToAddAlreadyExists
        case structSizeMismatch
        case sdkUnknown(Swift.String)

        public static var allCases: [SignalDecoderFailureReason] {
            return [
                .canSignalInfoIsNull,
                .conflictingSignal,
                .duplicateSignal,
                .emptyMessageSignal,
                .messageSignalInfoIsNull,
                .networkInterfaceTypeIncompatibleWithSignalDecoderType,
                .noDecoderInfoForSignalInModel,
                .noSignalInCatalogForDecoderSignal,
                .obdSignalInfoIsNull,
                .signalDecoderIncompatibleWithSignalCatalog,
                .signalDecoderTypeIncompatibleWithMessageSignalType,
                .signalNotAssociatedWithNetworkInterface,
                .signalNotInModel,
                .signalToAddAlreadyExists,
                .structSizeMismatch
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canSignalInfoIsNull: return "CAN_SIGNAL_INFO_IS_NULL"
            case .conflictingSignal: return "CONFLICTING_SIGNAL"
            case .duplicateSignal: return "DUPLICATE_SIGNAL"
            case .emptyMessageSignal: return "EMPTY_MESSAGE_SIGNAL"
            case .messageSignalInfoIsNull: return "MESSAGE_SIGNAL_INFO_IS_NULL"
            case .networkInterfaceTypeIncompatibleWithSignalDecoderType: return "NETWORK_INTERFACE_TYPE_INCOMPATIBLE_WITH_SIGNAL_DECODER_TYPE"
            case .noDecoderInfoForSignalInModel: return "NO_DECODER_INFO_FOR_SIGNAL_IN_MODEL"
            case .noSignalInCatalogForDecoderSignal: return "NO_SIGNAL_IN_CATALOG_FOR_DECODER_SIGNAL"
            case .obdSignalInfoIsNull: return "OBD_SIGNAL_INFO_IS_NULL"
            case .signalDecoderIncompatibleWithSignalCatalog: return "SIGNAL_DECODER_INCOMPATIBLE_WITH_SIGNAL_CATALOG"
            case .signalDecoderTypeIncompatibleWithMessageSignalType: return "SIGNAL_DECODER_TYPE_INCOMPATIBLE_WITH_MESSAGE_SIGNAL_TYPE"
            case .signalNotAssociatedWithNetworkInterface: return "SIGNAL_NOT_ASSOCIATED_WITH_NETWORK_INTERFACE"
            case .signalNotInModel: return "SIGNAL_NOT_IN_MODEL"
            case .signalToAddAlreadyExists: return "SIGNAL_TO_ADD_ALREADY_EXISTS"
            case .structSizeMismatch: return "STRUCT_SIZE_MISMATCH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// A reason that a signal decoder isn't valid.
    public struct InvalidSignalDecoder: Swift.Sendable {
        /// The possible cause for the invalid signal decoder.
        public var hint: Swift.String?
        /// The name of a signal decoder that isn't valid.
        public var name: Swift.String?
        /// A message about why the signal decoder isn't valid.
        public var reason: IoTFleetWiseClientTypes.SignalDecoderFailureReason?

        public init(
            hint: Swift.String? = nil,
            name: Swift.String? = nil,
            reason: IoTFleetWiseClientTypes.SignalDecoderFailureReason? = nil
        )
        {
            self.hint = hint
            self.name = name
            self.reason = reason
        }
    }
}

/// The request couldn't be completed because it contains signal decoders with one or more validation errors.
public struct DecoderManifestValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The request couldn't be completed because of invalid network interfaces in the request.
        public internal(set) var invalidNetworkInterfaces: [IoTFleetWiseClientTypes.InvalidNetworkInterface]? = nil
        /// The request couldn't be completed because of invalid signals in the request.
        public internal(set) var invalidSignals: [IoTFleetWiseClientTypes.InvalidSignalDecoder]? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DecoderManifestValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidNetworkInterfaces: [IoTFleetWiseClientTypes.InvalidNetworkInterface]? = nil,
        invalidSignals: [IoTFleetWiseClientTypes.InvalidSignalDecoder]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidNetworkInterfaces = invalidNetworkInterfaces
        self.properties.invalidSignals = invalidSignals
        self.properties.message = message
    }
}

extension IoTFleetWiseClientTypes {

    /// A network interface that specifies the On-board diagnostic (OBD) II network protocol.
    public struct ObdInterface: Swift.Sendable {
        /// The maximum number message requests per diagnostic trouble code per second.
        public var dtcRequestIntervalSeconds: Swift.Int
        /// Whether the vehicle has a transmission control module (TCM).
        public var hasTransmissionEcu: Swift.Bool
        /// The name of the interface.
        /// This member is required.
        public var name: Swift.String?
        /// The standard OBD II PID.
        public var obdStandard: Swift.String?
        /// The maximum number message requests per second.
        public var pidRequestIntervalSeconds: Swift.Int
        /// The ID of the message requesting vehicle data.
        /// This member is required.
        public var requestMessageId: Swift.Int
        /// Whether to use extended IDs in the message.
        public var useExtendedIds: Swift.Bool

        public init(
            dtcRequestIntervalSeconds: Swift.Int = 0,
            hasTransmissionEcu: Swift.Bool = false,
            name: Swift.String? = nil,
            obdStandard: Swift.String? = nil,
            pidRequestIntervalSeconds: Swift.Int = 0,
            requestMessageId: Swift.Int = 0,
            useExtendedIds: Swift.Bool = false
        )
        {
            self.dtcRequestIntervalSeconds = dtcRequestIntervalSeconds
            self.hasTransmissionEcu = hasTransmissionEcu
            self.name = name
            self.obdStandard = obdStandard
            self.pidRequestIntervalSeconds = pidRequestIntervalSeconds
            self.requestMessageId = requestMessageId
            self.useExtendedIds = useExtendedIds
        }
    }
}

extension IoTFleetWiseClientTypes {

    public enum NetworkInterfaceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canInterface
        case obdInterface
        case vehicleMiddleware
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkInterfaceType] {
            return [
                .canInterface,
                .obdInterface,
                .vehicleMiddleware
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canInterface: return "CAN_INTERFACE"
            case .obdInterface: return "OBD_INTERFACE"
            case .vehicleMiddleware: return "VEHICLE_MIDDLEWARE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetWiseClientTypes {

    public enum VehicleMiddlewareProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ros2
        case sdkUnknown(Swift.String)

        public static var allCases: [VehicleMiddlewareProtocol] {
            return [
                .ros2
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ros2: return "ROS_2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// The vehicle middleware defined as a type of network interface. Examples of vehicle middleware include ROS2 and SOME/IP.
    public struct VehicleMiddleware: Swift.Sendable {
        /// The name of the vehicle middleware.
        /// This member is required.
        public var name: Swift.String?
        /// The protocol name of the vehicle middleware.
        /// This member is required.
        public var protocolName: IoTFleetWiseClientTypes.VehicleMiddlewareProtocol?

        public init(
            name: Swift.String? = nil,
            protocolName: IoTFleetWiseClientTypes.VehicleMiddlewareProtocol? = nil
        )
        {
            self.name = name
            self.protocolName = protocolName
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// Represents a node and its specifications in an in-vehicle communication network. All signal decoders must be associated with a network node. To return this information about all the network interfaces specified in a decoder manifest, use the API operation.
    public struct NetworkInterface: Swift.Sendable {
        /// Information about a network interface specified by the Controller Area Network (CAN) protocol.
        public var canInterface: IoTFleetWiseClientTypes.CanInterface?
        /// The ID of the network interface.
        /// This member is required.
        public var interfaceId: Swift.String?
        /// Information about a network interface specified by the On-board diagnostic (OBD) II protocol.
        public var obdInterface: IoTFleetWiseClientTypes.ObdInterface?
        /// The network protocol for the vehicle. For example, CAN_SIGNAL specifies a protocol that defines how data is communicated between electronic control units (ECUs). OBD_SIGNAL specifies a protocol that defines how self-diagnostic data is communicated between ECUs.
        /// This member is required.
        public var type: IoTFleetWiseClientTypes.NetworkInterfaceType?
        /// The vehicle middleware defined as a type of network interface. Examples of vehicle middleware include ROS2 and SOME/IP.
        public var vehicleMiddleware: IoTFleetWiseClientTypes.VehicleMiddleware?

        public init(
            canInterface: IoTFleetWiseClientTypes.CanInterface? = nil,
            interfaceId: Swift.String? = nil,
            obdInterface: IoTFleetWiseClientTypes.ObdInterface? = nil,
            type: IoTFleetWiseClientTypes.NetworkInterfaceType? = nil,
            vehicleMiddleware: IoTFleetWiseClientTypes.VehicleMiddleware? = nil
        )
        {
            self.canInterface = canInterface
            self.interfaceId = interfaceId
            self.obdInterface = obdInterface
            self.type = type
            self.vehicleMiddleware = vehicleMiddleware
        }
    }
}

extension IoTFleetWiseClientTypes {

    public enum ROS2PrimitiveType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bool
        case byte
        case char
        case float32
        case float64
        case int16
        case int32
        case int64
        case int8
        case string
        case uint16
        case uint32
        case uint64
        case uint8
        case wstring
        case sdkUnknown(Swift.String)

        public static var allCases: [ROS2PrimitiveType] {
            return [
                .bool,
                .byte,
                .char,
                .float32,
                .float64,
                .int16,
                .int32,
                .int64,
                .int8,
                .string,
                .uint16,
                .uint32,
                .uint64,
                .uint8,
                .wstring
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bool: return "BOOL"
            case .byte: return "BYTE"
            case .char: return "CHAR"
            case .float32: return "FLOAT32"
            case .float64: return "FLOAT64"
            case .int16: return "INT16"
            case .int32: return "INT32"
            case .int64: return "INT64"
            case .int8: return "INT8"
            case .string: return "STRING"
            case .uint16: return "UINT16"
            case .uint32: return "UINT32"
            case .uint64: return "UINT64"
            case .uint8: return "UINT8"
            case .wstring: return "WSTRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// Represents a ROS 2 compliant primitive type message of the complex data structure.
    public struct ROS2PrimitiveMessageDefinition: Swift.Sendable {
        /// The offset used to calculate the signal value. Combined with scaling, the calculation is value = raw_value * scaling + offset.
        public var offset: Swift.Double?
        /// The primitive type (integer, floating point, boolean, etc.) for the ROS 2 primitive message definition.
        /// This member is required.
        public var primitiveType: IoTFleetWiseClientTypes.ROS2PrimitiveType?
        /// A multiplier used to decode the message.
        public var scaling: Swift.Double?
        /// An optional attribute specifying the upper bound for STRING and WSTRING.
        public var upperBound: Swift.Int?

        public init(
            offset: Swift.Double? = nil,
            primitiveType: IoTFleetWiseClientTypes.ROS2PrimitiveType? = nil,
            scaling: Swift.Double? = nil,
            upperBound: Swift.Int? = nil
        )
        {
            self.offset = offset
            self.primitiveType = primitiveType
            self.scaling = scaling
            self.upperBound = upperBound
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// Represents a primitive type node of the complex data structure.
    public enum PrimitiveMessageDefinition: Swift.Sendable {
        /// Information about a PrimitiveMessage using a ROS 2 compliant primitive type message of the complex data structure.
        case ros2primitivemessagedefinition(IoTFleetWiseClientTypes.ROS2PrimitiveMessageDefinition)
        case sdkUnknown(Swift.String)
    }
}

extension IoTFleetWiseClientTypes {

    public enum StructuredMessageListType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dynamicBoundedCapacity
        case dynamicUnboundedCapacity
        case fixedCapacity
        case sdkUnknown(Swift.String)

        public static var allCases: [StructuredMessageListType] {
            return [
                .dynamicBoundedCapacity,
                .dynamicUnboundedCapacity,
                .fixedCapacity
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dynamicBoundedCapacity: return "DYNAMIC_BOUNDED_CAPACITY"
            case .dynamicUnboundedCapacity: return "DYNAMIC_UNBOUNDED_CAPACITY"
            case .fixedCapacity: return "FIXED_CAPACITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// Information about signal messages using the on-board diagnostics (OBD) II protocol in a vehicle.
    public struct ObdSignal: Swift.Sendable {
        /// The number of bits to mask in a message.
        public var bitMaskLength: Swift.Int?
        /// The number of positions to shift bits in the message.
        public var bitRightShift: Swift.Int
        /// The length of a message.
        /// This member is required.
        public var byteLength: Swift.Int?
        /// The offset used to calculate the signal value. Combined with scaling, the calculation is value = raw_value * scaling + offset.
        /// This member is required.
        public var offset: Swift.Double?
        /// The diagnostic code used to request data from a vehicle for this signal.
        /// This member is required.
        public var pid: Swift.Int
        /// The length of the requested data.
        /// This member is required.
        public var pidResponseLength: Swift.Int?
        /// A multiplier used to decode the message.
        /// This member is required.
        public var scaling: Swift.Double?
        /// The mode of operation (diagnostic service) in a message.
        /// This member is required.
        public var serviceMode: Swift.Int
        /// Indicates the beginning of the message.
        /// This member is required.
        public var startByte: Swift.Int

        public init(
            bitMaskLength: Swift.Int? = nil,
            bitRightShift: Swift.Int = 0,
            byteLength: Swift.Int? = nil,
            offset: Swift.Double? = nil,
            pid: Swift.Int = 0,
            pidResponseLength: Swift.Int? = nil,
            scaling: Swift.Double? = nil,
            serviceMode: Swift.Int = 0,
            startByte: Swift.Int = 0
        )
        {
            self.bitMaskLength = bitMaskLength
            self.bitRightShift = bitRightShift
            self.byteLength = byteLength
            self.offset = offset
            self.pid = pid
            self.pidResponseLength = pidResponseLength
            self.scaling = scaling
            self.serviceMode = serviceMode
            self.startByte = startByte
        }
    }
}

extension IoTFleetWiseClientTypes {

    public enum SignalDecoderType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canSignal
        case messageSignal
        case obdSignal
        case sdkUnknown(Swift.String)

        public static var allCases: [SignalDecoderType] {
            return [
                .canSignal,
                .messageSignal,
                .obdSignal
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canSignal: return "CAN_SIGNAL"
            case .messageSignal: return "MESSAGE_SIGNAL"
            case .obdSignal: return "OBD_SIGNAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDecoderManifestOutput: Swift.Sendable {
    /// The ARN of the created decoder manifest.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the created decoder manifest.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

public struct CreateFleetInput: Swift.Sendable {
    /// A brief description of the fleet to create.
    public var description: Swift.String?
    /// The unique ID of the fleet to create.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The Amazon Resource Name (ARN) of a signal catalog.
    /// This member is required.
    public var signalCatalogArn: Swift.String?
    /// Metadata that can be used to manage the fleet.
    public var tags: [IoTFleetWiseClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        fleetId: Swift.String? = nil,
        signalCatalogArn: Swift.String? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.fleetId = fleetId
        self.signalCatalogArn = signalCatalogArn
        self.tags = tags
    }
}

public struct CreateFleetOutput: Swift.Sendable {
    /// The ARN of the created fleet.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the created fleet.
    /// This member is required.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

extension IoTFleetWiseClientTypes {

    /// A reason that a signal isn't valid.
    public struct InvalidSignal: Swift.Sendable {
        /// The name of the signal that isn't valid.
        public var name: Swift.String?
        /// A message about why the signal isn't valid.
        public var reason: Swift.String?

        public init(
            name: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.name = name
            self.reason = reason
        }
    }
}

/// The request couldn't be completed because it contains signals that aren't valid.
public struct InvalidSignalsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The signals which caused the exception.
        public internal(set) var invalidSignals: [IoTFleetWiseClientTypes.InvalidSignal]? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSignalsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidSignals: [IoTFleetWiseClientTypes.InvalidSignal]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.invalidSignals = invalidSignals
        self.properties.message = message
    }
}

public struct CreateModelManifestInput: Swift.Sendable {
    /// A brief description of the vehicle model.
    public var description: Swift.String?
    /// The name of the vehicle model to create.
    /// This member is required.
    public var name: Swift.String?
    /// A list of nodes, which are a general abstraction of signals.
    /// This member is required.
    public var nodes: [Swift.String]?
    /// The Amazon Resource Name (ARN) of a signal catalog.
    /// This member is required.
    public var signalCatalogArn: Swift.String?
    /// Metadata that can be used to manage the vehicle model.
    public var tags: [IoTFleetWiseClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        nodes: [Swift.String]? = nil,
        signalCatalogArn: Swift.String? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.nodes = nodes
        self.signalCatalogArn = signalCatalogArn
        self.tags = tags
    }
}

public struct CreateModelManifestOutput: Swift.Sendable {
    /// The ARN of the created vehicle model.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the created vehicle model.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

extension IoTFleetWiseClientTypes {

    public enum NodeDataEncoding: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case binary
        case typed
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeDataEncoding] {
            return [
                .binary,
                .typed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .binary: return "BINARY"
            case .typed: return "TYPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// Represents a member of the complex data structure. The data type of the property can be either primitive or another struct.
    public struct CustomProperty: Swift.Sendable {
        /// A comment in addition to the description.
        public var comment: Swift.String?
        /// Indicates whether the property is binary data.
        public var dataEncoding: IoTFleetWiseClientTypes.NodeDataEncoding?
        /// The data type for the custom property.
        /// This member is required.
        public var dataType: IoTFleetWiseClientTypes.NodeDataType?
        /// The deprecation message for the node or the branch that was moved or deleted.
        public var deprecationMessage: Swift.String?
        /// A brief description of the custom property.
        public var description: Swift.String?
        /// The fully qualified name of the custom property. For example, the fully qualified name of a custom property might be ComplexDataTypes.VehicleDataTypes.SVMCamera.FPS.
        /// This member is required.
        public var fullyQualifiedName: Swift.String?
        /// The fully qualified name of the struct node for the custom property if the data type of the custom property is Struct or StructArray.
        public var structFullyQualifiedName: Swift.String?

        public init(
            comment: Swift.String? = nil,
            dataEncoding: IoTFleetWiseClientTypes.NodeDataEncoding? = nil,
            dataType: IoTFleetWiseClientTypes.NodeDataType? = nil,
            deprecationMessage: Swift.String? = nil,
            description: Swift.String? = nil,
            fullyQualifiedName: Swift.String? = nil,
            structFullyQualifiedName: Swift.String? = nil
        )
        {
            self.comment = comment
            self.dataEncoding = dataEncoding
            self.dataType = dataType
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.structFullyQualifiedName = structFullyQualifiedName
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// An input component that reports the environmental condition of a vehicle. You can collect data about fluid levels, temperatures, vibrations, or battery voltage from sensors.
    public struct Sensor: Swift.Sendable {
        /// A list of possible values a sensor can take.
        public var allowedValues: [Swift.String]?
        /// A comment in addition to the description.
        public var comment: Swift.String?
        /// The specified data type of the sensor.
        /// This member is required.
        public var dataType: IoTFleetWiseClientTypes.NodeDataType?
        /// The deprecation message for the node or the branch that was moved or deleted.
        public var deprecationMessage: Swift.String?
        /// A brief description of a sensor.
        public var description: Swift.String?
        /// The fully qualified name of the sensor. For example, the fully qualified name of a sensor might be Vehicle.Body.Engine.Battery.
        /// This member is required.
        public var fullyQualifiedName: Swift.String?
        /// The specified possible maximum value of the sensor.
        public var max: Swift.Double?
        /// The specified possible minimum value of the sensor.
        public var min: Swift.Double?
        /// The fully qualified name of the struct node for a sensor if the data type of the actuator is Struct or StructArray. For example, the struct fully qualified name of a sensor might be Vehicle.ADAS.CameraStruct.
        public var structFullyQualifiedName: Swift.String?
        /// The scientific unit of measurement for data collected by the sensor.
        public var unit: Swift.String?

        public init(
            allowedValues: [Swift.String]? = nil,
            comment: Swift.String? = nil,
            dataType: IoTFleetWiseClientTypes.NodeDataType? = nil,
            deprecationMessage: Swift.String? = nil,
            description: Swift.String? = nil,
            fullyQualifiedName: Swift.String? = nil,
            max: Swift.Double? = nil,
            min: Swift.Double? = nil,
            structFullyQualifiedName: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.comment = comment
            self.dataType = dataType
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
            self.max = max
            self.min = min
            self.structFullyQualifiedName = structFullyQualifiedName
            self.unit = unit
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// The custom structure represents a complex or higher-order data structure.
    public struct CustomStruct: Swift.Sendable {
        /// A comment in addition to the description.
        public var comment: Swift.String?
        /// The deprecation message for the node or the branch that was moved or deleted.
        public var deprecationMessage: Swift.String?
        /// A brief description of the custom structure.
        public var description: Swift.String?
        /// The fully qualified name of the custom structure. For example, the fully qualified name of a custom structure might be ComplexDataTypes.VehicleDataTypes.SVMCamera.
        /// This member is required.
        public var fullyQualifiedName: Swift.String?

        public init(
            comment: Swift.String? = nil,
            deprecationMessage: Swift.String? = nil,
            description: Swift.String? = nil,
            fullyQualifiedName: Swift.String? = nil
        )
        {
            self.comment = comment
            self.deprecationMessage = deprecationMessage
            self.description = description
            self.fullyQualifiedName = fullyQualifiedName
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// A general abstraction of a signal. A node can be specified as an actuator, attribute, branch, or sensor.
    public enum Node: Swift.Sendable {
        /// Information about a node specified as a branch. A group of signals that are defined in a hierarchical structure.
        case branch(IoTFleetWiseClientTypes.Branch)
        /// An input component that reports the environmental condition of a vehicle. You can collect data about fluid levels, temperatures, vibrations, or battery voltage from sensors.
        case sensor(IoTFleetWiseClientTypes.Sensor)
        /// Information about a node specified as an actuator. An actuator is a digital representation of a vehicle device.
        case actuator(IoTFleetWiseClientTypes.Actuator)
        /// Information about a node specified as an attribute. An attribute represents static information about a vehicle.
        case attribute(IoTFleetWiseClientTypes.Attribute)
        /// Represents a complex or higher-order data structure.
        case `struct`(IoTFleetWiseClientTypes.CustomStruct)
        /// Represents a member of the complex data structure. The datatype of the property can be either primitive or another struct.
        case property(IoTFleetWiseClientTypes.CustomProperty)
        case sdkUnknown(Swift.String)
    }
}

/// The specified node type doesn't match the expected node type for a node. You can specify the node type as branch, sensor, actuator, or attribute.
public struct InvalidNodeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The specified node type isn't valid.
        public internal(set) var invalidNodes: [IoTFleetWiseClientTypes.Node]? = nil
        public internal(set) var message: Swift.String? = nil
        /// The reason the node validation failed.
        public internal(set) var reason: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNodeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        invalidNodes: [IoTFleetWiseClientTypes.Node]? = nil,
        message: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.properties.invalidNodes = invalidNodes
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct CreateSignalCatalogInput: Swift.Sendable {
    /// A brief description of the signal catalog.
    public var description: Swift.String?
    /// The name of the signal catalog to create.
    /// This member is required.
    public var name: Swift.String?
    /// A list of information about nodes, which are a general abstraction of signals. For more information, see the API data type.
    public var nodes: [IoTFleetWiseClientTypes.Node]?
    /// Metadata that can be used to manage the signal catalog.
    public var tags: [IoTFleetWiseClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        nodes: [IoTFleetWiseClientTypes.Node]? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.nodes = nodes
        self.tags = tags
    }
}

public struct CreateSignalCatalogOutput: Swift.Sendable {
    /// The ARN of the created signal catalog.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the created signal catalog.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

public struct CreateVehicleInput: Swift.Sendable {
    /// An option to create a new Amazon Web Services IoT thing when creating a vehicle, or to validate an existing Amazon Web Services IoT thing as a vehicle. Default:
    public var associationBehavior: IoTFleetWiseClientTypes.VehicleAssociationBehavior?
    /// Static information about a vehicle in a key-value pair. For example: "engineType" : "1.3 L R2" A campaign must include the keys (attribute names) in dataExtraDimensions for them to display in Amazon Timestream.
    public var attributes: [Swift.String: Swift.String]?
    /// The ARN of a decoder manifest.
    /// This member is required.
    public var decoderManifestArn: Swift.String?
    /// The Amazon Resource Name ARN of a vehicle model.
    /// This member is required.
    public var modelManifestArn: Swift.String?
    /// Metadata that can be used to manage the vehicle.
    public var tags: [IoTFleetWiseClientTypes.Tag]?
    /// The unique ID of the vehicle to create.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init(
        associationBehavior: IoTFleetWiseClientTypes.VehicleAssociationBehavior? = nil,
        attributes: [Swift.String: Swift.String]? = nil,
        decoderManifestArn: Swift.String? = nil,
        modelManifestArn: Swift.String? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.associationBehavior = associationBehavior
        self.attributes = attributes
        self.decoderManifestArn = decoderManifestArn
        self.modelManifestArn = modelManifestArn
        self.tags = tags
        self.vehicleName = vehicleName
    }
}

public struct CreateVehicleOutput: Swift.Sendable {
    /// The ARN of the created vehicle.
    public var arn: Swift.String?
    /// The ARN of a created or validated Amazon Web Services IoT thing.
    public var thingArn: Swift.String?
    /// The unique ID of the created vehicle.
    public var vehicleName: Swift.String?

    public init(
        arn: Swift.String? = nil,
        thingArn: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.thingArn = thingArn
        self.vehicleName = vehicleName
    }
}

public struct DeleteDecoderManifestInput: Swift.Sendable {
    /// The name of the decoder manifest to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteDecoderManifestOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the deleted decoder manifest.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the deleted decoder manifest.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

public struct GetDecoderManifestInput: Swift.Sendable {
    /// The name of the decoder manifest to retrieve information about.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension IoTFleetWiseClientTypes {

    public enum ManifestStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case draft
        case invalid
        case validating
        case sdkUnknown(Swift.String)

        public static var allCases: [ManifestStatus] {
            return [
                .active,
                .draft,
                .invalid,
                .validating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .draft: return "DRAFT"
            case .invalid: return "INVALID"
            case .validating: return "VALIDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetDecoderManifestOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the decoder manifest.
    /// This member is required.
    public var arn: Swift.String?
    /// The time the decoder manifest was created in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// A brief description of the decoder manifest.
    public var description: Swift.String?
    /// The time the decoder manifest was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var lastModificationTime: Foundation.Date?
    /// The detailed message for the decoder manifest. When a decoder manifest is in an INVALID status, the message contains detailed reason and help information.
    public var message: Swift.String?
    /// The ARN of a vehicle model (model manifest) associated with the decoder manifest.
    public var modelManifestArn: Swift.String?
    /// The name of the decoder manifest.
    /// This member is required.
    public var name: Swift.String?
    /// The state of the decoder manifest. If the status is ACTIVE, the decoder manifest can't be edited. If the status is marked DRAFT, you can edit the decoder manifest.
    public var status: IoTFleetWiseClientTypes.ManifestStatus?

    public init(
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        lastModificationTime: Foundation.Date? = nil,
        message: Swift.String? = nil,
        modelManifestArn: Swift.String? = nil,
        name: Swift.String? = nil,
        status: IoTFleetWiseClientTypes.ManifestStatus? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.modelManifestArn = modelManifestArn
        self.name = name
        self.status = status
    }
}

extension IoTFleetWiseClientTypes {

    /// Specifications for defining a vehicle network.
    public enum NetworkFileDefinition: Swift.Sendable {
        /// Information, including CAN DBC files, about the configurations used to create a decoder manifest.
        case candbc(IoTFleetWiseClientTypes.CanDbcDefinition)
        case sdkUnknown(Swift.String)
    }
}

public struct ImportDecoderManifestInput: Swift.Sendable {
    /// The name of the decoder manifest to import.
    /// This member is required.
    public var name: Swift.String?
    /// The file to load into an Amazon Web Services account.
    /// This member is required.
    public var networkFileDefinitions: [IoTFleetWiseClientTypes.NetworkFileDefinition]?

    public init(
        name: Swift.String? = nil,
        networkFileDefinitions: [IoTFleetWiseClientTypes.NetworkFileDefinition]? = nil
    )
    {
        self.name = name
        self.networkFileDefinitions = networkFileDefinitions
    }
}

public struct ImportDecoderManifestOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the decoder manifest that was imported.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the imported decoder manifest.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

public struct ListDecoderManifestNetworkInterfacesInput: Swift.Sendable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// The name of the decoder manifest to list information about.
    /// This member is required.
    public var name: Swift.String?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

public struct ListDecoderManifestNetworkInterfacesOutput: Swift.Sendable {
    /// A list of information about network interfaces.
    public var networkInterfaces: [IoTFleetWiseClientTypes.NetworkInterface]?
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        networkInterfaces: [IoTFleetWiseClientTypes.NetworkInterface]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkInterfaces = networkInterfaces
        self.nextToken = nextToken
    }
}

public struct ListDecoderManifestsInput: Swift.Sendable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of a vehicle model (model manifest) associated with the decoder manifest.
    public var modelManifestArn: Swift.String?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        modelManifestArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.modelManifestArn = modelManifestArn
        self.nextToken = nextToken
    }
}

extension IoTFleetWiseClientTypes {

    /// Information about a created decoder manifest. You can use the API operation to return this information about multiple decoder manifests.
    public struct DecoderManifestSummary: Swift.Sendable {
        /// The ARN of a vehicle model (model manifest) associated with the decoder manifest.
        public var arn: Swift.String?
        /// The time the decoder manifest was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// A brief description of the decoder manifest.
        public var description: Swift.String?
        /// The time the decoder manifest was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var lastModificationTime: Foundation.Date?
        /// The detailed message for the decoder manifest. When a decoder manifest is in an INVALID status, the message contains detailed reason and help information.
        public var message: Swift.String?
        /// The ARN of a vehicle model (model manifest) associated with the decoder manifest.
        public var modelManifestArn: Swift.String?
        /// The name of the decoder manifest.
        public var name: Swift.String?
        /// The state of the decoder manifest. If the status is ACTIVE, the decoder manifest can't be edited. If the status is marked DRAFT, you can edit the decoder manifest.
        public var status: IoTFleetWiseClientTypes.ManifestStatus?

        public init(
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastModificationTime: Foundation.Date? = nil,
            message: Swift.String? = nil,
            modelManifestArn: Swift.String? = nil,
            name: Swift.String? = nil,
            status: IoTFleetWiseClientTypes.ManifestStatus? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.message = message
            self.modelManifestArn = modelManifestArn
            self.name = name
            self.status = status
        }
    }
}

public struct ListDecoderManifestsOutput: Swift.Sendable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of information about each decoder manifest.
    public var summaries: [IoTFleetWiseClientTypes.DecoderManifestSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTFleetWiseClientTypes.DecoderManifestSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

public struct ListDecoderManifestSignalsInput: Swift.Sendable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// The name of the decoder manifest to list information about.
    /// This member is required.
    public var name: Swift.String?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

public struct UpdateDecoderManifestOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the updated decoder manifest.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the updated decoder manifest.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

public struct DeleteFleetInput: Swift.Sendable {
    /// The ID of the fleet to delete.
    /// This member is required.
    public var fleetId: Swift.String?

    public init(
        fleetId: Swift.String? = nil
    )
    {
        self.fleetId = fleetId
    }
}

public struct DeleteFleetOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the deleted fleet.
    public var arn: Swift.String?
    /// The ID of the deleted fleet.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

public struct DeleteModelManifestInput: Swift.Sendable {
    /// The name of the model manifest to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteModelManifestOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the deleted model manifest.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the deleted model manifest.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

public struct DeleteSignalCatalogInput: Swift.Sendable {
    /// The name of the signal catalog to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteSignalCatalogOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the deleted signal catalog.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the deleted signal catalog.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

public struct DeleteVehicleInput: Swift.Sendable {
    /// The ID of the vehicle to delete.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init(
        vehicleName: Swift.String? = nil
    )
    {
        self.vehicleName = vehicleName
    }
}

public struct DeleteVehicleOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the deleted vehicle.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the deleted vehicle.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init(
        arn: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.vehicleName = vehicleName
    }
}

public struct DisassociateVehicleFleetInput: Swift.Sendable {
    /// The unique ID of a fleet.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The unique ID of the vehicle to disassociate from the fleet.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init(
        fleetId: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.fleetId = fleetId
        self.vehicleName = vehicleName
    }
}

public struct DisassociateVehicleFleetOutput: Swift.Sendable {

    public init() { }
}

extension IoTFleetWiseClientTypes {

    public enum EncryptionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failure
        case pending
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionStatus] {
            return [
                .failure,
                .pending,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failure: return "FAILURE"
            case .pending: return "PENDING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetWiseClientTypes {

    public enum EncryptionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fleetwiseDefaultEncryption
        case kmsBasedEncryption
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .fleetwiseDefaultEncryption,
                .kmsBasedEncryption
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fleetwiseDefaultEncryption: return "FLEETWISE_DEFAULT_ENCRYPTION"
            case .kmsBasedEncryption: return "KMS_BASED_ENCRYPTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListFleetsForVehicleInput: Swift.Sendable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?
    /// The ID of the vehicle to retrieve information about.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vehicleName = vehicleName
    }
}

public struct ListFleetsForVehicleOutput: Swift.Sendable {
    /// A list of fleet IDs that the vehicle is associated with.
    public var fleets: [Swift.String]?
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        fleets: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleets = fleets
        self.nextToken = nextToken
    }
}

public struct GetFleetInput: Swift.Sendable {
    /// The ID of the fleet to retrieve information about.
    /// This member is required.
    public var fleetId: Swift.String?

    public init(
        fleetId: Swift.String? = nil
    )
    {
        self.fleetId = fleetId
    }
}

public struct GetFleetOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the fleet.
    /// This member is required.
    public var arn: Swift.String?
    /// The time the fleet was created in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// A brief description of the fleet.
    public var description: Swift.String?
    /// The ID of the fleet.
    /// This member is required.
    public var id: Swift.String?
    /// The time the fleet was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var lastModificationTime: Foundation.Date?
    /// The ARN of a signal catalog associated with the fleet.
    /// This member is required.
    public var signalCatalogArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        lastModificationTime: Foundation.Date? = nil,
        signalCatalogArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.lastModificationTime = lastModificationTime
        self.signalCatalogArn = signalCatalogArn
    }
}

public struct ListFleetsInput: Swift.Sendable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTFleetWiseClientTypes {

    /// Information about a fleet. You can use the API operation to return this information about multiple fleets.
    public struct FleetSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the fleet.
        /// This member is required.
        public var arn: Swift.String?
        /// The time the fleet was created, in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// A brief description of the fleet.
        public var description: Swift.String?
        /// The unique ID of the fleet.
        /// This member is required.
        public var id: Swift.String?
        /// The time the fleet was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public var lastModificationTime: Foundation.Date?
        /// The ARN of the signal catalog associated with the fleet.
        /// This member is required.
        public var signalCatalogArn: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastModificationTime: Foundation.Date? = nil,
            signalCatalogArn: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.lastModificationTime = lastModificationTime
            self.signalCatalogArn = signalCatalogArn
        }
    }
}

public struct ListFleetsOutput: Swift.Sendable {
    /// A list of information for each fleet.
    public var fleetSummaries: [IoTFleetWiseClientTypes.FleetSummary]?
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        fleetSummaries: [IoTFleetWiseClientTypes.FleetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetSummaries = fleetSummaries
        self.nextToken = nextToken
    }
}

public struct UpdateFleetInput: Swift.Sendable {
    /// An updated description of the fleet.
    public var description: Swift.String?
    /// The ID of the fleet to update.
    /// This member is required.
    public var fleetId: Swift.String?

    public init(
        description: Swift.String? = nil,
        fleetId: Swift.String? = nil
    )
    {
        self.description = description
        self.fleetId = fleetId
    }
}

public struct UpdateFleetOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the updated fleet.
    public var arn: Swift.String?
    /// The ID of the updated fleet.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

public struct ListVehiclesInFleetInput: Swift.Sendable {
    /// The ID of a fleet.
    /// This member is required.
    public var fleetId: Swift.String?
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        fleetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetId = fleetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListVehiclesInFleetOutput: Swift.Sendable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of vehicles associated with the fleet.
    public var vehicles: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        vehicles: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.vehicles = vehicles
    }
}

extension IoTFleetWiseClientTypes {

    /// [Vehicle Signal Specification (VSS)](https://www.w3.org/auto/wg/wiki/Vehicle_Signal_Specification_(VSS)/Vehicle_Data_Spec) is a precise language used to describe and model signals in vehicle networks. The JSON file collects signal specificiations in a VSS format.
    public enum FormattedVss: Swift.Sendable {
        /// Provides the VSS in JSON format.
        case vssjson(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

public struct GetEncryptionConfigurationInput: Swift.Sendable {

    public init() { }
}

public struct GetEncryptionConfigurationOutput: Swift.Sendable {
    /// The time when encryption was configured in seconds since epoch (January 1, 1970 at midnight UTC time).
    public var creationTime: Foundation.Date?
    /// The encryption status.
    /// This member is required.
    public var encryptionStatus: IoTFleetWiseClientTypes.EncryptionStatus?
    /// The type of encryption. Set to KMS_BASED_ENCRYPTION to use a KMS key that you own and manage. Set to FLEETWISE_DEFAULT_ENCRYPTION to use an Amazon Web Services managed key that is owned by the Amazon Web Services IoT FleetWise service account.
    /// This member is required.
    public var encryptionType: IoTFleetWiseClientTypes.EncryptionType?
    /// The error message that describes why encryption settings couldn't be configured, if applicable.
    public var errorMessage: Swift.String?
    /// The ID of the KMS key that is used for encryption.
    public var kmsKeyId: Swift.String?
    /// The time when encryption was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
    public var lastModificationTime: Foundation.Date?

    public init(
        creationTime: Foundation.Date? = nil,
        encryptionStatus: IoTFleetWiseClientTypes.EncryptionStatus? = nil,
        encryptionType: IoTFleetWiseClientTypes.EncryptionType? = nil,
        errorMessage: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        lastModificationTime: Foundation.Date? = nil
    )
    {
        self.creationTime = creationTime
        self.encryptionStatus = encryptionStatus
        self.encryptionType = encryptionType
        self.errorMessage = errorMessage
        self.kmsKeyId = kmsKeyId
        self.lastModificationTime = lastModificationTime
    }
}

public struct GetLoggingOptionsInput: Swift.Sendable {

    public init() { }
}

public struct GetLoggingOptionsOutput: Swift.Sendable {
    /// Returns information about log delivery to Amazon CloudWatch Logs.
    /// This member is required.
    public var cloudWatchLogDelivery: IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions?

    public init(
        cloudWatchLogDelivery: IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions? = nil
    )
    {
        self.cloudWatchLogDelivery = cloudWatchLogDelivery
    }
}

public struct GetModelManifestInput: Swift.Sendable {
    /// The name of the vehicle model to retrieve information about.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct GetModelManifestOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the vehicle model.
    /// This member is required.
    public var arn: Swift.String?
    /// The time the vehicle model was created, in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// A brief description of the vehicle model.
    public var description: Swift.String?
    /// The last time the vehicle model was modified.
    /// This member is required.
    public var lastModificationTime: Foundation.Date?
    /// The name of the vehicle model.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the signal catalog associated with the vehicle model.
    public var signalCatalogArn: Swift.String?
    /// The state of the vehicle model. If the status is ACTIVE, the vehicle model can't be edited. You can edit the vehicle model if the status is marked DRAFT.
    public var status: IoTFleetWiseClientTypes.ManifestStatus?

    public init(
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        lastModificationTime: Foundation.Date? = nil,
        name: Swift.String? = nil,
        signalCatalogArn: Swift.String? = nil,
        status: IoTFleetWiseClientTypes.ManifestStatus? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.lastModificationTime = lastModificationTime
        self.name = name
        self.signalCatalogArn = signalCatalogArn
        self.status = status
    }
}

public struct GetRegisterAccountStatusInput: Swift.Sendable {

    public init() { }
}

extension IoTFleetWiseClientTypes {

    public enum RegistrationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case registrationFailure
        case registrationPending
        case registrationSuccess
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationStatus] {
            return [
                .registrationFailure,
                .registrationPending,
                .registrationSuccess
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .registrationFailure: return "REGISTRATION_FAILURE"
            case .registrationPending: return "REGISTRATION_PENDING"
            case .registrationSuccess: return "REGISTRATION_SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// Information about registering an Identity and Access Management (IAM) resource so Amazon Web Services IoT FleetWise edge agent software can transfer your vehicle data to Amazon Timestream.
    public struct IamRegistrationResponse: Swift.Sendable {
        /// A message associated with a registration error.
        public var errorMessage: Swift.String?
        /// The status of registering your IAM resource. The status can be one of REGISTRATION_SUCCESS, REGISTRATION_PENDING, REGISTRATION_FAILURE.
        /// This member is required.
        public var registrationStatus: IoTFleetWiseClientTypes.RegistrationStatus?
        /// The Amazon Resource Name (ARN) of the IAM role to register.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            errorMessage: Swift.String? = nil,
            registrationStatus: IoTFleetWiseClientTypes.RegistrationStatus? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
            self.registrationStatus = registrationStatus
            self.roleArn = roleArn
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// Information about the registered Amazon Timestream resources or errors, if any.
    public struct TimestreamRegistrationResponse: Swift.Sendable {
        /// A message associated with a registration error.
        public var errorMessage: Swift.String?
        /// The status of registering your Amazon Timestream resources. The status can be one of REGISTRATION_SUCCESS, REGISTRATION_PENDING, REGISTRATION_FAILURE.
        /// This member is required.
        public var registrationStatus: IoTFleetWiseClientTypes.RegistrationStatus?
        /// The Amazon Resource Name (ARN) of the Timestream database.
        public var timestreamDatabaseArn: Swift.String?
        /// The name of the Timestream database.
        /// This member is required.
        public var timestreamDatabaseName: Swift.String?
        /// The ARN of the Timestream database table.
        public var timestreamTableArn: Swift.String?
        /// The name of the Timestream database table.
        /// This member is required.
        public var timestreamTableName: Swift.String?

        public init(
            errorMessage: Swift.String? = nil,
            registrationStatus: IoTFleetWiseClientTypes.RegistrationStatus? = nil,
            timestreamDatabaseArn: Swift.String? = nil,
            timestreamDatabaseName: Swift.String? = nil,
            timestreamTableArn: Swift.String? = nil,
            timestreamTableName: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
            self.registrationStatus = registrationStatus
            self.timestreamDatabaseArn = timestreamDatabaseArn
            self.timestreamDatabaseName = timestreamDatabaseName
            self.timestreamTableArn = timestreamTableArn
            self.timestreamTableName = timestreamTableName
        }
    }
}

public struct GetRegisterAccountStatusOutput: Swift.Sendable {
    /// The status of registering your account and resources. The status can be one of:
    ///
    /// * REGISTRATION_SUCCESS - The Amazon Web Services resource is successfully registered.
    ///
    /// * REGISTRATION_PENDING - Amazon Web Services IoT FleetWise is processing the registration request. This process takes approximately five minutes to complete.
    ///
    /// * REGISTRATION_FAILURE - Amazon Web Services IoT FleetWise can't register the AWS resource. Try again later.
    /// This member is required.
    public var accountStatus: IoTFleetWiseClientTypes.RegistrationStatus?
    /// The time the account was registered, in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The unique ID of the Amazon Web Services account, provided at account creation.
    /// This member is required.
    public var customerAccountId: Swift.String?
    /// Information about the registered IAM resources or errors, if any.
    /// This member is required.
    public var iamRegistrationResponse: IoTFleetWiseClientTypes.IamRegistrationResponse?
    /// The time this registration was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var lastModificationTime: Foundation.Date?
    /// Information about the registered Amazon Timestream resources or errors, if any.
    public var timestreamRegistrationResponse: IoTFleetWiseClientTypes.TimestreamRegistrationResponse?

    public init(
        accountStatus: IoTFleetWiseClientTypes.RegistrationStatus? = nil,
        creationTime: Foundation.Date? = nil,
        customerAccountId: Swift.String? = nil,
        iamRegistrationResponse: IoTFleetWiseClientTypes.IamRegistrationResponse? = nil,
        lastModificationTime: Foundation.Date? = nil,
        timestreamRegistrationResponse: IoTFleetWiseClientTypes.TimestreamRegistrationResponse? = nil
    )
    {
        self.accountStatus = accountStatus
        self.creationTime = creationTime
        self.customerAccountId = customerAccountId
        self.iamRegistrationResponse = iamRegistrationResponse
        self.lastModificationTime = lastModificationTime
        self.timestreamRegistrationResponse = timestreamRegistrationResponse
    }
}

public struct GetSignalCatalogInput: Swift.Sendable {
    /// The name of the signal catalog to retrieve information about.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension IoTFleetWiseClientTypes {

    /// Information about the number of nodes and node types in a vehicle network.
    public struct NodeCounts: Swift.Sendable {
        /// The total number of nodes in a vehicle network that represent actuators.
        public var totalActuators: Swift.Int
        /// The total number of nodes in a vehicle network that represent attributes.
        public var totalAttributes: Swift.Int
        /// The total number of nodes in a vehicle network that represent branches.
        public var totalBranches: Swift.Int
        /// The total number of nodes in a vehicle network.
        public var totalNodes: Swift.Int
        /// The total properties for the node.
        public var totalProperties: Swift.Int
        /// The total number of nodes in a vehicle network that represent sensors.
        public var totalSensors: Swift.Int
        /// The total structure for the node.
        public var totalStructs: Swift.Int

        public init(
            totalActuators: Swift.Int = 0,
            totalAttributes: Swift.Int = 0,
            totalBranches: Swift.Int = 0,
            totalNodes: Swift.Int = 0,
            totalProperties: Swift.Int = 0,
            totalSensors: Swift.Int = 0,
            totalStructs: Swift.Int = 0
        )
        {
            self.totalActuators = totalActuators
            self.totalAttributes = totalAttributes
            self.totalBranches = totalBranches
            self.totalNodes = totalNodes
            self.totalProperties = totalProperties
            self.totalSensors = totalSensors
            self.totalStructs = totalStructs
        }
    }
}

public struct GetSignalCatalogOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the signal catalog.
    /// This member is required.
    public var arn: Swift.String?
    /// The time the signal catalog was created in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// A brief description of the signal catalog.
    public var description: Swift.String?
    /// The last time the signal catalog was modified.
    /// This member is required.
    public var lastModificationTime: Foundation.Date?
    /// The name of the signal catalog.
    /// This member is required.
    public var name: Swift.String?
    /// The total number of network nodes specified in a signal catalog.
    public var nodeCounts: IoTFleetWiseClientTypes.NodeCounts?

    public init(
        arn: Swift.String? = nil,
        creationTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        lastModificationTime: Foundation.Date? = nil,
        name: Swift.String? = nil,
        nodeCounts: IoTFleetWiseClientTypes.NodeCounts? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.lastModificationTime = lastModificationTime
        self.name = name
        self.nodeCounts = nodeCounts
    }
}

public struct GetVehicleInput: Swift.Sendable {
    /// The ID of the vehicle to retrieve information about.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init(
        vehicleName: Swift.String? = nil
    )
    {
        self.vehicleName = vehicleName
    }
}

public struct GetVehicleOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the vehicle to retrieve information about.
    public var arn: Swift.String?
    /// Static information about a vehicle in a key-value pair. For example: "engineType" : "1.3 L R2"
    public var attributes: [Swift.String: Swift.String]?
    /// The time the vehicle was created in seconds since epoch (January 1, 1970 at midnight UTC time).
    public var creationTime: Foundation.Date?
    /// The ARN of a decoder manifest associated with the vehicle.
    public var decoderManifestArn: Swift.String?
    /// The time the vehicle was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
    public var lastModificationTime: Foundation.Date?
    /// The ARN of a vehicle model (model manifest) associated with the vehicle.
    public var modelManifestArn: Swift.String?
    /// The ID of the vehicle.
    public var vehicleName: Swift.String?

    public init(
        arn: Swift.String? = nil,
        attributes: [Swift.String: Swift.String]? = nil,
        creationTime: Foundation.Date? = nil,
        decoderManifestArn: Swift.String? = nil,
        lastModificationTime: Foundation.Date? = nil,
        modelManifestArn: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.attributes = attributes
        self.creationTime = creationTime
        self.decoderManifestArn = decoderManifestArn
        self.lastModificationTime = lastModificationTime
        self.modelManifestArn = modelManifestArn
        self.vehicleName = vehicleName
    }
}

public struct GetVehicleStatusInput: Swift.Sendable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?
    /// The ID of the vehicle to retrieve information about.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vehicleName = vehicleName
    }
}

extension IoTFleetWiseClientTypes {

    public enum VehicleState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case deleting
        case healthy
        case ready
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [VehicleState] {
            return [
                .created,
                .deleting,
                .healthy,
                .ready,
                .suspended
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .deleting: return "DELETING"
            case .healthy: return "HEALTHY"
            case .ready: return "READY"
            case .suspended: return "SUSPENDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// Information about the state of a vehicle and how it relates to the status of a campaign.
    public struct VehicleStatus: Swift.Sendable {
        /// The name of a campaign.
        public var campaignName: Swift.String?
        /// The state of a vehicle, which can be one of the following:
        ///
        /// * CREATED - Amazon Web Services IoT FleetWise sucessfully created the vehicle.
        ///
        /// * READY - The vehicle is ready to receive a campaign deployment.
        ///
        /// * HEALTHY - A campaign deployment was delivered to the vehicle.
        ///
        /// * SUSPENDED - A campaign associated with the vehicle was suspended and data collection was paused.
        ///
        /// * DELETING - Amazon Web Services IoT FleetWise is removing a campaign from the vehicle.
        public var status: IoTFleetWiseClientTypes.VehicleState?
        /// The unique ID of the vehicle.
        public var vehicleName: Swift.String?

        public init(
            campaignName: Swift.String? = nil,
            status: IoTFleetWiseClientTypes.VehicleState? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.campaignName = campaignName
            self.status = status
            self.vehicleName = vehicleName
        }
    }
}

public struct GetVehicleStatusOutput: Swift.Sendable {
    /// Lists information about the state of the vehicle with deployed campaigns.
    public var campaigns: [IoTFleetWiseClientTypes.VehicleStatus]?
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        campaigns: [IoTFleetWiseClientTypes.VehicleStatus]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.campaigns = campaigns
        self.nextToken = nextToken
    }
}

extension IoTFleetWiseClientTypes {

    /// The IAM resource that enables Amazon Web Services IoT FleetWise edge agent software to send data to Amazon Timestream. For more information, see [IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html) in the Identity and Access Management User Guide.
    public struct IamResources: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream. For example, arn:aws:iam::123456789012:role/SERVICE-ROLE-ARN.
        /// This member is required.
        public var roleArn: Swift.String?

        public init(
            roleArn: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
        }
    }
}

public struct ImportSignalCatalogInput: Swift.Sendable {
    /// A brief description of the signal catalog.
    public var description: Swift.String?
    /// The name of the signal catalog to import.
    /// This member is required.
    public var name: Swift.String?
    /// Metadata that can be used to manage the signal catalog.
    public var tags: [IoTFleetWiseClientTypes.Tag]?
    /// The contents of the Vehicle Signal Specification (VSS) configuration. VSS is a precise language used to describe and model signals in vehicle networks.
    public var vss: IoTFleetWiseClientTypes.FormattedVss?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil,
        vss: IoTFleetWiseClientTypes.FormattedVss? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
        self.vss = vss
    }
}

public struct ImportSignalCatalogOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the imported signal catalog.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the imported signal catalog.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The list of tags assigned to the resource.
    public var tags: [IoTFleetWiseClientTypes.Tag]?

    public init(
        tags: [IoTFleetWiseClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListModelManifestNodesInput: Swift.Sendable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// The name of the vehicle model to list information about.
    /// This member is required.
    public var name: Swift.String?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

public struct ListModelManifestNodesOutput: Swift.Sendable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of information about nodes.
    public var nodes: [IoTFleetWiseClientTypes.Node]?

    public init(
        nextToken: Swift.String? = nil,
        nodes: [IoTFleetWiseClientTypes.Node]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodes = nodes
    }
}

public struct ListModelManifestsInput: Swift.Sendable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?
    /// The ARN of a signal catalog. If you specify a signal catalog, only the vehicle models associated with it are returned.
    public var signalCatalogArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        signalCatalogArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.signalCatalogArn = signalCatalogArn
    }
}

extension IoTFleetWiseClientTypes {

    /// Information about a vehicle model (model manifest). You can use the API operation to return this information about multiple vehicle models.
    public struct ModelManifestSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the vehicle model.
        public var arn: Swift.String?
        /// The time the vehicle model was created, in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// A brief description of the vehicle model.
        public var description: Swift.String?
        /// The time the vehicle model was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var lastModificationTime: Foundation.Date?
        /// The name of the vehicle model.
        public var name: Swift.String?
        /// The ARN of the signal catalog associated with the vehicle model.
        public var signalCatalogArn: Swift.String?
        /// The state of the vehicle model. If the status is ACTIVE, the vehicle model can't be edited. If the status is DRAFT, you can edit the vehicle model.
        public var status: IoTFleetWiseClientTypes.ManifestStatus?

        public init(
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            lastModificationTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            signalCatalogArn: Swift.String? = nil,
            status: IoTFleetWiseClientTypes.ManifestStatus? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.lastModificationTime = lastModificationTime
            self.name = name
            self.signalCatalogArn = signalCatalogArn
            self.status = status
        }
    }
}

public struct ListModelManifestsOutput: Swift.Sendable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of information about vehicle models.
    public var summaries: [IoTFleetWiseClientTypes.ModelManifestSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTFleetWiseClientTypes.ModelManifestSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

public struct UpdateModelManifestInput: Swift.Sendable {
    /// A brief description of the vehicle model.
    public var description: Swift.String?
    /// The name of the vehicle model to update.
    /// This member is required.
    public var name: Swift.String?
    /// A list of fullyQualifiedName of nodes, which are a general abstraction of signals, to add to the vehicle model.
    public var nodesToAdd: [Swift.String]?
    /// A list of fullyQualifiedName of nodes, which are a general abstraction of signals, to remove from the vehicle model.
    public var nodesToRemove: [Swift.String]?
    /// The state of the vehicle model. If the status is ACTIVE, the vehicle model can't be edited. If the status is DRAFT, you can edit the vehicle model.
    public var status: IoTFleetWiseClientTypes.ManifestStatus?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        nodesToAdd: [Swift.String]? = nil,
        nodesToRemove: [Swift.String]? = nil,
        status: IoTFleetWiseClientTypes.ManifestStatus? = nil
    )
    {
        self.description = description
        self.name = name
        self.nodesToAdd = nodesToAdd
        self.nodesToRemove = nodesToRemove
        self.status = status
    }
}

public struct UpdateModelManifestOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the updated vehicle model.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the updated vehicle model.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

public struct PutEncryptionConfigurationInput: Swift.Sendable {
    /// The type of encryption. Choose KMS_BASED_ENCRYPTION to use a KMS key or FLEETWISE_DEFAULT_ENCRYPTION to use an Amazon Web Services managed key.
    /// This member is required.
    public var encryptionType: IoTFleetWiseClientTypes.EncryptionType?
    /// The ID of the KMS key that is used for encryption.
    public var kmsKeyId: Swift.String?

    public init(
        encryptionType: IoTFleetWiseClientTypes.EncryptionType? = nil,
        kmsKeyId: Swift.String? = nil
    )
    {
        self.encryptionType = encryptionType
        self.kmsKeyId = kmsKeyId
    }
}

public struct PutEncryptionConfigurationOutput: Swift.Sendable {
    /// The encryption status.
    /// This member is required.
    public var encryptionStatus: IoTFleetWiseClientTypes.EncryptionStatus?
    /// The type of encryption. Set to KMS_BASED_ENCRYPTION to use an KMS key that you own and manage. Set to FLEETWISE_DEFAULT_ENCRYPTION to use an Amazon Web Services managed key that is owned by the Amazon Web Services IoT FleetWise service account.
    /// This member is required.
    public var encryptionType: IoTFleetWiseClientTypes.EncryptionType?
    /// The ID of the KMS key that is used for encryption.
    public var kmsKeyId: Swift.String?

    public init(
        encryptionStatus: IoTFleetWiseClientTypes.EncryptionStatus? = nil,
        encryptionType: IoTFleetWiseClientTypes.EncryptionType? = nil,
        kmsKeyId: Swift.String? = nil
    )
    {
        self.encryptionStatus = encryptionStatus
        self.encryptionType = encryptionType
        self.kmsKeyId = kmsKeyId
    }
}

public struct PutLoggingOptionsInput: Swift.Sendable {
    /// Creates or updates the log delivery option to Amazon CloudWatch Logs.
    /// This member is required.
    public var cloudWatchLogDelivery: IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions?

    public init(
        cloudWatchLogDelivery: IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions? = nil
    )
    {
        self.cloudWatchLogDelivery = cloudWatchLogDelivery
    }
}

public struct PutLoggingOptionsOutput: Swift.Sendable {

    public init() { }
}

extension IoTFleetWiseClientTypes {

    /// The registered Amazon Timestream resources that Amazon Web Services IoT FleetWise edge agent software can transfer your vehicle data to.
    public struct TimestreamResources: Swift.Sendable {
        /// The name of the registered Amazon Timestream database.
        /// This member is required.
        public var timestreamDatabaseName: Swift.String?
        /// The name of the registered Amazon Timestream database table.
        /// This member is required.
        public var timestreamTableName: Swift.String?

        public init(
            timestreamDatabaseName: Swift.String? = nil,
            timestreamTableName: Swift.String? = nil
        )
        {
            self.timestreamDatabaseName = timestreamDatabaseName
            self.timestreamTableName = timestreamTableName
        }
    }
}

public struct RegisterAccountInput: Swift.Sendable {
    /// The IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream.
    @available(*, deprecated, message: "iamResources is no longer used or needed as input")
    public var iamResources: IoTFleetWiseClientTypes.IamResources?
    /// The registered Amazon Timestream resources that Amazon Web Services IoT FleetWise edge agent software can transfer your vehicle data to.
    @available(*, deprecated, message: "Amazon Timestream metadata is now passed in the CreateCampaign API.")
    public var timestreamResources: IoTFleetWiseClientTypes.TimestreamResources?

    public init(
        iamResources: IoTFleetWiseClientTypes.IamResources? = nil,
        timestreamResources: IoTFleetWiseClientTypes.TimestreamResources? = nil
    )
    {
        self.iamResources = iamResources
        self.timestreamResources = timestreamResources
    }
}

public struct RegisterAccountOutput: Swift.Sendable {
    /// The time the account was registered, in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var creationTime: Foundation.Date?
    /// The registered IAM resource that allows Amazon Web Services IoT FleetWise to send data to Amazon Timestream.
    /// This member is required.
    public var iamResources: IoTFleetWiseClientTypes.IamResources?
    /// The time this registration was last updated, in seconds since epoch (January 1, 1970 at midnight UTC time).
    /// This member is required.
    public var lastModificationTime: Foundation.Date?
    /// The status of registering your Amazon Web Services account, IAM role, and Timestream resources.
    /// This member is required.
    public var registerAccountStatus: IoTFleetWiseClientTypes.RegistrationStatus?
    /// The registered Amazon Timestream resources that Amazon Web Services IoT FleetWise edge agent software can transfer your vehicle data to.
    public var timestreamResources: IoTFleetWiseClientTypes.TimestreamResources?

    public init(
        creationTime: Foundation.Date? = nil,
        iamResources: IoTFleetWiseClientTypes.IamResources? = nil,
        lastModificationTime: Foundation.Date? = nil,
        registerAccountStatus: IoTFleetWiseClientTypes.RegistrationStatus? = nil,
        timestreamResources: IoTFleetWiseClientTypes.TimestreamResources? = nil
    )
    {
        self.creationTime = creationTime
        self.iamResources = iamResources
        self.lastModificationTime = lastModificationTime
        self.registerAccountStatus = registerAccountStatus
        self.timestreamResources = timestreamResources
    }
}

extension IoTFleetWiseClientTypes {

    public enum SignalNodeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actuator
        case attribute
        case branch
        case customProperty
        case customStruct
        case sensor
        case sdkUnknown(Swift.String)

        public static var allCases: [SignalNodeType] {
            return [
                .actuator,
                .attribute,
                .branch,
                .customProperty,
                .customStruct,
                .sensor
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actuator: return "ACTUATOR"
            case .attribute: return "ATTRIBUTE"
            case .branch: return "BRANCH"
            case .customProperty: return "CUSTOM_PROPERTY"
            case .customStruct: return "CUSTOM_STRUCT"
            case .sensor: return "SENSOR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListSignalCatalogNodesInput: Swift.Sendable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// The name of the signal catalog to list information about.
    /// This member is required.
    public var name: Swift.String?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?
    /// The type of node in the signal catalog.
    public var signalNodeType: IoTFleetWiseClientTypes.SignalNodeType?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        signalNodeType: IoTFleetWiseClientTypes.SignalNodeType? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.signalNodeType = signalNodeType
    }
}

public struct ListSignalCatalogNodesOutput: Swift.Sendable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of information about nodes.
    public var nodes: [IoTFleetWiseClientTypes.Node]?

    public init(
        nextToken: Swift.String? = nil,
        nodes: [IoTFleetWiseClientTypes.Node]? = nil
    )
    {
        self.nextToken = nextToken
        self.nodes = nodes
    }
}

public struct ListSignalCatalogsInput: Swift.Sendable {
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTFleetWiseClientTypes {

    /// Information about a collection of standardized signals, which can be attributes, branches, sensors, or actuators.
    public struct SignalCatalogSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the signal catalog.
        public var arn: Swift.String?
        /// The time the signal catalog was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        public var creationTime: Foundation.Date?
        /// The time the signal catalog was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        public var lastModificationTime: Foundation.Date?
        /// The name of the signal catalog.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            lastModificationTime: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.lastModificationTime = lastModificationTime
            self.name = name
        }
    }
}

public struct ListSignalCatalogsOutput: Swift.Sendable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of information about each signal catalog.
    public var summaries: [IoTFleetWiseClientTypes.SignalCatalogSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [IoTFleetWiseClientTypes.SignalCatalogSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

public struct UpdateSignalCatalogInput: Swift.Sendable {
    /// A brief description of the signal catalog to update.
    public var description: Swift.String?
    /// The name of the signal catalog to update.
    /// This member is required.
    public var name: Swift.String?
    /// A list of information about nodes to add to the signal catalog.
    public var nodesToAdd: [IoTFleetWiseClientTypes.Node]?
    /// A list of fullyQualifiedName of nodes to remove from the signal catalog.
    public var nodesToRemove: [Swift.String]?
    /// A list of information about nodes to update in the signal catalog.
    public var nodesToUpdate: [IoTFleetWiseClientTypes.Node]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        nodesToAdd: [IoTFleetWiseClientTypes.Node]? = nil,
        nodesToRemove: [Swift.String]? = nil,
        nodesToUpdate: [IoTFleetWiseClientTypes.Node]? = nil
    )
    {
        self.description = description
        self.name = name
        self.nodesToAdd = nodesToAdd
        self.nodesToRemove = nodesToRemove
        self.nodesToUpdate = nodesToUpdate
    }
}

public struct UpdateSignalCatalogOutput: Swift.Sendable {
    /// The ARN of the updated signal catalog.
    /// This member is required.
    public var arn: Swift.String?
    /// The name of the updated signal catalog.
    /// This member is required.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The new or modified tags for the resource.
    /// This member is required.
    public var tags: [IoTFleetWiseClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of the keys of the tags to be removed from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct ListVehiclesInput: Swift.Sendable {
    /// The fully qualified names of the attributes. For example, the fully qualified name of an attribute might be Vehicle.Body.Engine.Type.
    public var attributeNames: [Swift.String]?
    /// Static information about a vehicle attribute value in string format. For example: "1.3 L R2"
    public var attributeValues: [Swift.String]?
    /// The maximum number of items to return, between 1 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// The Amazon Resource Name (ARN) of a vehicle model (model manifest). You can use this optional parameter to list only the vehicles created from a certain vehicle model.
    public var modelManifestArn: Swift.String?
    /// A pagination token for the next set of results. If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next set of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        attributeNames: [Swift.String]? = nil,
        attributeValues: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        modelManifestArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attributeNames = attributeNames
        self.attributeValues = attributeValues
        self.maxResults = maxResults
        self.modelManifestArn = modelManifestArn
        self.nextToken = nextToken
    }
}

extension IoTFleetWiseClientTypes {

    /// Information about a vehicle. To return this information about vehicles in your account, you can use the API operation.
    public struct VehicleSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the vehicle.
        /// This member is required.
        public var arn: Swift.String?
        /// Static information about a vehicle in a key-value pair. For example: "engineType" : "1.3 L R2"
        public var attributes: [Swift.String: Swift.String]?
        /// The time the vehicle was created in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// The ARN of a decoder manifest associated with the vehicle.
        /// This member is required.
        public var decoderManifestArn: Swift.String?
        /// The time the vehicle was last updated in seconds since epoch (January 1, 1970 at midnight UTC time).
        /// This member is required.
        public var lastModificationTime: Foundation.Date?
        /// The ARN of a vehicle model (model manifest) associated with the vehicle.
        /// This member is required.
        public var modelManifestArn: Swift.String?
        /// The unique ID of the vehicle.
        /// This member is required.
        public var vehicleName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            attributes: [Swift.String: Swift.String]? = nil,
            creationTime: Foundation.Date? = nil,
            decoderManifestArn: Swift.String? = nil,
            lastModificationTime: Foundation.Date? = nil,
            modelManifestArn: Swift.String? = nil,
            vehicleName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.attributes = attributes
            self.creationTime = creationTime
            self.decoderManifestArn = decoderManifestArn
            self.lastModificationTime = lastModificationTime
            self.modelManifestArn = modelManifestArn
            self.vehicleName = vehicleName
        }
    }
}

public struct ListVehiclesOutput: Swift.Sendable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A list of vehicles and information about them.
    public var vehicleSummaries: [IoTFleetWiseClientTypes.VehicleSummary]?

    public init(
        nextToken: Swift.String? = nil,
        vehicleSummaries: [IoTFleetWiseClientTypes.VehicleSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.vehicleSummaries = vehicleSummaries
    }
}

public struct UpdateVehicleInput: Swift.Sendable {
    /// The method the specified attributes will update the existing attributes on the vehicle. UseOverwite to replace the vehicle attributes with the specified attributes. Or use Merge to combine all attributes. This is required if attributes are present in the input.
    public var attributeUpdateMode: IoTFleetWiseClientTypes.UpdateMode?
    /// Static information about a vehicle in a key-value pair. For example: "engineType" : "1.3 L R2"
    public var attributes: [Swift.String: Swift.String]?
    /// The ARN of the decoder manifest associated with this vehicle.
    public var decoderManifestArn: Swift.String?
    /// The ARN of a vehicle model (model manifest) associated with the vehicle.
    public var modelManifestArn: Swift.String?
    /// The unique ID of the vehicle to update.
    /// This member is required.
    public var vehicleName: Swift.String?

    public init(
        attributeUpdateMode: IoTFleetWiseClientTypes.UpdateMode? = nil,
        attributes: [Swift.String: Swift.String]? = nil,
        decoderManifestArn: Swift.String? = nil,
        modelManifestArn: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.attributeUpdateMode = attributeUpdateMode
        self.attributes = attributes
        self.decoderManifestArn = decoderManifestArn
        self.modelManifestArn = modelManifestArn
        self.vehicleName = vehicleName
    }
}

public struct UpdateVehicleOutput: Swift.Sendable {
    /// The ARN of the updated vehicle.
    public var arn: Swift.String?
    /// The ID of the updated vehicle.
    public var vehicleName: Swift.String?

    public init(
        arn: Swift.String? = nil,
        vehicleName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.vehicleName = vehicleName
    }
}

extension IoTFleetWiseClientTypes {

    /// The structured message for the message signal. It can be defined with either a primitiveMessageDefinition, structuredMessageListDefinition, or structuredMessageDefinition recursively.
    public indirect enum StructuredMessage: Swift.Sendable {
        /// Represents a primitive type node of the complex data structure.
        case primitivemessagedefinition(IoTFleetWiseClientTypes.PrimitiveMessageDefinition)
        /// Represents a list type node of the complex data structure.
        case structuredmessagelistdefinition(IoTFleetWiseClientTypes.StructuredMessageListDefinition)
        /// Represents a struct type node of the complex data structure.
        case structuredmessagedefinition([IoTFleetWiseClientTypes.StructuredMessageFieldNameAndDataTypePair])
        case sdkUnknown(Swift.String)
    }
}

extension IoTFleetWiseClientTypes {

    /// Represents a StructureMessageName to DataType map element.
    public struct StructuredMessageFieldNameAndDataTypePair: Swift.Sendable {
        /// The data type.
        /// This member is required.
        public var dataType: IoTFleetWiseClientTypes.StructuredMessage?
        /// The field name of the structured message. It determines how a data value is referenced in the target language.
        /// This member is required.
        public var fieldName: Swift.String?

        public init(
            dataType: IoTFleetWiseClientTypes.StructuredMessage? = nil,
            fieldName: Swift.String? = nil
        )
        {
            self.dataType = dataType
            self.fieldName = fieldName
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// Represents a list type node of the complex data structure.
    public struct StructuredMessageListDefinition: Swift.Sendable {
        /// The capacity of the structured message list definition when the list type is FIXED_CAPACITY or DYNAMIC_BOUNDED_CAPACITY.
        public var capacity: Swift.Int
        /// The type of list of the structured message list definition.
        /// This member is required.
        public var listType: IoTFleetWiseClientTypes.StructuredMessageListType?
        /// The member type of the structured message list definition.
        /// This member is required.
        public var memberType: IoTFleetWiseClientTypes.StructuredMessage?
        /// The name of the structured message list definition.
        /// This member is required.
        public var name: Swift.String?

        public init(
            capacity: Swift.Int = 0,
            listType: IoTFleetWiseClientTypes.StructuredMessageListType? = nil,
            memberType: IoTFleetWiseClientTypes.StructuredMessage? = nil,
            name: Swift.String? = nil
        )
        {
            self.capacity = capacity
            self.listType = listType
            self.memberType = memberType
            self.name = name
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// The decoding information for a specific message which support higher order data types.
    public struct MessageSignal: Swift.Sendable {
        /// The structured message for the message signal. It can be defined with either a primitiveMessageDefinition, structuredMessageListDefinition, or structuredMessageDefinition recursively.
        /// This member is required.
        public var structuredMessage: IoTFleetWiseClientTypes.StructuredMessage?
        /// The topic name for the message signal. It corresponds to topics in ROS 2.
        /// This member is required.
        public var topicName: Swift.String?

        public init(
            structuredMessage: IoTFleetWiseClientTypes.StructuredMessage? = nil,
            topicName: Swift.String? = nil
        )
        {
            self.structuredMessage = structuredMessage
            self.topicName = topicName
        }
    }
}

extension IoTFleetWiseClientTypes {

    /// Information about a signal decoder.
    public struct SignalDecoder: Swift.Sendable {
        /// Information about signal decoder using the Controller Area Network (CAN) protocol.
        public var canSignal: IoTFleetWiseClientTypes.CanSignal?
        /// The fully qualified name of a signal decoder as defined in a vehicle model.
        /// This member is required.
        public var fullyQualifiedName: Swift.String?
        /// The ID of a network interface that specifies what network protocol a vehicle follows.
        /// This member is required.
        public var interfaceId: Swift.String?
        /// The decoding information for a specific message which supports higher order data types.
        public var messageSignal: IoTFleetWiseClientTypes.MessageSignal?
        /// Information about signal decoder using the On-board diagnostic (OBD) II protocol.
        public var obdSignal: IoTFleetWiseClientTypes.ObdSignal?
        /// The network protocol for the vehicle. For example, CAN_SIGNAL specifies a protocol that defines how data is communicated between electronic control units (ECUs). OBD_SIGNAL specifies a protocol that defines how self-diagnostic data is communicated between ECUs.
        /// This member is required.
        public var type: IoTFleetWiseClientTypes.SignalDecoderType?

        public init(
            canSignal: IoTFleetWiseClientTypes.CanSignal? = nil,
            fullyQualifiedName: Swift.String? = nil,
            interfaceId: Swift.String? = nil,
            messageSignal: IoTFleetWiseClientTypes.MessageSignal? = nil,
            obdSignal: IoTFleetWiseClientTypes.ObdSignal? = nil,
            type: IoTFleetWiseClientTypes.SignalDecoderType? = nil
        )
        {
            self.canSignal = canSignal
            self.fullyQualifiedName = fullyQualifiedName
            self.interfaceId = interfaceId
            self.messageSignal = messageSignal
            self.obdSignal = obdSignal
            self.type = type
        }
    }
}

public struct CreateDecoderManifestInput: Swift.Sendable {
    /// A brief description of the decoder manifest.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the vehicle model (model manifest).
    /// This member is required.
    public var modelManifestArn: Swift.String?
    /// The unique name of the decoder manifest to create.
    /// This member is required.
    public var name: Swift.String?
    /// A list of information about available network interfaces.
    public var networkInterfaces: [IoTFleetWiseClientTypes.NetworkInterface]?
    /// A list of information about signal decoders.
    public var signalDecoders: [IoTFleetWiseClientTypes.SignalDecoder]?
    /// Metadata that can be used to manage the decoder manifest.
    public var tags: [IoTFleetWiseClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        modelManifestArn: Swift.String? = nil,
        name: Swift.String? = nil,
        networkInterfaces: [IoTFleetWiseClientTypes.NetworkInterface]? = nil,
        signalDecoders: [IoTFleetWiseClientTypes.SignalDecoder]? = nil,
        tags: [IoTFleetWiseClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.modelManifestArn = modelManifestArn
        self.name = name
        self.networkInterfaces = networkInterfaces
        self.signalDecoders = signalDecoders
        self.tags = tags
    }
}

public struct ListDecoderManifestSignalsOutput: Swift.Sendable {
    /// The token to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Information about a list of signals to decode.
    public var signalDecoders: [IoTFleetWiseClientTypes.SignalDecoder]?

    public init(
        nextToken: Swift.String? = nil,
        signalDecoders: [IoTFleetWiseClientTypes.SignalDecoder]? = nil
    )
    {
        self.nextToken = nextToken
        self.signalDecoders = signalDecoders
    }
}

public struct UpdateDecoderManifestInput: Swift.Sendable {
    /// A brief description of the decoder manifest to update.
    public var description: Swift.String?
    /// The name of the decoder manifest to update.
    /// This member is required.
    public var name: Swift.String?
    /// A list of information about the network interfaces to add to the decoder manifest.
    public var networkInterfacesToAdd: [IoTFleetWiseClientTypes.NetworkInterface]?
    /// A list of network interfaces to remove from the decoder manifest.
    public var networkInterfacesToRemove: [Swift.String]?
    /// A list of information about the network interfaces to update in the decoder manifest.
    public var networkInterfacesToUpdate: [IoTFleetWiseClientTypes.NetworkInterface]?
    /// A list of information about decoding additional signals to add to the decoder manifest.
    public var signalDecodersToAdd: [IoTFleetWiseClientTypes.SignalDecoder]?
    /// A list of signal decoders to remove from the decoder manifest.
    public var signalDecodersToRemove: [Swift.String]?
    /// A list of updated information about decoding signals to update in the decoder manifest.
    public var signalDecodersToUpdate: [IoTFleetWiseClientTypes.SignalDecoder]?
    /// The state of the decoder manifest. If the status is ACTIVE, the decoder manifest can't be edited. If the status is DRAFT, you can edit the decoder manifest.
    public var status: IoTFleetWiseClientTypes.ManifestStatus?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        networkInterfacesToAdd: [IoTFleetWiseClientTypes.NetworkInterface]? = nil,
        networkInterfacesToRemove: [Swift.String]? = nil,
        networkInterfacesToUpdate: [IoTFleetWiseClientTypes.NetworkInterface]? = nil,
        signalDecodersToAdd: [IoTFleetWiseClientTypes.SignalDecoder]? = nil,
        signalDecodersToRemove: [Swift.String]? = nil,
        signalDecodersToUpdate: [IoTFleetWiseClientTypes.SignalDecoder]? = nil,
        status: IoTFleetWiseClientTypes.ManifestStatus? = nil
    )
    {
        self.description = description
        self.name = name
        self.networkInterfacesToAdd = networkInterfacesToAdd
        self.networkInterfacesToRemove = networkInterfacesToRemove
        self.networkInterfacesToUpdate = networkInterfacesToUpdate
        self.signalDecodersToAdd = signalDecodersToAdd
        self.signalDecodersToRemove = signalDecodersToRemove
        self.signalDecodersToUpdate = signalDecodersToUpdate
        self.status = status
    }
}

extension AssociateVehicleFleetInput {

    static func urlPathProvider(_ value: AssociateVehicleFleetInput) -> Swift.String? {
        return "/"
    }
}

extension BatchCreateVehicleInput {

    static func urlPathProvider(_ value: BatchCreateVehicleInput) -> Swift.String? {
        return "/"
    }
}

extension BatchUpdateVehicleInput {

    static func urlPathProvider(_ value: BatchUpdateVehicleInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCampaignInput {

    static func urlPathProvider(_ value: CreateCampaignInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDecoderManifestInput {

    static func urlPathProvider(_ value: CreateDecoderManifestInput) -> Swift.String? {
        return "/"
    }
}

extension CreateFleetInput {

    static func urlPathProvider(_ value: CreateFleetInput) -> Swift.String? {
        return "/"
    }
}

extension CreateModelManifestInput {

    static func urlPathProvider(_ value: CreateModelManifestInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSignalCatalogInput {

    static func urlPathProvider(_ value: CreateSignalCatalogInput) -> Swift.String? {
        return "/"
    }
}

extension CreateVehicleInput {

    static func urlPathProvider(_ value: CreateVehicleInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCampaignInput {

    static func urlPathProvider(_ value: DeleteCampaignInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDecoderManifestInput {

    static func urlPathProvider(_ value: DeleteDecoderManifestInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteFleetInput {

    static func urlPathProvider(_ value: DeleteFleetInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteModelManifestInput {

    static func urlPathProvider(_ value: DeleteModelManifestInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSignalCatalogInput {

    static func urlPathProvider(_ value: DeleteSignalCatalogInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteVehicleInput {

    static func urlPathProvider(_ value: DeleteVehicleInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateVehicleFleetInput {

    static func urlPathProvider(_ value: DisassociateVehicleFleetInput) -> Swift.String? {
        return "/"
    }
}

extension GetCampaignInput {

    static func urlPathProvider(_ value: GetCampaignInput) -> Swift.String? {
        return "/"
    }
}

extension GetDecoderManifestInput {

    static func urlPathProvider(_ value: GetDecoderManifestInput) -> Swift.String? {
        return "/"
    }
}

extension GetEncryptionConfigurationInput {

    static func urlPathProvider(_ value: GetEncryptionConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension GetFleetInput {

    static func urlPathProvider(_ value: GetFleetInput) -> Swift.String? {
        return "/"
    }
}

extension GetLoggingOptionsInput {

    static func urlPathProvider(_ value: GetLoggingOptionsInput) -> Swift.String? {
        return "/"
    }
}

extension GetModelManifestInput {

    static func urlPathProvider(_ value: GetModelManifestInput) -> Swift.String? {
        return "/"
    }
}

extension GetRegisterAccountStatusInput {

    static func urlPathProvider(_ value: GetRegisterAccountStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetSignalCatalogInput {

    static func urlPathProvider(_ value: GetSignalCatalogInput) -> Swift.String? {
        return "/"
    }
}

extension GetVehicleInput {

    static func urlPathProvider(_ value: GetVehicleInput) -> Swift.String? {
        return "/"
    }
}

extension GetVehicleStatusInput {

    static func urlPathProvider(_ value: GetVehicleStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetVehicleStatusInput {

    static func queryItemProvider(_ value: GetVehicleStatusInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ImportDecoderManifestInput {

    static func urlPathProvider(_ value: ImportDecoderManifestInput) -> Swift.String? {
        return "/"
    }
}

extension ImportSignalCatalogInput {

    static func urlPathProvider(_ value: ImportSignalCatalogInput) -> Swift.String? {
        return "/"
    }
}

extension ListCampaignsInput {

    static func urlPathProvider(_ value: ListCampaignsInput) -> Swift.String? {
        return "/"
    }
}

extension ListCampaignsInput {

    static func queryItemProvider(_ value: ListCampaignsInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListDecoderManifestNetworkInterfacesInput {

    static func urlPathProvider(_ value: ListDecoderManifestNetworkInterfacesInput) -> Swift.String? {
        return "/"
    }
}

extension ListDecoderManifestNetworkInterfacesInput {

    static func queryItemProvider(_ value: ListDecoderManifestNetworkInterfacesInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListDecoderManifestsInput {

    static func urlPathProvider(_ value: ListDecoderManifestsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDecoderManifestsInput {

    static func queryItemProvider(_ value: ListDecoderManifestsInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListDecoderManifestSignalsInput {

    static func urlPathProvider(_ value: ListDecoderManifestSignalsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDecoderManifestSignalsInput {

    static func queryItemProvider(_ value: ListDecoderManifestSignalsInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListFleetsInput {

    static func urlPathProvider(_ value: ListFleetsInput) -> Swift.String? {
        return "/"
    }
}

extension ListFleetsInput {

    static func queryItemProvider(_ value: ListFleetsInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListFleetsForVehicleInput {

    static func urlPathProvider(_ value: ListFleetsForVehicleInput) -> Swift.String? {
        return "/"
    }
}

extension ListFleetsForVehicleInput {

    static func queryItemProvider(_ value: ListFleetsForVehicleInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListModelManifestNodesInput {

    static func urlPathProvider(_ value: ListModelManifestNodesInput) -> Swift.String? {
        return "/"
    }
}

extension ListModelManifestNodesInput {

    static func queryItemProvider(_ value: ListModelManifestNodesInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListModelManifestsInput {

    static func urlPathProvider(_ value: ListModelManifestsInput) -> Swift.String? {
        return "/"
    }
}

extension ListModelManifestsInput {

    static func queryItemProvider(_ value: ListModelManifestsInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListSignalCatalogNodesInput {

    static func urlPathProvider(_ value: ListSignalCatalogNodesInput) -> Swift.String? {
        return "/"
    }
}

extension ListSignalCatalogNodesInput {

    static func queryItemProvider(_ value: ListSignalCatalogNodesInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListSignalCatalogsInput {

    static func urlPathProvider(_ value: ListSignalCatalogsInput) -> Swift.String? {
        return "/"
    }
}

extension ListSignalCatalogsInput {

    static func queryItemProvider(_ value: ListSignalCatalogsInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func queryItemProvider(_ value: ListTagsForResourceInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListVehiclesInput {

    static func urlPathProvider(_ value: ListVehiclesInput) -> Swift.String? {
        return "/"
    }
}

extension ListVehiclesInput {

    static func queryItemProvider(_ value: ListVehiclesInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListVehiclesInFleetInput {

    static func urlPathProvider(_ value: ListVehiclesInFleetInput) -> Swift.String? {
        return "/"
    }
}

extension ListVehiclesInFleetInput {

    static func queryItemProvider(_ value: ListVehiclesInFleetInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension PutEncryptionConfigurationInput {

    static func urlPathProvider(_ value: PutEncryptionConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension PutLoggingOptionsInput {

    static func urlPathProvider(_ value: PutLoggingOptionsInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterAccountInput {

    static func urlPathProvider(_ value: RegisterAccountInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func queryItemProvider(_ value: TagResourceInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension UpdateCampaignInput {

    static func urlPathProvider(_ value: UpdateCampaignInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDecoderManifestInput {

    static func urlPathProvider(_ value: UpdateDecoderManifestInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateFleetInput {

    static func urlPathProvider(_ value: UpdateFleetInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateModelManifestInput {

    static func urlPathProvider(_ value: UpdateModelManifestInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSignalCatalogInput {

    static func urlPathProvider(_ value: UpdateSignalCatalogInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateVehicleInput {

    static func urlPathProvider(_ value: UpdateVehicleInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateVehicleFleetInput {

    static func write(value: AssociateVehicleFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fleetId"].write(value.fleetId)
    }
}

extension BatchCreateVehicleInput {

    static func write(value: BatchCreateVehicleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vehicles"].writeList(value.vehicles, memberWritingClosure: IoTFleetWiseClientTypes.CreateVehicleRequestItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchUpdateVehicleInput {

    static func write(value: BatchUpdateVehicleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vehicles"].writeList(value.vehicles, memberWritingClosure: IoTFleetWiseClientTypes.UpdateVehicleRequestItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateCampaignInput {

    static func write(value: CreateCampaignInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["collectionScheme"].write(value.collectionScheme, with: IoTFleetWiseClientTypes.CollectionScheme.write(value:to:))
        try writer["compression"].write(value.compression)
        try writer["dataDestinationConfigs"].writeList(value.dataDestinationConfigs, memberWritingClosure: IoTFleetWiseClientTypes.DataDestinationConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["dataExtraDimensions"].writeList(value.dataExtraDimensions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["diagnosticsMode"].write(value.diagnosticsMode)
        try writer["expiryTime"].writeTimestamp(value.expiryTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["postTriggerCollectionDuration"].write(value.postTriggerCollectionDuration)
        try writer["priority"].write(value.priority)
        try writer["signalCatalogArn"].write(value.signalCatalogArn)
        try writer["signalsToCollect"].writeList(value.signalsToCollect, memberWritingClosure: IoTFleetWiseClientTypes.SignalInformation.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["spoolingMode"].write(value.spoolingMode)
        try writer["startTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTFleetWiseClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targetArn"].write(value.targetArn)
    }
}

extension CreateDecoderManifestInput {

    static func write(value: CreateDecoderManifestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["modelManifestArn"].write(value.modelManifestArn)
        try writer["networkInterfaces"].writeList(value.networkInterfaces, memberWritingClosure: IoTFleetWiseClientTypes.NetworkInterface.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["signalDecoders"].writeList(value.signalDecoders, memberWritingClosure: IoTFleetWiseClientTypes.SignalDecoder.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTFleetWiseClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateFleetInput {

    static func write(value: CreateFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["signalCatalogArn"].write(value.signalCatalogArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTFleetWiseClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateModelManifestInput {

    static func write(value: CreateModelManifestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["nodes"].writeList(value.nodes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["signalCatalogArn"].write(value.signalCatalogArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTFleetWiseClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateSignalCatalogInput {

    static func write(value: CreateSignalCatalogInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["nodes"].writeList(value.nodes, memberWritingClosure: IoTFleetWiseClientTypes.Node.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTFleetWiseClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateVehicleInput {

    static func write(value: CreateVehicleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["associationBehavior"].write(value.associationBehavior)
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["decoderManifestArn"].write(value.decoderManifestArn)
        try writer["modelManifestArn"].write(value.modelManifestArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTFleetWiseClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteCampaignInput {

    static func write(value: DeleteCampaignInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteDecoderManifestInput {

    static func write(value: DeleteDecoderManifestInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteFleetInput {

    static func write(value: DeleteFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteModelManifestInput {

    static func write(value: DeleteModelManifestInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteSignalCatalogInput {

    static func write(value: DeleteSignalCatalogInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteVehicleInput {

    static func write(value: DeleteVehicleInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DisassociateVehicleFleetInput {

    static func write(value: DisassociateVehicleFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fleetId"].write(value.fleetId)
    }
}

extension GetCampaignInput {

    static func write(value: GetCampaignInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetDecoderManifestInput {

    static func write(value: GetDecoderManifestInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetEncryptionConfigurationInput {

    static func write(value: GetEncryptionConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetFleetInput {

    static func write(value: GetFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetLoggingOptionsInput {

    static func write(value: GetLoggingOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetModelManifestInput {

    static func write(value: GetModelManifestInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetRegisterAccountStatusInput {

    static func write(value: GetRegisterAccountStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetSignalCatalogInput {

    static func write(value: GetSignalCatalogInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetVehicleInput {

    static func write(value: GetVehicleInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetVehicleStatusInput {

    static func write(value: GetVehicleStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ImportDecoderManifestInput {

    static func write(value: ImportDecoderManifestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["networkFileDefinitions"].writeList(value.networkFileDefinitions, memberWritingClosure: IoTFleetWiseClientTypes.NetworkFileDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ImportSignalCatalogInput {

    static func write(value: ImportSignalCatalogInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTFleetWiseClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vss"].write(value.vss, with: IoTFleetWiseClientTypes.FormattedVss.write(value:to:))
    }
}

extension ListCampaignsInput {

    static func write(value: ListCampaignsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListDecoderManifestNetworkInterfacesInput {

    static func write(value: ListDecoderManifestNetworkInterfacesInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListDecoderManifestsInput {

    static func write(value: ListDecoderManifestsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListDecoderManifestSignalsInput {

    static func write(value: ListDecoderManifestSignalsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListFleetsInput {

    static func write(value: ListFleetsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListFleetsForVehicleInput {

    static func write(value: ListFleetsForVehicleInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListModelManifestNodesInput {

    static func write(value: ListModelManifestNodesInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListModelManifestsInput {

    static func write(value: ListModelManifestsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListSignalCatalogNodesInput {

    static func write(value: ListSignalCatalogNodesInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListSignalCatalogsInput {

    static func write(value: ListSignalCatalogsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListVehiclesInput {

    static func write(value: ListVehiclesInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListVehiclesInFleetInput {

    static func write(value: ListVehiclesInFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension PutEncryptionConfigurationInput {

    static func write(value: PutEncryptionConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionType"].write(value.encryptionType)
        try writer["kmsKeyId"].write(value.kmsKeyId)
    }
}

extension PutLoggingOptionsInput {

    static func write(value: PutLoggingOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudWatchLogDelivery"].write(value.cloudWatchLogDelivery, with: IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions.write(value:to:))
    }
}

extension RegisterAccountInput {

    static func write(value: RegisterAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["iamResources"].write(value.iamResources, with: IoTFleetWiseClientTypes.IamResources.write(value:to:))
        try writer["timestreamResources"].write(value.timestreamResources, with: IoTFleetWiseClientTypes.TimestreamResources.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: IoTFleetWiseClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension UpdateCampaignInput {

    static func write(value: UpdateCampaignInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["dataExtraDimensions"].writeList(value.dataExtraDimensions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
    }
}

extension UpdateDecoderManifestInput {

    static func write(value: UpdateDecoderManifestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["networkInterfacesToAdd"].writeList(value.networkInterfacesToAdd, memberWritingClosure: IoTFleetWiseClientTypes.NetworkInterface.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["networkInterfacesToRemove"].writeList(value.networkInterfacesToRemove, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["networkInterfacesToUpdate"].writeList(value.networkInterfacesToUpdate, memberWritingClosure: IoTFleetWiseClientTypes.NetworkInterface.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["signalDecodersToAdd"].writeList(value.signalDecodersToAdd, memberWritingClosure: IoTFleetWiseClientTypes.SignalDecoder.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["signalDecodersToRemove"].writeList(value.signalDecodersToRemove, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["signalDecodersToUpdate"].writeList(value.signalDecodersToUpdate, memberWritingClosure: IoTFleetWiseClientTypes.SignalDecoder.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["status"].write(value.status)
    }
}

extension UpdateFleetInput {

    static func write(value: UpdateFleetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
    }
}

extension UpdateModelManifestInput {

    static func write(value: UpdateModelManifestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["nodesToAdd"].writeList(value.nodesToAdd, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["nodesToRemove"].writeList(value.nodesToRemove, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["status"].write(value.status)
    }
}

extension UpdateSignalCatalogInput {

    static func write(value: UpdateSignalCatalogInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["nodesToAdd"].writeList(value.nodesToAdd, memberWritingClosure: IoTFleetWiseClientTypes.Node.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["nodesToRemove"].writeList(value.nodesToRemove, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["nodesToUpdate"].writeList(value.nodesToUpdate, memberWritingClosure: IoTFleetWiseClientTypes.Node.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateVehicleInput {

    static func write(value: UpdateVehicleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributeUpdateMode"].write(value.attributeUpdateMode)
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["decoderManifestArn"].write(value.decoderManifestArn)
        try writer["modelManifestArn"].write(value.modelManifestArn)
    }
}

extension AssociateVehicleFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateVehicleFleetOutput {
        return AssociateVehicleFleetOutput()
    }
}

extension BatchCreateVehicleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchCreateVehicleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchCreateVehicleOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.CreateVehicleError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vehicles = try reader["vehicles"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.CreateVehicleResponseItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchUpdateVehicleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdateVehicleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdateVehicleOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.UpdateVehicleError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vehicles = try reader["vehicles"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.UpdateVehicleResponseItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateCampaignOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCampaignOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCampaignOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension CreateDecoderManifestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDecoderManifestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDecoderManifestOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension CreateFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFleetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFleetOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        return value
    }
}

extension CreateModelManifestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateModelManifestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateModelManifestOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension CreateSignalCatalogOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSignalCatalogOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSignalCatalogOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension CreateVehicleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVehicleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVehicleOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.thingArn = try reader["thingArn"].readIfPresent()
        value.vehicleName = try reader["vehicleName"].readIfPresent()
        return value
    }
}

extension DeleteCampaignOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCampaignOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteCampaignOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension DeleteDecoderManifestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDecoderManifestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDecoderManifestOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFleetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteFleetOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension DeleteModelManifestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteModelManifestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteModelManifestOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteSignalCatalogOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSignalCatalogOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSignalCatalogOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteVehicleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVehicleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteVehicleOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.vehicleName = try reader["vehicleName"].readIfPresent() ?? ""
        return value
    }
}

extension DisassociateVehicleFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateVehicleFleetOutput {
        return DisassociateVehicleFleetOutput()
    }
}

extension GetCampaignOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCampaignOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCampaignOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.collectionScheme = try reader["collectionScheme"].readIfPresent(with: IoTFleetWiseClientTypes.CollectionScheme.read(from:))
        value.compression = try reader["compression"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dataDestinationConfigs = try reader["dataDestinationConfigs"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.DataDestinationConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataExtraDimensions = try reader["dataExtraDimensions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.description = try reader["description"].readIfPresent()
        value.diagnosticsMode = try reader["diagnosticsMode"].readIfPresent()
        value.expiryTime = try reader["expiryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationTime = try reader["lastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.name = try reader["name"].readIfPresent()
        value.postTriggerCollectionDuration = try reader["postTriggerCollectionDuration"].readIfPresent()
        value.priority = try reader["priority"].readIfPresent()
        value.signalCatalogArn = try reader["signalCatalogArn"].readIfPresent()
        value.signalsToCollect = try reader["signalsToCollect"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.SignalInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.spoolingMode = try reader["spoolingMode"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.targetArn = try reader["targetArn"].readIfPresent()
        return value
    }
}

extension GetDecoderManifestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDecoderManifestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDecoderManifestOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.lastModificationTime = try reader["lastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.message = try reader["message"].readIfPresent()
        value.modelManifestArn = try reader["modelManifestArn"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetEncryptionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEncryptionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEncryptionConfigurationOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.encryptionStatus = try reader["encryptionStatus"].readIfPresent() ?? .sdkUnknown("")
        value.encryptionType = try reader["encryptionType"].readIfPresent() ?? .sdkUnknown("")
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.lastModificationTime = try reader["lastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GetFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFleetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFleetOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.lastModificationTime = try reader["lastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.signalCatalogArn = try reader["signalCatalogArn"].readIfPresent() ?? ""
        return value
    }
}

extension GetLoggingOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLoggingOptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLoggingOptionsOutput()
        value.cloudWatchLogDelivery = try reader["cloudWatchLogDelivery"].readIfPresent(with: IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions.read(from:))
        return value
    }
}

extension GetModelManifestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelManifestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelManifestOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.lastModificationTime = try reader["lastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.signalCatalogArn = try reader["signalCatalogArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetRegisterAccountStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRegisterAccountStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRegisterAccountStatusOutput()
        value.accountStatus = try reader["accountStatus"].readIfPresent() ?? .sdkUnknown("")
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customerAccountId = try reader["customerAccountId"].readIfPresent() ?? ""
        value.iamRegistrationResponse = try reader["iamRegistrationResponse"].readIfPresent(with: IoTFleetWiseClientTypes.IamRegistrationResponse.read(from:))
        value.lastModificationTime = try reader["lastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.timestreamRegistrationResponse = try reader["timestreamRegistrationResponse"].readIfPresent(with: IoTFleetWiseClientTypes.TimestreamRegistrationResponse.read(from:))
        return value
    }
}

extension GetSignalCatalogOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSignalCatalogOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSignalCatalogOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.lastModificationTime = try reader["lastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.nodeCounts = try reader["nodeCounts"].readIfPresent(with: IoTFleetWiseClientTypes.NodeCounts.read(from:))
        return value
    }
}

extension GetVehicleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVehicleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVehicleOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.decoderManifestArn = try reader["decoderManifestArn"].readIfPresent()
        value.lastModificationTime = try reader["lastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.modelManifestArn = try reader["modelManifestArn"].readIfPresent()
        value.vehicleName = try reader["vehicleName"].readIfPresent()
        return value
    }
}

extension GetVehicleStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVehicleStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVehicleStatusOutput()
        value.campaigns = try reader["campaigns"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.VehicleStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ImportDecoderManifestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportDecoderManifestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportDecoderManifestOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension ImportSignalCatalogOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportSignalCatalogOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportSignalCatalogOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension ListCampaignsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCampaignsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCampaignsOutput()
        value.campaignSummaries = try reader["campaignSummaries"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.CampaignSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDecoderManifestNetworkInterfacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDecoderManifestNetworkInterfacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDecoderManifestNetworkInterfacesOutput()
        value.networkInterfaces = try reader["networkInterfaces"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.NetworkInterface.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDecoderManifestsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDecoderManifestsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDecoderManifestsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.summaries = try reader["summaries"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.DecoderManifestSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListDecoderManifestSignalsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDecoderManifestSignalsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDecoderManifestSignalsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.signalDecoders = try reader["signalDecoders"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.SignalDecoder.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListFleetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFleetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFleetsOutput()
        value.fleetSummaries = try reader["fleetSummaries"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.FleetSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFleetsForVehicleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFleetsForVehicleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFleetsForVehicleOutput()
        value.fleets = try reader["fleets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListModelManifestNodesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListModelManifestNodesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListModelManifestNodesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.nodes = try reader["nodes"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.Node.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListModelManifestsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListModelManifestsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListModelManifestsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.summaries = try reader["summaries"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.ModelManifestSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSignalCatalogNodesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSignalCatalogNodesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSignalCatalogNodesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.nodes = try reader["nodes"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.Node.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSignalCatalogsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSignalCatalogsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSignalCatalogsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.summaries = try reader["summaries"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.SignalCatalogSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListVehiclesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVehiclesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVehiclesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.vehicleSummaries = try reader["vehicleSummaries"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.VehicleSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListVehiclesInFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVehiclesInFleetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVehiclesInFleetOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.vehicles = try reader["vehicles"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutEncryptionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutEncryptionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutEncryptionConfigurationOutput()
        value.encryptionStatus = try reader["encryptionStatus"].readIfPresent() ?? .sdkUnknown("")
        value.encryptionType = try reader["encryptionType"].readIfPresent() ?? .sdkUnknown("")
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        return value
    }
}

extension PutLoggingOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutLoggingOptionsOutput {
        return PutLoggingOptionsOutput()
    }
}

extension RegisterAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterAccountOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.iamResources = try reader["iamResources"].readIfPresent(with: IoTFleetWiseClientTypes.IamResources.read(from:))
        value.lastModificationTime = try reader["lastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.registerAccountStatus = try reader["registerAccountStatus"].readIfPresent() ?? .sdkUnknown("")
        value.timestreamResources = try reader["timestreamResources"].readIfPresent(with: IoTFleetWiseClientTypes.TimestreamResources.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateCampaignOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCampaignOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCampaignOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension UpdateDecoderManifestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDecoderManifestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDecoderManifestOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateFleetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFleetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFleetOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension UpdateModelManifestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateModelManifestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateModelManifestOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateSignalCatalogOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSignalCatalogOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSignalCatalogOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateVehicleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVehicleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVehicleOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.vehicleName = try reader["vehicleName"].readIfPresent()
        return value
    }
}

func httpServiceError(baseError: AWSClientRuntime.AWSJSONError) throws -> Swift.Error? {
    switch baseError.code {
        case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
        default: return nil
    }
}

enum AssociateVehicleFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchCreateVehicleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchUpdateVehicleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCampaignOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDecoderManifestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DecoderManifestValidationException": return try DecoderManifestValidationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateModelManifestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidSignalsException": return try InvalidSignalsException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSignalCatalogOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InvalidNodeException": return try InvalidNodeException.makeError(baseError: baseError)
            case "InvalidSignalsException": return try InvalidSignalsException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVehicleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCampaignOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDecoderManifestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteModelManifestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSignalCatalogOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVehicleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateVehicleFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCampaignOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDecoderManifestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEncryptionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLoggingOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelManifestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRegisterAccountStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSignalCatalogOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVehicleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVehicleStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportDecoderManifestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DecoderManifestValidationException": return try DecoderManifestValidationException.makeError(baseError: baseError)
            case "InvalidSignalsException": return try InvalidSignalsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportSignalCatalogOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidSignalsException": return try InvalidSignalsException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCampaignsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDecoderManifestNetworkInterfacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDecoderManifestsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDecoderManifestSignalsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFleetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFleetsForVehicleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListModelManifestNodesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListModelManifestsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSignalCatalogNodesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSignalCatalogsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVehiclesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVehiclesInFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutEncryptionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutLoggingOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCampaignOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDecoderManifestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DecoderManifestValidationException": return try DecoderManifestValidationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFleetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateModelManifestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidSignalsException": return try InvalidSignalsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSignalCatalogOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "InvalidNodeException": return try InvalidNodeException.makeError(baseError: baseError)
            case "InvalidSignalsException": return try InvalidSignalsException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVehicleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resource = try reader["resource"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DecoderManifestValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DecoderManifestValidationException {
        let reader = baseError.errorBodyReader
        var value = DecoderManifestValidationException()
        value.properties.invalidNetworkInterfaces = try reader["invalidNetworkInterfaces"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.InvalidNetworkInterface.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.invalidSignals = try reader["invalidSignals"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.InvalidSignalDecoder.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSignalsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidSignalsException {
        let reader = baseError.errorBodyReader
        var value = InvalidSignalsException()
        value.properties.invalidSignals = try reader["invalidSignals"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.InvalidSignal.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidNodeException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidNodeException {
        let reader = baseError.errorBodyReader
        var value = InvalidNodeException()
        value.properties.invalidNodes = try reader["invalidNodes"].readListIfPresent(memberReadingClosure: IoTFleetWiseClientTypes.Node.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IoTFleetWiseClientTypes.CreateVehicleResponseItem {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.CreateVehicleResponseItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.CreateVehicleResponseItem()
        value.vehicleName = try reader["vehicleName"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.thingArn = try reader["thingArn"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.CreateVehicleError {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.CreateVehicleError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.CreateVehicleError()
        value.vehicleName = try reader["vehicleName"].readIfPresent()
        value.code = try reader["code"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.UpdateVehicleResponseItem {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.UpdateVehicleResponseItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.UpdateVehicleResponseItem()
        value.vehicleName = try reader["vehicleName"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.UpdateVehicleError {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.UpdateVehicleError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.UpdateVehicleError()
        value.vehicleName = try reader["vehicleName"].readIfPresent()
        value.code = try reader["code"].readIfPresent() ?? 0
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.SignalInformation {

    static func write(value: IoTFleetWiseClientTypes.SignalInformation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxSampleCount"].write(value.maxSampleCount)
        try writer["minimumSamplingIntervalMs"].write(value.minimumSamplingIntervalMs)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.SignalInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.SignalInformation()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.maxSampleCount = try reader["maxSampleCount"].readIfPresent()
        value.minimumSamplingIntervalMs = try reader["minimumSamplingIntervalMs"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.CollectionScheme {

    static func write(value: IoTFleetWiseClientTypes.CollectionScheme?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .conditionbasedcollectionscheme(conditionbasedcollectionscheme):
                try writer["conditionBasedCollectionScheme"].write(conditionbasedcollectionscheme, with: IoTFleetWiseClientTypes.ConditionBasedCollectionScheme.write(value:to:))
            case let .timebasedcollectionscheme(timebasedcollectionscheme):
                try writer["timeBasedCollectionScheme"].write(timebasedcollectionscheme, with: IoTFleetWiseClientTypes.TimeBasedCollectionScheme.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.CollectionScheme {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "timeBasedCollectionScheme":
                return .timebasedcollectionscheme(try reader["timeBasedCollectionScheme"].read(with: IoTFleetWiseClientTypes.TimeBasedCollectionScheme.read(from:)))
            case "conditionBasedCollectionScheme":
                return .conditionbasedcollectionscheme(try reader["conditionBasedCollectionScheme"].read(with: IoTFleetWiseClientTypes.ConditionBasedCollectionScheme.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension IoTFleetWiseClientTypes.ConditionBasedCollectionScheme {

    static func write(value: IoTFleetWiseClientTypes.ConditionBasedCollectionScheme?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["conditionLanguageVersion"].write(value.conditionLanguageVersion)
        try writer["expression"].write(value.expression)
        try writer["minimumTriggerIntervalMs"].write(value.minimumTriggerIntervalMs)
        try writer["triggerMode"].write(value.triggerMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.ConditionBasedCollectionScheme {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.ConditionBasedCollectionScheme()
        value.expression = try reader["expression"].readIfPresent() ?? ""
        value.minimumTriggerIntervalMs = try reader["minimumTriggerIntervalMs"].readIfPresent()
        value.triggerMode = try reader["triggerMode"].readIfPresent()
        value.conditionLanguageVersion = try reader["conditionLanguageVersion"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.TimeBasedCollectionScheme {

    static func write(value: IoTFleetWiseClientTypes.TimeBasedCollectionScheme?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["periodMs"].write(value.periodMs)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.TimeBasedCollectionScheme {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.TimeBasedCollectionScheme()
        value.periodMs = try reader["periodMs"].readIfPresent() ?? 0
        return value
    }
}

extension IoTFleetWiseClientTypes.DataDestinationConfig {

    static func write(value: IoTFleetWiseClientTypes.DataDestinationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3config(s3config):
                try writer["s3Config"].write(s3config, with: IoTFleetWiseClientTypes.S3Config.write(value:to:))
            case let .timestreamconfig(timestreamconfig):
                try writer["timestreamConfig"].write(timestreamconfig, with: IoTFleetWiseClientTypes.TimestreamConfig.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.DataDestinationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3Config":
                return .s3config(try reader["s3Config"].read(with: IoTFleetWiseClientTypes.S3Config.read(from:)))
            case "timestreamConfig":
                return .timestreamconfig(try reader["timestreamConfig"].read(with: IoTFleetWiseClientTypes.TimestreamConfig.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension IoTFleetWiseClientTypes.TimestreamConfig {

    static func write(value: IoTFleetWiseClientTypes.TimestreamConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["executionRoleArn"].write(value.executionRoleArn)
        try writer["timestreamTableArn"].write(value.timestreamTableArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.TimestreamConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.TimestreamConfig()
        value.timestreamTableArn = try reader["timestreamTableArn"].readIfPresent() ?? ""
        value.executionRoleArn = try reader["executionRoleArn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTFleetWiseClientTypes.S3Config {

    static func write(value: IoTFleetWiseClientTypes.S3Config?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketArn"].write(value.bucketArn)
        try writer["dataFormat"].write(value.dataFormat)
        try writer["prefix"].write(value.`prefix`)
        try writer["storageCompressionFormat"].write(value.storageCompressionFormat)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.S3Config {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.S3Config()
        value.bucketArn = try reader["bucketArn"].readIfPresent() ?? ""
        value.dataFormat = try reader["dataFormat"].readIfPresent()
        value.storageCompressionFormat = try reader["storageCompressionFormat"].readIfPresent()
        value.`prefix` = try reader["prefix"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions {

    static func write(value: IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["logGroupName"].write(value.logGroupName)
        try writer["logType"].write(value.logType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.CloudWatchLogDeliveryOptions()
        value.logType = try reader["logType"].readIfPresent() ?? .sdkUnknown("")
        value.logGroupName = try reader["logGroupName"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.TimestreamRegistrationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.TimestreamRegistrationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.TimestreamRegistrationResponse()
        value.timestreamDatabaseName = try reader["timestreamDatabaseName"].readIfPresent() ?? ""
        value.timestreamTableName = try reader["timestreamTableName"].readIfPresent() ?? ""
        value.timestreamDatabaseArn = try reader["timestreamDatabaseArn"].readIfPresent()
        value.timestreamTableArn = try reader["timestreamTableArn"].readIfPresent()
        value.registrationStatus = try reader["registrationStatus"].readIfPresent() ?? .sdkUnknown("")
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.IamRegistrationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.IamRegistrationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.IamRegistrationResponse()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.registrationStatus = try reader["registrationStatus"].readIfPresent() ?? .sdkUnknown("")
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.NodeCounts {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.NodeCounts {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.NodeCounts()
        value.totalNodes = try reader["totalNodes"].readIfPresent() ?? 0
        value.totalBranches = try reader["totalBranches"].readIfPresent() ?? 0
        value.totalSensors = try reader["totalSensors"].readIfPresent() ?? 0
        value.totalAttributes = try reader["totalAttributes"].readIfPresent() ?? 0
        value.totalActuators = try reader["totalActuators"].readIfPresent() ?? 0
        value.totalStructs = try reader["totalStructs"].readIfPresent() ?? 0
        value.totalProperties = try reader["totalProperties"].readIfPresent() ?? 0
        return value
    }
}

extension IoTFleetWiseClientTypes.VehicleStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.VehicleStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.VehicleStatus()
        value.campaignName = try reader["campaignName"].readIfPresent()
        value.vehicleName = try reader["vehicleName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.CampaignSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.CampaignSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.CampaignSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.signalCatalogArn = try reader["signalCatalogArn"].readIfPresent()
        value.targetArn = try reader["targetArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModificationTime = try reader["lastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension IoTFleetWiseClientTypes.NetworkInterface {

    static func write(value: IoTFleetWiseClientTypes.NetworkInterface?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["canInterface"].write(value.canInterface, with: IoTFleetWiseClientTypes.CanInterface.write(value:to:))
        try writer["interfaceId"].write(value.interfaceId)
        try writer["obdInterface"].write(value.obdInterface, with: IoTFleetWiseClientTypes.ObdInterface.write(value:to:))
        try writer["type"].write(value.type)
        try writer["vehicleMiddleware"].write(value.vehicleMiddleware, with: IoTFleetWiseClientTypes.VehicleMiddleware.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.NetworkInterface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.NetworkInterface()
        value.interfaceId = try reader["interfaceId"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.canInterface = try reader["canInterface"].readIfPresent(with: IoTFleetWiseClientTypes.CanInterface.read(from:))
        value.obdInterface = try reader["obdInterface"].readIfPresent(with: IoTFleetWiseClientTypes.ObdInterface.read(from:))
        value.vehicleMiddleware = try reader["vehicleMiddleware"].readIfPresent(with: IoTFleetWiseClientTypes.VehicleMiddleware.read(from:))
        return value
    }
}

extension IoTFleetWiseClientTypes.VehicleMiddleware {

    static func write(value: IoTFleetWiseClientTypes.VehicleMiddleware?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["protocolName"].write(value.protocolName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.VehicleMiddleware {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.VehicleMiddleware()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.protocolName = try reader["protocolName"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTFleetWiseClientTypes.ObdInterface {

    static func write(value: IoTFleetWiseClientTypes.ObdInterface?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dtcRequestIntervalSeconds"].write(value.dtcRequestIntervalSeconds)
        try writer["hasTransmissionEcu"].write(value.hasTransmissionEcu)
        try writer["name"].write(value.name)
        try writer["obdStandard"].write(value.obdStandard)
        try writer["pidRequestIntervalSeconds"].write(value.pidRequestIntervalSeconds)
        try writer["requestMessageId"].write(value.requestMessageId)
        try writer["useExtendedIds"].write(value.useExtendedIds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.ObdInterface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.ObdInterface()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.requestMessageId = try reader["requestMessageId"].readIfPresent() ?? 0
        value.obdStandard = try reader["obdStandard"].readIfPresent()
        value.pidRequestIntervalSeconds = try reader["pidRequestIntervalSeconds"].readIfPresent() ?? 0
        value.dtcRequestIntervalSeconds = try reader["dtcRequestIntervalSeconds"].readIfPresent() ?? 0
        value.useExtendedIds = try reader["useExtendedIds"].readIfPresent() ?? false
        value.hasTransmissionEcu = try reader["hasTransmissionEcu"].readIfPresent() ?? false
        return value
    }
}

extension IoTFleetWiseClientTypes.CanInterface {

    static func write(value: IoTFleetWiseClientTypes.CanInterface?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["protocolName"].write(value.protocolName)
        try writer["protocolVersion"].write(value.protocolVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.CanInterface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.CanInterface()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.protocolName = try reader["protocolName"].readIfPresent()
        value.protocolVersion = try reader["protocolVersion"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.DecoderManifestSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.DecoderManifestSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.DecoderManifestSummary()
        value.name = try reader["name"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.modelManifestArn = try reader["modelManifestArn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModificationTime = try reader["lastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.SignalDecoder {

    static func write(value: IoTFleetWiseClientTypes.SignalDecoder?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["canSignal"].write(value.canSignal, with: IoTFleetWiseClientTypes.CanSignal.write(value:to:))
        try writer["fullyQualifiedName"].write(value.fullyQualifiedName)
        try writer["interfaceId"].write(value.interfaceId)
        try writer["messageSignal"].write(value.messageSignal, with: IoTFleetWiseClientTypes.MessageSignal.write(value:to:))
        try writer["obdSignal"].write(value.obdSignal, with: IoTFleetWiseClientTypes.ObdSignal.write(value:to:))
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.SignalDecoder {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.SignalDecoder()
        value.fullyQualifiedName = try reader["fullyQualifiedName"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.interfaceId = try reader["interfaceId"].readIfPresent() ?? ""
        value.canSignal = try reader["canSignal"].readIfPresent(with: IoTFleetWiseClientTypes.CanSignal.read(from:))
        value.obdSignal = try reader["obdSignal"].readIfPresent(with: IoTFleetWiseClientTypes.ObdSignal.read(from:))
        value.messageSignal = try reader["messageSignal"].readIfPresent(with: IoTFleetWiseClientTypes.MessageSignal.read(from:))
        return value
    }
}

extension IoTFleetWiseClientTypes.MessageSignal {

    static func write(value: IoTFleetWiseClientTypes.MessageSignal?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["structuredMessage"].write(value.structuredMessage, with: IoTFleetWiseClientTypes.StructuredMessage.write(value:to:))
        try writer["topicName"].write(value.topicName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.MessageSignal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.MessageSignal()
        value.topicName = try reader["topicName"].readIfPresent() ?? ""
        value.structuredMessage = try reader["structuredMessage"].readIfPresent(with: IoTFleetWiseClientTypes.StructuredMessage.read(from:))
        return value
    }
}

extension IoTFleetWiseClientTypes.StructuredMessage {

    static func write(value: IoTFleetWiseClientTypes.StructuredMessage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .primitivemessagedefinition(primitivemessagedefinition):
                try writer["primitiveMessageDefinition"].write(primitivemessagedefinition, with: IoTFleetWiseClientTypes.PrimitiveMessageDefinition.write(value:to:))
            case let .structuredmessagedefinition(structuredmessagedefinition):
                try writer["structuredMessageDefinition"].writeList(structuredmessagedefinition, memberWritingClosure: IoTFleetWiseClientTypes.StructuredMessageFieldNameAndDataTypePair.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .structuredmessagelistdefinition(structuredmessagelistdefinition):
                try writer["structuredMessageListDefinition"].write(structuredmessagelistdefinition, with: IoTFleetWiseClientTypes.StructuredMessageListDefinition.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.StructuredMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "primitiveMessageDefinition":
                return .primitivemessagedefinition(try reader["primitiveMessageDefinition"].read(with: IoTFleetWiseClientTypes.PrimitiveMessageDefinition.read(from:)))
            case "structuredMessageListDefinition":
                return .structuredmessagelistdefinition(try reader["structuredMessageListDefinition"].read(with: IoTFleetWiseClientTypes.StructuredMessageListDefinition.read(from:)))
            case "structuredMessageDefinition":
                return .structuredmessagedefinition(try reader["structuredMessageDefinition"].readList(memberReadingClosure: IoTFleetWiseClientTypes.StructuredMessageFieldNameAndDataTypePair.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension IoTFleetWiseClientTypes.StructuredMessageFieldNameAndDataTypePair {

    static func write(value: IoTFleetWiseClientTypes.StructuredMessageFieldNameAndDataTypePair?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataType"].write(value.dataType, with: IoTFleetWiseClientTypes.StructuredMessage.write(value:to:))
        try writer["fieldName"].write(value.fieldName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.StructuredMessageFieldNameAndDataTypePair {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.StructuredMessageFieldNameAndDataTypePair()
        value.fieldName = try reader["fieldName"].readIfPresent() ?? ""
        value.dataType = try reader["dataType"].readIfPresent(with: IoTFleetWiseClientTypes.StructuredMessage.read(from:))
        return value
    }
}

extension IoTFleetWiseClientTypes.StructuredMessageListDefinition {

    static func write(value: IoTFleetWiseClientTypes.StructuredMessageListDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capacity"].write(value.capacity)
        try writer["listType"].write(value.listType)
        try writer["memberType"].write(value.memberType, with: IoTFleetWiseClientTypes.StructuredMessage.write(value:to:))
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.StructuredMessageListDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.StructuredMessageListDefinition()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.memberType = try reader["memberType"].readIfPresent(with: IoTFleetWiseClientTypes.StructuredMessage.read(from:))
        value.listType = try reader["listType"].readIfPresent() ?? .sdkUnknown("")
        value.capacity = try reader["capacity"].readIfPresent() ?? 0
        return value
    }
}

extension IoTFleetWiseClientTypes.PrimitiveMessageDefinition {

    static func write(value: IoTFleetWiseClientTypes.PrimitiveMessageDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .ros2primitivemessagedefinition(ros2primitivemessagedefinition):
                try writer["ros2PrimitiveMessageDefinition"].write(ros2primitivemessagedefinition, with: IoTFleetWiseClientTypes.ROS2PrimitiveMessageDefinition.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.PrimitiveMessageDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "ros2PrimitiveMessageDefinition":
                return .ros2primitivemessagedefinition(try reader["ros2PrimitiveMessageDefinition"].read(with: IoTFleetWiseClientTypes.ROS2PrimitiveMessageDefinition.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension IoTFleetWiseClientTypes.ROS2PrimitiveMessageDefinition {

    static func write(value: IoTFleetWiseClientTypes.ROS2PrimitiveMessageDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["offset"].write(value.offset)
        try writer["primitiveType"].write(value.primitiveType)
        try writer["scaling"].write(value.scaling)
        try writer["upperBound"].write(value.upperBound)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.ROS2PrimitiveMessageDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.ROS2PrimitiveMessageDefinition()
        value.primitiveType = try reader["primitiveType"].readIfPresent() ?? .sdkUnknown("")
        value.offset = try reader["offset"].readIfPresent()
        value.scaling = try reader["scaling"].readIfPresent()
        value.upperBound = try reader["upperBound"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.ObdSignal {

    static func write(value: IoTFleetWiseClientTypes.ObdSignal?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bitMaskLength"].write(value.bitMaskLength)
        try writer["bitRightShift"].write(value.bitRightShift)
        try writer["byteLength"].write(value.byteLength)
        try writer["offset"].write(value.offset)
        try writer["pid"].write(value.pid)
        try writer["pidResponseLength"].write(value.pidResponseLength)
        try writer["scaling"].write(value.scaling)
        try writer["serviceMode"].write(value.serviceMode)
        try writer["startByte"].write(value.startByte)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.ObdSignal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.ObdSignal()
        value.pidResponseLength = try reader["pidResponseLength"].readIfPresent() ?? 0
        value.serviceMode = try reader["serviceMode"].readIfPresent() ?? 0
        value.pid = try reader["pid"].readIfPresent() ?? 0
        value.scaling = try reader["scaling"].readIfPresent() ?? 0.0
        value.offset = try reader["offset"].readIfPresent() ?? 0.0
        value.startByte = try reader["startByte"].readIfPresent() ?? 0
        value.byteLength = try reader["byteLength"].readIfPresent() ?? 0
        value.bitRightShift = try reader["bitRightShift"].readIfPresent() ?? 0
        value.bitMaskLength = try reader["bitMaskLength"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.CanSignal {

    static func write(value: IoTFleetWiseClientTypes.CanSignal?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["factor"].write(value.factor)
        try writer["isBigEndian"].write(value.isBigEndian)
        try writer["isSigned"].write(value.isSigned)
        try writer["length"].write(value.length)
        try writer["messageId"].write(value.messageId)
        try writer["name"].write(value.name)
        try writer["offset"].write(value.offset)
        try writer["startBit"].write(value.startBit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.CanSignal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.CanSignal()
        value.messageId = try reader["messageId"].readIfPresent() ?? 0
        value.isBigEndian = try reader["isBigEndian"].readIfPresent() ?? false
        value.isSigned = try reader["isSigned"].readIfPresent() ?? false
        value.startBit = try reader["startBit"].readIfPresent() ?? 0
        value.offset = try reader["offset"].readIfPresent() ?? 0.0
        value.factor = try reader["factor"].readIfPresent() ?? 0.0
        value.length = try reader["length"].readIfPresent() ?? 0
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.FleetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.FleetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.FleetSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.signalCatalogArn = try reader["signalCatalogArn"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModificationTime = try reader["lastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTFleetWiseClientTypes.Node {

    static func write(value: IoTFleetWiseClientTypes.Node?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .actuator(actuator):
                try writer["actuator"].write(actuator, with: IoTFleetWiseClientTypes.Actuator.write(value:to:))
            case let .attribute(attribute):
                try writer["attribute"].write(attribute, with: IoTFleetWiseClientTypes.Attribute.write(value:to:))
            case let .branch(branch):
                try writer["branch"].write(branch, with: IoTFleetWiseClientTypes.Branch.write(value:to:))
            case let .property(property):
                try writer["property"].write(property, with: IoTFleetWiseClientTypes.CustomProperty.write(value:to:))
            case let .sensor(sensor):
                try writer["sensor"].write(sensor, with: IoTFleetWiseClientTypes.Sensor.write(value:to:))
            case let .`struct`(`struct`):
                try writer["struct"].write(`struct`, with: IoTFleetWiseClientTypes.CustomStruct.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.Node {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "branch":
                return .branch(try reader["branch"].read(with: IoTFleetWiseClientTypes.Branch.read(from:)))
            case "sensor":
                return .sensor(try reader["sensor"].read(with: IoTFleetWiseClientTypes.Sensor.read(from:)))
            case "actuator":
                return .actuator(try reader["actuator"].read(with: IoTFleetWiseClientTypes.Actuator.read(from:)))
            case "attribute":
                return .attribute(try reader["attribute"].read(with: IoTFleetWiseClientTypes.Attribute.read(from:)))
            case "struct":
                return .`struct`(try reader["struct"].read(with: IoTFleetWiseClientTypes.CustomStruct.read(from:)))
            case "property":
                return .property(try reader["property"].read(with: IoTFleetWiseClientTypes.CustomProperty.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension IoTFleetWiseClientTypes.CustomProperty {

    static func write(value: IoTFleetWiseClientTypes.CustomProperty?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comment"].write(value.comment)
        try writer["dataEncoding"].write(value.dataEncoding)
        try writer["dataType"].write(value.dataType)
        try writer["deprecationMessage"].write(value.deprecationMessage)
        try writer["description"].write(value.description)
        try writer["fullyQualifiedName"].write(value.fullyQualifiedName)
        try writer["structFullyQualifiedName"].write(value.structFullyQualifiedName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.CustomProperty {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.CustomProperty()
        value.fullyQualifiedName = try reader["fullyQualifiedName"].readIfPresent() ?? ""
        value.dataType = try reader["dataType"].readIfPresent() ?? .sdkUnknown("")
        value.dataEncoding = try reader["dataEncoding"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.deprecationMessage = try reader["deprecationMessage"].readIfPresent()
        value.comment = try reader["comment"].readIfPresent()
        value.structFullyQualifiedName = try reader["structFullyQualifiedName"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.CustomStruct {

    static func write(value: IoTFleetWiseClientTypes.CustomStruct?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comment"].write(value.comment)
        try writer["deprecationMessage"].write(value.deprecationMessage)
        try writer["description"].write(value.description)
        try writer["fullyQualifiedName"].write(value.fullyQualifiedName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.CustomStruct {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.CustomStruct()
        value.fullyQualifiedName = try reader["fullyQualifiedName"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.deprecationMessage = try reader["deprecationMessage"].readIfPresent()
        value.comment = try reader["comment"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.Attribute {

    static func write(value: IoTFleetWiseClientTypes.Attribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowedValues"].writeList(value.allowedValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["assignedValue"].write(value.assignedValue)
        try writer["comment"].write(value.comment)
        try writer["dataType"].write(value.dataType)
        try writer["defaultValue"].write(value.defaultValue)
        try writer["deprecationMessage"].write(value.deprecationMessage)
        try writer["description"].write(value.description)
        try writer["fullyQualifiedName"].write(value.fullyQualifiedName)
        try writer["max"].write(value.max)
        try writer["min"].write(value.min)
        try writer["unit"].write(value.unit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.Attribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.Attribute()
        value.fullyQualifiedName = try reader["fullyQualifiedName"].readIfPresent() ?? ""
        value.dataType = try reader["dataType"].readIfPresent() ?? .sdkUnknown("")
        value.description = try reader["description"].readIfPresent()
        value.unit = try reader["unit"].readIfPresent()
        value.allowedValues = try reader["allowedValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.min = try reader["min"].readIfPresent()
        value.max = try reader["max"].readIfPresent()
        value.assignedValue = try reader["assignedValue"].readIfPresent()
        value.defaultValue = try reader["defaultValue"].readIfPresent()
        value.deprecationMessage = try reader["deprecationMessage"].readIfPresent()
        value.comment = try reader["comment"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.Actuator {

    static func write(value: IoTFleetWiseClientTypes.Actuator?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowedValues"].writeList(value.allowedValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["assignedValue"].write(value.assignedValue)
        try writer["comment"].write(value.comment)
        try writer["dataType"].write(value.dataType)
        try writer["deprecationMessage"].write(value.deprecationMessage)
        try writer["description"].write(value.description)
        try writer["fullyQualifiedName"].write(value.fullyQualifiedName)
        try writer["max"].write(value.max)
        try writer["min"].write(value.min)
        try writer["structFullyQualifiedName"].write(value.structFullyQualifiedName)
        try writer["unit"].write(value.unit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.Actuator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.Actuator()
        value.fullyQualifiedName = try reader["fullyQualifiedName"].readIfPresent() ?? ""
        value.dataType = try reader["dataType"].readIfPresent() ?? .sdkUnknown("")
        value.description = try reader["description"].readIfPresent()
        value.unit = try reader["unit"].readIfPresent()
        value.allowedValues = try reader["allowedValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.min = try reader["min"].readIfPresent()
        value.max = try reader["max"].readIfPresent()
        value.assignedValue = try reader["assignedValue"].readIfPresent()
        value.deprecationMessage = try reader["deprecationMessage"].readIfPresent()
        value.comment = try reader["comment"].readIfPresent()
        value.structFullyQualifiedName = try reader["structFullyQualifiedName"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.Sensor {

    static func write(value: IoTFleetWiseClientTypes.Sensor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowedValues"].writeList(value.allowedValues, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["comment"].write(value.comment)
        try writer["dataType"].write(value.dataType)
        try writer["deprecationMessage"].write(value.deprecationMessage)
        try writer["description"].write(value.description)
        try writer["fullyQualifiedName"].write(value.fullyQualifiedName)
        try writer["max"].write(value.max)
        try writer["min"].write(value.min)
        try writer["structFullyQualifiedName"].write(value.structFullyQualifiedName)
        try writer["unit"].write(value.unit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.Sensor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.Sensor()
        value.fullyQualifiedName = try reader["fullyQualifiedName"].readIfPresent() ?? ""
        value.dataType = try reader["dataType"].readIfPresent() ?? .sdkUnknown("")
        value.description = try reader["description"].readIfPresent()
        value.unit = try reader["unit"].readIfPresent()
        value.allowedValues = try reader["allowedValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.min = try reader["min"].readIfPresent()
        value.max = try reader["max"].readIfPresent()
        value.deprecationMessage = try reader["deprecationMessage"].readIfPresent()
        value.comment = try reader["comment"].readIfPresent()
        value.structFullyQualifiedName = try reader["structFullyQualifiedName"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.Branch {

    static func write(value: IoTFleetWiseClientTypes.Branch?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["comment"].write(value.comment)
        try writer["deprecationMessage"].write(value.deprecationMessage)
        try writer["description"].write(value.description)
        try writer["fullyQualifiedName"].write(value.fullyQualifiedName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.Branch {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.Branch()
        value.fullyQualifiedName = try reader["fullyQualifiedName"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.deprecationMessage = try reader["deprecationMessage"].readIfPresent()
        value.comment = try reader["comment"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.ModelManifestSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.ModelManifestSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.ModelManifestSummary()
        value.name = try reader["name"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.signalCatalogArn = try reader["signalCatalogArn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModificationTime = try reader["lastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension IoTFleetWiseClientTypes.SignalCatalogSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.SignalCatalogSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.SignalCatalogSummary()
        value.name = try reader["name"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModificationTime = try reader["lastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTFleetWiseClientTypes.Tag {

    static func write(value: IoTFleetWiseClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension IoTFleetWiseClientTypes.VehicleSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.VehicleSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.VehicleSummary()
        value.vehicleName = try reader["vehicleName"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.modelManifestArn = try reader["modelManifestArn"].readIfPresent() ?? ""
        value.decoderManifestArn = try reader["decoderManifestArn"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModificationTime = try reader["lastModificationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IoTFleetWiseClientTypes.TimestreamResources {

    static func write(value: IoTFleetWiseClientTypes.TimestreamResources?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["timestreamDatabaseName"].write(value.timestreamDatabaseName)
        try writer["timestreamTableName"].write(value.timestreamTableName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.TimestreamResources {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.TimestreamResources()
        value.timestreamDatabaseName = try reader["timestreamDatabaseName"].readIfPresent() ?? ""
        value.timestreamTableName = try reader["timestreamTableName"].readIfPresent() ?? ""
        return value
    }
}

extension IoTFleetWiseClientTypes.IamResources {

    static func write(value: IoTFleetWiseClientTypes.IamResources?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.IamResources {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.IamResources()
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTFleetWiseClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension IoTFleetWiseClientTypes.InvalidSignalDecoder {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.InvalidSignalDecoder {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.InvalidSignalDecoder()
        value.name = try reader["name"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        value.hint = try reader["hint"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.InvalidNetworkInterface {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.InvalidNetworkInterface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.InvalidNetworkInterface()
        value.interfaceId = try reader["interfaceId"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.InvalidSignal {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTFleetWiseClientTypes.InvalidSignal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTFleetWiseClientTypes.InvalidSignal()
        value.name = try reader["name"].readIfPresent()
        value.reason = try reader["reason"].readIfPresent()
        return value
    }
}

extension IoTFleetWiseClientTypes.CreateVehicleRequestItem {

    static func write(value: IoTFleetWiseClientTypes.CreateVehicleRequestItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["associationBehavior"].write(value.associationBehavior)
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["decoderManifestArn"].write(value.decoderManifestArn)
        try writer["modelManifestArn"].write(value.modelManifestArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: IoTFleetWiseClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vehicleName"].write(value.vehicleName)
    }
}

extension IoTFleetWiseClientTypes.UpdateVehicleRequestItem {

    static func write(value: IoTFleetWiseClientTypes.UpdateVehicleRequestItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attributeUpdateMode"].write(value.attributeUpdateMode)
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["decoderManifestArn"].write(value.decoderManifestArn)
        try writer["modelManifestArn"].write(value.modelManifestArn)
        try writer["vehicleName"].write(value.vehicleName)
    }
}

extension IoTFleetWiseClientTypes.NetworkFileDefinition {

    static func write(value: IoTFleetWiseClientTypes.NetworkFileDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .candbc(candbc):
                try writer["canDbc"].write(candbc, with: IoTFleetWiseClientTypes.CanDbcDefinition.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension IoTFleetWiseClientTypes.CanDbcDefinition {

    static func write(value: IoTFleetWiseClientTypes.CanDbcDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["canDbcFiles"].writeList(value.canDbcFiles, memberWritingClosure: SmithyReadWrite.WritingClosures.writeData(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["networkInterface"].write(value.networkInterface)
        try writer["signalsMap"].writeMap(value.signalsMap, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension IoTFleetWiseClientTypes.FormattedVss {

    static func write(value: IoTFleetWiseClientTypes.FormattedVss?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .vssjson(vssjson):
                try writer["vssJson"].write(vssjson)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

public enum IoTFleetWiseClientTypes {}
