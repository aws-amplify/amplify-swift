//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension ImagebuilderClient {
    /// Paginate over `[ListComponentBuildVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListComponentBuildVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListComponentBuildVersionsOutput`
    public func listComponentBuildVersionsPaginated(input: ListComponentBuildVersionsInput) -> ClientRuntime.PaginatorSequence<ListComponentBuildVersionsInput, ListComponentBuildVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListComponentBuildVersionsInput, ListComponentBuildVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listComponentBuildVersions(input:))
    }
}

extension ListComponentBuildVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListComponentBuildVersionsInput {
        return ListComponentBuildVersionsInput(
            componentVersionArn: self.componentVersionArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListComponentBuildVersionsInput, OperationStackOutput == ListComponentBuildVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listComponentBuildVersionsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ComponentSummary]`
    /// - Returns: `[ImagebuilderClientTypes.ComponentSummary]`
    public func componentSummaryList() async throws -> [ImagebuilderClientTypes.ComponentSummary] {
        return try await self.asyncCompactMap { item in item.componentSummaryList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListComponentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListComponentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListComponentsOutput`
    public func listComponentsPaginated(input: ListComponentsInput) -> ClientRuntime.PaginatorSequence<ListComponentsInput, ListComponentsOutput> {
        return ClientRuntime.PaginatorSequence<ListComponentsInput, ListComponentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listComponents(input:))
    }
}

extension ListComponentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListComponentsInput {
        return ListComponentsInput(
            byName: self.byName,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )}
}

extension PaginatorSequence where OperationStackInput == ListComponentsInput, OperationStackOutput == ListComponentsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listComponentsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ComponentVersion]`
    /// - Returns: `[ImagebuilderClientTypes.ComponentVersion]`
    public func componentVersionList() async throws -> [ImagebuilderClientTypes.ComponentVersion] {
        return try await self.asyncCompactMap { item in item.componentVersionList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListContainerRecipesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListContainerRecipesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListContainerRecipesOutput`
    public func listContainerRecipesPaginated(input: ListContainerRecipesInput) -> ClientRuntime.PaginatorSequence<ListContainerRecipesInput, ListContainerRecipesOutput> {
        return ClientRuntime.PaginatorSequence<ListContainerRecipesInput, ListContainerRecipesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listContainerRecipes(input:))
    }
}

extension ListContainerRecipesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListContainerRecipesInput {
        return ListContainerRecipesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )}
}

extension PaginatorSequence where OperationStackInput == ListContainerRecipesInput, OperationStackOutput == ListContainerRecipesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listContainerRecipesPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ContainerRecipeSummary]`
    /// - Returns: `[ImagebuilderClientTypes.ContainerRecipeSummary]`
    public func containerRecipeSummaryList() async throws -> [ImagebuilderClientTypes.ContainerRecipeSummary] {
        return try await self.asyncCompactMap { item in item.containerRecipeSummaryList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListDistributionConfigurationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDistributionConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDistributionConfigurationsOutput`
    public func listDistributionConfigurationsPaginated(input: ListDistributionConfigurationsInput) -> ClientRuntime.PaginatorSequence<ListDistributionConfigurationsInput, ListDistributionConfigurationsOutput> {
        return ClientRuntime.PaginatorSequence<ListDistributionConfigurationsInput, ListDistributionConfigurationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDistributionConfigurations(input:))
    }
}

extension ListDistributionConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDistributionConfigurationsInput {
        return ListDistributionConfigurationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDistributionConfigurationsInput, OperationStackOutput == ListDistributionConfigurationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDistributionConfigurationsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.DistributionConfigurationSummary]`
    /// - Returns: `[ImagebuilderClientTypes.DistributionConfigurationSummary]`
    public func distributionConfigurationSummaryList() async throws -> [ImagebuilderClientTypes.DistributionConfigurationSummary] {
        return try await self.asyncCompactMap { item in item.distributionConfigurationSummaryList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListImageBuildVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImageBuildVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImageBuildVersionsOutput`
    public func listImageBuildVersionsPaginated(input: ListImageBuildVersionsInput) -> ClientRuntime.PaginatorSequence<ListImageBuildVersionsInput, ListImageBuildVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListImageBuildVersionsInput, ListImageBuildVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listImageBuildVersions(input:))
    }
}

extension ListImageBuildVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImageBuildVersionsInput {
        return ListImageBuildVersionsInput(
            filters: self.filters,
            imageVersionArn: self.imageVersionArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListImageBuildVersionsInput, OperationStackOutput == ListImageBuildVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listImageBuildVersionsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ImageSummary]`
    /// - Returns: `[ImagebuilderClientTypes.ImageSummary]`
    public func imageSummaryList() async throws -> [ImagebuilderClientTypes.ImageSummary] {
        return try await self.asyncCompactMap { item in item.imageSummaryList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListImagePackagesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImagePackagesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImagePackagesOutput`
    public func listImagePackagesPaginated(input: ListImagePackagesInput) -> ClientRuntime.PaginatorSequence<ListImagePackagesInput, ListImagePackagesOutput> {
        return ClientRuntime.PaginatorSequence<ListImagePackagesInput, ListImagePackagesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listImagePackages(input:))
    }
}

extension ListImagePackagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImagePackagesInput {
        return ListImagePackagesInput(
            imageBuildVersionArn: self.imageBuildVersionArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListImagePackagesInput, OperationStackOutput == ListImagePackagesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listImagePackagesPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ImagePackage]`
    /// - Returns: `[ImagebuilderClientTypes.ImagePackage]`
    public func imagePackageList() async throws -> [ImagebuilderClientTypes.ImagePackage] {
        return try await self.asyncCompactMap { item in item.imagePackageList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListImagePipelineImagesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImagePipelineImagesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImagePipelineImagesOutput`
    public func listImagePipelineImagesPaginated(input: ListImagePipelineImagesInput) -> ClientRuntime.PaginatorSequence<ListImagePipelineImagesInput, ListImagePipelineImagesOutput> {
        return ClientRuntime.PaginatorSequence<ListImagePipelineImagesInput, ListImagePipelineImagesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listImagePipelineImages(input:))
    }
}

extension ListImagePipelineImagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImagePipelineImagesInput {
        return ListImagePipelineImagesInput(
            filters: self.filters,
            imagePipelineArn: self.imagePipelineArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListImagePipelineImagesInput, OperationStackOutput == ListImagePipelineImagesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listImagePipelineImagesPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ImageSummary]`
    /// - Returns: `[ImagebuilderClientTypes.ImageSummary]`
    public func imageSummaryList() async throws -> [ImagebuilderClientTypes.ImageSummary] {
        return try await self.asyncCompactMap { item in item.imageSummaryList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListImagePipelinesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImagePipelinesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImagePipelinesOutput`
    public func listImagePipelinesPaginated(input: ListImagePipelinesInput) -> ClientRuntime.PaginatorSequence<ListImagePipelinesInput, ListImagePipelinesOutput> {
        return ClientRuntime.PaginatorSequence<ListImagePipelinesInput, ListImagePipelinesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listImagePipelines(input:))
    }
}

extension ListImagePipelinesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImagePipelinesInput {
        return ListImagePipelinesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListImagePipelinesInput, OperationStackOutput == ListImagePipelinesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listImagePipelinesPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ImagePipeline]`
    /// - Returns: `[ImagebuilderClientTypes.ImagePipeline]`
    public func imagePipelineList() async throws -> [ImagebuilderClientTypes.ImagePipeline] {
        return try await self.asyncCompactMap { item in item.imagePipelineList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListImageRecipesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImageRecipesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImageRecipesOutput`
    public func listImageRecipesPaginated(input: ListImageRecipesInput) -> ClientRuntime.PaginatorSequence<ListImageRecipesInput, ListImageRecipesOutput> {
        return ClientRuntime.PaginatorSequence<ListImageRecipesInput, ListImageRecipesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listImageRecipes(input:))
    }
}

extension ListImageRecipesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImageRecipesInput {
        return ListImageRecipesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )}
}

extension PaginatorSequence where OperationStackInput == ListImageRecipesInput, OperationStackOutput == ListImageRecipesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listImageRecipesPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ImageRecipeSummary]`
    /// - Returns: `[ImagebuilderClientTypes.ImageRecipeSummary]`
    public func imageRecipeSummaryList() async throws -> [ImagebuilderClientTypes.ImageRecipeSummary] {
        return try await self.asyncCompactMap { item in item.imageRecipeSummaryList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListImagesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImagesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImagesOutput`
    public func listImagesPaginated(input: ListImagesInput) -> ClientRuntime.PaginatorSequence<ListImagesInput, ListImagesOutput> {
        return ClientRuntime.PaginatorSequence<ListImagesInput, ListImagesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listImages(input:))
    }
}

extension ListImagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImagesInput {
        return ListImagesInput(
            byName: self.byName,
            filters: self.filters,
            includeDeprecated: self.includeDeprecated,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )}
}

extension PaginatorSequence where OperationStackInput == ListImagesInput, OperationStackOutput == ListImagesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listImagesPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ImageVersion]`
    /// - Returns: `[ImagebuilderClientTypes.ImageVersion]`
    public func imageVersionList() async throws -> [ImagebuilderClientTypes.ImageVersion] {
        return try await self.asyncCompactMap { item in item.imageVersionList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListImageScanFindingAggregationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImageScanFindingAggregationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImageScanFindingAggregationsOutput`
    public func listImageScanFindingAggregationsPaginated(input: ListImageScanFindingAggregationsInput) -> ClientRuntime.PaginatorSequence<ListImageScanFindingAggregationsInput, ListImageScanFindingAggregationsOutput> {
        return ClientRuntime.PaginatorSequence<ListImageScanFindingAggregationsInput, ListImageScanFindingAggregationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listImageScanFindingAggregations(input:))
    }
}

extension ListImageScanFindingAggregationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImageScanFindingAggregationsInput {
        return ListImageScanFindingAggregationsInput(
            filter: self.filter,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListImageScanFindingAggregationsInput, OperationStackOutput == ListImageScanFindingAggregationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listImageScanFindingAggregationsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ImageScanFindingAggregation]`
    /// - Returns: `[ImagebuilderClientTypes.ImageScanFindingAggregation]`
    public func responses() async throws -> [ImagebuilderClientTypes.ImageScanFindingAggregation] {
        return try await self.asyncCompactMap { item in item.responses }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListImageScanFindingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImageScanFindingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImageScanFindingsOutput`
    public func listImageScanFindingsPaginated(input: ListImageScanFindingsInput) -> ClientRuntime.PaginatorSequence<ListImageScanFindingsInput, ListImageScanFindingsOutput> {
        return ClientRuntime.PaginatorSequence<ListImageScanFindingsInput, ListImageScanFindingsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listImageScanFindings(input:))
    }
}

extension ListImageScanFindingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImageScanFindingsInput {
        return ListImageScanFindingsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListImageScanFindingsInput, OperationStackOutput == ListImageScanFindingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listImageScanFindingsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.ImageScanFinding]`
    /// - Returns: `[ImagebuilderClientTypes.ImageScanFinding]`
    public func findings() async throws -> [ImagebuilderClientTypes.ImageScanFinding] {
        return try await self.asyncCompactMap { item in item.findings }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListInfrastructureConfigurationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInfrastructureConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInfrastructureConfigurationsOutput`
    public func listInfrastructureConfigurationsPaginated(input: ListInfrastructureConfigurationsInput) -> ClientRuntime.PaginatorSequence<ListInfrastructureConfigurationsInput, ListInfrastructureConfigurationsOutput> {
        return ClientRuntime.PaginatorSequence<ListInfrastructureConfigurationsInput, ListInfrastructureConfigurationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listInfrastructureConfigurations(input:))
    }
}

extension ListInfrastructureConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInfrastructureConfigurationsInput {
        return ListInfrastructureConfigurationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListInfrastructureConfigurationsInput, OperationStackOutput == ListInfrastructureConfigurationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInfrastructureConfigurationsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.InfrastructureConfigurationSummary]`
    /// - Returns: `[ImagebuilderClientTypes.InfrastructureConfigurationSummary]`
    public func infrastructureConfigurationSummaryList() async throws -> [ImagebuilderClientTypes.InfrastructureConfigurationSummary] {
        return try await self.asyncCompactMap { item in item.infrastructureConfigurationSummaryList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListLifecycleExecutionResourcesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLifecycleExecutionResourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLifecycleExecutionResourcesOutput`
    public func listLifecycleExecutionResourcesPaginated(input: ListLifecycleExecutionResourcesInput) -> ClientRuntime.PaginatorSequence<ListLifecycleExecutionResourcesInput, ListLifecycleExecutionResourcesOutput> {
        return ClientRuntime.PaginatorSequence<ListLifecycleExecutionResourcesInput, ListLifecycleExecutionResourcesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listLifecycleExecutionResources(input:))
    }
}

extension ListLifecycleExecutionResourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLifecycleExecutionResourcesInput {
        return ListLifecycleExecutionResourcesInput(
            lifecycleExecutionId: self.lifecycleExecutionId,
            maxResults: self.maxResults,
            nextToken: token,
            parentResourceId: self.parentResourceId
        )}
}

extension PaginatorSequence where OperationStackInput == ListLifecycleExecutionResourcesInput, OperationStackOutput == ListLifecycleExecutionResourcesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listLifecycleExecutionResourcesPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.LifecycleExecutionResource]`
    /// - Returns: `[ImagebuilderClientTypes.LifecycleExecutionResource]`
    public func resources() async throws -> [ImagebuilderClientTypes.LifecycleExecutionResource] {
        return try await self.asyncCompactMap { item in item.resources }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListLifecycleExecutionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLifecycleExecutionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLifecycleExecutionsOutput`
    public func listLifecycleExecutionsPaginated(input: ListLifecycleExecutionsInput) -> ClientRuntime.PaginatorSequence<ListLifecycleExecutionsInput, ListLifecycleExecutionsOutput> {
        return ClientRuntime.PaginatorSequence<ListLifecycleExecutionsInput, ListLifecycleExecutionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listLifecycleExecutions(input:))
    }
}

extension ListLifecycleExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLifecycleExecutionsInput {
        return ListLifecycleExecutionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListLifecycleExecutionsInput, OperationStackOutput == ListLifecycleExecutionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listLifecycleExecutionsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.LifecycleExecution]`
    /// - Returns: `[ImagebuilderClientTypes.LifecycleExecution]`
    public func lifecycleExecutions() async throws -> [ImagebuilderClientTypes.LifecycleExecution] {
        return try await self.asyncCompactMap { item in item.lifecycleExecutions }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListLifecyclePoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListLifecyclePoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListLifecyclePoliciesOutput`
    public func listLifecyclePoliciesPaginated(input: ListLifecyclePoliciesInput) -> ClientRuntime.PaginatorSequence<ListLifecyclePoliciesInput, ListLifecyclePoliciesOutput> {
        return ClientRuntime.PaginatorSequence<ListLifecyclePoliciesInput, ListLifecyclePoliciesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listLifecyclePolicies(input:))
    }
}

extension ListLifecyclePoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListLifecyclePoliciesInput {
        return ListLifecyclePoliciesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListLifecyclePoliciesInput, OperationStackOutput == ListLifecyclePoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listLifecyclePoliciesPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.LifecyclePolicySummary]`
    /// - Returns: `[ImagebuilderClientTypes.LifecyclePolicySummary]`
    public func lifecyclePolicySummaryList() async throws -> [ImagebuilderClientTypes.LifecyclePolicySummary] {
        return try await self.asyncCompactMap { item in item.lifecyclePolicySummaryList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListWaitingWorkflowStepsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWaitingWorkflowStepsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWaitingWorkflowStepsOutput`
    public func listWaitingWorkflowStepsPaginated(input: ListWaitingWorkflowStepsInput) -> ClientRuntime.PaginatorSequence<ListWaitingWorkflowStepsInput, ListWaitingWorkflowStepsOutput> {
        return ClientRuntime.PaginatorSequence<ListWaitingWorkflowStepsInput, ListWaitingWorkflowStepsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listWaitingWorkflowSteps(input:))
    }
}

extension ListWaitingWorkflowStepsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWaitingWorkflowStepsInput {
        return ListWaitingWorkflowStepsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListWaitingWorkflowStepsInput, OperationStackOutput == ListWaitingWorkflowStepsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listWaitingWorkflowStepsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.WorkflowStepExecution]`
    /// - Returns: `[ImagebuilderClientTypes.WorkflowStepExecution]`
    public func steps() async throws -> [ImagebuilderClientTypes.WorkflowStepExecution] {
        return try await self.asyncCompactMap { item in item.steps }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListWorkflowBuildVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorkflowBuildVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorkflowBuildVersionsOutput`
    public func listWorkflowBuildVersionsPaginated(input: ListWorkflowBuildVersionsInput) -> ClientRuntime.PaginatorSequence<ListWorkflowBuildVersionsInput, ListWorkflowBuildVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListWorkflowBuildVersionsInput, ListWorkflowBuildVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listWorkflowBuildVersions(input:))
    }
}

extension ListWorkflowBuildVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkflowBuildVersionsInput {
        return ListWorkflowBuildVersionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            workflowVersionArn: self.workflowVersionArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListWorkflowBuildVersionsInput, OperationStackOutput == ListWorkflowBuildVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listWorkflowBuildVersionsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.WorkflowSummary]`
    /// - Returns: `[ImagebuilderClientTypes.WorkflowSummary]`
    public func workflowSummaryList() async throws -> [ImagebuilderClientTypes.WorkflowSummary] {
        return try await self.asyncCompactMap { item in item.workflowSummaryList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListWorkflowExecutionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorkflowExecutionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorkflowExecutionsOutput`
    public func listWorkflowExecutionsPaginated(input: ListWorkflowExecutionsInput) -> ClientRuntime.PaginatorSequence<ListWorkflowExecutionsInput, ListWorkflowExecutionsOutput> {
        return ClientRuntime.PaginatorSequence<ListWorkflowExecutionsInput, ListWorkflowExecutionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listWorkflowExecutions(input:))
    }
}

extension ListWorkflowExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkflowExecutionsInput {
        return ListWorkflowExecutionsInput(
            imageBuildVersionArn: self.imageBuildVersionArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListWorkflowExecutionsInput, OperationStackOutput == ListWorkflowExecutionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listWorkflowExecutionsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.WorkflowExecutionMetadata]`
    /// - Returns: `[ImagebuilderClientTypes.WorkflowExecutionMetadata]`
    public func workflowExecutions() async throws -> [ImagebuilderClientTypes.WorkflowExecutionMetadata] {
        return try await self.asyncCompactMap { item in item.workflowExecutions }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListWorkflowsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorkflowsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorkflowsOutput`
    public func listWorkflowsPaginated(input: ListWorkflowsInput) -> ClientRuntime.PaginatorSequence<ListWorkflowsInput, ListWorkflowsOutput> {
        return ClientRuntime.PaginatorSequence<ListWorkflowsInput, ListWorkflowsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listWorkflows(input:))
    }
}

extension ListWorkflowsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkflowsInput {
        return ListWorkflowsInput(
            byName: self.byName,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner
        )}
}

extension PaginatorSequence where OperationStackInput == ListWorkflowsInput, OperationStackOutput == ListWorkflowsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listWorkflowsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.WorkflowVersion]`
    /// - Returns: `[ImagebuilderClientTypes.WorkflowVersion]`
    public func workflowVersionList() async throws -> [ImagebuilderClientTypes.WorkflowVersion] {
        return try await self.asyncCompactMap { item in item.workflowVersionList }
    }
}
extension ImagebuilderClient {
    /// Paginate over `[ListWorkflowStepExecutionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorkflowStepExecutionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorkflowStepExecutionsOutput`
    public func listWorkflowStepExecutionsPaginated(input: ListWorkflowStepExecutionsInput) -> ClientRuntime.PaginatorSequence<ListWorkflowStepExecutionsInput, ListWorkflowStepExecutionsOutput> {
        return ClientRuntime.PaginatorSequence<ListWorkflowStepExecutionsInput, ListWorkflowStepExecutionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listWorkflowStepExecutions(input:))
    }
}

extension ListWorkflowStepExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkflowStepExecutionsInput {
        return ListWorkflowStepExecutionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            workflowExecutionId: self.workflowExecutionId
        )}
}

extension PaginatorSequence where OperationStackInput == ListWorkflowStepExecutionsInput, OperationStackOutput == ListWorkflowStepExecutionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listWorkflowStepExecutionsPaginated`
    /// to access the nested member `[ImagebuilderClientTypes.WorkflowStepMetadata]`
    /// - Returns: `[ImagebuilderClientTypes.WorkflowStepMetadata]`
    public func steps() async throws -> [ImagebuilderClientTypes.WorkflowStepMetadata] {
        return try await self.asyncCompactMap { item in item.steps }
    }
}
