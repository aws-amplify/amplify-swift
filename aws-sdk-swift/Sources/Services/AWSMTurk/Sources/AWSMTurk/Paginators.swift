//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension MTurkClient {
    /// Paginate over `[ListAssignmentsForHITOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAssignmentsForHITInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAssignmentsForHITOutput`
    public func listAssignmentsForHITPaginated(input: ListAssignmentsForHITInput) -> ClientRuntime.PaginatorSequence<ListAssignmentsForHITInput, ListAssignmentsForHITOutput> {
        return ClientRuntime.PaginatorSequence<ListAssignmentsForHITInput, ListAssignmentsForHITOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAssignmentsForHIT(input:))
    }
}

extension ListAssignmentsForHITInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAssignmentsForHITInput {
        return ListAssignmentsForHITInput(
            assignmentStatuses: self.assignmentStatuses,
            hitId: self.hitId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension MTurkClient {
    /// Paginate over `[ListBonusPaymentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBonusPaymentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBonusPaymentsOutput`
    public func listBonusPaymentsPaginated(input: ListBonusPaymentsInput) -> ClientRuntime.PaginatorSequence<ListBonusPaymentsInput, ListBonusPaymentsOutput> {
        return ClientRuntime.PaginatorSequence<ListBonusPaymentsInput, ListBonusPaymentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBonusPayments(input:))
    }
}

extension ListBonusPaymentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBonusPaymentsInput {
        return ListBonusPaymentsInput(
            assignmentId: self.assignmentId,
            hitId: self.hitId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension MTurkClient {
    /// Paginate over `[ListHITsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListHITsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListHITsOutput`
    public func listHITsPaginated(input: ListHITsInput) -> ClientRuntime.PaginatorSequence<ListHITsInput, ListHITsOutput> {
        return ClientRuntime.PaginatorSequence<ListHITsInput, ListHITsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listHITs(input:))
    }
}

extension ListHITsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListHITsInput {
        return ListHITsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension MTurkClient {
    /// Paginate over `[ListHITsForQualificationTypeOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListHITsForQualificationTypeInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListHITsForQualificationTypeOutput`
    public func listHITsForQualificationTypePaginated(input: ListHITsForQualificationTypeInput) -> ClientRuntime.PaginatorSequence<ListHITsForQualificationTypeInput, ListHITsForQualificationTypeOutput> {
        return ClientRuntime.PaginatorSequence<ListHITsForQualificationTypeInput, ListHITsForQualificationTypeOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listHITsForQualificationType(input:))
    }
}

extension ListHITsForQualificationTypeInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListHITsForQualificationTypeInput {
        return ListHITsForQualificationTypeInput(
            maxResults: self.maxResults,
            nextToken: token,
            qualificationTypeId: self.qualificationTypeId
        )}
}
extension MTurkClient {
    /// Paginate over `[ListQualificationRequestsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListQualificationRequestsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListQualificationRequestsOutput`
    public func listQualificationRequestsPaginated(input: ListQualificationRequestsInput) -> ClientRuntime.PaginatorSequence<ListQualificationRequestsInput, ListQualificationRequestsOutput> {
        return ClientRuntime.PaginatorSequence<ListQualificationRequestsInput, ListQualificationRequestsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listQualificationRequests(input:))
    }
}

extension ListQualificationRequestsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListQualificationRequestsInput {
        return ListQualificationRequestsInput(
            maxResults: self.maxResults,
            nextToken: token,
            qualificationTypeId: self.qualificationTypeId
        )}
}
extension MTurkClient {
    /// Paginate over `[ListQualificationTypesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListQualificationTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListQualificationTypesOutput`
    public func listQualificationTypesPaginated(input: ListQualificationTypesInput) -> ClientRuntime.PaginatorSequence<ListQualificationTypesInput, ListQualificationTypesOutput> {
        return ClientRuntime.PaginatorSequence<ListQualificationTypesInput, ListQualificationTypesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listQualificationTypes(input:))
    }
}

extension ListQualificationTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListQualificationTypesInput {
        return ListQualificationTypesInput(
            maxResults: self.maxResults,
            mustBeOwnedByCaller: self.mustBeOwnedByCaller,
            mustBeRequestable: self.mustBeRequestable,
            nextToken: token,
            query: self.query
        )}
}
extension MTurkClient {
    /// Paginate over `[ListReviewableHITsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListReviewableHITsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListReviewableHITsOutput`
    public func listReviewableHITsPaginated(input: ListReviewableHITsInput) -> ClientRuntime.PaginatorSequence<ListReviewableHITsInput, ListReviewableHITsOutput> {
        return ClientRuntime.PaginatorSequence<ListReviewableHITsInput, ListReviewableHITsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listReviewableHITs(input:))
    }
}

extension ListReviewableHITsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListReviewableHITsInput {
        return ListReviewableHITsInput(
            hitTypeId: self.hitTypeId,
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )}
}
extension MTurkClient {
    /// Paginate over `[ListReviewPolicyResultsForHITOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListReviewPolicyResultsForHITInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListReviewPolicyResultsForHITOutput`
    public func listReviewPolicyResultsForHITPaginated(input: ListReviewPolicyResultsForHITInput) -> ClientRuntime.PaginatorSequence<ListReviewPolicyResultsForHITInput, ListReviewPolicyResultsForHITOutput> {
        return ClientRuntime.PaginatorSequence<ListReviewPolicyResultsForHITInput, ListReviewPolicyResultsForHITOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listReviewPolicyResultsForHIT(input:))
    }
}

extension ListReviewPolicyResultsForHITInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListReviewPolicyResultsForHITInput {
        return ListReviewPolicyResultsForHITInput(
            hitId: self.hitId,
            maxResults: self.maxResults,
            nextToken: token,
            policyLevels: self.policyLevels,
            retrieveActions: self.retrieveActions,
            retrieveResults: self.retrieveResults
        )}
}
extension MTurkClient {
    /// Paginate over `[ListWorkerBlocksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorkerBlocksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorkerBlocksOutput`
    public func listWorkerBlocksPaginated(input: ListWorkerBlocksInput) -> ClientRuntime.PaginatorSequence<ListWorkerBlocksInput, ListWorkerBlocksOutput> {
        return ClientRuntime.PaginatorSequence<ListWorkerBlocksInput, ListWorkerBlocksOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listWorkerBlocks(input:))
    }
}

extension ListWorkerBlocksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkerBlocksInput {
        return ListWorkerBlocksInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension MTurkClient {
    /// Paginate over `[ListWorkersWithQualificationTypeOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorkersWithQualificationTypeInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorkersWithQualificationTypeOutput`
    public func listWorkersWithQualificationTypePaginated(input: ListWorkersWithQualificationTypeInput) -> ClientRuntime.PaginatorSequence<ListWorkersWithQualificationTypeInput, ListWorkersWithQualificationTypeOutput> {
        return ClientRuntime.PaginatorSequence<ListWorkersWithQualificationTypeInput, ListWorkersWithQualificationTypeOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listWorkersWithQualificationType(input:))
    }
}

extension ListWorkersWithQualificationTypeInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkersWithQualificationTypeInput {
        return ListWorkersWithQualificationTypeInput(
            maxResults: self.maxResults,
            nextToken: token,
            qualificationTypeId: self.qualificationTypeId,
            status: self.status
        )}
}
