//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct AbortDocumentVersionUploadOutput: Swift.Sendable {

    public init() { }
}

public struct DeactivateUserOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteCommentOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteDocumentOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteDocumentVersionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFolderContentsOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteFolderOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteNotificationSubscriptionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteUserOutput: Swift.Sendable {

    public init() { }
}

public struct RemoveAllResourcePermissionsOutput: Swift.Sendable {

    public init() { }
}

public struct RemoveResourcePermissionOutput: Swift.Sendable {

    public init() { }
}

public struct RestoreDocumentVersionsOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateDocumentOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateDocumentVersionOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateFolderOutput: Swift.Sendable {

    public init() { }
}

/// The resource hierarchy is changing.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource does not exist.
public struct EntityNotExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The IDs of the non-existent resources.
        public internal(set) var entityIds: [Swift.String]? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityNotExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        entityIds: [Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.entityIds = entityIds
        self.properties.message = message
    }
}

/// The Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.
public struct FailedDependencyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FailedDependencyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified document version is not in the INITIALIZED state.
public struct ProhibitedStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ProhibitedStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// One or more of the dependencies is unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The operation is not permitted.
public struct UnauthorizedOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedOperationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The caller does not have access to perform the action on the resource.
public struct UnauthorizedResourceAccessException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedResourceAccessException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AbortDocumentVersionUploadInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// The ID of the version.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.versionId = versionId
    }
}

extension AbortDocumentVersionUploadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AbortDocumentVersionUploadInput(documentId: \(Swift.String(describing: documentId)), versionId: \(Swift.String(describing: versionId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct ActivateUserInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.userId = userId
    }
}

extension ActivateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActivateUserInput(userId: \(Swift.String(describing: userId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {

    public enum LocaleType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case de
        case `default`
        case en
        case es
        case fr
        case ja
        case ko
        case ptBr
        case ru
        case zhCn
        case zhTw
        case sdkUnknown(Swift.String)

        public static var allCases: [LocaleType] {
            return [
                .de,
                .default,
                .en,
                .es,
                .fr,
                .ja,
                .ko,
                .ptBr,
                .ru,
                .zhCn,
                .zhTw
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .de: return "de"
            case .default: return "default"
            case .en: return "en"
            case .es: return "es"
            case .fr: return "fr"
            case .ja: return "ja"
            case .ko: return "ko"
            case .ptBr: return "pt_BR"
            case .ru: return "ru"
            case .zhCn: return "zh_CN"
            case .zhTw: return "zh_TW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    public enum UserStatusType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [UserStatusType] {
            return [
                .active,
                .inactive,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    public enum StorageType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case quota
        case unlimited
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageType] {
            return [
                .quota,
                .unlimited
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .quota: return "QUOTA"
            case .unlimited: return "UNLIMITED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    /// Describes the storage for a user.
    public struct StorageRuleType: Swift.Sendable {
        /// The amount of storage allocated, in bytes.
        public var storageAllocatedInBytes: Swift.Int?
        /// The type of storage.
        public var storageType: WorkDocsClientTypes.StorageType?

        public init(
            storageAllocatedInBytes: Swift.Int? = nil,
            storageType: WorkDocsClientTypes.StorageType? = nil
        )
        {
            self.storageAllocatedInBytes = storageAllocatedInBytes
            self.storageType = storageType
        }
    }
}

extension WorkDocsClientTypes {

    /// Describes the storage for a user.
    public struct UserStorageMetadata: Swift.Sendable {
        /// The storage for a user.
        public var storageRule: WorkDocsClientTypes.StorageRuleType?
        /// The amount of storage used, in bytes.
        public var storageUtilizedInBytes: Swift.Int?

        public init(
            storageRule: WorkDocsClientTypes.StorageRuleType? = nil,
            storageUtilizedInBytes: Swift.Int? = nil
        )
        {
            self.storageRule = storageRule
            self.storageUtilizedInBytes = storageUtilizedInBytes
        }
    }
}

extension WorkDocsClientTypes {

    public enum UserType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case admin
        case minimaluser
        case poweruser
        case user
        case workspacesuser
        case sdkUnknown(Swift.String)

        public static var allCases: [UserType] {
            return [
                .admin,
                .minimaluser,
                .poweruser,
                .user,
                .workspacesuser
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .admin: return "ADMIN"
            case .minimaluser: return "MINIMALUSER"
            case .poweruser: return "POWERUSER"
            case .user: return "USER"
            case .workspacesuser: return "WORKSPACESUSER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    /// Describes a user.
    public struct User: Swift.Sendable {
        /// The time when the user was created.
        public var createdTimestamp: Foundation.Date?
        /// The email address of the user.
        public var emailAddress: Swift.String?
        /// The given name of the user.
        public var givenName: Swift.String?
        /// The ID of the user.
        public var id: Swift.String?
        /// The locale of the user.
        public var locale: WorkDocsClientTypes.LocaleType?
        /// The time when the user was modified.
        public var modifiedTimestamp: Foundation.Date?
        /// The ID of the organization.
        public var organizationId: Swift.String?
        /// The ID of the recycle bin folder.
        public var recycleBinFolderId: Swift.String?
        /// The ID of the root folder.
        public var rootFolderId: Swift.String?
        /// The status of the user.
        public var status: WorkDocsClientTypes.UserStatusType?
        /// The storage for the user.
        public var storage: WorkDocsClientTypes.UserStorageMetadata?
        /// The surname of the user.
        public var surname: Swift.String?
        /// The time zone ID of the user.
        public var timeZoneId: Swift.String?
        /// The type of user.
        public var type: WorkDocsClientTypes.UserType?
        /// The login name of the user.
        public var username: Swift.String?

        public init(
            createdTimestamp: Foundation.Date? = nil,
            emailAddress: Swift.String? = nil,
            givenName: Swift.String? = nil,
            id: Swift.String? = nil,
            locale: WorkDocsClientTypes.LocaleType? = nil,
            modifiedTimestamp: Foundation.Date? = nil,
            organizationId: Swift.String? = nil,
            recycleBinFolderId: Swift.String? = nil,
            rootFolderId: Swift.String? = nil,
            status: WorkDocsClientTypes.UserStatusType? = nil,
            storage: WorkDocsClientTypes.UserStorageMetadata? = nil,
            surname: Swift.String? = nil,
            timeZoneId: Swift.String? = nil,
            type: WorkDocsClientTypes.UserType? = nil,
            username: Swift.String? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.emailAddress = emailAddress
            self.givenName = givenName
            self.id = id
            self.locale = locale
            self.modifiedTimestamp = modifiedTimestamp
            self.organizationId = organizationId
            self.recycleBinFolderId = recycleBinFolderId
            self.rootFolderId = rootFolderId
            self.status = status
            self.storage = storage
            self.surname = surname
            self.timeZoneId = timeZoneId
            self.type = type
            self.username = username
        }
    }
}

extension WorkDocsClientTypes.User: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "User(createdTimestamp: \(Swift.String(describing: createdTimestamp)), id: \(Swift.String(describing: id)), locale: \(Swift.String(describing: locale)), modifiedTimestamp: \(Swift.String(describing: modifiedTimestamp)), organizationId: \(Swift.String(describing: organizationId)), recycleBinFolderId: \(Swift.String(describing: recycleBinFolderId)), rootFolderId: \(Swift.String(describing: rootFolderId)), status: \(Swift.String(describing: status)), storage: \(Swift.String(describing: storage)), timeZoneId: \(Swift.String(describing: timeZoneId)), type: \(Swift.String(describing: type)), emailAddress: \"CONTENT_REDACTED\", givenName: \"CONTENT_REDACTED\", surname: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

public struct ActivateUserOutput: Swift.Sendable {
    /// The user information.
    public var user: WorkDocsClientTypes.User?

    public init(
        user: WorkDocsClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

extension WorkDocsClientTypes {

    public enum CommentStatusType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleted
        case draft
        case published
        case sdkUnknown(Swift.String)

        public static var allCases: [CommentStatusType] {
            return [
                .deleted,
                .draft,
                .published
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .draft: return "DRAFT"
            case .published: return "PUBLISHED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    /// Describes the metadata of a comment.
    public struct CommentMetadata: Swift.Sendable {
        /// The ID of the comment.
        public var commentId: Swift.String?
        /// The status of the comment.
        public var commentStatus: WorkDocsClientTypes.CommentStatusType?
        /// The user who made the comment.
        public var contributor: WorkDocsClientTypes.User?
        /// The ID of the user who made the comment.
        public var contributorId: Swift.String?
        /// The timestamp that the comment was created.
        public var createdTimestamp: Foundation.Date?
        /// The ID of the user being replied to.
        public var recipientId: Swift.String?

        public init(
            commentId: Swift.String? = nil,
            commentStatus: WorkDocsClientTypes.CommentStatusType? = nil,
            contributor: WorkDocsClientTypes.User? = nil,
            contributorId: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            recipientId: Swift.String? = nil
        )
        {
            self.commentId = commentId
            self.commentStatus = commentStatus
            self.contributor = contributor
            self.contributorId = contributorId
            self.createdTimestamp = createdTimestamp
            self.recipientId = recipientId
        }
    }
}

extension WorkDocsClientTypes {

    /// Describes the metadata of the user.
    public struct UserMetadata: Swift.Sendable {
        /// The email address of the user.
        public var emailAddress: Swift.String?
        /// The given name of the user before a rename operation.
        public var givenName: Swift.String?
        /// The ID of the user.
        public var id: Swift.String?
        /// The surname of the user.
        public var surname: Swift.String?
        /// The name of the user.
        public var username: Swift.String?

        public init(
            emailAddress: Swift.String? = nil,
            givenName: Swift.String? = nil,
            id: Swift.String? = nil,
            surname: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.emailAddress = emailAddress
            self.givenName = givenName
            self.id = id
            self.surname = surname
            self.username = username
        }
    }
}

extension WorkDocsClientTypes.UserMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserMetadata(id: \(Swift.String(describing: id)), emailAddress: \"CONTENT_REDACTED\", givenName: \"CONTENT_REDACTED\", surname: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case document
        case folder
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .document,
                .folder
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .document: return "DOCUMENT"
            case .folder: return "FOLDER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    /// Describes the metadata of a resource.
    public struct ResourceMetadata: Swift.Sendable {
        /// The ID of the resource.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?
        /// The original name of the resource before a rename operation.
        public var originalName: Swift.String?
        /// The owner of the resource.
        public var owner: WorkDocsClientTypes.UserMetadata?
        /// The parent ID of the resource before a rename operation.
        public var parentId: Swift.String?
        /// The type of resource.
        public var type: WorkDocsClientTypes.ResourceType?
        /// The version ID of the resource. This is an optional field and is filled for action on document version.
        public var versionId: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            originalName: Swift.String? = nil,
            owner: WorkDocsClientTypes.UserMetadata? = nil,
            parentId: Swift.String? = nil,
            type: WorkDocsClientTypes.ResourceType? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
            self.originalName = originalName
            self.owner = owner
            self.parentId = parentId
            self.type = type
            self.versionId = versionId
        }
    }
}

extension WorkDocsClientTypes.ResourceMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceMetadata(id: \(Swift.String(describing: id)), owner: \(Swift.String(describing: owner)), parentId: \(Swift.String(describing: parentId)), type: \(Swift.String(describing: type)), versionId: \(Swift.String(describing: versionId)), name: \"CONTENT_REDACTED\", originalName: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {

    /// Describes the metadata of a user group.
    public struct GroupMetadata: Swift.Sendable {
        /// The ID of the user group.
        public var id: Swift.String?
        /// The name of the group.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }
}

extension WorkDocsClientTypes {

    /// Describes the users or user groups.
    public struct Participants: Swift.Sendable {
        /// The list of user groups.
        public var groups: [WorkDocsClientTypes.GroupMetadata]?
        /// The list of users.
        public var users: [WorkDocsClientTypes.UserMetadata]?

        public init(
            groups: [WorkDocsClientTypes.GroupMetadata]? = nil,
            users: [WorkDocsClientTypes.UserMetadata]? = nil
        )
        {
            self.groups = groups
            self.users = users
        }
    }
}

extension WorkDocsClientTypes {

    public enum ActivityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case documentAnnotationAdded
        case documentAnnotationDeleted
        case documentCheckedIn
        case documentCheckedOut
        case documentCommentAdded
        case documentCommentDeleted
        case documentMoved
        case documentRecycled
        case documentRenamed
        case documentRestored
        case documentReverted
        case documentShareableLinkCreated
        case documentShareableLinkPermissionChanged
        case documentShareableLinkRemoved
        case documentShared
        case documentSharePermissionChanged
        case documentUnshared
        case documentVersionDeleted
        case documentVersionDownloaded
        case documentVersionUploaded
        case documentVersionViewed
        case folderCreated
        case folderDeleted
        case folderMoved
        case folderRecycled
        case folderRenamed
        case folderRestored
        case folderShareableLinkCreated
        case folderShareableLinkPermissionChanged
        case folderShareableLinkRemoved
        case folderShared
        case folderSharePermissionChanged
        case folderUnshared
        case sdkUnknown(Swift.String)

        public static var allCases: [ActivityType] {
            return [
                .documentAnnotationAdded,
                .documentAnnotationDeleted,
                .documentCheckedIn,
                .documentCheckedOut,
                .documentCommentAdded,
                .documentCommentDeleted,
                .documentMoved,
                .documentRecycled,
                .documentRenamed,
                .documentRestored,
                .documentReverted,
                .documentShareableLinkCreated,
                .documentShareableLinkPermissionChanged,
                .documentShareableLinkRemoved,
                .documentShared,
                .documentSharePermissionChanged,
                .documentUnshared,
                .documentVersionDeleted,
                .documentVersionDownloaded,
                .documentVersionUploaded,
                .documentVersionViewed,
                .folderCreated,
                .folderDeleted,
                .folderMoved,
                .folderRecycled,
                .folderRenamed,
                .folderRestored,
                .folderShareableLinkCreated,
                .folderShareableLinkPermissionChanged,
                .folderShareableLinkRemoved,
                .folderShared,
                .folderSharePermissionChanged,
                .folderUnshared
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .documentAnnotationAdded: return "DOCUMENT_ANNOTATION_ADDED"
            case .documentAnnotationDeleted: return "DOCUMENT_ANNOTATION_DELETED"
            case .documentCheckedIn: return "DOCUMENT_CHECKED_IN"
            case .documentCheckedOut: return "DOCUMENT_CHECKED_OUT"
            case .documentCommentAdded: return "DOCUMENT_COMMENT_ADDED"
            case .documentCommentDeleted: return "DOCUMENT_COMMENT_DELETED"
            case .documentMoved: return "DOCUMENT_MOVED"
            case .documentRecycled: return "DOCUMENT_RECYCLED"
            case .documentRenamed: return "DOCUMENT_RENAMED"
            case .documentRestored: return "DOCUMENT_RESTORED"
            case .documentReverted: return "DOCUMENT_REVERTED"
            case .documentShareableLinkCreated: return "DOCUMENT_SHAREABLE_LINK_CREATED"
            case .documentShareableLinkPermissionChanged: return "DOCUMENT_SHAREABLE_LINK_PERMISSION_CHANGED"
            case .documentShareableLinkRemoved: return "DOCUMENT_SHAREABLE_LINK_REMOVED"
            case .documentShared: return "DOCUMENT_SHARED"
            case .documentSharePermissionChanged: return "DOCUMENT_SHARE_PERMISSION_CHANGED"
            case .documentUnshared: return "DOCUMENT_UNSHARED"
            case .documentVersionDeleted: return "DOCUMENT_VERSION_DELETED"
            case .documentVersionDownloaded: return "DOCUMENT_VERSION_DOWNLOADED"
            case .documentVersionUploaded: return "DOCUMENT_VERSION_UPLOADED"
            case .documentVersionViewed: return "DOCUMENT_VERSION_VIEWED"
            case .folderCreated: return "FOLDER_CREATED"
            case .folderDeleted: return "FOLDER_DELETED"
            case .folderMoved: return "FOLDER_MOVED"
            case .folderRecycled: return "FOLDER_RECYCLED"
            case .folderRenamed: return "FOLDER_RENAMED"
            case .folderRestored: return "FOLDER_RESTORED"
            case .folderShareableLinkCreated: return "FOLDER_SHAREABLE_LINK_CREATED"
            case .folderShareableLinkPermissionChanged: return "FOLDER_SHAREABLE_LINK_PERMISSION_CHANGED"
            case .folderShareableLinkRemoved: return "FOLDER_SHAREABLE_LINK_REMOVED"
            case .folderShared: return "FOLDER_SHARED"
            case .folderSharePermissionChanged: return "FOLDER_SHARE_PERMISSION_CHANGED"
            case .folderUnshared: return "FOLDER_UNSHARED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    /// Describes the activity information.
    public struct Activity: Swift.Sendable {
        /// Metadata of the commenting activity. This is an optional field and is filled for commenting activities.
        public var commentMetadata: WorkDocsClientTypes.CommentMetadata?
        /// The user who performed the action.
        public var initiator: WorkDocsClientTypes.UserMetadata?
        /// Indicates whether an activity is indirect or direct. An indirect activity results from a direct activity performed on a parent resource. For example, sharing a parent folder (the direct activity) shares all of the subfolders and documents within the parent folder (the indirect activity).
        public var isIndirectActivity: Swift.Bool
        /// The ID of the organization.
        public var organizationId: Swift.String?
        /// The original parent of the resource. This is an optional field and is filled for move activities.
        public var originalParent: WorkDocsClientTypes.ResourceMetadata?
        /// The list of users or groups impacted by this action. This is an optional field and is filled for the following sharing activities: DOCUMENT_SHARED, DOCUMENT_SHARED, DOCUMENT_UNSHARED, FOLDER_SHARED, FOLDER_UNSHARED.
        public var participants: WorkDocsClientTypes.Participants?
        /// The metadata of the resource involved in the user action.
        public var resourceMetadata: WorkDocsClientTypes.ResourceMetadata?
        /// The timestamp when the action was performed.
        public var timeStamp: Foundation.Date?
        /// The activity type.
        public var type: WorkDocsClientTypes.ActivityType?

        public init(
            commentMetadata: WorkDocsClientTypes.CommentMetadata? = nil,
            initiator: WorkDocsClientTypes.UserMetadata? = nil,
            isIndirectActivity: Swift.Bool = false,
            organizationId: Swift.String? = nil,
            originalParent: WorkDocsClientTypes.ResourceMetadata? = nil,
            participants: WorkDocsClientTypes.Participants? = nil,
            resourceMetadata: WorkDocsClientTypes.ResourceMetadata? = nil,
            timeStamp: Foundation.Date? = nil,
            type: WorkDocsClientTypes.ActivityType? = nil
        )
        {
            self.commentMetadata = commentMetadata
            self.initiator = initiator
            self.isIndirectActivity = isIndirectActivity
            self.organizationId = organizationId
            self.originalParent = originalParent
            self.participants = participants
            self.resourceMetadata = resourceMetadata
            self.timeStamp = timeStamp
            self.type = type
        }
    }
}

extension WorkDocsClientTypes {

    public enum AdditionalResponseFieldType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case weburl
        case sdkUnknown(Swift.String)

        public static var allCases: [AdditionalResponseFieldType] {
            return [
                .weburl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .weburl: return "WEBURL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    /// Set of options which defines notification preferences of given action.
    public struct NotificationOptions: Swift.Sendable {
        /// Text value to be included in the email body.
        public var emailMessage: Swift.String?
        /// Boolean value to indicate an email notification should be sent to the recipients.
        public var sendEmail: Swift.Bool

        public init(
            emailMessage: Swift.String? = nil,
            sendEmail: Swift.Bool = false
        )
        {
            self.emailMessage = emailMessage
            self.sendEmail = sendEmail
        }
    }
}

extension WorkDocsClientTypes.NotificationOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotificationOptions(sendEmail: \(Swift.String(describing: sendEmail)), emailMessage: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {

    public enum RoleType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contributor
        case coowner
        case owner
        case viewer
        case sdkUnknown(Swift.String)

        public static var allCases: [RoleType] {
            return [
                .contributor,
                .coowner,
                .owner,
                .viewer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contributor: return "CONTRIBUTOR"
            case .coowner: return "COOWNER"
            case .owner: return "OWNER"
            case .viewer: return "VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    public enum PrincipalType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case anonymous
        case group
        case invite
        case organization
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [PrincipalType] {
            return [
                .anonymous,
                .group,
                .invite,
                .organization,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .anonymous: return "ANONYMOUS"
            case .group: return "GROUP"
            case .invite: return "INVITE"
            case .organization: return "ORGANIZATION"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    /// Describes the recipient type and ID, if available.
    public struct SharePrincipal: Swift.Sendable {
        /// The ID of the recipient.
        /// This member is required.
        public var id: Swift.String?
        /// The role of the recipient.
        /// This member is required.
        public var role: WorkDocsClientTypes.RoleType?
        /// The type of the recipient.
        /// This member is required.
        public var type: WorkDocsClientTypes.PrincipalType?

        public init(
            id: Swift.String? = nil,
            role: WorkDocsClientTypes.RoleType? = nil,
            type: WorkDocsClientTypes.PrincipalType? = nil
        )
        {
            self.id = id
            self.role = role
            self.type = type
        }
    }
}

public struct AddResourcePermissionsInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The notification options.
    public var notificationOptions: WorkDocsClientTypes.NotificationOptions?
    /// The users, groups, or organization being granted permission.
    /// This member is required.
    public var principals: [WorkDocsClientTypes.SharePrincipal]?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        notificationOptions: WorkDocsClientTypes.NotificationOptions? = nil,
        principals: [WorkDocsClientTypes.SharePrincipal]? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.notificationOptions = notificationOptions
        self.principals = principals
        self.resourceId = resourceId
    }
}

extension AddResourcePermissionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddResourcePermissionsInput(notificationOptions: \(Swift.String(describing: notificationOptions)), principals: \(Swift.String(describing: principals)), resourceId: \(Swift.String(describing: resourceId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {

    public enum ShareStatusType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failure
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareStatusType] {
            return [
                .failure,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failure: return "FAILURE"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    /// Describes the share results of a resource.
    public struct ShareResult: Swift.Sendable {
        /// The ID of the invited user.
        public var inviteePrincipalId: Swift.String?
        /// The ID of the principal.
        public var principalId: Swift.String?
        /// The role.
        public var role: WorkDocsClientTypes.RoleType?
        /// The ID of the resource that was shared.
        public var shareId: Swift.String?
        /// The status.
        public var status: WorkDocsClientTypes.ShareStatusType?
        /// The status message.
        public var statusMessage: Swift.String?

        public init(
            inviteePrincipalId: Swift.String? = nil,
            principalId: Swift.String? = nil,
            role: WorkDocsClientTypes.RoleType? = nil,
            shareId: Swift.String? = nil,
            status: WorkDocsClientTypes.ShareStatusType? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.inviteePrincipalId = inviteePrincipalId
            self.principalId = principalId
            self.role = role
            self.shareId = shareId
            self.status = status
            self.statusMessage = statusMessage
        }
    }
}

extension WorkDocsClientTypes.ShareResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ShareResult(inviteePrincipalId: \(Swift.String(describing: inviteePrincipalId)), principalId: \(Swift.String(describing: principalId)), role: \(Swift.String(describing: role)), shareId: \(Swift.String(describing: shareId)), status: \(Swift.String(describing: status)), statusMessage: \"CONTENT_REDACTED\")"}
}

public struct AddResourcePermissionsOutput: Swift.Sendable {
    /// The share results.
    public var shareResults: [WorkDocsClientTypes.ShareResult]?

    public init(
        shareResults: [WorkDocsClientTypes.ShareResult]? = nil
    )
    {
        self.shareResults = shareResults
    }
}

/// This exception is thrown when the document is locked for comments and user tries to create or delete a comment on that document.
public struct DocumentLockedForCommentsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DocumentLockedForCommentsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The requested operation is not allowed on the specified comment object.
public struct InvalidCommentOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidCommentOperationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension WorkDocsClientTypes {

    public enum CommentVisibilityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [CommentVisibilityType] {
            return [
                .private,
                .public
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateCommentInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// Set this parameter to TRUE to send an email out to the document collaborators after the comment is created.
    public var notifyCollaborators: Swift.Bool?
    /// The ID of the parent comment.
    public var parentId: Swift.String?
    /// The text of the comment.
    /// This member is required.
    public var text: Swift.String?
    /// The ID of the root comment in the thread.
    public var threadId: Swift.String?
    /// The ID of the document version.
    /// This member is required.
    public var versionId: Swift.String?
    /// The visibility of the comment. Options are either PRIVATE, where the comment is visible only to the comment author and document owner and co-owners, or PUBLIC, where the comment is visible to document owners, co-owners, and contributors.
    public var visibility: WorkDocsClientTypes.CommentVisibilityType?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        notifyCollaborators: Swift.Bool? = false,
        parentId: Swift.String? = nil,
        text: Swift.String? = nil,
        threadId: Swift.String? = nil,
        versionId: Swift.String? = nil,
        visibility: WorkDocsClientTypes.CommentVisibilityType? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.notifyCollaborators = notifyCollaborators
        self.parentId = parentId
        self.text = text
        self.threadId = threadId
        self.versionId = versionId
        self.visibility = visibility
    }
}

extension CreateCommentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCommentInput(documentId: \(Swift.String(describing: documentId)), notifyCollaborators: \(Swift.String(describing: notifyCollaborators)), parentId: \(Swift.String(describing: parentId)), threadId: \(Swift.String(describing: threadId)), versionId: \(Swift.String(describing: versionId)), visibility: \(Swift.String(describing: visibility)), authenticationToken: \"CONTENT_REDACTED\", text: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {

    /// Describes a comment.
    public struct Comment: Swift.Sendable {
        /// The ID of the comment.
        /// This member is required.
        public var commentId: Swift.String?
        /// The details of the user who made the comment.
        public var contributor: WorkDocsClientTypes.User?
        /// The time that the comment was created.
        public var createdTimestamp: Foundation.Date?
        /// The ID of the parent comment.
        public var parentId: Swift.String?
        /// If the comment is a reply to another user's comment, this field contains the user ID of the user being replied to.
        public var recipientId: Swift.String?
        /// The status of the comment.
        public var status: WorkDocsClientTypes.CommentStatusType?
        /// The text of the comment.
        public var text: Swift.String?
        /// The ID of the root comment in the thread.
        public var threadId: Swift.String?
        /// The visibility of the comment. Options are either PRIVATE, where the comment is visible only to the comment author and document owner and co-owners, or PUBLIC, where the comment is visible to document owners, co-owners, and contributors.
        public var visibility: WorkDocsClientTypes.CommentVisibilityType?

        public init(
            commentId: Swift.String? = nil,
            contributor: WorkDocsClientTypes.User? = nil,
            createdTimestamp: Foundation.Date? = nil,
            parentId: Swift.String? = nil,
            recipientId: Swift.String? = nil,
            status: WorkDocsClientTypes.CommentStatusType? = nil,
            text: Swift.String? = nil,
            threadId: Swift.String? = nil,
            visibility: WorkDocsClientTypes.CommentVisibilityType? = nil
        )
        {
            self.commentId = commentId
            self.contributor = contributor
            self.createdTimestamp = createdTimestamp
            self.parentId = parentId
            self.recipientId = recipientId
            self.status = status
            self.text = text
            self.threadId = threadId
            self.visibility = visibility
        }
    }
}

extension WorkDocsClientTypes.Comment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Comment(commentId: \(Swift.String(describing: commentId)), contributor: \(Swift.String(describing: contributor)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), parentId: \(Swift.String(describing: parentId)), recipientId: \(Swift.String(describing: recipientId)), status: \(Swift.String(describing: status)), threadId: \(Swift.String(describing: threadId)), visibility: \(Swift.String(describing: visibility)), text: \"CONTENT_REDACTED\")"}
}

public struct CreateCommentOutput: Swift.Sendable {
    /// The comment that has been created.
    public var comment: WorkDocsClientTypes.Comment?

    public init(
        comment: WorkDocsClientTypes.Comment? = nil
    )
    {
        self.comment = comment
    }
}

/// The limit has been reached on the number of custom properties for the specified resource.
public struct CustomMetadataLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CustomMetadataLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateCustomMetadataInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// Custom metadata in the form of name-value pairs.
    /// This member is required.
    public var customMetadata: [Swift.String: Swift.String]?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The ID of the version, if the custom metadata is being added to a document version.
    public var versionId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        customMetadata: [Swift.String: Swift.String]? = nil,
        resourceId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.customMetadata = customMetadata
        self.resourceId = resourceId
        self.versionId = versionId
    }
}

extension CreateCustomMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCustomMetadataInput(customMetadata: \(Swift.String(describing: customMetadata)), resourceId: \(Swift.String(describing: resourceId)), versionId: \(Swift.String(describing: versionId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct CreateCustomMetadataOutput: Swift.Sendable {

    public init() { }
}

/// Another operation is in progress on the resource that conflicts with the current operation.
public struct ConflictingOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictingOperationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource already exists.
public struct EntityAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EntityAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The maximum of 100,000 files and folders under the parent folder has been exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateFolderInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The name of the new folder.
    public var name: Swift.String?
    /// The ID of the parent folder.
    /// This member is required.
    public var parentFolderId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        name: Swift.String? = nil,
        parentFolderId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.name = name
        self.parentFolderId = parentFolderId
    }
}

extension CreateFolderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateFolderInput(parentFolderId: \(Swift.String(describing: parentFolderId)), authenticationToken: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {

    public enum ResourceStateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case recycled
        case recycling
        case restoring
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceStateType] {
            return [
                .active,
                .recycled,
                .recycling,
                .restoring
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .recycled: return "RECYCLED"
            case .recycling: return "RECYCLING"
            case .restoring: return "RESTORING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    /// Describes a folder.
    public struct FolderMetadata: Swift.Sendable {
        /// The time when the folder was created.
        public var createdTimestamp: Foundation.Date?
        /// The ID of the creator.
        public var creatorId: Swift.String?
        /// The ID of the folder.
        public var id: Swift.String?
        /// List of labels on the folder.
        public var labels: [Swift.String]?
        /// The size of the latest version of the folder metadata.
        public var latestVersionSize: Swift.Int?
        /// The time when the folder was updated.
        public var modifiedTimestamp: Foundation.Date?
        /// The name of the folder.
        public var name: Swift.String?
        /// The ID of the parent folder.
        public var parentFolderId: Swift.String?
        /// The resource state of the folder.
        public var resourceState: WorkDocsClientTypes.ResourceStateType?
        /// The unique identifier created from the subfolders and documents of the folder.
        public var signature: Swift.String?
        /// The size of the folder metadata.
        public var size: Swift.Int?

        public init(
            createdTimestamp: Foundation.Date? = nil,
            creatorId: Swift.String? = nil,
            id: Swift.String? = nil,
            labels: [Swift.String]? = nil,
            latestVersionSize: Swift.Int? = nil,
            modifiedTimestamp: Foundation.Date? = nil,
            name: Swift.String? = nil,
            parentFolderId: Swift.String? = nil,
            resourceState: WorkDocsClientTypes.ResourceStateType? = nil,
            signature: Swift.String? = nil,
            size: Swift.Int? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.creatorId = creatorId
            self.id = id
            self.labels = labels
            self.latestVersionSize = latestVersionSize
            self.modifiedTimestamp = modifiedTimestamp
            self.name = name
            self.parentFolderId = parentFolderId
            self.resourceState = resourceState
            self.signature = signature
            self.size = size
        }
    }
}

extension WorkDocsClientTypes.FolderMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FolderMetadata(createdTimestamp: \(Swift.String(describing: createdTimestamp)), creatorId: \(Swift.String(describing: creatorId)), id: \(Swift.String(describing: id)), labels: \(Swift.String(describing: labels)), latestVersionSize: \(Swift.String(describing: latestVersionSize)), modifiedTimestamp: \(Swift.String(describing: modifiedTimestamp)), parentFolderId: \(Swift.String(describing: parentFolderId)), resourceState: \(Swift.String(describing: resourceState)), signature: \(Swift.String(describing: signature)), size: \(Swift.String(describing: size)), name: \"CONTENT_REDACTED\")"}
}

public struct CreateFolderOutput: Swift.Sendable {
    /// The metadata of the folder.
    public var metadata: WorkDocsClientTypes.FolderMetadata?

    public init(
        metadata: WorkDocsClientTypes.FolderMetadata? = nil
    )
    {
        self.metadata = metadata
    }
}

/// The limit has been reached on the number of labels for the specified resource.
public struct TooManyLabelsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyLabelsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateLabelsInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// List of labels to add to the resource.
    /// This member is required.
    public var labels: [Swift.String]?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        labels: [Swift.String]? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.labels = labels
        self.resourceId = resourceId
    }
}

extension CreateLabelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLabelsInput(labels: \(Swift.String(describing: labels)), resourceId: \(Swift.String(describing: resourceId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct CreateLabelsOutput: Swift.Sendable {

    public init() { }
}

/// The pagination marker or limit fields are not valid.
public struct InvalidArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArgumentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You've reached the limit on the number of subscriptions for the WorkDocs instance.
public struct TooManySubscriptionsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManySubscriptionsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension WorkDocsClientTypes {

    public enum SubscriptionProtocolType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case https
        case sqs
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionProtocolType] {
            return [
                .https,
                .sqs
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .https: return "HTTPS"
            case .sqs: return "SQS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    public enum SubscriptionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionType] {
            return [
                .all
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateNotificationSubscriptionInput: Swift.Sendable {
    /// The endpoint to receive the notifications. If the protocol is HTTPS, the endpoint is a URL that begins with https.
    /// This member is required.
    public var endpoint: Swift.String?
    /// The ID of the organization.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The protocol to use. The supported value is https, which delivers JSON-encoded messages using HTTPS POST.
    /// This member is required.
    public var `protocol`: WorkDocsClientTypes.SubscriptionProtocolType?
    /// The notification type.
    /// This member is required.
    public var subscriptionType: WorkDocsClientTypes.SubscriptionType?

    public init(
        endpoint: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        `protocol`: WorkDocsClientTypes.SubscriptionProtocolType? = nil,
        subscriptionType: WorkDocsClientTypes.SubscriptionType? = nil
    )
    {
        self.endpoint = endpoint
        self.organizationId = organizationId
        self.`protocol` = `protocol`
        self.subscriptionType = subscriptionType
    }
}

extension WorkDocsClientTypes {

    /// Describes a subscription.
    public struct Subscription: Swift.Sendable {
        /// The endpoint of the subscription.
        public var endPoint: Swift.String?
        /// The protocol of the subscription.
        public var `protocol`: WorkDocsClientTypes.SubscriptionProtocolType?
        /// The ID of the subscription.
        public var subscriptionId: Swift.String?

        public init(
            endPoint: Swift.String? = nil,
            `protocol`: WorkDocsClientTypes.SubscriptionProtocolType? = nil,
            subscriptionId: Swift.String? = nil
        )
        {
            self.endPoint = endPoint
            self.`protocol` = `protocol`
            self.subscriptionId = subscriptionId
        }
    }
}

public struct CreateNotificationSubscriptionOutput: Swift.Sendable {
    /// The subscription.
    public var subscription: WorkDocsClientTypes.Subscription?

    public init(
        subscription: WorkDocsClientTypes.Subscription? = nil
    )
    {
        self.subscription = subscription
    }
}

public struct CreateUserInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The email address of the user.
    public var emailAddress: Swift.String?
    /// The given name of the user.
    /// This member is required.
    public var givenName: Swift.String?
    /// The ID of the organization.
    public var organizationId: Swift.String?
    /// The password of the user.
    /// This member is required.
    public var password: Swift.String?
    /// The amount of storage for the user.
    public var storageRule: WorkDocsClientTypes.StorageRuleType?
    /// The surname of the user.
    /// This member is required.
    public var surname: Swift.String?
    /// The time zone ID of the user.
    public var timeZoneId: Swift.String?
    /// The login name of the user.
    /// This member is required.
    public var username: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        givenName: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        password: Swift.String? = nil,
        storageRule: WorkDocsClientTypes.StorageRuleType? = nil,
        surname: Swift.String? = nil,
        timeZoneId: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.emailAddress = emailAddress
        self.givenName = givenName
        self.organizationId = organizationId
        self.password = password
        self.storageRule = storageRule
        self.surname = surname
        self.timeZoneId = timeZoneId
        self.username = username
    }
}

extension CreateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserInput(organizationId: \(Swift.String(describing: organizationId)), storageRule: \(Swift.String(describing: storageRule)), timeZoneId: \(Swift.String(describing: timeZoneId)), authenticationToken: \"CONTENT_REDACTED\", emailAddress: \"CONTENT_REDACTED\", givenName: \"CONTENT_REDACTED\", password: \"CONTENT_REDACTED\", surname: \"CONTENT_REDACTED\", username: \"CONTENT_REDACTED\")"}
}

public struct CreateUserOutput: Swift.Sendable {
    /// The user information.
    public var user: WorkDocsClientTypes.User?

    public init(
        user: WorkDocsClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

public struct DeactivateUserInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.userId = userId
    }
}

extension DeactivateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeactivateUserInput(userId: \(Swift.String(describing: userId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct DeleteCommentInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the comment.
    /// This member is required.
    public var commentId: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// The ID of the document version.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        commentId: Swift.String? = nil,
        documentId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.commentId = commentId
        self.documentId = documentId
        self.versionId = versionId
    }
}

extension DeleteCommentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCommentInput(commentId: \(Swift.String(describing: commentId)), documentId: \(Swift.String(describing: documentId)), versionId: \(Swift.String(describing: versionId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct DeleteCustomMetadataInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// Flag to indicate removal of all custom metadata properties from the specified resource.
    public var deleteAll: Swift.Bool?
    /// List of properties to remove.
    public var keys: [Swift.String]?
    /// The ID of the resource, either a document or folder.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The ID of the version, if the custom metadata is being deleted from a document version.
    public var versionId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        deleteAll: Swift.Bool? = false,
        keys: [Swift.String]? = nil,
        resourceId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.deleteAll = deleteAll
        self.keys = keys
        self.resourceId = resourceId
        self.versionId = versionId
    }
}

extension DeleteCustomMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCustomMetadataInput(deleteAll: \(Swift.String(describing: deleteAll)), keys: \(Swift.String(describing: keys)), resourceId: \(Swift.String(describing: resourceId)), versionId: \(Swift.String(describing: versionId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct DeleteCustomMetadataOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteDocumentInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
    }
}

extension DeleteDocumentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDocumentInput(documentId: \(Swift.String(describing: documentId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

/// The operation is invalid.
public struct InvalidOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOperationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteDocumentVersionInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// Deletes all versions of a document prior to the current version.
    /// This member is required.
    public var deletePriorVersions: Swift.Bool?
    /// The ID of the document associated with the version being deleted.
    /// This member is required.
    public var documentId: Swift.String?
    /// The ID of the version being deleted.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        deletePriorVersions: Swift.Bool? = false,
        documentId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.deletePriorVersions = deletePriorVersions
        self.documentId = documentId
        self.versionId = versionId
    }
}

extension DeleteDocumentVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDocumentVersionInput(deletePriorVersions: \(Swift.String(describing: deletePriorVersions)), documentId: \(Swift.String(describing: documentId)), versionId: \(Swift.String(describing: versionId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct DeleteFolderInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        folderId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
    }
}

extension DeleteFolderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFolderInput(folderId: \(Swift.String(describing: folderId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct DeleteFolderContentsInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        folderId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
    }
}

extension DeleteFolderContentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteFolderContentsInput(folderId: \(Swift.String(describing: folderId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct DeleteLabelsInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// Flag to request removal of all labels from the specified resource.
    public var deleteAll: Swift.Bool?
    /// List of labels to delete from the resource.
    public var labels: [Swift.String]?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        deleteAll: Swift.Bool? = false,
        labels: [Swift.String]? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.deleteAll = deleteAll
        self.labels = labels
        self.resourceId = resourceId
    }
}

extension DeleteLabelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLabelsInput(deleteAll: \(Swift.String(describing: deleteAll)), labels: \(Swift.String(describing: labels)), resourceId: \(Swift.String(describing: resourceId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct DeleteLabelsOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteNotificationSubscriptionInput: Swift.Sendable {
    /// The ID of the organization.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The ID of the subscription.
    /// This member is required.
    public var subscriptionId: Swift.String?

    public init(
        organizationId: Swift.String? = nil,
        subscriptionId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.subscriptionId = subscriptionId
    }
}

public struct DeleteUserInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Do not set this field when using administrative API actions, as in accessing the API using Amazon Web Services credentials.
    public var authenticationToken: Swift.String?
    /// The ID of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.userId = userId
    }
}

extension DeleteUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUserInput(userId: \(Swift.String(describing: userId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct DescribeActivitiesInput: Swift.Sendable {
    /// Specifies which activity types to include in the response. If this field is left empty, all activity types are returned.
    public var activityTypes: Swift.String?
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The timestamp that determines the end time of the activities. The response includes the activities performed before the specified timestamp.
    public var endTime: Foundation.Date?
    /// Includes indirect activities. An indirect activity results from a direct activity performed on a parent resource. For example, sharing a parent folder (the direct activity) shares all of the subfolders and documents within the parent folder (the indirect activity).
    public var includeIndirectActivities: Swift.Bool?
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The ID of the organization. This is a mandatory parameter when using administrative API (SigV4) requests.
    public var organizationId: Swift.String?
    /// The document or folder ID for which to describe activity types.
    public var resourceId: Swift.String?
    /// The timestamp that determines the starting time of the activities. The response includes the activities performed after the specified timestamp.
    public var startTime: Foundation.Date?
    /// The ID of the user who performed the action. The response includes activities pertaining to this user. This is an optional parameter and is only applicable for administrative API (SigV4) requests.
    public var userId: Swift.String?

    public init(
        activityTypes: Swift.String? = nil,
        authenticationToken: Swift.String? = nil,
        endTime: Foundation.Date? = nil,
        includeIndirectActivities: Swift.Bool? = false,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        userId: Swift.String? = nil
    )
    {
        self.activityTypes = activityTypes
        self.authenticationToken = authenticationToken
        self.endTime = endTime
        self.includeIndirectActivities = includeIndirectActivities
        self.limit = limit
        self.marker = marker
        self.organizationId = organizationId
        self.resourceId = resourceId
        self.startTime = startTime
        self.userId = userId
    }
}

extension DescribeActivitiesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeActivitiesInput(activityTypes: \(Swift.String(describing: activityTypes)), endTime: \(Swift.String(describing: endTime)), includeIndirectActivities: \(Swift.String(describing: includeIndirectActivities)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), organizationId: \(Swift.String(describing: organizationId)), resourceId: \(Swift.String(describing: resourceId)), startTime: \(Swift.String(describing: startTime)), userId: \(Swift.String(describing: userId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct DescribeActivitiesOutput: Swift.Sendable {
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The list of activities for the specified user and time period.
    public var userActivities: [WorkDocsClientTypes.Activity]?

    public init(
        marker: Swift.String? = nil,
        userActivities: [WorkDocsClientTypes.Activity]? = nil
    )
    {
        self.marker = marker
        self.userActivities = userActivities
    }
}

public struct DescribeCommentsInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// The marker for the next set of results. This marker was received from a previous call.
    public var marker: Swift.String?
    /// The ID of the document version.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.limit = limit
        self.marker = marker
        self.versionId = versionId
    }
}

extension DescribeCommentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCommentsInput(documentId: \(Swift.String(describing: documentId)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), versionId: \(Swift.String(describing: versionId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct DescribeCommentsOutput: Swift.Sendable {
    /// The list of comments for the specified document version.
    public var comments: [WorkDocsClientTypes.Comment]?
    /// The marker for the next set of results. This marker was received from a previous call.
    public var marker: Swift.String?

    public init(
        comments: [WorkDocsClientTypes.Comment]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.comments = comments
        self.marker = marker
    }
}

/// The password is invalid.
public struct InvalidPasswordException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPasswordException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeDocumentVersionsInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// Specify "SOURCE" to include initialized versions and a URL for the source document.
    public var fields: Swift.String?
    /// A comma-separated list of values. Specify "INITIALIZED" to include incomplete versions.
    public var include: Swift.String?
    /// The maximum number of versions to return with this call.
    public var limit: Swift.Int?
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        fields: Swift.String? = nil,
        include: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.fields = fields
        self.include = include
        self.limit = limit
        self.marker = marker
    }
}

extension DescribeDocumentVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDocumentVersionsInput(documentId: \(Swift.String(describing: documentId)), fields: \(Swift.String(describing: fields)), include: \(Swift.String(describing: include)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {

    public enum DocumentSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case original
        case withComments
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentSourceType] {
            return [
                .original,
                .withComments
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .original: return "ORIGINAL"
            case .withComments: return "WITH_COMMENTS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    public enum DocumentStatusType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case initialized
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentStatusType] {
            return [
                .active,
                .initialized
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .initialized: return "INITIALIZED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    public enum DocumentThumbnailType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case large
        case small
        case smallHq
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentThumbnailType] {
            return [
                .large,
                .small,
                .smallHq
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .large: return "LARGE"
            case .small: return "SMALL"
            case .smallHq: return "SMALL_HQ"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    /// Describes a version of a document.
    public struct DocumentVersionMetadata: Swift.Sendable {
        /// The timestamp when the content of the document was originally created.
        public var contentCreatedTimestamp: Foundation.Date?
        /// The timestamp when the content of the document was modified.
        public var contentModifiedTimestamp: Foundation.Date?
        /// The content type of the document.
        public var contentType: Swift.String?
        /// The timestamp when the document was first uploaded.
        public var createdTimestamp: Foundation.Date?
        /// The ID of the creator.
        public var creatorId: Swift.String?
        /// The ID of the version.
        public var id: Swift.String?
        /// The timestamp when the document was last uploaded.
        public var modifiedTimestamp: Foundation.Date?
        /// The name of the version.
        public var name: Swift.String?
        /// The signature of the document.
        public var signature: Swift.String?
        /// The size of the document, in bytes.
        public var size: Swift.Int?
        /// The source of the document.
        public var source: [Swift.String: Swift.String]?
        /// The status of the document.
        public var status: WorkDocsClientTypes.DocumentStatusType?
        /// The thumbnail of the document.
        public var thumbnail: [Swift.String: Swift.String]?

        public init(
            contentCreatedTimestamp: Foundation.Date? = nil,
            contentModifiedTimestamp: Foundation.Date? = nil,
            contentType: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            creatorId: Swift.String? = nil,
            id: Swift.String? = nil,
            modifiedTimestamp: Foundation.Date? = nil,
            name: Swift.String? = nil,
            signature: Swift.String? = nil,
            size: Swift.Int? = nil,
            source: [Swift.String: Swift.String]? = nil,
            status: WorkDocsClientTypes.DocumentStatusType? = nil,
            thumbnail: [Swift.String: Swift.String]? = nil
        )
        {
            self.contentCreatedTimestamp = contentCreatedTimestamp
            self.contentModifiedTimestamp = contentModifiedTimestamp
            self.contentType = contentType
            self.createdTimestamp = createdTimestamp
            self.creatorId = creatorId
            self.id = id
            self.modifiedTimestamp = modifiedTimestamp
            self.name = name
            self.signature = signature
            self.size = size
            self.source = source
            self.status = status
            self.thumbnail = thumbnail
        }
    }
}

extension WorkDocsClientTypes.DocumentVersionMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DocumentVersionMetadata(contentCreatedTimestamp: \(Swift.String(describing: contentCreatedTimestamp)), contentModifiedTimestamp: \(Swift.String(describing: contentModifiedTimestamp)), contentType: \(Swift.String(describing: contentType)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), creatorId: \(Swift.String(describing: creatorId)), id: \(Swift.String(describing: id)), modifiedTimestamp: \(Swift.String(describing: modifiedTimestamp)), signature: \(Swift.String(describing: signature)), size: \(Swift.String(describing: size)), status: \(Swift.String(describing: status)), name: \"CONTENT_REDACTED\", source: [keys: \(Swift.String(describing: source?.keys)), values: \"CONTENT_REDACTED\"], thumbnail: [keys: \(Swift.String(describing: thumbnail?.keys)), values: \"CONTENT_REDACTED\"])"}
}

public struct DescribeDocumentVersionsOutput: Swift.Sendable {
    /// The document versions.
    public var documentVersions: [WorkDocsClientTypes.DocumentVersionMetadata]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?

    public init(
        documentVersions: [WorkDocsClientTypes.DocumentVersionMetadata]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.documentVersions = documentVersions
        self.marker = marker
    }
}

extension WorkDocsClientTypes {

    public enum OrderType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderType] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    public enum ResourceSortType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case date
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceSortType] {
            return [
                .date,
                .name
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .date: return "DATE"
            case .name: return "NAME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    public enum FolderContentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case document
        case folder
        case sdkUnknown(Swift.String)

        public static var allCases: [FolderContentType] {
            return [
                .all,
                .document,
                .folder
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .document: return "DOCUMENT"
            case .folder: return "FOLDER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeFolderContentsInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The contents to include. Specify "INITIALIZED" to include initialized documents.
    public var include: Swift.String?
    /// The maximum number of items to return with this call.
    public var limit: Swift.Int?
    /// The marker for the next set of results. This marker was received from a previous call.
    public var marker: Swift.String?
    /// The order for the contents of the folder.
    public var order: WorkDocsClientTypes.OrderType?
    /// The sorting criteria.
    public var sort: WorkDocsClientTypes.ResourceSortType?
    /// The type of items.
    public var type: WorkDocsClientTypes.FolderContentType?

    public init(
        authenticationToken: Swift.String? = nil,
        folderId: Swift.String? = nil,
        include: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        order: WorkDocsClientTypes.OrderType? = nil,
        sort: WorkDocsClientTypes.ResourceSortType? = nil,
        type: WorkDocsClientTypes.FolderContentType? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
        self.include = include
        self.limit = limit
        self.marker = marker
        self.order = order
        self.sort = sort
        self.type = type
    }
}

extension DescribeFolderContentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeFolderContentsInput(folderId: \(Swift.String(describing: folderId)), include: \(Swift.String(describing: include)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), order: \(Swift.String(describing: order)), sort: \(Swift.String(describing: sort)), type: \(Swift.String(describing: type)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {

    /// Describes the document.
    public struct DocumentMetadata: Swift.Sendable {
        /// The time when the document was created.
        public var createdTimestamp: Foundation.Date?
        /// The ID of the creator.
        public var creatorId: Swift.String?
        /// The ID of the document.
        public var id: Swift.String?
        /// List of labels on the document.
        public var labels: [Swift.String]?
        /// The latest version of the document.
        public var latestVersionMetadata: WorkDocsClientTypes.DocumentVersionMetadata?
        /// The time when the document was updated.
        public var modifiedTimestamp: Foundation.Date?
        /// The ID of the parent folder.
        public var parentFolderId: Swift.String?
        /// The resource state.
        public var resourceState: WorkDocsClientTypes.ResourceStateType?

        public init(
            createdTimestamp: Foundation.Date? = nil,
            creatorId: Swift.String? = nil,
            id: Swift.String? = nil,
            labels: [Swift.String]? = nil,
            latestVersionMetadata: WorkDocsClientTypes.DocumentVersionMetadata? = nil,
            modifiedTimestamp: Foundation.Date? = nil,
            parentFolderId: Swift.String? = nil,
            resourceState: WorkDocsClientTypes.ResourceStateType? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.creatorId = creatorId
            self.id = id
            self.labels = labels
            self.latestVersionMetadata = latestVersionMetadata
            self.modifiedTimestamp = modifiedTimestamp
            self.parentFolderId = parentFolderId
            self.resourceState = resourceState
        }
    }
}

public struct DescribeFolderContentsOutput: Swift.Sendable {
    /// The documents in the specified folder.
    public var documents: [WorkDocsClientTypes.DocumentMetadata]?
    /// The subfolders in the specified folder.
    public var folders: [WorkDocsClientTypes.FolderMetadata]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?

    public init(
        documents: [WorkDocsClientTypes.DocumentMetadata]? = nil,
        folders: [WorkDocsClientTypes.FolderMetadata]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.documents = documents
        self.folders = folders
        self.marker = marker
    }
}

public struct DescribeGroupsInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The maximum number of items to return with this call.
    public var limit: Swift.Int?
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?
    /// The ID of the organization.
    public var organizationId: Swift.String?
    /// A query to describe groups by group name.
    /// This member is required.
    public var searchQuery: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        searchQuery: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.limit = limit
        self.marker = marker
        self.organizationId = organizationId
        self.searchQuery = searchQuery
    }
}

extension DescribeGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGroupsInput(limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), organizationId: \(Swift.String(describing: organizationId)), authenticationToken: \"CONTENT_REDACTED\", searchQuery: \"CONTENT_REDACTED\")"}
}

public struct DescribeGroupsOutput: Swift.Sendable {
    /// The list of groups.
    public var groups: [WorkDocsClientTypes.GroupMetadata]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?

    public init(
        groups: [WorkDocsClientTypes.GroupMetadata]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.groups = groups
        self.marker = marker
    }
}

public struct DescribeNotificationSubscriptionsInput: Swift.Sendable {
    /// The maximum number of items to return with this call.
    public var limit: Swift.Int?
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?
    /// The ID of the organization.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.organizationId = organizationId
    }
}

public struct DescribeNotificationSubscriptionsOutput: Swift.Sendable {
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?
    /// The subscriptions.
    public var subscriptions: [WorkDocsClientTypes.Subscription]?

    public init(
        marker: Swift.String? = nil,
        subscriptions: [WorkDocsClientTypes.Subscription]? = nil
    )
    {
        self.marker = marker
        self.subscriptions = subscriptions
    }
}

public struct DescribeResourcePermissionsInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The maximum number of items to return with this call.
    public var limit: Swift.Int?
    /// The marker for the next set of results. (You received this marker from a previous call)
    public var marker: Swift.String?
    /// The ID of the principal to filter permissions by.
    public var principalId: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        principalId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.limit = limit
        self.marker = marker
        self.principalId = principalId
        self.resourceId = resourceId
    }
}

extension DescribeResourcePermissionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeResourcePermissionsInput(limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), principalId: \(Swift.String(describing: principalId)), resourceId: \(Swift.String(describing: resourceId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {

    public enum RolePermissionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case direct
        case inherited
        case sdkUnknown(Swift.String)

        public static var allCases: [RolePermissionType] {
            return [
                .direct,
                .inherited
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .direct: return "DIRECT"
            case .inherited: return "INHERITED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    /// Describes the permissions.
    public struct PermissionInfo: Swift.Sendable {
        /// The role of the user.
        public var role: WorkDocsClientTypes.RoleType?
        /// The type of permissions.
        public var type: WorkDocsClientTypes.RolePermissionType?

        public init(
            role: WorkDocsClientTypes.RoleType? = nil,
            type: WorkDocsClientTypes.RolePermissionType? = nil
        )
        {
            self.role = role
            self.type = type
        }
    }
}

extension WorkDocsClientTypes {

    /// Describes a resource.
    public struct Principal: Swift.Sendable {
        /// The ID of the resource.
        public var id: Swift.String?
        /// The permission information for the resource.
        public var roles: [WorkDocsClientTypes.PermissionInfo]?
        /// The type of resource.
        public var type: WorkDocsClientTypes.PrincipalType?

        public init(
            id: Swift.String? = nil,
            roles: [WorkDocsClientTypes.PermissionInfo]? = nil,
            type: WorkDocsClientTypes.PrincipalType? = nil
        )
        {
            self.id = id
            self.roles = roles
            self.type = type
        }
    }
}

public struct DescribeResourcePermissionsOutput: Swift.Sendable {
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?
    /// The principals.
    public var principals: [WorkDocsClientTypes.Principal]?

    public init(
        marker: Swift.String? = nil,
        principals: [WorkDocsClientTypes.Principal]? = nil
    )
    {
        self.marker = marker
        self.principals = principals
    }
}

public struct DescribeRootFoldersInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token.
    /// This member is required.
    public var authenticationToken: Swift.String?
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.limit = limit
        self.marker = marker
    }
}

extension DescribeRootFoldersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRootFoldersInput(limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct DescribeRootFoldersOutput: Swift.Sendable {
    /// The user's special folders.
    public var folders: [WorkDocsClientTypes.FolderMetadata]?
    /// The marker for the next set of results.
    public var marker: Swift.String?

    public init(
        folders: [WorkDocsClientTypes.FolderMetadata]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.folders = folders
        self.marker = marker
    }
}

/// The response is too large to return. The request must include a filter to reduce the size of the response.
public struct RequestedEntityTooLargeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestedEntityTooLargeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension WorkDocsClientTypes {

    public enum UserFilterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activePending
        case all
        case sdkUnknown(Swift.String)

        public static var allCases: [UserFilterType] {
            return [
                .activePending,
                .all
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activePending: return "ACTIVE_PENDING"
            case .all: return "ALL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    public enum UserSortType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fullName
        case storageLimit
        case storageUsed
        case userName
        case userStatus
        case sdkUnknown(Swift.String)

        public static var allCases: [UserSortType] {
            return [
                .fullName,
                .storageLimit,
                .storageUsed,
                .userName,
                .userStatus
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fullName: return "FULL_NAME"
            case .storageLimit: return "STORAGE_LIMIT"
            case .storageUsed: return "STORAGE_USED"
            case .userName: return "USER_NAME"
            case .userStatus: return "USER_STATUS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeUsersInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// A comma-separated list of values. Specify "STORAGE_METADATA" to include the user storage quota and utilization information.
    public var fields: Swift.String?
    /// The state of the users. Specify "ALL" to include inactive users.
    public var include: WorkDocsClientTypes.UserFilterType?
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?
    /// The order for the results.
    public var order: WorkDocsClientTypes.OrderType?
    /// The ID of the organization.
    public var organizationId: Swift.String?
    /// A query to filter users by user name. Remember the following about the Userids and Query parameters:
    ///
    /// * If you don't use either parameter, the API returns a paginated list of all users on the site.
    ///
    /// * If you use both parameters, the API ignores the Query parameter.
    ///
    /// * The Userid parameter only returns user names that match a corresponding user ID.
    ///
    /// * The Query parameter runs a "prefix" search for users by the GivenName, SurName, or UserName fields included in a [CreateUser](https://docs.aws.amazon.com/workdocs/latest/APIReference/API_CreateUser.html) API call. For example, querying on Ma returns Mrcia Oliveira, Mara Garca, and Mateo Jackson. If you use multiple characters, the API only returns data that matches all characters. For example, querying on Ma J only returns Mateo Jackson.
    public var query: Swift.String?
    /// The sorting criteria.
    public var sort: WorkDocsClientTypes.UserSortType?
    /// The IDs of the users.
    public var userIds: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        fields: Swift.String? = nil,
        include: WorkDocsClientTypes.UserFilterType? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        order: WorkDocsClientTypes.OrderType? = nil,
        organizationId: Swift.String? = nil,
        query: Swift.String? = nil,
        sort: WorkDocsClientTypes.UserSortType? = nil,
        userIds: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.fields = fields
        self.include = include
        self.limit = limit
        self.marker = marker
        self.order = order
        self.organizationId = organizationId
        self.query = query
        self.sort = sort
        self.userIds = userIds
    }
}

extension DescribeUsersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUsersInput(fields: \(Swift.String(describing: fields)), include: \(Swift.String(describing: include)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), order: \(Swift.String(describing: order)), organizationId: \(Swift.String(describing: organizationId)), sort: \(Swift.String(describing: sort)), userIds: \(Swift.String(describing: userIds)), authenticationToken: \"CONTENT_REDACTED\", query: \"CONTENT_REDACTED\")"}
}

public struct DescribeUsersOutput: Swift.Sendable {
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?
    /// The total number of users included in the results.
    @available(*, deprecated)
    public var totalNumberOfUsers: Swift.Int?
    /// The users.
    public var users: [WorkDocsClientTypes.User]?

    public init(
        marker: Swift.String? = nil,
        totalNumberOfUsers: Swift.Int? = nil,
        users: [WorkDocsClientTypes.User]? = nil
    )
    {
        self.marker = marker
        self.totalNumberOfUsers = totalNumberOfUsers
        self.users = users
    }
}

public struct GetCurrentUserInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token.
    /// This member is required.
    public var authenticationToken: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
    }
}

extension GetCurrentUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetCurrentUserInput(authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct GetCurrentUserOutput: Swift.Sendable {
    /// Metadata of the user.
    public var user: WorkDocsClientTypes.User?

    public init(
        user: WorkDocsClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

public struct GetDocumentInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// Set this to TRUE to include custom metadata in the response.
    public var includeCustomMetadata: Swift.Bool?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        includeCustomMetadata: Swift.Bool? = false
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.includeCustomMetadata = includeCustomMetadata
    }
}

extension GetDocumentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDocumentInput(documentId: \(Swift.String(describing: documentId)), includeCustomMetadata: \(Swift.String(describing: includeCustomMetadata)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct GetDocumentOutput: Swift.Sendable {
    /// The custom metadata on the document.
    public var customMetadata: [Swift.String: Swift.String]?
    /// The metadata details of the document.
    public var metadata: WorkDocsClientTypes.DocumentMetadata?

    public init(
        customMetadata: [Swift.String: Swift.String]? = nil,
        metadata: WorkDocsClientTypes.DocumentMetadata? = nil
    )
    {
        self.customMetadata = customMetadata
        self.metadata = metadata
    }
}

public struct GetDocumentPathInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// A comma-separated list of values. Specify NAME to include the names of the parent folders.
    public var fields: Swift.String?
    /// The maximum number of levels in the hierarchy to return.
    public var limit: Swift.Int?
    /// This value is not supported.
    public var marker: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        fields: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.fields = fields
        self.limit = limit
        self.marker = marker
    }
}

extension GetDocumentPathInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDocumentPathInput(documentId: \(Swift.String(describing: documentId)), fields: \(Swift.String(describing: fields)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {

    /// Describes the resource path.
    public struct ResourcePathComponent: Swift.Sendable {
        /// The ID of the resource path.
        public var id: Swift.String?
        /// The name of the resource path.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }
}

extension WorkDocsClientTypes.ResourcePathComponent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourcePathComponent(id: \(Swift.String(describing: id)), name: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {

    /// Describes the path information of a resource.
    public struct ResourcePath: Swift.Sendable {
        /// The components of the resource path.
        public var components: [WorkDocsClientTypes.ResourcePathComponent]?

        public init(
            components: [WorkDocsClientTypes.ResourcePathComponent]? = nil
        )
        {
            self.components = components
        }
    }
}

public struct GetDocumentPathOutput: Swift.Sendable {
    /// The path information.
    public var path: WorkDocsClientTypes.ResourcePath?

    public init(
        path: WorkDocsClientTypes.ResourcePath? = nil
    )
    {
        self.path = path
    }
}

public struct GetDocumentVersionInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// A comma-separated list of values. Specify "SOURCE" to include a URL for the source document.
    public var fields: Swift.String?
    /// Set this to TRUE to include custom metadata in the response.
    public var includeCustomMetadata: Swift.Bool?
    /// The version ID of the document.
    /// This member is required.
    public var versionId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        fields: Swift.String? = nil,
        includeCustomMetadata: Swift.Bool? = false,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.fields = fields
        self.includeCustomMetadata = includeCustomMetadata
        self.versionId = versionId
    }
}

extension GetDocumentVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDocumentVersionInput(documentId: \(Swift.String(describing: documentId)), fields: \(Swift.String(describing: fields)), includeCustomMetadata: \(Swift.String(describing: includeCustomMetadata)), versionId: \(Swift.String(describing: versionId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct GetDocumentVersionOutput: Swift.Sendable {
    /// The custom metadata on the document version.
    public var customMetadata: [Swift.String: Swift.String]?
    /// The version metadata.
    public var metadata: WorkDocsClientTypes.DocumentVersionMetadata?

    public init(
        customMetadata: [Swift.String: Swift.String]? = nil,
        metadata: WorkDocsClientTypes.DocumentVersionMetadata? = nil
    )
    {
        self.customMetadata = customMetadata
        self.metadata = metadata
    }
}

public struct GetFolderInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// Set to TRUE to include custom metadata in the response.
    public var includeCustomMetadata: Swift.Bool?

    public init(
        authenticationToken: Swift.String? = nil,
        folderId: Swift.String? = nil,
        includeCustomMetadata: Swift.Bool? = false
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
        self.includeCustomMetadata = includeCustomMetadata
    }
}

extension GetFolderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFolderInput(folderId: \(Swift.String(describing: folderId)), includeCustomMetadata: \(Swift.String(describing: includeCustomMetadata)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct GetFolderOutput: Swift.Sendable {
    /// The custom metadata on the folder.
    public var customMetadata: [Swift.String: Swift.String]?
    /// The metadata of the folder.
    public var metadata: WorkDocsClientTypes.FolderMetadata?

    public init(
        customMetadata: [Swift.String: Swift.String]? = nil,
        metadata: WorkDocsClientTypes.FolderMetadata? = nil
    )
    {
        self.customMetadata = customMetadata
        self.metadata = metadata
    }
}

public struct GetFolderPathInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// A comma-separated list of values. Specify "NAME" to include the names of the parent folders.
    public var fields: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The maximum number of levels in the hierarchy to return.
    public var limit: Swift.Int?
    /// This value is not supported.
    public var marker: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        fields: Swift.String? = nil,
        folderId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.fields = fields
        self.folderId = folderId
        self.limit = limit
        self.marker = marker
    }
}

extension GetFolderPathInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetFolderPathInput(fields: \(Swift.String(describing: fields)), folderId: \(Swift.String(describing: folderId)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct GetFolderPathOutput: Swift.Sendable {
    /// The path information.
    public var path: WorkDocsClientTypes.ResourcePath?

    public init(
        path: WorkDocsClientTypes.ResourcePath? = nil
    )
    {
        self.path = path
    }
}

extension WorkDocsClientTypes {

    public enum ResourceCollectionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sharedWithMe
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceCollectionType] {
            return [
                .sharedWithMe
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sharedWithMe: return "SHARED_WITH_ME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetResourcesInput: Swift.Sendable {
    /// The Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The collection type.
    public var collectionType: WorkDocsClientTypes.ResourceCollectionType?
    /// The maximum number of resources to return.
    public var limit: Swift.Int?
    /// The marker for the next set of results. This marker was received from a previous call.
    public var marker: Swift.String?
    /// The user ID for the resource collection. This is a required field for accessing the API operation using IAM credentials.
    public var userId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        collectionType: WorkDocsClientTypes.ResourceCollectionType? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.collectionType = collectionType
        self.limit = limit
        self.marker = marker
        self.userId = userId
    }
}

extension GetResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourcesInput(collectionType: \(Swift.String(describing: collectionType)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), userId: \(Swift.String(describing: userId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct GetResourcesOutput: Swift.Sendable {
    /// The documents in the specified collection.
    public var documents: [WorkDocsClientTypes.DocumentMetadata]?
    /// The folders in the specified folder.
    public var folders: [WorkDocsClientTypes.FolderMetadata]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?

    public init(
        documents: [WorkDocsClientTypes.DocumentMetadata]? = nil,
        folders: [WorkDocsClientTypes.FolderMetadata]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.documents = documents
        self.folders = folders
        self.marker = marker
    }
}

/// This exception is thrown when a valid checkout ID is not presented on document version upload calls for a document that has been checked out from Web client.
public struct DraftUploadOutOfSyncException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DraftUploadOutOfSyncException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource is already checked out.
public struct ResourceAlreadyCheckedOutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyCheckedOutException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The storage limit has been exceeded.
public struct StorageLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StorageLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The storage limit will be exceeded.
public struct StorageLimitWillExceedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StorageLimitWillExceedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct InitiateDocumentVersionUploadInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The timestamp when the content of the document was originally created.
    public var contentCreatedTimestamp: Foundation.Date?
    /// The timestamp when the content of the document was modified.
    public var contentModifiedTimestamp: Foundation.Date?
    /// The content type of the document.
    public var contentType: Swift.String?
    /// The size of the document, in bytes.
    public var documentSizeInBytes: Swift.Int?
    /// The ID of the document.
    public var id: Swift.String?
    /// The name of the document.
    public var name: Swift.String?
    /// The ID of the parent folder.
    public var parentFolderId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        contentCreatedTimestamp: Foundation.Date? = nil,
        contentModifiedTimestamp: Foundation.Date? = nil,
        contentType: Swift.String? = nil,
        documentSizeInBytes: Swift.Int? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        parentFolderId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.contentCreatedTimestamp = contentCreatedTimestamp
        self.contentModifiedTimestamp = contentModifiedTimestamp
        self.contentType = contentType
        self.documentSizeInBytes = documentSizeInBytes
        self.id = id
        self.name = name
        self.parentFolderId = parentFolderId
    }
}

extension InitiateDocumentVersionUploadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InitiateDocumentVersionUploadInput(contentCreatedTimestamp: \(Swift.String(describing: contentCreatedTimestamp)), contentModifiedTimestamp: \(Swift.String(describing: contentModifiedTimestamp)), contentType: \(Swift.String(describing: contentType)), documentSizeInBytes: \(Swift.String(describing: documentSizeInBytes)), id: \(Swift.String(describing: id)), parentFolderId: \(Swift.String(describing: parentFolderId)), authenticationToken: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {

    /// Describes the upload.
    public struct UploadMetadata: Swift.Sendable {
        /// The signed headers.
        public var signedHeaders: [Swift.String: Swift.String]?
        /// The URL of the upload.
        public var uploadUrl: Swift.String?

        public init(
            signedHeaders: [Swift.String: Swift.String]? = nil,
            uploadUrl: Swift.String? = nil
        )
        {
            self.signedHeaders = signedHeaders
            self.uploadUrl = uploadUrl
        }
    }
}

extension WorkDocsClientTypes.UploadMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UploadMetadata(signedHeaders: \(Swift.String(describing: signedHeaders)), uploadUrl: \"CONTENT_REDACTED\")"}
}

public struct InitiateDocumentVersionUploadOutput: Swift.Sendable {
    /// The document metadata.
    public var metadata: WorkDocsClientTypes.DocumentMetadata?
    /// The upload metadata.
    public var uploadMetadata: WorkDocsClientTypes.UploadMetadata?

    public init(
        metadata: WorkDocsClientTypes.DocumentMetadata? = nil,
        uploadMetadata: WorkDocsClientTypes.UploadMetadata? = nil
    )
    {
        self.metadata = metadata
        self.uploadMetadata = uploadMetadata
    }
}

public struct RemoveAllResourcePermissionsInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.resourceId = resourceId
    }
}

extension RemoveAllResourcePermissionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveAllResourcePermissionsInput(resourceId: \(Swift.String(describing: resourceId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct RemoveResourcePermissionInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The principal ID of the resource.
    /// This member is required.
    public var principalId: Swift.String?
    /// The principal type of the resource.
    public var principalType: WorkDocsClientTypes.PrincipalType?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: WorkDocsClientTypes.PrincipalType? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.principalId = principalId
        self.principalType = principalType
        self.resourceId = resourceId
    }
}

extension RemoveResourcePermissionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RemoveResourcePermissionInput(principalId: \(Swift.String(describing: principalId)), principalType: \(Swift.String(describing: principalType)), resourceId: \(Swift.String(describing: resourceId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct RestoreDocumentVersionsInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
    }
}

extension RestoreDocumentVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreDocumentVersionsInput(documentId: \(Swift.String(describing: documentId)), authenticationToken: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {

    public enum ContentCategoryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case audio
        case document
        case image
        case other
        case pdf
        case presentation
        case sourceCode
        case spreadsheet
        case video
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentCategoryType] {
            return [
                .audio,
                .document,
                .image,
                .other,
                .pdf,
                .presentation,
                .sourceCode,
                .spreadsheet,
                .video
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .audio: return "AUDIO"
            case .document: return "DOCUMENT"
            case .image: return "IMAGE"
            case .other: return "OTHER"
            case .pdf: return "PDF"
            case .presentation: return "PRESENTATION"
            case .sourceCode: return "SOURCE_CODE"
            case .spreadsheet: return "SPREADSHEET"
            case .video: return "VIDEO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    /// Filters results based on timestamp range (in epochs).
    public struct DateRangeType: Swift.Sendable {
        /// Timestamp range end value (in epochs).
        public var endValue: Foundation.Date?
        /// Timestamp range start value (in epochs)
        public var startValue: Foundation.Date?

        public init(
            endValue: Foundation.Date? = nil,
            startValue: Foundation.Date? = nil
        )
        {
            self.endValue = endValue
            self.startValue = startValue
        }
    }
}

extension WorkDocsClientTypes {

    public enum PrincipalRoleType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contributor
        case coowner
        case owner
        case viewer
        case sdkUnknown(Swift.String)

        public static var allCases: [PrincipalRoleType] {
            return [
                .contributor,
                .coowner,
                .owner,
                .viewer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contributor: return "CONTRIBUTOR"
            case .coowner: return "COOWNER"
            case .owner: return "OWNER"
            case .viewer: return "VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    /// Filter based on UserIds or GroupIds.
    public struct SearchPrincipalType: Swift.Sendable {
        /// UserIds or GroupIds.
        /// This member is required.
        public var id: Swift.String?
        /// The Role of a User or Group.
        public var roles: [WorkDocsClientTypes.PrincipalRoleType]?

        public init(
            id: Swift.String? = nil,
            roles: [WorkDocsClientTypes.PrincipalRoleType]? = nil
        )
        {
            self.id = id
            self.roles = roles
        }
    }
}

extension WorkDocsClientTypes {

    public enum SearchResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case comment
        case document
        case documentVersion
        case folder
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchResourceType] {
            return [
                .comment,
                .document,
                .documentVersion,
                .folder
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .comment: return "COMMENT"
            case .document: return "DOCUMENT"
            case .documentVersion: return "DOCUMENT_VERSION"
            case .folder: return "FOLDER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    public enum SearchCollectionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case owned
        case sharedWithMe
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchCollectionType] {
            return [
                .owned,
                .sharedWithMe
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .owned: return "OWNED"
            case .sharedWithMe: return "SHARED_WITH_ME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    /// Filter based on size (in bytes).
    public struct LongRangeType: Swift.Sendable {
        /// The size end range (in bytes).
        public var endValue: Swift.Int?
        /// The size start range (in bytes).
        public var startValue: Swift.Int?

        public init(
            endValue: Swift.Int? = nil,
            startValue: Swift.Int? = nil
        )
        {
            self.endValue = endValue
            self.startValue = startValue
        }
    }
}

extension WorkDocsClientTypes {

    public enum LanguageCodeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ar
        case bg
        case bn
        case cs
        case da
        case de
        case `default`
        case el
        case en
        case es
        case fa
        case fi
        case fr
        case hi
        case hu
        case id
        case it
        case ja
        case ko
        case lt
        case lv
        case nl
        case no
        case pt
        case ro
        case ru
        case sv
        case sw
        case th
        case tr
        case zh
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCodeType] {
            return [
                .ar,
                .bg,
                .bn,
                .cs,
                .da,
                .de,
                .default,
                .el,
                .en,
                .es,
                .fa,
                .fi,
                .fr,
                .hi,
                .hu,
                .id,
                .it,
                .ja,
                .ko,
                .lt,
                .lv,
                .nl,
                .no,
                .pt,
                .ro,
                .ru,
                .sv,
                .sw,
                .th,
                .tr,
                .zh
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ar: return "AR"
            case .bg: return "BG"
            case .bn: return "BN"
            case .cs: return "CS"
            case .da: return "DA"
            case .de: return "DE"
            case .default: return "DEFAULT"
            case .el: return "EL"
            case .en: return "EN"
            case .es: return "ES"
            case .fa: return "FA"
            case .fi: return "FI"
            case .fr: return "FR"
            case .hi: return "HI"
            case .hu: return "HU"
            case .id: return "ID"
            case .it: return "IT"
            case .ja: return "JA"
            case .ko: return "KO"
            case .lt: return "LT"
            case .lv: return "LV"
            case .nl: return "NL"
            case .no: return "NO"
            case .pt: return "PT"
            case .ro: return "RO"
            case .ru: return "RU"
            case .sv: return "SV"
            case .sw: return "SW"
            case .th: return "TH"
            case .tr: return "TR"
            case .zh: return "ZH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    /// Filters results based on entity metadata.
    public struct Filters: Swift.Sendable {
        /// Filter based on resources path.
        public var ancestorIds: [Swift.String]?
        /// Filters by content category.
        public var contentCategories: [WorkDocsClientTypes.ContentCategoryType]?
        /// Filter based on resources creation timestamp.
        public var createdRange: WorkDocsClientTypes.DateRangeType?
        /// Filter by labels using exact match.
        public var labels: [Swift.String]?
        /// Filter based on resources modified timestamp.
        public var modifiedRange: WorkDocsClientTypes.DateRangeType?
        /// Filter based on UserIds or GroupIds.
        public var principals: [WorkDocsClientTypes.SearchPrincipalType]?
        /// Filters based on entity type.
        public var resourceTypes: [WorkDocsClientTypes.SearchResourceType]?
        /// Filter based on file groupings.
        public var searchCollectionTypes: [WorkDocsClientTypes.SearchCollectionType]?
        /// Filter based on size (in bytes).
        public var sizeRange: WorkDocsClientTypes.LongRangeType?
        /// Filters by the locale of the content or comment.
        public var textLocales: [WorkDocsClientTypes.LanguageCodeType]?

        public init(
            ancestorIds: [Swift.String]? = nil,
            contentCategories: [WorkDocsClientTypes.ContentCategoryType]? = nil,
            createdRange: WorkDocsClientTypes.DateRangeType? = nil,
            labels: [Swift.String]? = nil,
            modifiedRange: WorkDocsClientTypes.DateRangeType? = nil,
            principals: [WorkDocsClientTypes.SearchPrincipalType]? = nil,
            resourceTypes: [WorkDocsClientTypes.SearchResourceType]? = nil,
            searchCollectionTypes: [WorkDocsClientTypes.SearchCollectionType]? = nil,
            sizeRange: WorkDocsClientTypes.LongRangeType? = nil,
            textLocales: [WorkDocsClientTypes.LanguageCodeType]? = nil
        )
        {
            self.ancestorIds = ancestorIds
            self.contentCategories = contentCategories
            self.createdRange = createdRange
            self.labels = labels
            self.modifiedRange = modifiedRange
            self.principals = principals
            self.resourceTypes = resourceTypes
            self.searchCollectionTypes = searchCollectionTypes
            self.sizeRange = sizeRange
            self.textLocales = textLocales
        }
    }
}

extension WorkDocsClientTypes {

    public enum OrderByFieldType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createdTimestamp
        case modifiedTimestamp
        case name
        case relevance
        case size
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderByFieldType] {
            return [
                .createdTimestamp,
                .modifiedTimestamp,
                .name,
                .relevance,
                .size
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createdTimestamp: return "CREATED_TIMESTAMP"
            case .modifiedTimestamp: return "MODIFIED_TIMESTAMP"
            case .name: return "NAME"
            case .relevance: return "RELEVANCE"
            case .size: return "SIZE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    public enum SortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .asc,
                .desc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    /// The result of the sort operation.
    public struct SearchSortResult: Swift.Sendable {
        /// Sort search results based on this field name.
        public var field: WorkDocsClientTypes.OrderByFieldType?
        /// Sort direction.
        public var order: WorkDocsClientTypes.SortOrder?

        public init(
            field: WorkDocsClientTypes.OrderByFieldType? = nil,
            order: WorkDocsClientTypes.SortOrder? = nil
        )
        {
            self.field = field
            self.order = order
        }
    }
}

extension WorkDocsClientTypes {

    public enum SearchQueryScopeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case content
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [SearchQueryScopeType] {
            return [
                .content,
                .name
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .content: return "CONTENT"
            case .name: return "NAME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct SearchResourcesInput: Swift.Sendable {
    /// A list of attributes to include in the response. Used to request fields that are not normally returned in a standard response.
    public var additionalResponseFields: [WorkDocsClientTypes.AdditionalResponseFieldType]?
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// Filters results based on entity metadata.
    public var filters: WorkDocsClientTypes.Filters?
    /// Max results count per page.
    public var limit: Swift.Int?
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// Order by results in one or more categories.
    public var orderBy: [WorkDocsClientTypes.SearchSortResult]?
    /// Filters based on the resource owner OrgId. This is a mandatory parameter when using Admin SigV4 credentials.
    public var organizationId: Swift.String?
    /// Filter based on the text field type. A Folder has only a name and no content. A Comment has only content and no name. A Document or Document Version has a name and content
    public var queryScopes: [WorkDocsClientTypes.SearchQueryScopeType]?
    /// The String to search for. Searches across different text fields based on request parameters. Use double quotes around the query string for exact phrase matches.
    public var queryText: Swift.String?

    public init(
        additionalResponseFields: [WorkDocsClientTypes.AdditionalResponseFieldType]? = nil,
        authenticationToken: Swift.String? = nil,
        filters: WorkDocsClientTypes.Filters? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        orderBy: [WorkDocsClientTypes.SearchSortResult]? = nil,
        organizationId: Swift.String? = nil,
        queryScopes: [WorkDocsClientTypes.SearchQueryScopeType]? = nil,
        queryText: Swift.String? = nil
    )
    {
        self.additionalResponseFields = additionalResponseFields
        self.authenticationToken = authenticationToken
        self.filters = filters
        self.limit = limit
        self.marker = marker
        self.orderBy = orderBy
        self.organizationId = organizationId
        self.queryScopes = queryScopes
        self.queryText = queryText
    }
}

extension SearchResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchResourcesInput(additionalResponseFields: \(Swift.String(describing: additionalResponseFields)), filters: \(Swift.String(describing: filters)), limit: \(Swift.String(describing: limit)), marker: \(Swift.String(describing: marker)), orderBy: \(Swift.String(describing: orderBy)), organizationId: \(Swift.String(describing: organizationId)), queryScopes: \(Swift.String(describing: queryScopes)), authenticationToken: \"CONTENT_REDACTED\", queryText: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {

    public enum ResponseItemType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case comment
        case document
        case documentVersion
        case folder
        case sdkUnknown(Swift.String)

        public static var allCases: [ResponseItemType] {
            return [
                .comment,
                .document,
                .documentVersion,
                .folder
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .comment: return "COMMENT"
            case .document: return "DOCUMENT"
            case .documentVersion: return "DOCUMENT_VERSION"
            case .folder: return "FOLDER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkDocsClientTypes {

    /// List of Documents, Folders, Comments, and Document Versions matching the query.
    public struct ResponseItem: Swift.Sendable {
        /// The comment that matches the query.
        public var commentMetadata: WorkDocsClientTypes.CommentMetadata?
        /// The document that matches the query.
        public var documentMetadata: WorkDocsClientTypes.DocumentMetadata?
        /// The document version that matches the metadata.
        public var documentVersionMetadata: WorkDocsClientTypes.DocumentVersionMetadata?
        /// The folder that matches the query.
        public var folderMetadata: WorkDocsClientTypes.FolderMetadata?
        /// The type of item being returned.
        public var resourceType: WorkDocsClientTypes.ResponseItemType?
        /// The webUrl of the item being returned.
        public var webUrl: Swift.String?

        public init(
            commentMetadata: WorkDocsClientTypes.CommentMetadata? = nil,
            documentMetadata: WorkDocsClientTypes.DocumentMetadata? = nil,
            documentVersionMetadata: WorkDocsClientTypes.DocumentVersionMetadata? = nil,
            folderMetadata: WorkDocsClientTypes.FolderMetadata? = nil,
            resourceType: WorkDocsClientTypes.ResponseItemType? = nil,
            webUrl: Swift.String? = nil
        )
        {
            self.commentMetadata = commentMetadata
            self.documentMetadata = documentMetadata
            self.documentVersionMetadata = documentVersionMetadata
            self.folderMetadata = folderMetadata
            self.resourceType = resourceType
            self.webUrl = webUrl
        }
    }
}

extension WorkDocsClientTypes.ResponseItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResponseItem(commentMetadata: \(Swift.String(describing: commentMetadata)), documentMetadata: \(Swift.String(describing: documentMetadata)), documentVersionMetadata: \(Swift.String(describing: documentVersionMetadata)), folderMetadata: \(Swift.String(describing: folderMetadata)), resourceType: \(Swift.String(describing: resourceType)), webUrl: \"CONTENT_REDACTED\")"}
}

public struct SearchResourcesOutput: Swift.Sendable {
    /// List of Documents, Folders, Comments, and Document Versions matching the query.
    public var items: [WorkDocsClientTypes.ResponseItem]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?

    public init(
        items: [WorkDocsClientTypes.ResponseItem]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.items = items
        self.marker = marker
    }
}

public struct UpdateDocumentInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// The name of the document.
    public var name: Swift.String?
    /// The ID of the parent folder.
    public var parentFolderId: Swift.String?
    /// The resource state of the document. Only ACTIVE and RECYCLED are supported.
    public var resourceState: WorkDocsClientTypes.ResourceStateType?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        name: Swift.String? = nil,
        parentFolderId: Swift.String? = nil,
        resourceState: WorkDocsClientTypes.ResourceStateType? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.name = name
        self.parentFolderId = parentFolderId
        self.resourceState = resourceState
    }
}

extension UpdateDocumentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDocumentInput(documentId: \(Swift.String(describing: documentId)), parentFolderId: \(Swift.String(describing: parentFolderId)), resourceState: \(Swift.String(describing: resourceState)), authenticationToken: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension WorkDocsClientTypes {

    public enum DocumentVersionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentVersionStatus] {
            return [
                .active
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateDocumentVersionInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// The version ID of the document.
    /// This member is required.
    public var versionId: Swift.String?
    /// The status of the version.
    public var versionStatus: WorkDocsClientTypes.DocumentVersionStatus?

    public init(
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        versionId: Swift.String? = nil,
        versionStatus: WorkDocsClientTypes.DocumentVersionStatus? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.versionId = versionId
        self.versionStatus = versionStatus
    }
}

extension UpdateDocumentVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDocumentVersionInput(documentId: \(Swift.String(describing: documentId)), versionId: \(Swift.String(describing: versionId)), versionStatus: \(Swift.String(describing: versionStatus)), authenticationToken: \"CONTENT_REDACTED\")"}
}

public struct UpdateFolderInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The name of the folder.
    public var name: Swift.String?
    /// The ID of the parent folder.
    public var parentFolderId: Swift.String?
    /// The resource state of the folder. Only ACTIVE and RECYCLED are accepted values from the API.
    public var resourceState: WorkDocsClientTypes.ResourceStateType?

    public init(
        authenticationToken: Swift.String? = nil,
        folderId: Swift.String? = nil,
        name: Swift.String? = nil,
        parentFolderId: Swift.String? = nil,
        resourceState: WorkDocsClientTypes.ResourceStateType? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
        self.name = name
        self.parentFolderId = parentFolderId
        self.resourceState = resourceState
    }
}

extension UpdateFolderInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateFolderInput(folderId: \(Swift.String(describing: folderId)), parentFolderId: \(Swift.String(describing: parentFolderId)), resourceState: \(Swift.String(describing: resourceState)), authenticationToken: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

/// The last user in the organization is being deactivated.
public struct DeactivatingLastSystemUserException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeactivatingLastSystemUserException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

/// The user is undergoing transfer of ownership.
public struct IllegalUserStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalUserStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension WorkDocsClientTypes {

    public enum BooleanEnumType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `false`
        case `true`
        case sdkUnknown(Swift.String)

        public static var allCases: [BooleanEnumType] {
            return [
                .false,
                .true
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .false: return "FALSE"
            case .true: return "TRUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateUserInput: Swift.Sendable {
    /// Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The given name of the user.
    public var givenName: Swift.String?
    /// Boolean value to determine whether the user is granted Power user privileges.
    public var grantPoweruserPrivileges: WorkDocsClientTypes.BooleanEnumType?
    /// The locale of the user.
    public var locale: WorkDocsClientTypes.LocaleType?
    /// The amount of storage for the user.
    public var storageRule: WorkDocsClientTypes.StorageRuleType?
    /// The surname of the user.
    public var surname: Swift.String?
    /// The time zone ID of the user.
    public var timeZoneId: Swift.String?
    /// The type of the user.
    public var type: WorkDocsClientTypes.UserType?
    /// The ID of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        authenticationToken: Swift.String? = nil,
        givenName: Swift.String? = nil,
        grantPoweruserPrivileges: WorkDocsClientTypes.BooleanEnumType? = nil,
        locale: WorkDocsClientTypes.LocaleType? = nil,
        storageRule: WorkDocsClientTypes.StorageRuleType? = nil,
        surname: Swift.String? = nil,
        timeZoneId: Swift.String? = nil,
        type: WorkDocsClientTypes.UserType? = nil,
        userId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.givenName = givenName
        self.grantPoweruserPrivileges = grantPoweruserPrivileges
        self.locale = locale
        self.storageRule = storageRule
        self.surname = surname
        self.timeZoneId = timeZoneId
        self.type = type
        self.userId = userId
    }
}

extension UpdateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserInput(grantPoweruserPrivileges: \(Swift.String(describing: grantPoweruserPrivileges)), locale: \(Swift.String(describing: locale)), storageRule: \(Swift.String(describing: storageRule)), timeZoneId: \(Swift.String(describing: timeZoneId)), type: \(Swift.String(describing: type)), userId: \(Swift.String(describing: userId)), authenticationToken: \"CONTENT_REDACTED\", givenName: \"CONTENT_REDACTED\", surname: \"CONTENT_REDACTED\")"}
}

public struct UpdateUserOutput: Swift.Sendable {
    /// The user information.
    public var user: WorkDocsClientTypes.User?

    public init(
        user: WorkDocsClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

extension AbortDocumentVersionUploadInput {

    static func urlPathProvider(_ value: AbortDocumentVersionUploadInput) -> Swift.String? {
        guard let documentId = value.documentId else {
            return nil
        }
        guard let versionId = value.versionId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())"
    }
}

extension AbortDocumentVersionUploadInput {

    static func headerProvider(_ value: AbortDocumentVersionUploadInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension ActivateUserInput {

    static func urlPathProvider(_ value: ActivateUserInput) -> Swift.String? {
        guard let userId = value.userId else {
            return nil
        }
        return "/api/v1/users/\(userId.urlPercentEncoding())/activation"
    }
}

extension ActivateUserInput {

    static func headerProvider(_ value: ActivateUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension AddResourcePermissionsInput {

    static func urlPathProvider(_ value: AddResourcePermissionsInput) -> Swift.String? {
        guard let resourceId = value.resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/permissions"
    }
}

extension AddResourcePermissionsInput {

    static func headerProvider(_ value: AddResourcePermissionsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension CreateCommentInput {

    static func urlPathProvider(_ value: CreateCommentInput) -> Swift.String? {
        guard let documentId = value.documentId else {
            return nil
        }
        guard let versionId = value.versionId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())/comment"
    }
}

extension CreateCommentInput {

    static func headerProvider(_ value: CreateCommentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension CreateCustomMetadataInput {

    static func urlPathProvider(_ value: CreateCustomMetadataInput) -> Swift.String? {
        guard let resourceId = value.resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/customMetadata"
    }
}

extension CreateCustomMetadataInput {

    static func headerProvider(_ value: CreateCustomMetadataInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension CreateCustomMetadataInput {

    static func queryItemProvider(_ value: CreateCustomMetadataInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let versionId = value.versionId {
            let versionIdQueryItem = Smithy.URIQueryItem(name: "versionid".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        return items
    }
}

extension CreateFolderInput {

    static func urlPathProvider(_ value: CreateFolderInput) -> Swift.String? {
        return "/api/v1/folders"
    }
}

extension CreateFolderInput {

    static func headerProvider(_ value: CreateFolderInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension CreateLabelsInput {

    static func urlPathProvider(_ value: CreateLabelsInput) -> Swift.String? {
        guard let resourceId = value.resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/labels"
    }
}

extension CreateLabelsInput {

    static func headerProvider(_ value: CreateLabelsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension CreateNotificationSubscriptionInput {

    static func urlPathProvider(_ value: CreateNotificationSubscriptionInput) -> Swift.String? {
        guard let organizationId = value.organizationId else {
            return nil
        }
        return "/api/v1/organizations/\(organizationId.urlPercentEncoding())/subscriptions"
    }
}

extension CreateUserInput {

    static func urlPathProvider(_ value: CreateUserInput) -> Swift.String? {
        return "/api/v1/users"
    }
}

extension CreateUserInput {

    static func headerProvider(_ value: CreateUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeactivateUserInput {

    static func urlPathProvider(_ value: DeactivateUserInput) -> Swift.String? {
        guard let userId = value.userId else {
            return nil
        }
        return "/api/v1/users/\(userId.urlPercentEncoding())/activation"
    }
}

extension DeactivateUserInput {

    static func headerProvider(_ value: DeactivateUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteCommentInput {

    static func urlPathProvider(_ value: DeleteCommentInput) -> Swift.String? {
        guard let documentId = value.documentId else {
            return nil
        }
        guard let versionId = value.versionId else {
            return nil
        }
        guard let commentId = value.commentId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())/comment/\(commentId.urlPercentEncoding())"
    }
}

extension DeleteCommentInput {

    static func headerProvider(_ value: DeleteCommentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteCustomMetadataInput {

    static func urlPathProvider(_ value: DeleteCustomMetadataInput) -> Swift.String? {
        guard let resourceId = value.resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/customMetadata"
    }
}

extension DeleteCustomMetadataInput {

    static func headerProvider(_ value: DeleteCustomMetadataInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteCustomMetadataInput {

    static func queryItemProvider(_ value: DeleteCustomMetadataInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let versionId = value.versionId {
            let versionIdQueryItem = Smithy.URIQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        if let deleteAll = value.deleteAll {
            let deleteAllQueryItem = Smithy.URIQueryItem(name: "deleteAll".urlPercentEncoding(), value: Swift.String(deleteAll).urlPercentEncoding())
            items.append(deleteAllQueryItem)
        }
        if let keys = value.keys {
            keys.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "keys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension DeleteDocumentInput {

    static func urlPathProvider(_ value: DeleteDocumentInput) -> Swift.String? {
        guard let documentId = value.documentId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())"
    }
}

extension DeleteDocumentInput {

    static func headerProvider(_ value: DeleteDocumentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteDocumentVersionInput {

    static func urlPathProvider(_ value: DeleteDocumentVersionInput) -> Swift.String? {
        guard let documentId = value.documentId else {
            return nil
        }
        guard let versionId = value.versionId else {
            return nil
        }
        return "/api/v1/documentVersions/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())"
    }
}

extension DeleteDocumentVersionInput {

    static func headerProvider(_ value: DeleteDocumentVersionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteDocumentVersionInput {

    static func queryItemProvider(_ value: DeleteDocumentVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let deletePriorVersions = value.deletePriorVersions else {
            let message = "Creating a URL Query Item failed. deletePriorVersions is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let deletePriorVersionsQueryItem = Smithy.URIQueryItem(name: "deletePriorVersions".urlPercentEncoding(), value: Swift.String(deletePriorVersions).urlPercentEncoding())
        items.append(deletePriorVersionsQueryItem)
        return items
    }
}

extension DeleteFolderInput {

    static func urlPathProvider(_ value: DeleteFolderInput) -> Swift.String? {
        guard let folderId = value.folderId else {
            return nil
        }
        return "/api/v1/folders/\(folderId.urlPercentEncoding())"
    }
}

extension DeleteFolderInput {

    static func headerProvider(_ value: DeleteFolderInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteFolderContentsInput {

    static func urlPathProvider(_ value: DeleteFolderContentsInput) -> Swift.String? {
        guard let folderId = value.folderId else {
            return nil
        }
        return "/api/v1/folders/\(folderId.urlPercentEncoding())/contents"
    }
}

extension DeleteFolderContentsInput {

    static func headerProvider(_ value: DeleteFolderContentsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteLabelsInput {

    static func urlPathProvider(_ value: DeleteLabelsInput) -> Swift.String? {
        guard let resourceId = value.resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/labels"
    }
}

extension DeleteLabelsInput {

    static func headerProvider(_ value: DeleteLabelsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteLabelsInput {

    static func queryItemProvider(_ value: DeleteLabelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let deleteAll = value.deleteAll {
            let deleteAllQueryItem = Smithy.URIQueryItem(name: "deleteAll".urlPercentEncoding(), value: Swift.String(deleteAll).urlPercentEncoding())
            items.append(deleteAllQueryItem)
        }
        if let labels = value.labels {
            labels.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "labels".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension DeleteNotificationSubscriptionInput {

    static func urlPathProvider(_ value: DeleteNotificationSubscriptionInput) -> Swift.String? {
        guard let organizationId = value.organizationId else {
            return nil
        }
        guard let subscriptionId = value.subscriptionId else {
            return nil
        }
        return "/api/v1/organizations/\(organizationId.urlPercentEncoding())/subscriptions/\(subscriptionId.urlPercentEncoding())"
    }
}

extension DeleteUserInput {

    static func urlPathProvider(_ value: DeleteUserInput) -> Swift.String? {
        guard let userId = value.userId else {
            return nil
        }
        return "/api/v1/users/\(userId.urlPercentEncoding())"
    }
}

extension DeleteUserInput {

    static func headerProvider(_ value: DeleteUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeActivitiesInput {

    static func urlPathProvider(_ value: DescribeActivitiesInput) -> Swift.String? {
        return "/api/v1/activities"
    }
}

extension DescribeActivitiesInput {

    static func headerProvider(_ value: DescribeActivitiesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeActivitiesInput {

    static func queryItemProvider(_ value: DescribeActivitiesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let endTime = value.endTime {
            let endTimeQueryItem = Smithy.URIQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
            items.append(endTimeQueryItem)
        }
        if let resourceId = value.resourceId {
            let resourceIdQueryItem = Smithy.URIQueryItem(name: "resourceId".urlPercentEncoding(), value: Swift.String(resourceId).urlPercentEncoding())
            items.append(resourceIdQueryItem)
        }
        if let userId = value.userId {
            let userIdQueryItem = Smithy.URIQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
            items.append(userIdQueryItem)
        }
        if let startTime = value.startTime {
            let startTimeQueryItem = Smithy.URIQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
            items.append(startTimeQueryItem)
        }
        if let includeIndirectActivities = value.includeIndirectActivities {
            let includeIndirectActivitiesQueryItem = Smithy.URIQueryItem(name: "includeIndirectActivities".urlPercentEncoding(), value: Swift.String(includeIndirectActivities).urlPercentEncoding())
            items.append(includeIndirectActivitiesQueryItem)
        }
        if let organizationId = value.organizationId {
            let organizationIdQueryItem = Smithy.URIQueryItem(name: "organizationId".urlPercentEncoding(), value: Swift.String(organizationId).urlPercentEncoding())
            items.append(organizationIdQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let activityTypes = value.activityTypes {
            let activityTypesQueryItem = Smithy.URIQueryItem(name: "activityTypes".urlPercentEncoding(), value: Swift.String(activityTypes).urlPercentEncoding())
            items.append(activityTypesQueryItem)
        }
        return items
    }
}

extension DescribeCommentsInput {

    static func urlPathProvider(_ value: DescribeCommentsInput) -> Swift.String? {
        guard let documentId = value.documentId else {
            return nil
        }
        guard let versionId = value.versionId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())/comments"
    }
}

extension DescribeCommentsInput {

    static func headerProvider(_ value: DescribeCommentsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeCommentsInput {

    static func queryItemProvider(_ value: DescribeCommentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        return items
    }
}

extension DescribeDocumentVersionsInput {

    static func urlPathProvider(_ value: DescribeDocumentVersionsInput) -> Swift.String? {
        guard let documentId = value.documentId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions"
    }
}

extension DescribeDocumentVersionsInput {

    static func headerProvider(_ value: DescribeDocumentVersionsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeDocumentVersionsInput {

    static func queryItemProvider(_ value: DescribeDocumentVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let fields = value.fields {
            let fieldsQueryItem = Smithy.URIQueryItem(name: "fields".urlPercentEncoding(), value: Swift.String(fields).urlPercentEncoding())
            items.append(fieldsQueryItem)
        }
        if let include = value.include {
            let includeQueryItem = Smithy.URIQueryItem(name: "include".urlPercentEncoding(), value: Swift.String(include).urlPercentEncoding())
            items.append(includeQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension DescribeFolderContentsInput {

    static func urlPathProvider(_ value: DescribeFolderContentsInput) -> Swift.String? {
        guard let folderId = value.folderId else {
            return nil
        }
        return "/api/v1/folders/\(folderId.urlPercentEncoding())/contents"
    }
}

extension DescribeFolderContentsInput {

    static func headerProvider(_ value: DescribeFolderContentsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeFolderContentsInput {

    static func queryItemProvider(_ value: DescribeFolderContentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let order = value.order {
            let orderQueryItem = Smithy.URIQueryItem(name: "order".urlPercentEncoding(), value: Swift.String(order.rawValue).urlPercentEncoding())
            items.append(orderQueryItem)
        }
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let sort = value.sort {
            let sortQueryItem = Smithy.URIQueryItem(name: "sort".urlPercentEncoding(), value: Swift.String(sort.rawValue).urlPercentEncoding())
            items.append(sortQueryItem)
        }
        if let include = value.include {
            let includeQueryItem = Smithy.URIQueryItem(name: "include".urlPercentEncoding(), value: Swift.String(include).urlPercentEncoding())
            items.append(includeQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        return items
    }
}

extension DescribeGroupsInput {

    static func urlPathProvider(_ value: DescribeGroupsInput) -> Swift.String? {
        return "/api/v1/groups"
    }
}

extension DescribeGroupsInput {

    static func headerProvider(_ value: DescribeGroupsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeGroupsInput {

    static func queryItemProvider(_ value: DescribeGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let searchQuery = value.searchQuery else {
            let message = "Creating a URL Query Item failed. searchQuery is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let searchQueryQueryItem = Smithy.URIQueryItem(name: "searchQuery".urlPercentEncoding(), value: Swift.String(searchQuery).urlPercentEncoding())
        items.append(searchQueryQueryItem)
        if let organizationId = value.organizationId {
            let organizationIdQueryItem = Smithy.URIQueryItem(name: "organizationId".urlPercentEncoding(), value: Swift.String(organizationId).urlPercentEncoding())
            items.append(organizationIdQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension DescribeNotificationSubscriptionsInput {

    static func urlPathProvider(_ value: DescribeNotificationSubscriptionsInput) -> Swift.String? {
        guard let organizationId = value.organizationId else {
            return nil
        }
        return "/api/v1/organizations/\(organizationId.urlPercentEncoding())/subscriptions"
    }
}

extension DescribeNotificationSubscriptionsInput {

    static func queryItemProvider(_ value: DescribeNotificationSubscriptionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension DescribeResourcePermissionsInput {

    static func urlPathProvider(_ value: DescribeResourcePermissionsInput) -> Swift.String? {
        guard let resourceId = value.resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/permissions"
    }
}

extension DescribeResourcePermissionsInput {

    static func headerProvider(_ value: DescribeResourcePermissionsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeResourcePermissionsInput {

    static func queryItemProvider(_ value: DescribeResourcePermissionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let principalId = value.principalId {
            let principalIdQueryItem = Smithy.URIQueryItem(name: "principalId".urlPercentEncoding(), value: Swift.String(principalId).urlPercentEncoding())
            items.append(principalIdQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        return items
    }
}

extension DescribeRootFoldersInput {

    static func urlPathProvider(_ value: DescribeRootFoldersInput) -> Swift.String? {
        return "/api/v1/me/root"
    }
}

extension DescribeRootFoldersInput {

    static func headerProvider(_ value: DescribeRootFoldersInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeRootFoldersInput {

    static func queryItemProvider(_ value: DescribeRootFoldersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        return items
    }
}

extension DescribeUsersInput {

    static func urlPathProvider(_ value: DescribeUsersInput) -> Swift.String? {
        return "/api/v1/users"
    }
}

extension DescribeUsersInput {

    static func headerProvider(_ value: DescribeUsersInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeUsersInput {

    static func queryItemProvider(_ value: DescribeUsersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let order = value.order {
            let orderQueryItem = Smithy.URIQueryItem(name: "order".urlPercentEncoding(), value: Swift.String(order.rawValue).urlPercentEncoding())
            items.append(orderQueryItem)
        }
        if let fields = value.fields {
            let fieldsQueryItem = Smithy.URIQueryItem(name: "fields".urlPercentEncoding(), value: Swift.String(fields).urlPercentEncoding())
            items.append(fieldsQueryItem)
        }
        if let query = value.query {
            let queryQueryItem = Smithy.URIQueryItem(name: "query".urlPercentEncoding(), value: Swift.String(query).urlPercentEncoding())
            items.append(queryQueryItem)
        }
        if let include = value.include {
            let includeQueryItem = Smithy.URIQueryItem(name: "include".urlPercentEncoding(), value: Swift.String(include.rawValue).urlPercentEncoding())
            items.append(includeQueryItem)
        }
        if let sort = value.sort {
            let sortQueryItem = Smithy.URIQueryItem(name: "sort".urlPercentEncoding(), value: Swift.String(sort.rawValue).urlPercentEncoding())
            items.append(sortQueryItem)
        }
        if let organizationId = value.organizationId {
            let organizationIdQueryItem = Smithy.URIQueryItem(name: "organizationId".urlPercentEncoding(), value: Swift.String(organizationId).urlPercentEncoding())
            items.append(organizationIdQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let userIds = value.userIds {
            let userIdsQueryItem = Smithy.URIQueryItem(name: "userIds".urlPercentEncoding(), value: Swift.String(userIds).urlPercentEncoding())
            items.append(userIdsQueryItem)
        }
        return items
    }
}

extension GetCurrentUserInput {

    static func urlPathProvider(_ value: GetCurrentUserInput) -> Swift.String? {
        return "/api/v1/me"
    }
}

extension GetCurrentUserInput {

    static func headerProvider(_ value: GetCurrentUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetDocumentInput {

    static func urlPathProvider(_ value: GetDocumentInput) -> Swift.String? {
        guard let documentId = value.documentId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())"
    }
}

extension GetDocumentInput {

    static func headerProvider(_ value: GetDocumentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetDocumentInput {

    static func queryItemProvider(_ value: GetDocumentInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let includeCustomMetadata = value.includeCustomMetadata {
            let includeCustomMetadataQueryItem = Smithy.URIQueryItem(name: "includeCustomMetadata".urlPercentEncoding(), value: Swift.String(includeCustomMetadata).urlPercentEncoding())
            items.append(includeCustomMetadataQueryItem)
        }
        return items
    }
}

extension GetDocumentPathInput {

    static func urlPathProvider(_ value: GetDocumentPathInput) -> Swift.String? {
        guard let documentId = value.documentId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/path"
    }
}

extension GetDocumentPathInput {

    static func headerProvider(_ value: GetDocumentPathInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetDocumentPathInput {

    static func queryItemProvider(_ value: GetDocumentPathInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let fields = value.fields {
            let fieldsQueryItem = Smithy.URIQueryItem(name: "fields".urlPercentEncoding(), value: Swift.String(fields).urlPercentEncoding())
            items.append(fieldsQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        return items
    }
}

extension GetDocumentVersionInput {

    static func urlPathProvider(_ value: GetDocumentVersionInput) -> Swift.String? {
        guard let documentId = value.documentId else {
            return nil
        }
        guard let versionId = value.versionId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())"
    }
}

extension GetDocumentVersionInput {

    static func headerProvider(_ value: GetDocumentVersionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetDocumentVersionInput {

    static func queryItemProvider(_ value: GetDocumentVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let fields = value.fields {
            let fieldsQueryItem = Smithy.URIQueryItem(name: "fields".urlPercentEncoding(), value: Swift.String(fields).urlPercentEncoding())
            items.append(fieldsQueryItem)
        }
        if let includeCustomMetadata = value.includeCustomMetadata {
            let includeCustomMetadataQueryItem = Smithy.URIQueryItem(name: "includeCustomMetadata".urlPercentEncoding(), value: Swift.String(includeCustomMetadata).urlPercentEncoding())
            items.append(includeCustomMetadataQueryItem)
        }
        return items
    }
}

extension GetFolderInput {

    static func urlPathProvider(_ value: GetFolderInput) -> Swift.String? {
        guard let folderId = value.folderId else {
            return nil
        }
        return "/api/v1/folders/\(folderId.urlPercentEncoding())"
    }
}

extension GetFolderInput {

    static func headerProvider(_ value: GetFolderInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetFolderInput {

    static func queryItemProvider(_ value: GetFolderInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let includeCustomMetadata = value.includeCustomMetadata {
            let includeCustomMetadataQueryItem = Smithy.URIQueryItem(name: "includeCustomMetadata".urlPercentEncoding(), value: Swift.String(includeCustomMetadata).urlPercentEncoding())
            items.append(includeCustomMetadataQueryItem)
        }
        return items
    }
}

extension GetFolderPathInput {

    static func urlPathProvider(_ value: GetFolderPathInput) -> Swift.String? {
        guard let folderId = value.folderId else {
            return nil
        }
        return "/api/v1/folders/\(folderId.urlPercentEncoding())/path"
    }
}

extension GetFolderPathInput {

    static func headerProvider(_ value: GetFolderPathInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetFolderPathInput {

    static func queryItemProvider(_ value: GetFolderPathInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let fields = value.fields {
            let fieldsQueryItem = Smithy.URIQueryItem(name: "fields".urlPercentEncoding(), value: Swift.String(fields).urlPercentEncoding())
            items.append(fieldsQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        return items
    }
}

extension GetResourcesInput {

    static func urlPathProvider(_ value: GetResourcesInput) -> Swift.String? {
        return "/api/v1/resources"
    }
}

extension GetResourcesInput {

    static func headerProvider(_ value: GetResourcesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetResourcesInput {

    static func queryItemProvider(_ value: GetResourcesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let userId = value.userId {
            let userIdQueryItem = Smithy.URIQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
            items.append(userIdQueryItem)
        }
        if let collectionType = value.collectionType {
            let collectionTypeQueryItem = Smithy.URIQueryItem(name: "collectionType".urlPercentEncoding(), value: Swift.String(collectionType.rawValue).urlPercentEncoding())
            items.append(collectionTypeQueryItem)
        }
        if let limit = value.limit {
            let limitQueryItem = Smithy.URIQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let marker = value.marker {
            let markerQueryItem = Smithy.URIQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        return items
    }
}

extension InitiateDocumentVersionUploadInput {

    static func urlPathProvider(_ value: InitiateDocumentVersionUploadInput) -> Swift.String? {
        return "/api/v1/documents"
    }
}

extension InitiateDocumentVersionUploadInput {

    static func headerProvider(_ value: InitiateDocumentVersionUploadInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension RemoveAllResourcePermissionsInput {

    static func urlPathProvider(_ value: RemoveAllResourcePermissionsInput) -> Swift.String? {
        guard let resourceId = value.resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/permissions"
    }
}

extension RemoveAllResourcePermissionsInput {

    static func headerProvider(_ value: RemoveAllResourcePermissionsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension RemoveResourcePermissionInput {

    static func urlPathProvider(_ value: RemoveResourcePermissionInput) -> Swift.String? {
        guard let resourceId = value.resourceId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/permissions/\(principalId.urlPercentEncoding())"
    }
}

extension RemoveResourcePermissionInput {

    static func headerProvider(_ value: RemoveResourcePermissionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension RemoveResourcePermissionInput {

    static func queryItemProvider(_ value: RemoveResourcePermissionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let principalType = value.principalType {
            let principalTypeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(principalType.rawValue).urlPercentEncoding())
            items.append(principalTypeQueryItem)
        }
        return items
    }
}

extension RestoreDocumentVersionsInput {

    static func urlPathProvider(_ value: RestoreDocumentVersionsInput) -> Swift.String? {
        guard let documentId = value.documentId else {
            return nil
        }
        return "/api/v1/documentVersions/restore/\(documentId.urlPercentEncoding())"
    }
}

extension RestoreDocumentVersionsInput {

    static func headerProvider(_ value: RestoreDocumentVersionsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension SearchResourcesInput {

    static func urlPathProvider(_ value: SearchResourcesInput) -> Swift.String? {
        return "/api/v1/search"
    }
}

extension SearchResourcesInput {

    static func headerProvider(_ value: SearchResourcesInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension UpdateDocumentInput {

    static func urlPathProvider(_ value: UpdateDocumentInput) -> Swift.String? {
        guard let documentId = value.documentId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())"
    }
}

extension UpdateDocumentInput {

    static func headerProvider(_ value: UpdateDocumentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension UpdateDocumentVersionInput {

    static func urlPathProvider(_ value: UpdateDocumentVersionInput) -> Swift.String? {
        guard let documentId = value.documentId else {
            return nil
        }
        guard let versionId = value.versionId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())"
    }
}

extension UpdateDocumentVersionInput {

    static func headerProvider(_ value: UpdateDocumentVersionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension UpdateFolderInput {

    static func urlPathProvider(_ value: UpdateFolderInput) -> Swift.String? {
        guard let folderId = value.folderId else {
            return nil
        }
        return "/api/v1/folders/\(folderId.urlPercentEncoding())"
    }
}

extension UpdateFolderInput {

    static func headerProvider(_ value: UpdateFolderInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension UpdateUserInput {

    static func urlPathProvider(_ value: UpdateUserInput) -> Swift.String? {
        guard let userId = value.userId else {
            return nil
        }
        return "/api/v1/users/\(userId.urlPercentEncoding())"
    }
}

extension UpdateUserInput {

    static func headerProvider(_ value: UpdateUserInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let authenticationToken = value.authenticationToken {
            items.add(SmithyHTTPAPI.Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension AddResourcePermissionsInput {

    static func write(value: AddResourcePermissionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NotificationOptions"].write(value.notificationOptions, with: WorkDocsClientTypes.NotificationOptions.write(value:to:))
        try writer["Principals"].writeList(value.principals, memberWritingClosure: WorkDocsClientTypes.SharePrincipal.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateCommentInput {

    static func write(value: CreateCommentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NotifyCollaborators"].write(value.notifyCollaborators)
        try writer["ParentId"].write(value.parentId)
        try writer["Text"].write(value.text)
        try writer["ThreadId"].write(value.threadId)
        try writer["Visibility"].write(value.visibility)
    }
}

extension CreateCustomMetadataInput {

    static func write(value: CreateCustomMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomMetadata"].writeMap(value.customMetadata, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateFolderInput {

    static func write(value: CreateFolderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["ParentFolderId"].write(value.parentFolderId)
    }
}

extension CreateLabelsInput {

    static func write(value: CreateLabelsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Labels"].writeList(value.labels, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateNotificationSubscriptionInput {

    static func write(value: CreateNotificationSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Endpoint"].write(value.endpoint)
        try writer["Protocol"].write(value.`protocol`)
        try writer["SubscriptionType"].write(value.subscriptionType)
    }
}

extension CreateUserInput {

    static func write(value: CreateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EmailAddress"].write(value.emailAddress)
        try writer["GivenName"].write(value.givenName)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["Password"].write(value.password)
        try writer["StorageRule"].write(value.storageRule, with: WorkDocsClientTypes.StorageRuleType.write(value:to:))
        try writer["Surname"].write(value.surname)
        try writer["TimeZoneId"].write(value.timeZoneId)
        try writer["Username"].write(value.username)
    }
}

extension InitiateDocumentVersionUploadInput {

    static func write(value: InitiateDocumentVersionUploadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContentCreatedTimestamp"].writeTimestamp(value.contentCreatedTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ContentModifiedTimestamp"].writeTimestamp(value.contentModifiedTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ContentType"].write(value.contentType)
        try writer["DocumentSizeInBytes"].write(value.documentSizeInBytes)
        try writer["Id"].write(value.id)
        try writer["Name"].write(value.name)
        try writer["ParentFolderId"].write(value.parentFolderId)
    }
}

extension SearchResourcesInput {

    static func write(value: SearchResourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalResponseFields"].writeList(value.additionalResponseFields, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkDocsClientTypes.AdditionalResponseFieldType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filters"].write(value.filters, with: WorkDocsClientTypes.Filters.write(value:to:))
        try writer["Limit"].write(value.limit)
        try writer["Marker"].write(value.marker)
        try writer["OrderBy"].writeList(value.orderBy, memberWritingClosure: WorkDocsClientTypes.SearchSortResult.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OrganizationId"].write(value.organizationId)
        try writer["QueryScopes"].writeList(value.queryScopes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkDocsClientTypes.SearchQueryScopeType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["QueryText"].write(value.queryText)
    }
}

extension UpdateDocumentInput {

    static func write(value: UpdateDocumentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["ParentFolderId"].write(value.parentFolderId)
        try writer["ResourceState"].write(value.resourceState)
    }
}

extension UpdateDocumentVersionInput {

    static func write(value: UpdateDocumentVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VersionStatus"].write(value.versionStatus)
    }
}

extension UpdateFolderInput {

    static func write(value: UpdateFolderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["ParentFolderId"].write(value.parentFolderId)
        try writer["ResourceState"].write(value.resourceState)
    }
}

extension UpdateUserInput {

    static func write(value: UpdateUserInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GivenName"].write(value.givenName)
        try writer["GrantPoweruserPrivileges"].write(value.grantPoweruserPrivileges)
        try writer["Locale"].write(value.locale)
        try writer["StorageRule"].write(value.storageRule, with: WorkDocsClientTypes.StorageRuleType.write(value:to:))
        try writer["Surname"].write(value.surname)
        try writer["TimeZoneId"].write(value.timeZoneId)
        try writer["Type"].write(value.type)
    }
}

extension AbortDocumentVersionUploadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AbortDocumentVersionUploadOutput {
        return AbortDocumentVersionUploadOutput()
    }
}

extension ActivateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ActivateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ActivateUserOutput()
        value.user = try reader["User"].readIfPresent(with: WorkDocsClientTypes.User.read(from:))
        return value
    }
}

extension AddResourcePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddResourcePermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddResourcePermissionsOutput()
        value.shareResults = try reader["ShareResults"].readListIfPresent(memberReadingClosure: WorkDocsClientTypes.ShareResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateCommentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCommentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCommentOutput()
        value.comment = try reader["Comment"].readIfPresent(with: WorkDocsClientTypes.Comment.read(from:))
        return value
    }
}

extension CreateCustomMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCustomMetadataOutput {
        return CreateCustomMetadataOutput()
    }
}

extension CreateFolderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFolderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFolderOutput()
        value.metadata = try reader["Metadata"].readIfPresent(with: WorkDocsClientTypes.FolderMetadata.read(from:))
        return value
    }
}

extension CreateLabelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLabelsOutput {
        return CreateLabelsOutput()
    }
}

extension CreateNotificationSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateNotificationSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNotificationSubscriptionOutput()
        value.subscription = try reader["Subscription"].readIfPresent(with: WorkDocsClientTypes.Subscription.read(from:))
        return value
    }
}

extension CreateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUserOutput()
        value.user = try reader["User"].readIfPresent(with: WorkDocsClientTypes.User.read(from:))
        return value
    }
}

extension DeactivateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeactivateUserOutput {
        return DeactivateUserOutput()
    }
}

extension DeleteCommentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCommentOutput {
        return DeleteCommentOutput()
    }
}

extension DeleteCustomMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCustomMetadataOutput {
        return DeleteCustomMetadataOutput()
    }
}

extension DeleteDocumentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDocumentOutput {
        return DeleteDocumentOutput()
    }
}

extension DeleteDocumentVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDocumentVersionOutput {
        return DeleteDocumentVersionOutput()
    }
}

extension DeleteFolderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFolderOutput {
        return DeleteFolderOutput()
    }
}

extension DeleteFolderContentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFolderContentsOutput {
        return DeleteFolderContentsOutput()
    }
}

extension DeleteLabelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLabelsOutput {
        return DeleteLabelsOutput()
    }
}

extension DeleteNotificationSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteNotificationSubscriptionOutput {
        return DeleteNotificationSubscriptionOutput()
    }
}

extension DeleteUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUserOutput {
        return DeleteUserOutput()
    }
}

extension DescribeActivitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeActivitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeActivitiesOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.userActivities = try reader["UserActivities"].readListIfPresent(memberReadingClosure: WorkDocsClientTypes.Activity.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeCommentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCommentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCommentsOutput()
        value.comments = try reader["Comments"].readListIfPresent(memberReadingClosure: WorkDocsClientTypes.Comment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension DescribeDocumentVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDocumentVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDocumentVersionsOutput()
        value.documentVersions = try reader["DocumentVersions"].readListIfPresent(memberReadingClosure: WorkDocsClientTypes.DocumentVersionMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension DescribeFolderContentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeFolderContentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeFolderContentsOutput()
        value.documents = try reader["Documents"].readListIfPresent(memberReadingClosure: WorkDocsClientTypes.DocumentMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.folders = try reader["Folders"].readListIfPresent(memberReadingClosure: WorkDocsClientTypes.FolderMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension DescribeGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeGroupsOutput()
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: WorkDocsClientTypes.GroupMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension DescribeNotificationSubscriptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeNotificationSubscriptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeNotificationSubscriptionsOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.subscriptions = try reader["Subscriptions"].readListIfPresent(memberReadingClosure: WorkDocsClientTypes.Subscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeResourcePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeResourcePermissionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeResourcePermissionsOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.principals = try reader["Principals"].readListIfPresent(memberReadingClosure: WorkDocsClientTypes.Principal.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeRootFoldersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRootFoldersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRootFoldersOutput()
        value.folders = try reader["Folders"].readListIfPresent(memberReadingClosure: WorkDocsClientTypes.FolderMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension DescribeUsersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeUsersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeUsersOutput()
        value.marker = try reader["Marker"].readIfPresent()
        value.totalNumberOfUsers = try reader["TotalNumberOfUsers"].readIfPresent()
        value.users = try reader["Users"].readListIfPresent(memberReadingClosure: WorkDocsClientTypes.User.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetCurrentUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCurrentUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCurrentUserOutput()
        value.user = try reader["User"].readIfPresent(with: WorkDocsClientTypes.User.read(from:))
        return value
    }
}

extension GetDocumentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDocumentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDocumentOutput()
        value.customMetadata = try reader["CustomMetadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.metadata = try reader["Metadata"].readIfPresent(with: WorkDocsClientTypes.DocumentMetadata.read(from:))
        return value
    }
}

extension GetDocumentPathOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDocumentPathOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDocumentPathOutput()
        value.path = try reader["Path"].readIfPresent(with: WorkDocsClientTypes.ResourcePath.read(from:))
        return value
    }
}

extension GetDocumentVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDocumentVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDocumentVersionOutput()
        value.customMetadata = try reader["CustomMetadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.metadata = try reader["Metadata"].readIfPresent(with: WorkDocsClientTypes.DocumentVersionMetadata.read(from:))
        return value
    }
}

extension GetFolderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFolderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFolderOutput()
        value.customMetadata = try reader["CustomMetadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.metadata = try reader["Metadata"].readIfPresent(with: WorkDocsClientTypes.FolderMetadata.read(from:))
        return value
    }
}

extension GetFolderPathOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFolderPathOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFolderPathOutput()
        value.path = try reader["Path"].readIfPresent(with: WorkDocsClientTypes.ResourcePath.read(from:))
        return value
    }
}

extension GetResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcesOutput()
        value.documents = try reader["Documents"].readListIfPresent(memberReadingClosure: WorkDocsClientTypes.DocumentMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.folders = try reader["Folders"].readListIfPresent(memberReadingClosure: WorkDocsClientTypes.FolderMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension InitiateDocumentVersionUploadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InitiateDocumentVersionUploadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = InitiateDocumentVersionUploadOutput()
        value.metadata = try reader["Metadata"].readIfPresent(with: WorkDocsClientTypes.DocumentMetadata.read(from:))
        value.uploadMetadata = try reader["UploadMetadata"].readIfPresent(with: WorkDocsClientTypes.UploadMetadata.read(from:))
        return value
    }
}

extension RemoveAllResourcePermissionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveAllResourcePermissionsOutput {
        return RemoveAllResourcePermissionsOutput()
    }
}

extension RemoveResourcePermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveResourcePermissionOutput {
        return RemoveResourcePermissionOutput()
    }
}

extension RestoreDocumentVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RestoreDocumentVersionsOutput {
        return RestoreDocumentVersionsOutput()
    }
}

extension SearchResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SearchResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SearchResourcesOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: WorkDocsClientTypes.ResponseItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.marker = try reader["Marker"].readIfPresent()
        return value
    }
}

extension UpdateDocumentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDocumentOutput {
        return UpdateDocumentOutput()
    }
}

extension UpdateDocumentVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDocumentVersionOutput {
        return UpdateDocumentVersionOutput()
    }
}

extension UpdateFolderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFolderOutput {
        return UpdateFolderOutput()
    }
}

extension UpdateUserOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUserOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateUserOutput()
        value.user = try reader["User"].readIfPresent(with: WorkDocsClientTypes.User.read(from:))
        return value
    }
}

enum AbortDocumentVersionUploadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ActivateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AddResourcePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCommentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DocumentLockedForCommentsException": return try DocumentLockedForCommentsException.makeError(baseError: baseError)
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "InvalidCommentOperationException": return try InvalidCommentOperationException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCustomMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CustomMetadataLimitExceededException": return try CustomMetadataLimitExceededException.makeError(baseError: baseError)
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFolderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "EntityAlreadyExistsException": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLabelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyLabelsException": return try TooManyLabelsException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateNotificationSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManySubscriptionsException": return try TooManySubscriptionsException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityAlreadyExistsException": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeactivateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCommentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DocumentLockedForCommentsException": return try DocumentLockedForCommentsException.makeError(baseError: baseError)
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCustomMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDocumentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDocumentVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFolderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFolderContentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLabelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteNotificationSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeActivitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCommentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDocumentVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidPasswordException": return try InvalidPasswordException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeFolderContentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeNotificationSubscriptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeResourcePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRootFoldersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeUsersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "RequestedEntityTooLargeException": return try RequestedEntityTooLargeException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCurrentUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDocumentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidPasswordException": return try InvalidPasswordException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDocumentPathOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDocumentVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "InvalidPasswordException": return try InvalidPasswordException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFolderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFolderPathOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InitiateDocumentVersionUploadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DraftUploadOutOfSyncException": return try DraftUploadOutOfSyncException.makeError(baseError: baseError)
            case "EntityAlreadyExistsException": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidPasswordException": return try InvalidPasswordException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ResourceAlreadyCheckedOutException": return try ResourceAlreadyCheckedOutException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "StorageLimitExceededException": return try StorageLimitExceededException.makeError(baseError: baseError)
            case "StorageLimitWillExceedException": return try StorageLimitWillExceedException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveAllResourcePermissionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveResourcePermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RestoreDocumentVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SearchResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDocumentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "EntityAlreadyExistsException": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDocumentVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFolderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "EntityAlreadyExistsException": return try EntityAlreadyExistsException.makeError(baseError: baseError)
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUserOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DeactivatingLastSystemUserException": return try DeactivatingLastSystemUserException.makeError(baseError: baseError)
            case "EntityNotExistsException": return try EntityNotExistsException.makeError(baseError: baseError)
            case "FailedDependencyException": return try FailedDependencyException.makeError(baseError: baseError)
            case "IllegalUserStateException": return try IllegalUserStateException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ProhibitedStateException": return try ProhibitedStateException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperationException": return try UnauthorizedOperationException.makeError(baseError: baseError)
            case "UnauthorizedResourceAccessException": return try UnauthorizedResourceAccessException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension FailedDependencyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> FailedDependencyException {
        let reader = baseError.errorBodyReader
        var value = FailedDependencyException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConcurrentModificationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConcurrentModificationException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentModificationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ProhibitedStateException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ProhibitedStateException {
        let reader = baseError.errorBodyReader
        var value = ProhibitedStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedOperationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedOperationException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedOperationException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedResourceAccessException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedResourceAccessException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedResourceAccessException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EntityNotExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> EntityNotExistsException {
        let reader = baseError.errorBodyReader
        var value = EntityNotExistsException()
        value.properties.entityIds = try reader["EntityIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidCommentOperationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidCommentOperationException {
        let reader = baseError.errorBodyReader
        var value = InvalidCommentOperationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DocumentLockedForCommentsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DocumentLockedForCommentsException {
        let reader = baseError.errorBodyReader
        var value = DocumentLockedForCommentsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CustomMetadataLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> CustomMetadataLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = CustomMetadataLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictingOperationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictingOperationException {
        let reader = baseError.errorBodyReader
        var value = ConflictingOperationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EntityAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> EntityAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = EntityAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyLabelsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyLabelsException {
        let reader = baseError.errorBodyReader
        var value = TooManyLabelsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidArgumentException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidArgumentException {
        let reader = baseError.errorBodyReader
        var value = InvalidArgumentException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManySubscriptionsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManySubscriptionsException {
        let reader = baseError.errorBodyReader
        var value = TooManySubscriptionsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidOperationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidOperationException {
        let reader = baseError.errorBodyReader
        var value = InvalidOperationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPasswordException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidPasswordException {
        let reader = baseError.errorBodyReader
        var value = InvalidPasswordException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RequestedEntityTooLargeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RequestedEntityTooLargeException {
        let reader = baseError.errorBodyReader
        var value = RequestedEntityTooLargeException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DraftUploadOutOfSyncException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DraftUploadOutOfSyncException {
        let reader = baseError.errorBodyReader
        var value = DraftUploadOutOfSyncException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyCheckedOutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceAlreadyCheckedOutException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyCheckedOutException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StorageLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> StorageLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = StorageLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StorageLimitWillExceedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> StorageLimitWillExceedException {
        let reader = baseError.errorBodyReader
        var value = StorageLimitWillExceedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IllegalUserStateException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> IllegalUserStateException {
        let reader = baseError.errorBodyReader
        var value = IllegalUserStateException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DeactivatingLastSystemUserException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DeactivatingLastSystemUserException {
        let reader = baseError.errorBodyReader
        var value = DeactivatingLastSystemUserException()
        value.properties.code = try reader["Code"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension WorkDocsClientTypes.User {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.User {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.User()
        value.id = try reader["Id"].readIfPresent()
        value.username = try reader["Username"].readIfPresent()
        value.emailAddress = try reader["EmailAddress"].readIfPresent()
        value.givenName = try reader["GivenName"].readIfPresent()
        value.surname = try reader["Surname"].readIfPresent()
        value.organizationId = try reader["OrganizationId"].readIfPresent()
        value.rootFolderId = try reader["RootFolderId"].readIfPresent()
        value.recycleBinFolderId = try reader["RecycleBinFolderId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.modifiedTimestamp = try reader["ModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.timeZoneId = try reader["TimeZoneId"].readIfPresent()
        value.locale = try reader["Locale"].readIfPresent()
        value.storage = try reader["Storage"].readIfPresent(with: WorkDocsClientTypes.UserStorageMetadata.read(from:))
        return value
    }
}

extension WorkDocsClientTypes.UserStorageMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.UserStorageMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.UserStorageMetadata()
        value.storageUtilizedInBytes = try reader["StorageUtilizedInBytes"].readIfPresent()
        value.storageRule = try reader["StorageRule"].readIfPresent(with: WorkDocsClientTypes.StorageRuleType.read(from:))
        return value
    }
}

extension WorkDocsClientTypes.StorageRuleType {

    static func write(value: WorkDocsClientTypes.StorageRuleType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StorageAllocatedInBytes"].write(value.storageAllocatedInBytes)
        try writer["StorageType"].write(value.storageType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.StorageRuleType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.StorageRuleType()
        value.storageAllocatedInBytes = try reader["StorageAllocatedInBytes"].readIfPresent()
        value.storageType = try reader["StorageType"].readIfPresent()
        return value
    }
}

extension WorkDocsClientTypes.ShareResult {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.ShareResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.ShareResult()
        value.principalId = try reader["PrincipalId"].readIfPresent()
        value.inviteePrincipalId = try reader["InviteePrincipalId"].readIfPresent()
        value.role = try reader["Role"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.shareId = try reader["ShareId"].readIfPresent()
        value.statusMessage = try reader["StatusMessage"].readIfPresent()
        return value
    }
}

extension WorkDocsClientTypes.Comment {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.Comment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.Comment()
        value.commentId = try reader["CommentId"].readIfPresent() ?? ""
        value.parentId = try reader["ParentId"].readIfPresent()
        value.threadId = try reader["ThreadId"].readIfPresent()
        value.text = try reader["Text"].readIfPresent()
        value.contributor = try reader["Contributor"].readIfPresent(with: WorkDocsClientTypes.User.read(from:))
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.recipientId = try reader["RecipientId"].readIfPresent()
        return value
    }
}

extension WorkDocsClientTypes.FolderMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.FolderMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.FolderMetadata()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.creatorId = try reader["CreatorId"].readIfPresent()
        value.parentFolderId = try reader["ParentFolderId"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.modifiedTimestamp = try reader["ModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.resourceState = try reader["ResourceState"].readIfPresent()
        value.signature = try reader["Signature"].readIfPresent()
        value.labels = try reader["Labels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.size = try reader["Size"].readIfPresent()
        value.latestVersionSize = try reader["LatestVersionSize"].readIfPresent()
        return value
    }
}

extension WorkDocsClientTypes.Subscription {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.Subscription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.Subscription()
        value.subscriptionId = try reader["SubscriptionId"].readIfPresent()
        value.endPoint = try reader["EndPoint"].readIfPresent()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        return value
    }
}

extension WorkDocsClientTypes.Activity {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.Activity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.Activity()
        value.type = try reader["Type"].readIfPresent()
        value.timeStamp = try reader["TimeStamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.isIndirectActivity = try reader["IsIndirectActivity"].readIfPresent() ?? false
        value.organizationId = try reader["OrganizationId"].readIfPresent()
        value.initiator = try reader["Initiator"].readIfPresent(with: WorkDocsClientTypes.UserMetadata.read(from:))
        value.participants = try reader["Participants"].readIfPresent(with: WorkDocsClientTypes.Participants.read(from:))
        value.resourceMetadata = try reader["ResourceMetadata"].readIfPresent(with: WorkDocsClientTypes.ResourceMetadata.read(from:))
        value.originalParent = try reader["OriginalParent"].readIfPresent(with: WorkDocsClientTypes.ResourceMetadata.read(from:))
        value.commentMetadata = try reader["CommentMetadata"].readIfPresent(with: WorkDocsClientTypes.CommentMetadata.read(from:))
        return value
    }
}

extension WorkDocsClientTypes.CommentMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.CommentMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.CommentMetadata()
        value.commentId = try reader["CommentId"].readIfPresent()
        value.contributor = try reader["Contributor"].readIfPresent(with: WorkDocsClientTypes.User.read(from:))
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.commentStatus = try reader["CommentStatus"].readIfPresent()
        value.recipientId = try reader["RecipientId"].readIfPresent()
        value.contributorId = try reader["ContributorId"].readIfPresent()
        return value
    }
}

extension WorkDocsClientTypes.ResourceMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.ResourceMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.ResourceMetadata()
        value.type = try reader["Type"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.originalName = try reader["OriginalName"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.versionId = try reader["VersionId"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent(with: WorkDocsClientTypes.UserMetadata.read(from:))
        value.parentId = try reader["ParentId"].readIfPresent()
        return value
    }
}

extension WorkDocsClientTypes.UserMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.UserMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.UserMetadata()
        value.id = try reader["Id"].readIfPresent()
        value.username = try reader["Username"].readIfPresent()
        value.givenName = try reader["GivenName"].readIfPresent()
        value.surname = try reader["Surname"].readIfPresent()
        value.emailAddress = try reader["EmailAddress"].readIfPresent()
        return value
    }
}

extension WorkDocsClientTypes.Participants {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.Participants {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.Participants()
        value.users = try reader["Users"].readListIfPresent(memberReadingClosure: WorkDocsClientTypes.UserMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: WorkDocsClientTypes.GroupMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WorkDocsClientTypes.GroupMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.GroupMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.GroupMetadata()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension WorkDocsClientTypes.DocumentVersionMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.DocumentVersionMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.DocumentVersionMetadata()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.contentType = try reader["ContentType"].readIfPresent()
        value.size = try reader["Size"].readIfPresent()
        value.signature = try reader["Signature"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.modifiedTimestamp = try reader["ModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.contentCreatedTimestamp = try reader["ContentCreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.contentModifiedTimestamp = try reader["ContentModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creatorId = try reader["CreatorId"].readIfPresent()
        value.thumbnail = try reader["Thumbnail"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.source = try reader["Source"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WorkDocsClientTypes.DocumentMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.DocumentMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.DocumentMetadata()
        value.id = try reader["Id"].readIfPresent()
        value.creatorId = try reader["CreatorId"].readIfPresent()
        value.parentFolderId = try reader["ParentFolderId"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.modifiedTimestamp = try reader["ModifiedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.latestVersionMetadata = try reader["LatestVersionMetadata"].readIfPresent(with: WorkDocsClientTypes.DocumentVersionMetadata.read(from:))
        value.resourceState = try reader["ResourceState"].readIfPresent()
        value.labels = try reader["Labels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WorkDocsClientTypes.Principal {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.Principal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.Principal()
        value.id = try reader["Id"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.roles = try reader["Roles"].readListIfPresent(memberReadingClosure: WorkDocsClientTypes.PermissionInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WorkDocsClientTypes.PermissionInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.PermissionInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.PermissionInfo()
        value.role = try reader["Role"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension WorkDocsClientTypes.ResourcePath {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.ResourcePath {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.ResourcePath()
        value.components = try reader["Components"].readListIfPresent(memberReadingClosure: WorkDocsClientTypes.ResourcePathComponent.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WorkDocsClientTypes.ResourcePathComponent {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.ResourcePathComponent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.ResourcePathComponent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension WorkDocsClientTypes.UploadMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.UploadMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.UploadMetadata()
        value.uploadUrl = try reader["UploadUrl"].readIfPresent()
        value.signedHeaders = try reader["SignedHeaders"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WorkDocsClientTypes.ResponseItem {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkDocsClientTypes.ResponseItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkDocsClientTypes.ResponseItem()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.webUrl = try reader["WebUrl"].readIfPresent()
        value.documentMetadata = try reader["DocumentMetadata"].readIfPresent(with: WorkDocsClientTypes.DocumentMetadata.read(from:))
        value.folderMetadata = try reader["FolderMetadata"].readIfPresent(with: WorkDocsClientTypes.FolderMetadata.read(from:))
        value.commentMetadata = try reader["CommentMetadata"].readIfPresent(with: WorkDocsClientTypes.CommentMetadata.read(from:))
        value.documentVersionMetadata = try reader["DocumentVersionMetadata"].readIfPresent(with: WorkDocsClientTypes.DocumentVersionMetadata.read(from:))
        return value
    }
}

extension WorkDocsClientTypes.SharePrincipal {

    static func write(value: WorkDocsClientTypes.SharePrincipal?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["Role"].write(value.role)
        try writer["Type"].write(value.type)
    }
}

extension WorkDocsClientTypes.NotificationOptions {

    static func write(value: WorkDocsClientTypes.NotificationOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EmailMessage"].write(value.emailMessage)
        try writer["SendEmail"].write(value.sendEmail)
    }
}

extension WorkDocsClientTypes.Filters {

    static func write(value: WorkDocsClientTypes.Filters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AncestorIds"].writeList(value.ancestorIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ContentCategories"].writeList(value.contentCategories, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkDocsClientTypes.ContentCategoryType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CreatedRange"].write(value.createdRange, with: WorkDocsClientTypes.DateRangeType.write(value:to:))
        try writer["Labels"].writeList(value.labels, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ModifiedRange"].write(value.modifiedRange, with: WorkDocsClientTypes.DateRangeType.write(value:to:))
        try writer["Principals"].writeList(value.principals, memberWritingClosure: WorkDocsClientTypes.SearchPrincipalType.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceTypes"].writeList(value.resourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkDocsClientTypes.SearchResourceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SearchCollectionTypes"].writeList(value.searchCollectionTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkDocsClientTypes.SearchCollectionType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SizeRange"].write(value.sizeRange, with: WorkDocsClientTypes.LongRangeType.write(value:to:))
        try writer["TextLocales"].writeList(value.textLocales, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkDocsClientTypes.LanguageCodeType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension WorkDocsClientTypes.DateRangeType {

    static func write(value: WorkDocsClientTypes.DateRangeType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndValue"].writeTimestamp(value.endValue, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["StartValue"].writeTimestamp(value.startValue, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension WorkDocsClientTypes.LongRangeType {

    static func write(value: WorkDocsClientTypes.LongRangeType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndValue"].write(value.endValue)
        try writer["StartValue"].write(value.startValue)
    }
}

extension WorkDocsClientTypes.SearchPrincipalType {

    static func write(value: WorkDocsClientTypes.SearchPrincipalType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["Roles"].writeList(value.roles, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkDocsClientTypes.PrincipalRoleType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension WorkDocsClientTypes.SearchSortResult {

    static func write(value: WorkDocsClientTypes.SearchSortResult?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Field"].write(value.field)
        try writer["Order"].write(value.order)
    }
}

public enum WorkDocsClientTypes {}
