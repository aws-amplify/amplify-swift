//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension IoTClient {
    /// Paginate over `[GetBehaviorModelTrainingSummariesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetBehaviorModelTrainingSummariesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetBehaviorModelTrainingSummariesOutput`
    public func getBehaviorModelTrainingSummariesPaginated(input: GetBehaviorModelTrainingSummariesInput) -> ClientRuntime.PaginatorSequence<GetBehaviorModelTrainingSummariesInput, GetBehaviorModelTrainingSummariesOutput> {
        return ClientRuntime.PaginatorSequence<GetBehaviorModelTrainingSummariesInput, GetBehaviorModelTrainingSummariesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getBehaviorModelTrainingSummaries(input:))
    }
}

extension GetBehaviorModelTrainingSummariesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetBehaviorModelTrainingSummariesInput {
        return GetBehaviorModelTrainingSummariesInput(
            maxResults: self.maxResults,
            nextToken: token,
            securityProfileName: self.securityProfileName
        )}
}

extension PaginatorSequence where OperationStackInput == GetBehaviorModelTrainingSummariesInput, OperationStackOutput == GetBehaviorModelTrainingSummariesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getBehaviorModelTrainingSummariesPaginated`
    /// to access the nested member `[IoTClientTypes.BehaviorModelTrainingSummary]`
    /// - Returns: `[IoTClientTypes.BehaviorModelTrainingSummary]`
    public func summaries() async throws -> [IoTClientTypes.BehaviorModelTrainingSummary] {
        return try await self.asyncCompactMap { item in item.summaries }
    }
}
extension IoTClient {
    /// Paginate over `[ListActiveViolationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListActiveViolationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListActiveViolationsOutput`
    public func listActiveViolationsPaginated(input: ListActiveViolationsInput) -> ClientRuntime.PaginatorSequence<ListActiveViolationsInput, ListActiveViolationsOutput> {
        return ClientRuntime.PaginatorSequence<ListActiveViolationsInput, ListActiveViolationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listActiveViolations(input:))
    }
}

extension ListActiveViolationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListActiveViolationsInput {
        return ListActiveViolationsInput(
            behaviorCriteriaType: self.behaviorCriteriaType,
            listSuppressedAlerts: self.listSuppressedAlerts,
            maxResults: self.maxResults,
            nextToken: token,
            securityProfileName: self.securityProfileName,
            thingName: self.thingName,
            verificationState: self.verificationState
        )}
}

extension PaginatorSequence where OperationStackInput == ListActiveViolationsInput, OperationStackOutput == ListActiveViolationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listActiveViolationsPaginated`
    /// to access the nested member `[IoTClientTypes.ActiveViolation]`
    /// - Returns: `[IoTClientTypes.ActiveViolation]`
    public func activeViolations() async throws -> [IoTClientTypes.ActiveViolation] {
        return try await self.asyncCompactMap { item in item.activeViolations }
    }
}
extension IoTClient {
    /// Paginate over `[ListAttachedPoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAttachedPoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAttachedPoliciesOutput`
    public func listAttachedPoliciesPaginated(input: ListAttachedPoliciesInput) -> ClientRuntime.PaginatorSequence<ListAttachedPoliciesInput, ListAttachedPoliciesOutput> {
        return ClientRuntime.PaginatorSequence<ListAttachedPoliciesInput, ListAttachedPoliciesOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listAttachedPolicies(input:))
    }
}

extension ListAttachedPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAttachedPoliciesInput {
        return ListAttachedPoliciesInput(
            marker: token,
            pageSize: self.pageSize,
            recursive: self.recursive,
            target: self.target
        )}
}

extension PaginatorSequence where OperationStackInput == ListAttachedPoliciesInput, OperationStackOutput == ListAttachedPoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAttachedPoliciesPaginated`
    /// to access the nested member `[IoTClientTypes.Policy]`
    /// - Returns: `[IoTClientTypes.Policy]`
    public func policies() async throws -> [IoTClientTypes.Policy] {
        return try await self.asyncCompactMap { item in item.policies }
    }
}
extension IoTClient {
    /// Paginate over `[ListAuditFindingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAuditFindingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAuditFindingsOutput`
    public func listAuditFindingsPaginated(input: ListAuditFindingsInput) -> ClientRuntime.PaginatorSequence<ListAuditFindingsInput, ListAuditFindingsOutput> {
        return ClientRuntime.PaginatorSequence<ListAuditFindingsInput, ListAuditFindingsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAuditFindings(input:))
    }
}

extension ListAuditFindingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAuditFindingsInput {
        return ListAuditFindingsInput(
            checkName: self.checkName,
            endTime: self.endTime,
            listSuppressedFindings: self.listSuppressedFindings,
            maxResults: self.maxResults,
            nextToken: token,
            resourceIdentifier: self.resourceIdentifier,
            startTime: self.startTime,
            taskId: self.taskId
        )}
}

extension PaginatorSequence where OperationStackInput == ListAuditFindingsInput, OperationStackOutput == ListAuditFindingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAuditFindingsPaginated`
    /// to access the nested member `[IoTClientTypes.AuditFinding]`
    /// - Returns: `[IoTClientTypes.AuditFinding]`
    public func findings() async throws -> [IoTClientTypes.AuditFinding] {
        return try await self.asyncCompactMap { item in item.findings }
    }
}
extension IoTClient {
    /// Paginate over `[ListAuditMitigationActionsExecutionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAuditMitigationActionsExecutionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAuditMitigationActionsExecutionsOutput`
    public func listAuditMitigationActionsExecutionsPaginated(input: ListAuditMitigationActionsExecutionsInput) -> ClientRuntime.PaginatorSequence<ListAuditMitigationActionsExecutionsInput, ListAuditMitigationActionsExecutionsOutput> {
        return ClientRuntime.PaginatorSequence<ListAuditMitigationActionsExecutionsInput, ListAuditMitigationActionsExecutionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAuditMitigationActionsExecutions(input:))
    }
}

extension ListAuditMitigationActionsExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAuditMitigationActionsExecutionsInput {
        return ListAuditMitigationActionsExecutionsInput(
            actionStatus: self.actionStatus,
            findingId: self.findingId,
            maxResults: self.maxResults,
            nextToken: token,
            taskId: self.taskId
        )}
}

extension PaginatorSequence where OperationStackInput == ListAuditMitigationActionsExecutionsInput, OperationStackOutput == ListAuditMitigationActionsExecutionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAuditMitigationActionsExecutionsPaginated`
    /// to access the nested member `[IoTClientTypes.AuditMitigationActionExecutionMetadata]`
    /// - Returns: `[IoTClientTypes.AuditMitigationActionExecutionMetadata]`
    public func actionsExecutions() async throws -> [IoTClientTypes.AuditMitigationActionExecutionMetadata] {
        return try await self.asyncCompactMap { item in item.actionsExecutions }
    }
}
extension IoTClient {
    /// Paginate over `[ListAuditMitigationActionsTasksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAuditMitigationActionsTasksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAuditMitigationActionsTasksOutput`
    public func listAuditMitigationActionsTasksPaginated(input: ListAuditMitigationActionsTasksInput) -> ClientRuntime.PaginatorSequence<ListAuditMitigationActionsTasksInput, ListAuditMitigationActionsTasksOutput> {
        return ClientRuntime.PaginatorSequence<ListAuditMitigationActionsTasksInput, ListAuditMitigationActionsTasksOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAuditMitigationActionsTasks(input:))
    }
}

extension ListAuditMitigationActionsTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAuditMitigationActionsTasksInput {
        return ListAuditMitigationActionsTasksInput(
            auditTaskId: self.auditTaskId,
            endTime: self.endTime,
            findingId: self.findingId,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime,
            taskStatus: self.taskStatus
        )}
}

extension PaginatorSequence where OperationStackInput == ListAuditMitigationActionsTasksInput, OperationStackOutput == ListAuditMitigationActionsTasksOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAuditMitigationActionsTasksPaginated`
    /// to access the nested member `[IoTClientTypes.AuditMitigationActionsTaskMetadata]`
    /// - Returns: `[IoTClientTypes.AuditMitigationActionsTaskMetadata]`
    public func tasks() async throws -> [IoTClientTypes.AuditMitigationActionsTaskMetadata] {
        return try await self.asyncCompactMap { item in item.tasks }
    }
}
extension IoTClient {
    /// Paginate over `[ListAuditSuppressionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAuditSuppressionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAuditSuppressionsOutput`
    public func listAuditSuppressionsPaginated(input: ListAuditSuppressionsInput) -> ClientRuntime.PaginatorSequence<ListAuditSuppressionsInput, ListAuditSuppressionsOutput> {
        return ClientRuntime.PaginatorSequence<ListAuditSuppressionsInput, ListAuditSuppressionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAuditSuppressions(input:))
    }
}

extension ListAuditSuppressionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAuditSuppressionsInput {
        return ListAuditSuppressionsInput(
            ascendingOrder: self.ascendingOrder,
            checkName: self.checkName,
            maxResults: self.maxResults,
            nextToken: token,
            resourceIdentifier: self.resourceIdentifier
        )}
}

extension PaginatorSequence where OperationStackInput == ListAuditSuppressionsInput, OperationStackOutput == ListAuditSuppressionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAuditSuppressionsPaginated`
    /// to access the nested member `[IoTClientTypes.AuditSuppression]`
    /// - Returns: `[IoTClientTypes.AuditSuppression]`
    public func suppressions() async throws -> [IoTClientTypes.AuditSuppression] {
        return try await self.asyncCompactMap { item in item.suppressions }
    }
}
extension IoTClient {
    /// Paginate over `[ListAuditTasksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAuditTasksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAuditTasksOutput`
    public func listAuditTasksPaginated(input: ListAuditTasksInput) -> ClientRuntime.PaginatorSequence<ListAuditTasksInput, ListAuditTasksOutput> {
        return ClientRuntime.PaginatorSequence<ListAuditTasksInput, ListAuditTasksOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAuditTasks(input:))
    }
}

extension ListAuditTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAuditTasksInput {
        return ListAuditTasksInput(
            endTime: self.endTime,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime,
            taskStatus: self.taskStatus,
            taskType: self.taskType
        )}
}

extension PaginatorSequence where OperationStackInput == ListAuditTasksInput, OperationStackOutput == ListAuditTasksOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAuditTasksPaginated`
    /// to access the nested member `[IoTClientTypes.AuditTaskMetadata]`
    /// - Returns: `[IoTClientTypes.AuditTaskMetadata]`
    public func tasks() async throws -> [IoTClientTypes.AuditTaskMetadata] {
        return try await self.asyncCompactMap { item in item.tasks }
    }
}
extension IoTClient {
    /// Paginate over `[ListAuthorizersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAuthorizersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAuthorizersOutput`
    public func listAuthorizersPaginated(input: ListAuthorizersInput) -> ClientRuntime.PaginatorSequence<ListAuthorizersInput, ListAuthorizersOutput> {
        return ClientRuntime.PaginatorSequence<ListAuthorizersInput, ListAuthorizersOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listAuthorizers(input:))
    }
}

extension ListAuthorizersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAuthorizersInput {
        return ListAuthorizersInput(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize,
            status: self.status
        )}
}

extension PaginatorSequence where OperationStackInput == ListAuthorizersInput, OperationStackOutput == ListAuthorizersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAuthorizersPaginated`
    /// to access the nested member `[IoTClientTypes.AuthorizerSummary]`
    /// - Returns: `[IoTClientTypes.AuthorizerSummary]`
    public func authorizers() async throws -> [IoTClientTypes.AuthorizerSummary] {
        return try await self.asyncCompactMap { item in item.authorizers }
    }
}
extension IoTClient {
    /// Paginate over `[ListBillingGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBillingGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBillingGroupsOutput`
    public func listBillingGroupsPaginated(input: ListBillingGroupsInput) -> ClientRuntime.PaginatorSequence<ListBillingGroupsInput, ListBillingGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListBillingGroupsInput, ListBillingGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBillingGroups(input:))
    }
}

extension ListBillingGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBillingGroupsInput {
        return ListBillingGroupsInput(
            maxResults: self.maxResults,
            namePrefixFilter: self.namePrefixFilter,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListBillingGroupsInput, OperationStackOutput == ListBillingGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listBillingGroupsPaginated`
    /// to access the nested member `[IoTClientTypes.GroupNameAndArn]`
    /// - Returns: `[IoTClientTypes.GroupNameAndArn]`
    public func billingGroups() async throws -> [IoTClientTypes.GroupNameAndArn] {
        return try await self.asyncCompactMap { item in item.billingGroups }
    }
}
extension IoTClient {
    /// Paginate over `[ListCACertificatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCACertificatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCACertificatesOutput`
    public func listCACertificatesPaginated(input: ListCACertificatesInput) -> ClientRuntime.PaginatorSequence<ListCACertificatesInput, ListCACertificatesOutput> {
        return ClientRuntime.PaginatorSequence<ListCACertificatesInput, ListCACertificatesOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listCACertificates(input:))
    }
}

extension ListCACertificatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCACertificatesInput {
        return ListCACertificatesInput(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize,
            templateName: self.templateName
        )}
}

extension PaginatorSequence where OperationStackInput == ListCACertificatesInput, OperationStackOutput == ListCACertificatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCACertificatesPaginated`
    /// to access the nested member `[IoTClientTypes.CACertificate]`
    /// - Returns: `[IoTClientTypes.CACertificate]`
    public func certificates() async throws -> [IoTClientTypes.CACertificate] {
        return try await self.asyncCompactMap { item in item.certificates }
    }
}
extension IoTClient {
    /// Paginate over `[ListCertificatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCertificatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCertificatesOutput`
    public func listCertificatesPaginated(input: ListCertificatesInput) -> ClientRuntime.PaginatorSequence<ListCertificatesInput, ListCertificatesOutput> {
        return ClientRuntime.PaginatorSequence<ListCertificatesInput, ListCertificatesOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listCertificates(input:))
    }
}

extension ListCertificatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCertificatesInput {
        return ListCertificatesInput(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize
        )}
}

extension PaginatorSequence where OperationStackInput == ListCertificatesInput, OperationStackOutput == ListCertificatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCertificatesPaginated`
    /// to access the nested member `[IoTClientTypes.Certificate]`
    /// - Returns: `[IoTClientTypes.Certificate]`
    public func certificates() async throws -> [IoTClientTypes.Certificate] {
        return try await self.asyncCompactMap { item in item.certificates }
    }
}
extension IoTClient {
    /// Paginate over `[ListCertificatesByCAOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCertificatesByCAInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCertificatesByCAOutput`
    public func listCertificatesByCAPaginated(input: ListCertificatesByCAInput) -> ClientRuntime.PaginatorSequence<ListCertificatesByCAInput, ListCertificatesByCAOutput> {
        return ClientRuntime.PaginatorSequence<ListCertificatesByCAInput, ListCertificatesByCAOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listCertificatesByCA(input:))
    }
}

extension ListCertificatesByCAInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCertificatesByCAInput {
        return ListCertificatesByCAInput(
            ascendingOrder: self.ascendingOrder,
            caCertificateId: self.caCertificateId,
            marker: token,
            pageSize: self.pageSize
        )}
}

extension PaginatorSequence where OperationStackInput == ListCertificatesByCAInput, OperationStackOutput == ListCertificatesByCAOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCertificatesByCAPaginated`
    /// to access the nested member `[IoTClientTypes.Certificate]`
    /// - Returns: `[IoTClientTypes.Certificate]`
    public func certificates() async throws -> [IoTClientTypes.Certificate] {
        return try await self.asyncCompactMap { item in item.certificates }
    }
}
extension IoTClient {
    /// Paginate over `[ListCustomMetricsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCustomMetricsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCustomMetricsOutput`
    public func listCustomMetricsPaginated(input: ListCustomMetricsInput) -> ClientRuntime.PaginatorSequence<ListCustomMetricsInput, ListCustomMetricsOutput> {
        return ClientRuntime.PaginatorSequence<ListCustomMetricsInput, ListCustomMetricsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCustomMetrics(input:))
    }
}

extension ListCustomMetricsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCustomMetricsInput {
        return ListCustomMetricsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListCustomMetricsInput, OperationStackOutput == ListCustomMetricsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCustomMetricsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func metricNames() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.metricNames }
    }
}
extension IoTClient {
    /// Paginate over `[ListDetectMitigationActionsExecutionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDetectMitigationActionsExecutionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDetectMitigationActionsExecutionsOutput`
    public func listDetectMitigationActionsExecutionsPaginated(input: ListDetectMitigationActionsExecutionsInput) -> ClientRuntime.PaginatorSequence<ListDetectMitigationActionsExecutionsInput, ListDetectMitigationActionsExecutionsOutput> {
        return ClientRuntime.PaginatorSequence<ListDetectMitigationActionsExecutionsInput, ListDetectMitigationActionsExecutionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDetectMitigationActionsExecutions(input:))
    }
}

extension ListDetectMitigationActionsExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDetectMitigationActionsExecutionsInput {
        return ListDetectMitigationActionsExecutionsInput(
            endTime: self.endTime,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime,
            taskId: self.taskId,
            thingName: self.thingName,
            violationId: self.violationId
        )}
}

extension PaginatorSequence where OperationStackInput == ListDetectMitigationActionsExecutionsInput, OperationStackOutput == ListDetectMitigationActionsExecutionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDetectMitigationActionsExecutionsPaginated`
    /// to access the nested member `[IoTClientTypes.DetectMitigationActionExecution]`
    /// - Returns: `[IoTClientTypes.DetectMitigationActionExecution]`
    public func actionsExecutions() async throws -> [IoTClientTypes.DetectMitigationActionExecution] {
        return try await self.asyncCompactMap { item in item.actionsExecutions }
    }
}
extension IoTClient {
    /// Paginate over `[ListDetectMitigationActionsTasksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDetectMitigationActionsTasksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDetectMitigationActionsTasksOutput`
    public func listDetectMitigationActionsTasksPaginated(input: ListDetectMitigationActionsTasksInput) -> ClientRuntime.PaginatorSequence<ListDetectMitigationActionsTasksInput, ListDetectMitigationActionsTasksOutput> {
        return ClientRuntime.PaginatorSequence<ListDetectMitigationActionsTasksInput, ListDetectMitigationActionsTasksOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDetectMitigationActionsTasks(input:))
    }
}

extension ListDetectMitigationActionsTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDetectMitigationActionsTasksInput {
        return ListDetectMitigationActionsTasksInput(
            endTime: self.endTime,
            maxResults: self.maxResults,
            nextToken: token,
            startTime: self.startTime
        )}
}

extension PaginatorSequence where OperationStackInput == ListDetectMitigationActionsTasksInput, OperationStackOutput == ListDetectMitigationActionsTasksOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDetectMitigationActionsTasksPaginated`
    /// to access the nested member `[IoTClientTypes.DetectMitigationActionsTaskSummary]`
    /// - Returns: `[IoTClientTypes.DetectMitigationActionsTaskSummary]`
    public func tasks() async throws -> [IoTClientTypes.DetectMitigationActionsTaskSummary] {
        return try await self.asyncCompactMap { item in item.tasks }
    }
}
extension IoTClient {
    /// Paginate over `[ListDimensionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDimensionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDimensionsOutput`
    public func listDimensionsPaginated(input: ListDimensionsInput) -> ClientRuntime.PaginatorSequence<ListDimensionsInput, ListDimensionsOutput> {
        return ClientRuntime.PaginatorSequence<ListDimensionsInput, ListDimensionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listDimensions(input:))
    }
}

extension ListDimensionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDimensionsInput {
        return ListDimensionsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListDimensionsInput, OperationStackOutput == ListDimensionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDimensionsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func dimensionNames() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.dimensionNames }
    }
}
extension IoTClient {
    /// Paginate over `[ListDomainConfigurationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDomainConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDomainConfigurationsOutput`
    public func listDomainConfigurationsPaginated(input: ListDomainConfigurationsInput) -> ClientRuntime.PaginatorSequence<ListDomainConfigurationsInput, ListDomainConfigurationsOutput> {
        return ClientRuntime.PaginatorSequence<ListDomainConfigurationsInput, ListDomainConfigurationsOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listDomainConfigurations(input:))
    }
}

extension ListDomainConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDomainConfigurationsInput {
        return ListDomainConfigurationsInput(
            marker: token,
            pageSize: self.pageSize,
            serviceType: self.serviceType
        )}
}

extension PaginatorSequence where OperationStackInput == ListDomainConfigurationsInput, OperationStackOutput == ListDomainConfigurationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDomainConfigurationsPaginated`
    /// to access the nested member `[IoTClientTypes.DomainConfigurationSummary]`
    /// - Returns: `[IoTClientTypes.DomainConfigurationSummary]`
    public func domainConfigurations() async throws -> [IoTClientTypes.DomainConfigurationSummary] {
        return try await self.asyncCompactMap { item in item.domainConfigurations }
    }
}
extension IoTClient {
    /// Paginate over `[ListFleetMetricsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListFleetMetricsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListFleetMetricsOutput`
    public func listFleetMetricsPaginated(input: ListFleetMetricsInput) -> ClientRuntime.PaginatorSequence<ListFleetMetricsInput, ListFleetMetricsOutput> {
        return ClientRuntime.PaginatorSequence<ListFleetMetricsInput, ListFleetMetricsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listFleetMetrics(input:))
    }
}

extension ListFleetMetricsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFleetMetricsInput {
        return ListFleetMetricsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListFleetMetricsInput, OperationStackOutput == ListFleetMetricsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listFleetMetricsPaginated`
    /// to access the nested member `[IoTClientTypes.FleetMetricNameAndArn]`
    /// - Returns: `[IoTClientTypes.FleetMetricNameAndArn]`
    public func fleetMetrics() async throws -> [IoTClientTypes.FleetMetricNameAndArn] {
        return try await self.asyncCompactMap { item in item.fleetMetrics }
    }
}
extension IoTClient {
    /// Paginate over `[ListIndicesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIndicesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIndicesOutput`
    public func listIndicesPaginated(input: ListIndicesInput) -> ClientRuntime.PaginatorSequence<ListIndicesInput, ListIndicesOutput> {
        return ClientRuntime.PaginatorSequence<ListIndicesInput, ListIndicesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listIndices(input:))
    }
}

extension ListIndicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIndicesInput {
        return ListIndicesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListIndicesInput, OperationStackOutput == ListIndicesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listIndicesPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func indexNames() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.indexNames }
    }
}
extension IoTClient {
    /// Paginate over `[ListJobExecutionsForJobOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListJobExecutionsForJobInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListJobExecutionsForJobOutput`
    public func listJobExecutionsForJobPaginated(input: ListJobExecutionsForJobInput) -> ClientRuntime.PaginatorSequence<ListJobExecutionsForJobInput, ListJobExecutionsForJobOutput> {
        return ClientRuntime.PaginatorSequence<ListJobExecutionsForJobInput, ListJobExecutionsForJobOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listJobExecutionsForJob(input:))
    }
}

extension ListJobExecutionsForJobInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListJobExecutionsForJobInput {
        return ListJobExecutionsForJobInput(
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )}
}

extension PaginatorSequence where OperationStackInput == ListJobExecutionsForJobInput, OperationStackOutput == ListJobExecutionsForJobOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listJobExecutionsForJobPaginated`
    /// to access the nested member `[IoTClientTypes.JobExecutionSummaryForJob]`
    /// - Returns: `[IoTClientTypes.JobExecutionSummaryForJob]`
    public func executionSummaries() async throws -> [IoTClientTypes.JobExecutionSummaryForJob] {
        return try await self.asyncCompactMap { item in item.executionSummaries }
    }
}
extension IoTClient {
    /// Paginate over `[ListJobExecutionsForThingOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListJobExecutionsForThingInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListJobExecutionsForThingOutput`
    public func listJobExecutionsForThingPaginated(input: ListJobExecutionsForThingInput) -> ClientRuntime.PaginatorSequence<ListJobExecutionsForThingInput, ListJobExecutionsForThingOutput> {
        return ClientRuntime.PaginatorSequence<ListJobExecutionsForThingInput, ListJobExecutionsForThingOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listJobExecutionsForThing(input:))
    }
}

extension ListJobExecutionsForThingInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListJobExecutionsForThingInput {
        return ListJobExecutionsForThingInput(
            jobId: self.jobId,
            maxResults: self.maxResults,
            namespaceId: self.namespaceId,
            nextToken: token,
            status: self.status,
            thingName: self.thingName
        )}
}

extension PaginatorSequence where OperationStackInput == ListJobExecutionsForThingInput, OperationStackOutput == ListJobExecutionsForThingOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listJobExecutionsForThingPaginated`
    /// to access the nested member `[IoTClientTypes.JobExecutionSummaryForThing]`
    /// - Returns: `[IoTClientTypes.JobExecutionSummaryForThing]`
    public func executionSummaries() async throws -> [IoTClientTypes.JobExecutionSummaryForThing] {
        return try await self.asyncCompactMap { item in item.executionSummaries }
    }
}
extension IoTClient {
    /// Paginate over `[ListJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListJobsOutput`
    public func listJobsPaginated(input: ListJobsInput) -> ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listJobs(input:))
    }
}

extension ListJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListJobsInput {
        return ListJobsInput(
            maxResults: self.maxResults,
            namespaceId: self.namespaceId,
            nextToken: token,
            status: self.status,
            targetSelection: self.targetSelection,
            thingGroupId: self.thingGroupId,
            thingGroupName: self.thingGroupName
        )}
}

extension PaginatorSequence where OperationStackInput == ListJobsInput, OperationStackOutput == ListJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listJobsPaginated`
    /// to access the nested member `[IoTClientTypes.JobSummary]`
    /// - Returns: `[IoTClientTypes.JobSummary]`
    public func jobs() async throws -> [IoTClientTypes.JobSummary] {
        return try await self.asyncCompactMap { item in item.jobs }
    }
}
extension IoTClient {
    /// Paginate over `[ListJobTemplatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListJobTemplatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListJobTemplatesOutput`
    public func listJobTemplatesPaginated(input: ListJobTemplatesInput) -> ClientRuntime.PaginatorSequence<ListJobTemplatesInput, ListJobTemplatesOutput> {
        return ClientRuntime.PaginatorSequence<ListJobTemplatesInput, ListJobTemplatesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listJobTemplates(input:))
    }
}

extension ListJobTemplatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListJobTemplatesInput {
        return ListJobTemplatesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListJobTemplatesInput, OperationStackOutput == ListJobTemplatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listJobTemplatesPaginated`
    /// to access the nested member `[IoTClientTypes.JobTemplateSummary]`
    /// - Returns: `[IoTClientTypes.JobTemplateSummary]`
    public func jobTemplates() async throws -> [IoTClientTypes.JobTemplateSummary] {
        return try await self.asyncCompactMap { item in item.jobTemplates }
    }
}
extension IoTClient {
    /// Paginate over `[ListManagedJobTemplatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListManagedJobTemplatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListManagedJobTemplatesOutput`
    public func listManagedJobTemplatesPaginated(input: ListManagedJobTemplatesInput) -> ClientRuntime.PaginatorSequence<ListManagedJobTemplatesInput, ListManagedJobTemplatesOutput> {
        return ClientRuntime.PaginatorSequence<ListManagedJobTemplatesInput, ListManagedJobTemplatesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listManagedJobTemplates(input:))
    }
}

extension ListManagedJobTemplatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListManagedJobTemplatesInput {
        return ListManagedJobTemplatesInput(
            maxResults: self.maxResults,
            nextToken: token,
            templateName: self.templateName
        )}
}

extension PaginatorSequence where OperationStackInput == ListManagedJobTemplatesInput, OperationStackOutput == ListManagedJobTemplatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listManagedJobTemplatesPaginated`
    /// to access the nested member `[IoTClientTypes.ManagedJobTemplateSummary]`
    /// - Returns: `[IoTClientTypes.ManagedJobTemplateSummary]`
    public func managedJobTemplates() async throws -> [IoTClientTypes.ManagedJobTemplateSummary] {
        return try await self.asyncCompactMap { item in item.managedJobTemplates }
    }
}
extension IoTClient {
    /// Paginate over `[ListMetricValuesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMetricValuesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMetricValuesOutput`
    public func listMetricValuesPaginated(input: ListMetricValuesInput) -> ClientRuntime.PaginatorSequence<ListMetricValuesInput, ListMetricValuesOutput> {
        return ClientRuntime.PaginatorSequence<ListMetricValuesInput, ListMetricValuesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMetricValues(input:))
    }
}

extension ListMetricValuesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMetricValuesInput {
        return ListMetricValuesInput(
            dimensionName: self.dimensionName,
            dimensionValueOperator: self.dimensionValueOperator,
            endTime: self.endTime,
            maxResults: self.maxResults,
            metricName: self.metricName,
            nextToken: token,
            startTime: self.startTime,
            thingName: self.thingName
        )}
}

extension PaginatorSequence where OperationStackInput == ListMetricValuesInput, OperationStackOutput == ListMetricValuesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMetricValuesPaginated`
    /// to access the nested member `[IoTClientTypes.MetricDatum]`
    /// - Returns: `[IoTClientTypes.MetricDatum]`
    public func metricDatumList() async throws -> [IoTClientTypes.MetricDatum] {
        return try await self.asyncCompactMap { item in item.metricDatumList }
    }
}
extension IoTClient {
    /// Paginate over `[ListMitigationActionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMitigationActionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMitigationActionsOutput`
    public func listMitigationActionsPaginated(input: ListMitigationActionsInput) -> ClientRuntime.PaginatorSequence<ListMitigationActionsInput, ListMitigationActionsOutput> {
        return ClientRuntime.PaginatorSequence<ListMitigationActionsInput, ListMitigationActionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMitigationActions(input:))
    }
}

extension ListMitigationActionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMitigationActionsInput {
        return ListMitigationActionsInput(
            actionType: self.actionType,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListMitigationActionsInput, OperationStackOutput == ListMitigationActionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMitigationActionsPaginated`
    /// to access the nested member `[IoTClientTypes.MitigationActionIdentifier]`
    /// - Returns: `[IoTClientTypes.MitigationActionIdentifier]`
    public func actionIdentifiers() async throws -> [IoTClientTypes.MitigationActionIdentifier] {
        return try await self.asyncCompactMap { item in item.actionIdentifiers }
    }
}
extension IoTClient {
    /// Paginate over `[ListOTAUpdatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOTAUpdatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOTAUpdatesOutput`
    public func listOTAUpdatesPaginated(input: ListOTAUpdatesInput) -> ClientRuntime.PaginatorSequence<ListOTAUpdatesInput, ListOTAUpdatesOutput> {
        return ClientRuntime.PaginatorSequence<ListOTAUpdatesInput, ListOTAUpdatesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listOTAUpdates(input:))
    }
}

extension ListOTAUpdatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOTAUpdatesInput {
        return ListOTAUpdatesInput(
            maxResults: self.maxResults,
            nextToken: token,
            otaUpdateStatus: self.otaUpdateStatus
        )}
}

extension PaginatorSequence where OperationStackInput == ListOTAUpdatesInput, OperationStackOutput == ListOTAUpdatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOTAUpdatesPaginated`
    /// to access the nested member `[IoTClientTypes.OTAUpdateSummary]`
    /// - Returns: `[IoTClientTypes.OTAUpdateSummary]`
    public func otaUpdates() async throws -> [IoTClientTypes.OTAUpdateSummary] {
        return try await self.asyncCompactMap { item in item.otaUpdates }
    }
}
extension IoTClient {
    /// Paginate over `[ListOutgoingCertificatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOutgoingCertificatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOutgoingCertificatesOutput`
    public func listOutgoingCertificatesPaginated(input: ListOutgoingCertificatesInput) -> ClientRuntime.PaginatorSequence<ListOutgoingCertificatesInput, ListOutgoingCertificatesOutput> {
        return ClientRuntime.PaginatorSequence<ListOutgoingCertificatesInput, ListOutgoingCertificatesOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listOutgoingCertificates(input:))
    }
}

extension ListOutgoingCertificatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOutgoingCertificatesInput {
        return ListOutgoingCertificatesInput(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize
        )}
}

extension PaginatorSequence where OperationStackInput == ListOutgoingCertificatesInput, OperationStackOutput == ListOutgoingCertificatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOutgoingCertificatesPaginated`
    /// to access the nested member `[IoTClientTypes.OutgoingCertificate]`
    /// - Returns: `[IoTClientTypes.OutgoingCertificate]`
    public func outgoingCertificates() async throws -> [IoTClientTypes.OutgoingCertificate] {
        return try await self.asyncCompactMap { item in item.outgoingCertificates }
    }
}
extension IoTClient {
    /// Paginate over `[ListPackagesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPackagesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPackagesOutput`
    public func listPackagesPaginated(input: ListPackagesInput) -> ClientRuntime.PaginatorSequence<ListPackagesInput, ListPackagesOutput> {
        return ClientRuntime.PaginatorSequence<ListPackagesInput, ListPackagesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPackages(input:))
    }
}

extension ListPackagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPackagesInput {
        return ListPackagesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListPackagesInput, OperationStackOutput == ListPackagesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPackagesPaginated`
    /// to access the nested member `[IoTClientTypes.PackageSummary]`
    /// - Returns: `[IoTClientTypes.PackageSummary]`
    public func packageSummaries() async throws -> [IoTClientTypes.PackageSummary] {
        return try await self.asyncCompactMap { item in item.packageSummaries }
    }
}
extension IoTClient {
    /// Paginate over `[ListPackageVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPackageVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPackageVersionsOutput`
    public func listPackageVersionsPaginated(input: ListPackageVersionsInput) -> ClientRuntime.PaginatorSequence<ListPackageVersionsInput, ListPackageVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListPackageVersionsInput, ListPackageVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPackageVersions(input:))
    }
}

extension ListPackageVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPackageVersionsInput {
        return ListPackageVersionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            packageName: self.packageName,
            status: self.status
        )}
}

extension PaginatorSequence where OperationStackInput == ListPackageVersionsInput, OperationStackOutput == ListPackageVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPackageVersionsPaginated`
    /// to access the nested member `[IoTClientTypes.PackageVersionSummary]`
    /// - Returns: `[IoTClientTypes.PackageVersionSummary]`
    public func packageVersionSummaries() async throws -> [IoTClientTypes.PackageVersionSummary] {
        return try await self.asyncCompactMap { item in item.packageVersionSummaries }
    }
}
extension IoTClient {
    /// Paginate over `[ListPoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPoliciesOutput`
    public func listPoliciesPaginated(input: ListPoliciesInput) -> ClientRuntime.PaginatorSequence<ListPoliciesInput, ListPoliciesOutput> {
        return ClientRuntime.PaginatorSequence<ListPoliciesInput, ListPoliciesOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listPolicies(input:))
    }
}

extension ListPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPoliciesInput {
        return ListPoliciesInput(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize
        )}
}

extension PaginatorSequence where OperationStackInput == ListPoliciesInput, OperationStackOutput == ListPoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPoliciesPaginated`
    /// to access the nested member `[IoTClientTypes.Policy]`
    /// - Returns: `[IoTClientTypes.Policy]`
    public func policies() async throws -> [IoTClientTypes.Policy] {
        return try await self.asyncCompactMap { item in item.policies }
    }
}
extension IoTClient {
    /// Paginate over `[ListPolicyPrincipalsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPolicyPrincipalsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPolicyPrincipalsOutput`
    public func listPolicyPrincipalsPaginated(input: ListPolicyPrincipalsInput) -> ClientRuntime.PaginatorSequence<ListPolicyPrincipalsInput, ListPolicyPrincipalsOutput> {
        return ClientRuntime.PaginatorSequence<ListPolicyPrincipalsInput, ListPolicyPrincipalsOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listPolicyPrincipals(input:))
    }
}

extension ListPolicyPrincipalsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPolicyPrincipalsInput {
        return ListPolicyPrincipalsInput(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize,
            policyName: self.policyName
        )}
}

extension PaginatorSequence where OperationStackInput == ListPolicyPrincipalsInput, OperationStackOutput == ListPolicyPrincipalsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPolicyPrincipalsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func principals() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.principals }
    }
}
extension IoTClient {
    /// Paginate over `[ListPrincipalPoliciesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPrincipalPoliciesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPrincipalPoliciesOutput`
    public func listPrincipalPoliciesPaginated(input: ListPrincipalPoliciesInput) -> ClientRuntime.PaginatorSequence<ListPrincipalPoliciesInput, ListPrincipalPoliciesOutput> {
        return ClientRuntime.PaginatorSequence<ListPrincipalPoliciesInput, ListPrincipalPoliciesOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listPrincipalPolicies(input:))
    }
}

extension ListPrincipalPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPrincipalPoliciesInput {
        return ListPrincipalPoliciesInput(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize,
            principal: self.principal
        )}
}

extension PaginatorSequence where OperationStackInput == ListPrincipalPoliciesInput, OperationStackOutput == ListPrincipalPoliciesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPrincipalPoliciesPaginated`
    /// to access the nested member `[IoTClientTypes.Policy]`
    /// - Returns: `[IoTClientTypes.Policy]`
    public func policies() async throws -> [IoTClientTypes.Policy] {
        return try await self.asyncCompactMap { item in item.policies }
    }
}
extension IoTClient {
    /// Paginate over `[ListPrincipalThingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPrincipalThingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPrincipalThingsOutput`
    public func listPrincipalThingsPaginated(input: ListPrincipalThingsInput) -> ClientRuntime.PaginatorSequence<ListPrincipalThingsInput, ListPrincipalThingsOutput> {
        return ClientRuntime.PaginatorSequence<ListPrincipalThingsInput, ListPrincipalThingsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPrincipalThings(input:))
    }
}

extension ListPrincipalThingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPrincipalThingsInput {
        return ListPrincipalThingsInput(
            maxResults: self.maxResults,
            nextToken: token,
            principal: self.principal
        )}
}

extension PaginatorSequence where OperationStackInput == ListPrincipalThingsInput, OperationStackOutput == ListPrincipalThingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPrincipalThingsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func things() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.things }
    }
}
extension IoTClient {
    /// Paginate over `[ListProvisioningTemplatesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProvisioningTemplatesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProvisioningTemplatesOutput`
    public func listProvisioningTemplatesPaginated(input: ListProvisioningTemplatesInput) -> ClientRuntime.PaginatorSequence<ListProvisioningTemplatesInput, ListProvisioningTemplatesOutput> {
        return ClientRuntime.PaginatorSequence<ListProvisioningTemplatesInput, ListProvisioningTemplatesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listProvisioningTemplates(input:))
    }
}

extension ListProvisioningTemplatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProvisioningTemplatesInput {
        return ListProvisioningTemplatesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListProvisioningTemplatesInput, OperationStackOutput == ListProvisioningTemplatesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listProvisioningTemplatesPaginated`
    /// to access the nested member `[IoTClientTypes.ProvisioningTemplateSummary]`
    /// - Returns: `[IoTClientTypes.ProvisioningTemplateSummary]`
    public func templates() async throws -> [IoTClientTypes.ProvisioningTemplateSummary] {
        return try await self.asyncCompactMap { item in item.templates }
    }
}
extension IoTClient {
    /// Paginate over `[ListProvisioningTemplateVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProvisioningTemplateVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProvisioningTemplateVersionsOutput`
    public func listProvisioningTemplateVersionsPaginated(input: ListProvisioningTemplateVersionsInput) -> ClientRuntime.PaginatorSequence<ListProvisioningTemplateVersionsInput, ListProvisioningTemplateVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListProvisioningTemplateVersionsInput, ListProvisioningTemplateVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listProvisioningTemplateVersions(input:))
    }
}

extension ListProvisioningTemplateVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProvisioningTemplateVersionsInput {
        return ListProvisioningTemplateVersionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            templateName: self.templateName
        )}
}

extension PaginatorSequence where OperationStackInput == ListProvisioningTemplateVersionsInput, OperationStackOutput == ListProvisioningTemplateVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listProvisioningTemplateVersionsPaginated`
    /// to access the nested member `[IoTClientTypes.ProvisioningTemplateVersionSummary]`
    /// - Returns: `[IoTClientTypes.ProvisioningTemplateVersionSummary]`
    public func versions() async throws -> [IoTClientTypes.ProvisioningTemplateVersionSummary] {
        return try await self.asyncCompactMap { item in item.versions }
    }
}
extension IoTClient {
    /// Paginate over `[ListRelatedResourcesForAuditFindingOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRelatedResourcesForAuditFindingInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRelatedResourcesForAuditFindingOutput`
    public func listRelatedResourcesForAuditFindingPaginated(input: ListRelatedResourcesForAuditFindingInput) -> ClientRuntime.PaginatorSequence<ListRelatedResourcesForAuditFindingInput, ListRelatedResourcesForAuditFindingOutput> {
        return ClientRuntime.PaginatorSequence<ListRelatedResourcesForAuditFindingInput, ListRelatedResourcesForAuditFindingOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRelatedResourcesForAuditFinding(input:))
    }
}

extension ListRelatedResourcesForAuditFindingInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRelatedResourcesForAuditFindingInput {
        return ListRelatedResourcesForAuditFindingInput(
            findingId: self.findingId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListRelatedResourcesForAuditFindingInput, OperationStackOutput == ListRelatedResourcesForAuditFindingOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRelatedResourcesForAuditFindingPaginated`
    /// to access the nested member `[IoTClientTypes.RelatedResource]`
    /// - Returns: `[IoTClientTypes.RelatedResource]`
    public func relatedResources() async throws -> [IoTClientTypes.RelatedResource] {
        return try await self.asyncCompactMap { item in item.relatedResources }
    }
}
extension IoTClient {
    /// Paginate over `[ListRoleAliasesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRoleAliasesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRoleAliasesOutput`
    public func listRoleAliasesPaginated(input: ListRoleAliasesInput) -> ClientRuntime.PaginatorSequence<ListRoleAliasesInput, ListRoleAliasesOutput> {
        return ClientRuntime.PaginatorSequence<ListRoleAliasesInput, ListRoleAliasesOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listRoleAliases(input:))
    }
}

extension ListRoleAliasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRoleAliasesInput {
        return ListRoleAliasesInput(
            ascendingOrder: self.ascendingOrder,
            marker: token,
            pageSize: self.pageSize
        )}
}

extension PaginatorSequence where OperationStackInput == ListRoleAliasesInput, OperationStackOutput == ListRoleAliasesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRoleAliasesPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func roleAliases() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.roleAliases }
    }
}
extension IoTClient {
    /// Paginate over `[ListSbomValidationResultsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSbomValidationResultsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSbomValidationResultsOutput`
    public func listSbomValidationResultsPaginated(input: ListSbomValidationResultsInput) -> ClientRuntime.PaginatorSequence<ListSbomValidationResultsInput, ListSbomValidationResultsOutput> {
        return ClientRuntime.PaginatorSequence<ListSbomValidationResultsInput, ListSbomValidationResultsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSbomValidationResults(input:))
    }
}

extension ListSbomValidationResultsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSbomValidationResultsInput {
        return ListSbomValidationResultsInput(
            maxResults: self.maxResults,
            nextToken: token,
            packageName: self.packageName,
            validationResult: self.validationResult,
            versionName: self.versionName
        )}
}

extension PaginatorSequence where OperationStackInput == ListSbomValidationResultsInput, OperationStackOutput == ListSbomValidationResultsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSbomValidationResultsPaginated`
    /// to access the nested member `[IoTClientTypes.SbomValidationResultSummary]`
    /// - Returns: `[IoTClientTypes.SbomValidationResultSummary]`
    public func validationResultSummaries() async throws -> [IoTClientTypes.SbomValidationResultSummary] {
        return try await self.asyncCompactMap { item in item.validationResultSummaries }
    }
}
extension IoTClient {
    /// Paginate over `[ListScheduledAuditsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListScheduledAuditsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListScheduledAuditsOutput`
    public func listScheduledAuditsPaginated(input: ListScheduledAuditsInput) -> ClientRuntime.PaginatorSequence<ListScheduledAuditsInput, ListScheduledAuditsOutput> {
        return ClientRuntime.PaginatorSequence<ListScheduledAuditsInput, ListScheduledAuditsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listScheduledAudits(input:))
    }
}

extension ListScheduledAuditsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListScheduledAuditsInput {
        return ListScheduledAuditsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListScheduledAuditsInput, OperationStackOutput == ListScheduledAuditsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listScheduledAuditsPaginated`
    /// to access the nested member `[IoTClientTypes.ScheduledAuditMetadata]`
    /// - Returns: `[IoTClientTypes.ScheduledAuditMetadata]`
    public func scheduledAudits() async throws -> [IoTClientTypes.ScheduledAuditMetadata] {
        return try await self.asyncCompactMap { item in item.scheduledAudits }
    }
}
extension IoTClient {
    /// Paginate over `[ListSecurityProfilesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSecurityProfilesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSecurityProfilesOutput`
    public func listSecurityProfilesPaginated(input: ListSecurityProfilesInput) -> ClientRuntime.PaginatorSequence<ListSecurityProfilesInput, ListSecurityProfilesOutput> {
        return ClientRuntime.PaginatorSequence<ListSecurityProfilesInput, ListSecurityProfilesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSecurityProfiles(input:))
    }
}

extension ListSecurityProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSecurityProfilesInput {
        return ListSecurityProfilesInput(
            dimensionName: self.dimensionName,
            maxResults: self.maxResults,
            metricName: self.metricName,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListSecurityProfilesInput, OperationStackOutput == ListSecurityProfilesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSecurityProfilesPaginated`
    /// to access the nested member `[IoTClientTypes.SecurityProfileIdentifier]`
    /// - Returns: `[IoTClientTypes.SecurityProfileIdentifier]`
    public func securityProfileIdentifiers() async throws -> [IoTClientTypes.SecurityProfileIdentifier] {
        return try await self.asyncCompactMap { item in item.securityProfileIdentifiers }
    }
}
extension IoTClient {
    /// Paginate over `[ListSecurityProfilesForTargetOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSecurityProfilesForTargetInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSecurityProfilesForTargetOutput`
    public func listSecurityProfilesForTargetPaginated(input: ListSecurityProfilesForTargetInput) -> ClientRuntime.PaginatorSequence<ListSecurityProfilesForTargetInput, ListSecurityProfilesForTargetOutput> {
        return ClientRuntime.PaginatorSequence<ListSecurityProfilesForTargetInput, ListSecurityProfilesForTargetOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSecurityProfilesForTarget(input:))
    }
}

extension ListSecurityProfilesForTargetInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSecurityProfilesForTargetInput {
        return ListSecurityProfilesForTargetInput(
            maxResults: self.maxResults,
            nextToken: token,
            recursive: self.recursive,
            securityProfileTargetArn: self.securityProfileTargetArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListSecurityProfilesForTargetInput, OperationStackOutput == ListSecurityProfilesForTargetOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSecurityProfilesForTargetPaginated`
    /// to access the nested member `[IoTClientTypes.SecurityProfileTargetMapping]`
    /// - Returns: `[IoTClientTypes.SecurityProfileTargetMapping]`
    public func securityProfileTargetMappings() async throws -> [IoTClientTypes.SecurityProfileTargetMapping] {
        return try await self.asyncCompactMap { item in item.securityProfileTargetMappings }
    }
}
extension IoTClient {
    /// Paginate over `[ListStreamsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListStreamsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListStreamsOutput`
    public func listStreamsPaginated(input: ListStreamsInput) -> ClientRuntime.PaginatorSequence<ListStreamsInput, ListStreamsOutput> {
        return ClientRuntime.PaginatorSequence<ListStreamsInput, ListStreamsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listStreams(input:))
    }
}

extension ListStreamsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListStreamsInput {
        return ListStreamsInput(
            ascendingOrder: self.ascendingOrder,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListStreamsInput, OperationStackOutput == ListStreamsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listStreamsPaginated`
    /// to access the nested member `[IoTClientTypes.StreamSummary]`
    /// - Returns: `[IoTClientTypes.StreamSummary]`
    public func streams() async throws -> [IoTClientTypes.StreamSummary] {
        return try await self.asyncCompactMap { item in item.streams }
    }
}
extension IoTClient {
    /// Paginate over `[ListTagsForResourceOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTagsForResourceInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTagsForResourceOutput`
    public func listTagsForResourcePaginated(input: ListTagsForResourceInput) -> ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutput> {
        return ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTagsForResource(input:))
    }
}

extension ListTagsForResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsForResourceInput {
        return ListTagsForResourceInput(
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListTagsForResourceInput, OperationStackOutput == ListTagsForResourceOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTagsForResourcePaginated`
    /// to access the nested member `[IoTClientTypes.Tag]`
    /// - Returns: `[IoTClientTypes.Tag]`
    public func tags() async throws -> [IoTClientTypes.Tag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}
extension IoTClient {
    /// Paginate over `[ListTargetsForPolicyOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTargetsForPolicyInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTargetsForPolicyOutput`
    public func listTargetsForPolicyPaginated(input: ListTargetsForPolicyInput) -> ClientRuntime.PaginatorSequence<ListTargetsForPolicyInput, ListTargetsForPolicyOutput> {
        return ClientRuntime.PaginatorSequence<ListTargetsForPolicyInput, ListTargetsForPolicyOutput>(input: input, inputKey: \.marker, outputKey: \.nextMarker, paginationFunction: self.listTargetsForPolicy(input:))
    }
}

extension ListTargetsForPolicyInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTargetsForPolicyInput {
        return ListTargetsForPolicyInput(
            marker: token,
            pageSize: self.pageSize,
            policyName: self.policyName
        )}
}

extension PaginatorSequence where OperationStackInput == ListTargetsForPolicyInput, OperationStackOutput == ListTargetsForPolicyOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTargetsForPolicyPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func targets() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.targets }
    }
}
extension IoTClient {
    /// Paginate over `[ListTargetsForSecurityProfileOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTargetsForSecurityProfileInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTargetsForSecurityProfileOutput`
    public func listTargetsForSecurityProfilePaginated(input: ListTargetsForSecurityProfileInput) -> ClientRuntime.PaginatorSequence<ListTargetsForSecurityProfileInput, ListTargetsForSecurityProfileOutput> {
        return ClientRuntime.PaginatorSequence<ListTargetsForSecurityProfileInput, ListTargetsForSecurityProfileOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTargetsForSecurityProfile(input:))
    }
}

extension ListTargetsForSecurityProfileInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTargetsForSecurityProfileInput {
        return ListTargetsForSecurityProfileInput(
            maxResults: self.maxResults,
            nextToken: token,
            securityProfileName: self.securityProfileName
        )}
}

extension PaginatorSequence where OperationStackInput == ListTargetsForSecurityProfileInput, OperationStackOutput == ListTargetsForSecurityProfileOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTargetsForSecurityProfilePaginated`
    /// to access the nested member `[IoTClientTypes.SecurityProfileTarget]`
    /// - Returns: `[IoTClientTypes.SecurityProfileTarget]`
    public func securityProfileTargets() async throws -> [IoTClientTypes.SecurityProfileTarget] {
        return try await self.asyncCompactMap { item in item.securityProfileTargets }
    }
}
extension IoTClient {
    /// Paginate over `[ListThingGroupsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListThingGroupsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListThingGroupsOutput`
    public func listThingGroupsPaginated(input: ListThingGroupsInput) -> ClientRuntime.PaginatorSequence<ListThingGroupsInput, ListThingGroupsOutput> {
        return ClientRuntime.PaginatorSequence<ListThingGroupsInput, ListThingGroupsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listThingGroups(input:))
    }
}

extension ListThingGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThingGroupsInput {
        return ListThingGroupsInput(
            maxResults: self.maxResults,
            namePrefixFilter: self.namePrefixFilter,
            nextToken: token,
            parentGroup: self.parentGroup,
            recursive: self.recursive
        )}
}

extension PaginatorSequence where OperationStackInput == ListThingGroupsInput, OperationStackOutput == ListThingGroupsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listThingGroupsPaginated`
    /// to access the nested member `[IoTClientTypes.GroupNameAndArn]`
    /// - Returns: `[IoTClientTypes.GroupNameAndArn]`
    public func thingGroups() async throws -> [IoTClientTypes.GroupNameAndArn] {
        return try await self.asyncCompactMap { item in item.thingGroups }
    }
}
extension IoTClient {
    /// Paginate over `[ListThingGroupsForThingOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListThingGroupsForThingInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListThingGroupsForThingOutput`
    public func listThingGroupsForThingPaginated(input: ListThingGroupsForThingInput) -> ClientRuntime.PaginatorSequence<ListThingGroupsForThingInput, ListThingGroupsForThingOutput> {
        return ClientRuntime.PaginatorSequence<ListThingGroupsForThingInput, ListThingGroupsForThingOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listThingGroupsForThing(input:))
    }
}

extension ListThingGroupsForThingInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThingGroupsForThingInput {
        return ListThingGroupsForThingInput(
            maxResults: self.maxResults,
            nextToken: token,
            thingName: self.thingName
        )}
}

extension PaginatorSequence where OperationStackInput == ListThingGroupsForThingInput, OperationStackOutput == ListThingGroupsForThingOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listThingGroupsForThingPaginated`
    /// to access the nested member `[IoTClientTypes.GroupNameAndArn]`
    /// - Returns: `[IoTClientTypes.GroupNameAndArn]`
    public func thingGroups() async throws -> [IoTClientTypes.GroupNameAndArn] {
        return try await self.asyncCompactMap { item in item.thingGroups }
    }
}
extension IoTClient {
    /// Paginate over `[ListThingPrincipalsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListThingPrincipalsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListThingPrincipalsOutput`
    public func listThingPrincipalsPaginated(input: ListThingPrincipalsInput) -> ClientRuntime.PaginatorSequence<ListThingPrincipalsInput, ListThingPrincipalsOutput> {
        return ClientRuntime.PaginatorSequence<ListThingPrincipalsInput, ListThingPrincipalsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listThingPrincipals(input:))
    }
}

extension ListThingPrincipalsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThingPrincipalsInput {
        return ListThingPrincipalsInput(
            maxResults: self.maxResults,
            nextToken: token,
            thingName: self.thingName
        )}
}

extension PaginatorSequence where OperationStackInput == ListThingPrincipalsInput, OperationStackOutput == ListThingPrincipalsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listThingPrincipalsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func principals() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.principals }
    }
}
extension IoTClient {
    /// Paginate over `[ListThingRegistrationTaskReportsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListThingRegistrationTaskReportsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListThingRegistrationTaskReportsOutput`
    public func listThingRegistrationTaskReportsPaginated(input: ListThingRegistrationTaskReportsInput) -> ClientRuntime.PaginatorSequence<ListThingRegistrationTaskReportsInput, ListThingRegistrationTaskReportsOutput> {
        return ClientRuntime.PaginatorSequence<ListThingRegistrationTaskReportsInput, ListThingRegistrationTaskReportsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listThingRegistrationTaskReports(input:))
    }
}

extension ListThingRegistrationTaskReportsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThingRegistrationTaskReportsInput {
        return ListThingRegistrationTaskReportsInput(
            maxResults: self.maxResults,
            nextToken: token,
            reportType: self.reportType,
            taskId: self.taskId
        )}
}

extension PaginatorSequence where OperationStackInput == ListThingRegistrationTaskReportsInput, OperationStackOutput == ListThingRegistrationTaskReportsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listThingRegistrationTaskReportsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func resourceLinks() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.resourceLinks }
    }
}
extension IoTClient {
    /// Paginate over `[ListThingRegistrationTasksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListThingRegistrationTasksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListThingRegistrationTasksOutput`
    public func listThingRegistrationTasksPaginated(input: ListThingRegistrationTasksInput) -> ClientRuntime.PaginatorSequence<ListThingRegistrationTasksInput, ListThingRegistrationTasksOutput> {
        return ClientRuntime.PaginatorSequence<ListThingRegistrationTasksInput, ListThingRegistrationTasksOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listThingRegistrationTasks(input:))
    }
}

extension ListThingRegistrationTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThingRegistrationTasksInput {
        return ListThingRegistrationTasksInput(
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )}
}

extension PaginatorSequence where OperationStackInput == ListThingRegistrationTasksInput, OperationStackOutput == ListThingRegistrationTasksOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listThingRegistrationTasksPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func taskIds() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.taskIds }
    }
}
extension IoTClient {
    /// Paginate over `[ListThingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListThingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListThingsOutput`
    public func listThingsPaginated(input: ListThingsInput) -> ClientRuntime.PaginatorSequence<ListThingsInput, ListThingsOutput> {
        return ClientRuntime.PaginatorSequence<ListThingsInput, ListThingsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listThings(input:))
    }
}

extension ListThingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThingsInput {
        return ListThingsInput(
            attributeName: self.attributeName,
            attributeValue: self.attributeValue,
            maxResults: self.maxResults,
            nextToken: token,
            thingTypeName: self.thingTypeName,
            usePrefixAttributeValue: self.usePrefixAttributeValue
        )}
}

extension PaginatorSequence where OperationStackInput == ListThingsInput, OperationStackOutput == ListThingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listThingsPaginated`
    /// to access the nested member `[IoTClientTypes.ThingAttribute]`
    /// - Returns: `[IoTClientTypes.ThingAttribute]`
    public func things() async throws -> [IoTClientTypes.ThingAttribute] {
        return try await self.asyncCompactMap { item in item.things }
    }
}
extension IoTClient {
    /// Paginate over `[ListThingsInBillingGroupOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListThingsInBillingGroupInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListThingsInBillingGroupOutput`
    public func listThingsInBillingGroupPaginated(input: ListThingsInBillingGroupInput) -> ClientRuntime.PaginatorSequence<ListThingsInBillingGroupInput, ListThingsInBillingGroupOutput> {
        return ClientRuntime.PaginatorSequence<ListThingsInBillingGroupInput, ListThingsInBillingGroupOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listThingsInBillingGroup(input:))
    }
}

extension ListThingsInBillingGroupInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThingsInBillingGroupInput {
        return ListThingsInBillingGroupInput(
            billingGroupName: self.billingGroupName,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListThingsInBillingGroupInput, OperationStackOutput == ListThingsInBillingGroupOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listThingsInBillingGroupPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func things() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.things }
    }
}
extension IoTClient {
    /// Paginate over `[ListThingsInThingGroupOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListThingsInThingGroupInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListThingsInThingGroupOutput`
    public func listThingsInThingGroupPaginated(input: ListThingsInThingGroupInput) -> ClientRuntime.PaginatorSequence<ListThingsInThingGroupInput, ListThingsInThingGroupOutput> {
        return ClientRuntime.PaginatorSequence<ListThingsInThingGroupInput, ListThingsInThingGroupOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listThingsInThingGroup(input:))
    }
}

extension ListThingsInThingGroupInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThingsInThingGroupInput {
        return ListThingsInThingGroupInput(
            maxResults: self.maxResults,
            nextToken: token,
            recursive: self.recursive,
            thingGroupName: self.thingGroupName
        )}
}

extension PaginatorSequence where OperationStackInput == ListThingsInThingGroupInput, OperationStackOutput == ListThingsInThingGroupOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listThingsInThingGroupPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func things() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.things }
    }
}
extension IoTClient {
    /// Paginate over `[ListThingTypesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListThingTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListThingTypesOutput`
    public func listThingTypesPaginated(input: ListThingTypesInput) -> ClientRuntime.PaginatorSequence<ListThingTypesInput, ListThingTypesOutput> {
        return ClientRuntime.PaginatorSequence<ListThingTypesInput, ListThingTypesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listThingTypes(input:))
    }
}

extension ListThingTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListThingTypesInput {
        return ListThingTypesInput(
            maxResults: self.maxResults,
            nextToken: token,
            thingTypeName: self.thingTypeName
        )}
}

extension PaginatorSequence where OperationStackInput == ListThingTypesInput, OperationStackOutput == ListThingTypesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listThingTypesPaginated`
    /// to access the nested member `[IoTClientTypes.ThingTypeDefinition]`
    /// - Returns: `[IoTClientTypes.ThingTypeDefinition]`
    public func thingTypes() async throws -> [IoTClientTypes.ThingTypeDefinition] {
        return try await self.asyncCompactMap { item in item.thingTypes }
    }
}
extension IoTClient {
    /// Paginate over `[ListTopicRuleDestinationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTopicRuleDestinationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTopicRuleDestinationsOutput`
    public func listTopicRuleDestinationsPaginated(input: ListTopicRuleDestinationsInput) -> ClientRuntime.PaginatorSequence<ListTopicRuleDestinationsInput, ListTopicRuleDestinationsOutput> {
        return ClientRuntime.PaginatorSequence<ListTopicRuleDestinationsInput, ListTopicRuleDestinationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTopicRuleDestinations(input:))
    }
}

extension ListTopicRuleDestinationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTopicRuleDestinationsInput {
        return ListTopicRuleDestinationsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListTopicRuleDestinationsInput, OperationStackOutput == ListTopicRuleDestinationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTopicRuleDestinationsPaginated`
    /// to access the nested member `[IoTClientTypes.TopicRuleDestinationSummary]`
    /// - Returns: `[IoTClientTypes.TopicRuleDestinationSummary]`
    public func destinationSummaries() async throws -> [IoTClientTypes.TopicRuleDestinationSummary] {
        return try await self.asyncCompactMap { item in item.destinationSummaries }
    }
}
extension IoTClient {
    /// Paginate over `[ListTopicRulesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTopicRulesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTopicRulesOutput`
    public func listTopicRulesPaginated(input: ListTopicRulesInput) -> ClientRuntime.PaginatorSequence<ListTopicRulesInput, ListTopicRulesOutput> {
        return ClientRuntime.PaginatorSequence<ListTopicRulesInput, ListTopicRulesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTopicRules(input:))
    }
}

extension ListTopicRulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTopicRulesInput {
        return ListTopicRulesInput(
            maxResults: self.maxResults,
            nextToken: token,
            ruleDisabled: self.ruleDisabled,
            topic: self.topic
        )}
}

extension PaginatorSequence where OperationStackInput == ListTopicRulesInput, OperationStackOutput == ListTopicRulesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTopicRulesPaginated`
    /// to access the nested member `[IoTClientTypes.TopicRuleListItem]`
    /// - Returns: `[IoTClientTypes.TopicRuleListItem]`
    public func rules() async throws -> [IoTClientTypes.TopicRuleListItem] {
        return try await self.asyncCompactMap { item in item.rules }
    }
}
extension IoTClient {
    /// Paginate over `[ListV2LoggingLevelsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListV2LoggingLevelsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListV2LoggingLevelsOutput`
    public func listV2LoggingLevelsPaginated(input: ListV2LoggingLevelsInput) -> ClientRuntime.PaginatorSequence<ListV2LoggingLevelsInput, ListV2LoggingLevelsOutput> {
        return ClientRuntime.PaginatorSequence<ListV2LoggingLevelsInput, ListV2LoggingLevelsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listV2LoggingLevels(input:))
    }
}

extension ListV2LoggingLevelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListV2LoggingLevelsInput {
        return ListV2LoggingLevelsInput(
            maxResults: self.maxResults,
            nextToken: token,
            targetType: self.targetType
        )}
}

extension PaginatorSequence where OperationStackInput == ListV2LoggingLevelsInput, OperationStackOutput == ListV2LoggingLevelsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listV2LoggingLevelsPaginated`
    /// to access the nested member `[IoTClientTypes.LogTargetConfiguration]`
    /// - Returns: `[IoTClientTypes.LogTargetConfiguration]`
    public func logTargetConfigurations() async throws -> [IoTClientTypes.LogTargetConfiguration] {
        return try await self.asyncCompactMap { item in item.logTargetConfigurations }
    }
}
extension IoTClient {
    /// Paginate over `[ListViolationEventsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListViolationEventsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListViolationEventsOutput`
    public func listViolationEventsPaginated(input: ListViolationEventsInput) -> ClientRuntime.PaginatorSequence<ListViolationEventsInput, ListViolationEventsOutput> {
        return ClientRuntime.PaginatorSequence<ListViolationEventsInput, ListViolationEventsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listViolationEvents(input:))
    }
}

extension ListViolationEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListViolationEventsInput {
        return ListViolationEventsInput(
            behaviorCriteriaType: self.behaviorCriteriaType,
            endTime: self.endTime,
            listSuppressedAlerts: self.listSuppressedAlerts,
            maxResults: self.maxResults,
            nextToken: token,
            securityProfileName: self.securityProfileName,
            startTime: self.startTime,
            thingName: self.thingName,
            verificationState: self.verificationState
        )}
}

extension PaginatorSequence where OperationStackInput == ListViolationEventsInput, OperationStackOutput == ListViolationEventsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listViolationEventsPaginated`
    /// to access the nested member `[IoTClientTypes.ViolationEvent]`
    /// - Returns: `[IoTClientTypes.ViolationEvent]`
    public func violationEvents() async throws -> [IoTClientTypes.ViolationEvent] {
        return try await self.asyncCompactMap { item in item.violationEvents }
    }
}
