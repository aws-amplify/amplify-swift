//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

extension PinpointSMSVoiceV2ClientTypes {

    public enum AccessDeniedExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountDisabled
        case insufficientAccountReputation
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessDeniedExceptionReason] {
            return [
                .accountDisabled,
                .insufficientAccountReputation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountDisabled: return "ACCOUNT_DISABLED"
            case .insufficientAccountReputation: return "INSUFFICIENT_ACCOUNT_REPUTATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request was denied because you don't have sufficient permissions to access the resource.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: PinpointSMSVoiceV2ClientTypes.AccessDeniedExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: PinpointSMSVoiceV2ClientTypes.AccessDeniedExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum AccountAttributeName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountTier
        case defaultProtectConfigurationId
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountAttributeName] {
            return [
                .accountTier,
                .defaultProtectConfigurationId
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountTier: return "ACCOUNT_TIER"
            case .defaultProtectConfigurationId: return "DEFAULT_PROTECT_CONFIGURATION_ID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Displays the attributes associated with a single Amazon Web Services account.
    public struct AccountAttribute: Swift.Sendable {
        /// The name of the account attribute.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.AccountAttributeName?
        /// The value associated with the account attribute name.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.AccountAttributeName? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum AccountLimitName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case configurationSets
        case optOutLists
        case phoneNumbers
        case pools
        case registrations
        case registrationAttachments
        case senderIds
        case verifiedDestinationNumbers
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountLimitName] {
            return [
                .configurationSets,
                .optOutLists,
                .phoneNumbers,
                .pools,
                .registrations,
                .registrationAttachments,
                .senderIds,
                .verifiedDestinationNumbers
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .configurationSets: return "CONFIGURATION_SETS"
            case .optOutLists: return "OPT_OUT_LISTS"
            case .phoneNumbers: return "PHONE_NUMBERS"
            case .pools: return "POOLS"
            case .registrations: return "REGISTRATIONS"
            case .registrationAttachments: return "REGISTRATION_ATTACHMENTS"
            case .senderIds: return "SENDER_IDS"
            case .verifiedDestinationNumbers: return "VERIFIED_DESTINATION_NUMBERS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The current resource quotas associated with an Amazon Web Services account.
    public struct AccountLimit: Swift.Sendable {
        /// The Amazon Web Services set limit for that resource type, in US dollars.
        /// This member is required.
        public var max: Swift.Int
        /// The name of the attribute to apply the account limit to.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.AccountLimitName?
        /// The current amount that has been spent, in US dollars.
        /// This member is required.
        public var used: Swift.Int

        public init(
            max: Swift.Int = 0,
            name: PinpointSMSVoiceV2ClientTypes.AccountLimitName? = nil,
            used: Swift.Int = 0
        )
        {
            self.max = max
            self.name = name
            self.used = used
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum ConflictExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createRegistrationVersionNotAllowed
        case deletionProtectionEnabled
        case destinationCountryBlockedByProtectConfiguration
        case destinationPhoneNumberNotVerified
        case destinationPhoneNumberOptedOut
        case disassociateRegistrationNotAllowed
        case discardRegistrationVersionNotAllowed
        case editRegistrationFieldValuesNotAllowed
        case eventDestinationMismatch
        case keywordMismatch
        case lastPhoneNumber
        case messageTypeMismatch
        case noOriginationIdentitiesFound
        case numberCapabilitiesMismatch
        case optOutListMismatch
        case phoneNumberAssociatedToPool
        case phoneNumberAssociatedToRegistration
        case phoneNumberNotAssociatedToPool
        case phoneNumberNotInRegistrationRegion
        case protectConfigurationAssociatedWithConfigurationSet
        case protectConfigurationIsAccountDefault
        case protectConfigurationNotAssociatedWithConfigurationSet
        case registrationAlreadySubmitted
        case registrationNotComplete
        case resourceAlreadyExists
        case resourceDeletionNotAllowed
        case resourceModificationNotAllowed
        case resourceNotActive
        case resourceNotEmpty
        case selfManagedOptOutsMismatch
        case senderIdAssociatedToPool
        case submitRegistrationVersionNotAllowed
        case twoWayConfigMismatch
        case verificationAlreadyComplete
        case verificationCodeExpired
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .createRegistrationVersionNotAllowed,
                .deletionProtectionEnabled,
                .destinationCountryBlockedByProtectConfiguration,
                .destinationPhoneNumberNotVerified,
                .destinationPhoneNumberOptedOut,
                .disassociateRegistrationNotAllowed,
                .discardRegistrationVersionNotAllowed,
                .editRegistrationFieldValuesNotAllowed,
                .eventDestinationMismatch,
                .keywordMismatch,
                .lastPhoneNumber,
                .messageTypeMismatch,
                .noOriginationIdentitiesFound,
                .numberCapabilitiesMismatch,
                .optOutListMismatch,
                .phoneNumberAssociatedToPool,
                .phoneNumberAssociatedToRegistration,
                .phoneNumberNotAssociatedToPool,
                .phoneNumberNotInRegistrationRegion,
                .protectConfigurationAssociatedWithConfigurationSet,
                .protectConfigurationIsAccountDefault,
                .protectConfigurationNotAssociatedWithConfigurationSet,
                .registrationAlreadySubmitted,
                .registrationNotComplete,
                .resourceAlreadyExists,
                .resourceDeletionNotAllowed,
                .resourceModificationNotAllowed,
                .resourceNotActive,
                .resourceNotEmpty,
                .selfManagedOptOutsMismatch,
                .senderIdAssociatedToPool,
                .submitRegistrationVersionNotAllowed,
                .twoWayConfigMismatch,
                .verificationAlreadyComplete,
                .verificationCodeExpired
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createRegistrationVersionNotAllowed: return "CREATE_REGISTRATION_VERSION_NOT_ALLOWED"
            case .deletionProtectionEnabled: return "DELETION_PROTECTION_ENABLED"
            case .destinationCountryBlockedByProtectConfiguration: return "DESTINATION_COUNTRY_BLOCKED_BY_PROTECT_CONFIGURATION"
            case .destinationPhoneNumberNotVerified: return "DESTINATION_PHONE_NUMBER_NOT_VERIFIED"
            case .destinationPhoneNumberOptedOut: return "DESTINATION_PHONE_NUMBER_OPTED_OUT"
            case .disassociateRegistrationNotAllowed: return "DISASSOCIATE_REGISTRATION_NOT_ALLOWED"
            case .discardRegistrationVersionNotAllowed: return "DISCARD_REGISTRATION_VERSION_NOT_ALLOWED"
            case .editRegistrationFieldValuesNotAllowed: return "EDIT_REGISTRATION_FIELD_VALUES_NOT_ALLOWED"
            case .eventDestinationMismatch: return "EVENT_DESTINATION_MISMATCH"
            case .keywordMismatch: return "KEYWORD_MISMATCH"
            case .lastPhoneNumber: return "LAST_PHONE_NUMBER"
            case .messageTypeMismatch: return "MESSAGE_TYPE_MISMATCH"
            case .noOriginationIdentitiesFound: return "NO_ORIGINATION_IDENTITIES_FOUND"
            case .numberCapabilitiesMismatch: return "NUMBER_CAPABILITIES_MISMATCH"
            case .optOutListMismatch: return "OPT_OUT_LIST_MISMATCH"
            case .phoneNumberAssociatedToPool: return "PHONE_NUMBER_ASSOCIATED_TO_POOL"
            case .phoneNumberAssociatedToRegistration: return "PHONE_NUMBER_ASSOCIATED_TO_REGISTRATION"
            case .phoneNumberNotAssociatedToPool: return "PHONE_NUMBER_NOT_ASSOCIATED_TO_POOL"
            case .phoneNumberNotInRegistrationRegion: return "PHONE_NUMBER_NOT_IN_REGISTRATION_REGION"
            case .protectConfigurationAssociatedWithConfigurationSet: return "PROTECT_CONFIGURATION_ASSOCIATED_WITH_CONFIGURATION_SET"
            case .protectConfigurationIsAccountDefault: return "PROTECT_CONFIGURATION_IS_ACCOUNT_DEFAULT"
            case .protectConfigurationNotAssociatedWithConfigurationSet: return "PROTECT_CONFIGURATION_NOT_ASSOCIATED_WITH_CONFIGURATION_SET"
            case .registrationAlreadySubmitted: return "REGISTRATION_ALREADY_SUBMITTED"
            case .registrationNotComplete: return "REGISTRATION_NOT_COMPLETE"
            case .resourceAlreadyExists: return "RESOURCE_ALREADY_EXISTS"
            case .resourceDeletionNotAllowed: return "RESOURCE_DELETION_NOT_ALLOWED"
            case .resourceModificationNotAllowed: return "RESOURCE_MODIFICATION_NOT_ALLOWED"
            case .resourceNotActive: return "RESOURCE_NOT_ACTIVE"
            case .resourceNotEmpty: return "RESOURCE_NOT_EMPTY"
            case .selfManagedOptOutsMismatch: return "SELF_MANAGED_OPT_OUTS_MISMATCH"
            case .senderIdAssociatedToPool: return "SENDER_ID_ASSOCIATED_TO_POOL"
            case .submitRegistrationVersionNotAllowed: return "SUBMIT_REGISTRATION_VERSION_NOT_ALLOWED"
            case .twoWayConfigMismatch: return "TWO_WAY_CONFIG_MISMATCH"
            case .verificationAlreadyComplete: return "VERIFICATION_ALREADY_COMPLETE"
            case .verificationCodeExpired: return "VERIFICATION_CODE_EXPIRED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case configurationSet
        case eventDestination
        case keyword
        case optedOutNumber
        case optOutList
        case phoneNumber
        case policy
        case pool
        case protectConfiguration
        case registration
        case registrationAttachment
        case senderId
        case verifiedDestinationNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .account,
                .configurationSet,
                .eventDestination,
                .keyword,
                .optedOutNumber,
                .optOutList,
                .phoneNumber,
                .policy,
                .pool,
                .protectConfiguration,
                .registration,
                .registrationAttachment,
                .senderId,
                .verifiedDestinationNumber
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "account"
            case .configurationSet: return "configuration-set"
            case .eventDestination: return "event-destination"
            case .keyword: return "keyword"
            case .optedOutNumber: return "opted-out-number"
            case .optOutList: return "opt-out-list"
            case .phoneNumber: return "phone-number"
            case .policy: return "policy"
            case .pool: return "pool"
            case .protectConfiguration: return "protect-configuration"
            case .registration: return "registration"
            case .registrationAttachment: return "registration-attachment"
            case .senderId: return "sender-id"
            case .verifiedDestinationNumber: return "verified-destination-number"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Your request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time or it could be that the requested action isn't valid for the current state or configuration of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: PinpointSMSVoiceV2ClientTypes.ConflictExceptionReason? = nil
        /// The unique identifier of the request.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that caused the exception.
        public internal(set) var resourceType: PinpointSMSVoiceV2ClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: PinpointSMSVoiceV2ClientTypes.ConflictExceptionReason? = nil,
        resourceId: Swift.String? = nil,
        resourceType: PinpointSMSVoiceV2ClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The API encountered an unexpected error and couldn't complete the request. You might be able to successfully issue the request again in the future.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier of the request.
        public internal(set) var requestId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.requestId = requestId
    }
}

/// A requested resource couldn't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The unique identifier of the resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that caused the exception.
        public internal(set) var resourceType: PinpointSMSVoiceV2ClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: PinpointSMSVoiceV2ClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum ServiceQuotaExceededExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case associationsPerRegistration
        case configurationSetsPerAccount
        case dailyDestinationCallLimit
        case eventDestinationsPerConfigurationSet
        case keywordsPerPhoneNumber
        case keywordsPerPool
        case monthlySpendLimitReachedForMedia
        case monthlySpendLimitReachedForText
        case monthlySpendLimitReachedForVoice
        case optOutListsPerAccount
        case originationIdentitiesPerPool
        case phoneNumbersPerAccount
        case phoneNumbersPerRegistration
        case poolsPerAccount
        case protectConfigurationsPerAccount
        case registrationsPerAccount
        case registrationAttachmentsCreatedPerDay
        case registrationAttachmentsPerAccount
        case registrationVersionsCreatedPerDay
        case senderIdsPerAccount
        case tagsPerResource
        case verificationAttemptsPerDay
        case verifiedDestinationNumbersPerAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceQuotaExceededExceptionReason] {
            return [
                .associationsPerRegistration,
                .configurationSetsPerAccount,
                .dailyDestinationCallLimit,
                .eventDestinationsPerConfigurationSet,
                .keywordsPerPhoneNumber,
                .keywordsPerPool,
                .monthlySpendLimitReachedForMedia,
                .monthlySpendLimitReachedForText,
                .monthlySpendLimitReachedForVoice,
                .optOutListsPerAccount,
                .originationIdentitiesPerPool,
                .phoneNumbersPerAccount,
                .phoneNumbersPerRegistration,
                .poolsPerAccount,
                .protectConfigurationsPerAccount,
                .registrationsPerAccount,
                .registrationAttachmentsCreatedPerDay,
                .registrationAttachmentsPerAccount,
                .registrationVersionsCreatedPerDay,
                .senderIdsPerAccount,
                .tagsPerResource,
                .verificationAttemptsPerDay,
                .verifiedDestinationNumbersPerAccount
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .associationsPerRegistration: return "ASSOCIATIONS_PER_REGISTRATION"
            case .configurationSetsPerAccount: return "CONFIGURATION_SETS_PER_ACCOUNT"
            case .dailyDestinationCallLimit: return "DAILY_DESTINATION_CALL_LIMIT"
            case .eventDestinationsPerConfigurationSet: return "EVENT_DESTINATIONS_PER_CONFIGURATION_SET"
            case .keywordsPerPhoneNumber: return "KEYWORDS_PER_PHONE_NUMBER"
            case .keywordsPerPool: return "KEYWORDS_PER_POOL"
            case .monthlySpendLimitReachedForMedia: return "MONTHLY_SPEND_LIMIT_REACHED_FOR_MEDIA"
            case .monthlySpendLimitReachedForText: return "MONTHLY_SPEND_LIMIT_REACHED_FOR_TEXT"
            case .monthlySpendLimitReachedForVoice: return "MONTHLY_SPEND_LIMIT_REACHED_FOR_VOICE"
            case .optOutListsPerAccount: return "OPT_OUT_LISTS_PER_ACCOUNT"
            case .originationIdentitiesPerPool: return "ORIGINATION_IDENTITIES_PER_POOL"
            case .phoneNumbersPerAccount: return "PHONE_NUMBERS_PER_ACCOUNT"
            case .phoneNumbersPerRegistration: return "PHONE_NUMBERS_PER_REGISTRATION"
            case .poolsPerAccount: return "POOLS_PER_ACCOUNT"
            case .protectConfigurationsPerAccount: return "PROTECT_CONFIGURATIONS_PER_ACCOUNT"
            case .registrationsPerAccount: return "REGISTRATIONS_PER_ACCOUNT"
            case .registrationAttachmentsCreatedPerDay: return "REGISTRATION_ATTACHMENTS_CREATED_PER_DAY"
            case .registrationAttachmentsPerAccount: return "REGISTRATION_ATTACHMENTS_PER_ACCOUNT"
            case .registrationVersionsCreatedPerDay: return "REGISTRATION_VERSIONS_CREATED_PER_DAY"
            case .senderIdsPerAccount: return "SENDER_IDS_PER_ACCOUNT"
            case .tagsPerResource: return "TAGS_PER_RESOURCE"
            case .verificationAttemptsPerDay: return "VERIFICATION_ATTEMPTS_PER_DAY"
            case .verifiedDestinationNumbersPerAccount: return "VERIFIED_DESTINATION_NUMBERS_PER_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: PinpointSMSVoiceV2ClientTypes.ServiceQuotaExceededExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: PinpointSMSVoiceV2ClientTypes.ServiceQuotaExceededExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

/// An error that occurred because too many requests were sent during a certain amount of time.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The field associated with the validation exception.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The message associated with the validation exception with information to help determine its cause.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case attachmentTypeNotSupported
        case cannotAddOptedOutNumber
        case cannotParse
        case countryCodeMismatch
        case destinationCountryBlocked
        case fieldValidationFailed
        case invalidArn
        case invalidFilterValues
        case invalidIdentityForDestinationCountry
        case invalidNextToken
        case invalidParameter
        case invalidRegistrationAssociation
        case invalidRequest
        case maximumSizeExceeded
        case mediaTypeNotSupported
        case missingParameter
        case other
        case parametersCannotBeUsedTogether
        case phoneNumberCannotBeOptedIn
        case phoneNumberCannotBeReleased
        case priceOverThreshold
        case registrationFieldCannotBeDeleted
        case requestedSpendLimitHigherThanServiceLimit
        case resourceNotAccessible
        case senderIdNotRegistered
        case senderIdNotSupported
        case senderIdRequiresRegistration
        case twoWayChannelNotPresent
        case twoWayNotEnabled
        case twoWayNotSupportedInCountry
        case twoWayNotSupportedInRegion
        case twoWayTopicNotPresent
        case unknownOperation
        case unknownRegistrationField
        case unknownRegistrationSection
        case unknownRegistrationType
        case unknownRegistrationVersion
        case unspecifiedParameterNotSupported
        case verificationCodeMismatch
        case voiceCapabilityNotAvailable
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .attachmentTypeNotSupported,
                .cannotAddOptedOutNumber,
                .cannotParse,
                .countryCodeMismatch,
                .destinationCountryBlocked,
                .fieldValidationFailed,
                .invalidArn,
                .invalidFilterValues,
                .invalidIdentityForDestinationCountry,
                .invalidNextToken,
                .invalidParameter,
                .invalidRegistrationAssociation,
                .invalidRequest,
                .maximumSizeExceeded,
                .mediaTypeNotSupported,
                .missingParameter,
                .other,
                .parametersCannotBeUsedTogether,
                .phoneNumberCannotBeOptedIn,
                .phoneNumberCannotBeReleased,
                .priceOverThreshold,
                .registrationFieldCannotBeDeleted,
                .requestedSpendLimitHigherThanServiceLimit,
                .resourceNotAccessible,
                .senderIdNotRegistered,
                .senderIdNotSupported,
                .senderIdRequiresRegistration,
                .twoWayChannelNotPresent,
                .twoWayNotEnabled,
                .twoWayNotSupportedInCountry,
                .twoWayNotSupportedInRegion,
                .twoWayTopicNotPresent,
                .unknownOperation,
                .unknownRegistrationField,
                .unknownRegistrationSection,
                .unknownRegistrationType,
                .unknownRegistrationVersion,
                .unspecifiedParameterNotSupported,
                .verificationCodeMismatch,
                .voiceCapabilityNotAvailable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .attachmentTypeNotSupported: return "ATTACHMENT_TYPE_NOT_SUPPORTED"
            case .cannotAddOptedOutNumber: return "CANNOT_ADD_OPTED_OUT_NUMBER"
            case .cannotParse: return "CANNOT_PARSE"
            case .countryCodeMismatch: return "COUNTRY_CODE_MISMATCH"
            case .destinationCountryBlocked: return "DESTINATION_COUNTRY_BLOCKED"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .invalidArn: return "INVALID_ARN"
            case .invalidFilterValues: return "INVALID_FILTER_VALUES"
            case .invalidIdentityForDestinationCountry: return "INVALID_IDENTITY_FOR_DESTINATION_COUNTRY"
            case .invalidNextToken: return "INVALID_NEXT_TOKEN"
            case .invalidParameter: return "INVALID_PARAMETER"
            case .invalidRegistrationAssociation: return "INVALID_REGISTRATION_ASSOCIATION"
            case .invalidRequest: return "INVALID_REQUEST"
            case .maximumSizeExceeded: return "MAXIMUM_SIZE_EXCEEDED"
            case .mediaTypeNotSupported: return "MEDIA_TYPE_NOT_SUPPORTED"
            case .missingParameter: return "MISSING_PARAMETER"
            case .other: return "OTHER"
            case .parametersCannotBeUsedTogether: return "PARAMETERS_CANNOT_BE_USED_TOGETHER"
            case .phoneNumberCannotBeOptedIn: return "PHONE_NUMBER_CANNOT_BE_OPTED_IN"
            case .phoneNumberCannotBeReleased: return "PHONE_NUMBER_CANNOT_BE_RELEASED"
            case .priceOverThreshold: return "PRICE_OVER_THRESHOLD"
            case .registrationFieldCannotBeDeleted: return "REGISTRATION_FIELD_CANNOT_BE_DELETED"
            case .requestedSpendLimitHigherThanServiceLimit: return "REQUESTED_SPEND_LIMIT_HIGHER_THAN_SERVICE_LIMIT"
            case .resourceNotAccessible: return "RESOURCE_NOT_ACCESSIBLE"
            case .senderIdNotRegistered: return "SENDER_ID_NOT_REGISTERED"
            case .senderIdNotSupported: return "SENDER_ID_NOT_SUPPORTED"
            case .senderIdRequiresRegistration: return "SENDER_ID_REQUIRES_REGISTRATION"
            case .twoWayChannelNotPresent: return "TWO_WAY_CHANNEL_NOT_PRESENT"
            case .twoWayNotEnabled: return "TWO_WAY_NOT_ENABLED"
            case .twoWayNotSupportedInCountry: return "TWO_WAY_NOT_SUPPORTED_IN_COUNTRY"
            case .twoWayNotSupportedInRegion: return "TWO_WAY_NOT_SUPPORTED_IN_REGION"
            case .twoWayTopicNotPresent: return "TWO_WAY_TOPIC_NOT_PRESENT"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case .unknownRegistrationField: return "UNKNOWN_REGISTRATION_FIELD"
            case .unknownRegistrationSection: return "UNKNOWN_REGISTRATION_SECTION"
            case .unknownRegistrationType: return "UNKNOWN_REGISTRATION_TYPE"
            case .unknownRegistrationVersion: return "UNKNOWN_REGISTRATION_VERSION"
            case .unspecifiedParameterNotSupported: return "UNSPECIFIED_PARAMETER_NOT_SUPPORTED"
            case .verificationCodeMismatch: return "VERIFICATION_CODE_MISMATCH"
            case .voiceCapabilityNotAvailable: return "VOICE_CAPABILITY_NOT_AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// A validation exception for a field.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The field that failed validation.
        public internal(set) var fields: [PinpointSMSVoiceV2ClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: PinpointSMSVoiceV2ClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [PinpointSMSVoiceV2ClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: PinpointSMSVoiceV2ClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct AssociateOriginationIdentityInput: Swift.Sendable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The new two-character code, in ISO 3166-1 alpha-2 format, for the country or region of the origination identity.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The origination identity to use, such as PhoneNumberId, PhoneNumberArn, SenderId, or SenderIdArn. You can use [DescribePhoneNumbers] to find the values for PhoneNumberId and PhoneNumberArn, while [DescribeSenderIds] can be used to get the values for SenderId and SenderIdArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    /// This member is required.
    public var originationIdentity: Swift.String?
    /// The pool to update with the new Identity. This value can be either the PoolId or PoolArn, and you can find these values using [DescribePools]. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    /// This member is required.
    public var poolId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        isoCountryCode: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        poolId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.isoCountryCode = isoCountryCode
        self.originationIdentity = originationIdentity
        self.poolId = poolId
    }
}

public struct AssociateOriginationIdentityOutput: Swift.Sendable {
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    public var isoCountryCode: Swift.String?
    /// The PhoneNumberId or SenderId of the origination identity.
    public var originationIdentity: Swift.String?
    /// The PhoneNumberArn or SenderIdArn of the origination identity.
    public var originationIdentityArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the pool that is now associated with the origination identity.
    public var poolArn: Swift.String?
    /// The PoolId of the pool that is now associated with the origination identity.
    public var poolId: Swift.String?

    public init(
        isoCountryCode: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        originationIdentityArn: Swift.String? = nil,
        poolArn: Swift.String? = nil,
        poolId: Swift.String? = nil
    )
    {
        self.isoCountryCode = isoCountryCode
        self.originationIdentity = originationIdentity
        self.originationIdentityArn = originationIdentityArn
        self.poolArn = poolArn
        self.poolId = poolId
    }
}

public struct AssociateProtectConfigurationInput: Swift.Sendable {
    /// The name of the ConfigurationSet.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// The unique identifier for the protect configuration.
    /// This member is required.
    public var protectConfigurationId: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil,
        protectConfigurationId: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.protectConfigurationId = protectConfigurationId
    }
}

public struct AssociateProtectConfigurationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the configuration set.
    /// This member is required.
    public var configurationSetArn: Swift.String?
    /// The name of the ConfigurationSet.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// The Amazon Resource Name (ARN) of the protect configuration.
    /// This member is required.
    public var protectConfigurationArn: Swift.String?
    /// The unique identifier for the protect configuration.
    /// This member is required.
    public var protectConfigurationId: Swift.String?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        protectConfigurationArn: Swift.String? = nil,
        protectConfigurationId: Swift.String? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.protectConfigurationArn = protectConfigurationArn
        self.protectConfigurationId = protectConfigurationId
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum AttachmentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleted
        case uploadComplete
        case uploadFailed
        case uploadInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentStatus] {
            return [
                .deleted,
                .uploadComplete,
                .uploadFailed,
                .uploadInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .uploadComplete: return "UPLOAD_COMPLETE"
            case .uploadFailed: return "UPLOAD_FAILED"
            case .uploadInProgress: return "UPLOAD_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum AttachmentUploadErrorReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internalError
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentUploadErrorReason] {
            return [
                .internalError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "INTERNAL_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Contains the destination configuration to use when publishing message sending events.
    public struct CloudWatchLogsDestination: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of an Identity and Access Management role that is able to write event data to an Amazon CloudWatch destination.
        /// This member is required.
        public var iamRoleArn: Swift.String?
        /// The name of the Amazon CloudWatch log group that you want to record events in.
        /// This member is required.
        public var logGroupArn: Swift.String?

        public init(
            iamRoleArn: Swift.String? = nil,
            logGroupArn: Swift.String? = nil
        )
        {
            self.iamRoleArn = iamRoleArn
            self.logGroupArn = logGroupArn
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum ConfigurationSetFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case defaultMessageType
        case defaultSenderId
        case eventDestinationName
        case matchingEventTypes
        case protectConfigurationId
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationSetFilterName] {
            return [
                .defaultMessageType,
                .defaultSenderId,
                .eventDestinationName,
                .matchingEventTypes,
                .protectConfigurationId
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .defaultMessageType: return "default-message-type"
            case .defaultSenderId: return "default-sender-id"
            case .eventDestinationName: return "event-destination-name"
            case .matchingEventTypes: return "matching-event-types"
            case .protectConfigurationId: return "protect-configuration-id"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The information for configuration sets that meet a specified criteria.
    public struct ConfigurationSetFilter: Swift.Sendable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilterName?
        /// An array values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum MessageType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case promotional
        case transactional
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageType] {
            return [
                .promotional,
                .transactional
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .promotional: return "PROMOTIONAL"
            case .transactional: return "TRANSACTIONAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Contains the delivery stream Amazon Resource Name (ARN), and the ARN of the Identity and Access Management (IAM) role associated with a Firehose event destination. Event destinations, such as Firehose, are associated with configuration sets, which enable you to publish message sending events.
    public struct KinesisFirehoseDestination: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the delivery stream.
        /// This member is required.
        public var deliveryStreamArn: Swift.String?
        /// The ARN of an Identity and Access Management role that is able to write event data to an Amazon Data Firehose destination.
        /// This member is required.
        public var iamRoleArn: Swift.String?

        public init(
            deliveryStreamArn: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil
        )
        {
            self.deliveryStreamArn = deliveryStreamArn
            self.iamRoleArn = iamRoleArn
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum EventType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case mediaAll
        case mediaBlocked
        case mediaCarrierBlocked
        case mediaCarrierUnreachable
        case mediaDelivered
        case mediaFileInaccessible
        case mediaFileSizeExceeded
        case mediaFileTypeUnsupported
        case mediaInvalid
        case mediaInvalidMessage
        case mediaPending
        case mediaQueued
        case mediaSpam
        case mediaSuccessful
        case mediaTtlExpired
        case mediaUnknown
        case mediaUnreachable
        case textAll
        case textBlocked
        case textCarrierBlocked
        case textCarrierUnreachable
        case textDelivered
        case textInvalid
        case textInvalidMessage
        case textPending
        case textQueued
        case textSent
        case textSpam
        case textSuccessful
        case textTtlExpired
        case textUnknown
        case textUnreachable
        case voiceAll
        case voiceAnswered
        case voiceBusy
        case voiceCompleted
        case voiceFailed
        case voiceInitiated
        case voiceNoAnswer
        case voiceRinging
        case voiceTtlExpired
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .all,
                .mediaAll,
                .mediaBlocked,
                .mediaCarrierBlocked,
                .mediaCarrierUnreachable,
                .mediaDelivered,
                .mediaFileInaccessible,
                .mediaFileSizeExceeded,
                .mediaFileTypeUnsupported,
                .mediaInvalid,
                .mediaInvalidMessage,
                .mediaPending,
                .mediaQueued,
                .mediaSpam,
                .mediaSuccessful,
                .mediaTtlExpired,
                .mediaUnknown,
                .mediaUnreachable,
                .textAll,
                .textBlocked,
                .textCarrierBlocked,
                .textCarrierUnreachable,
                .textDelivered,
                .textInvalid,
                .textInvalidMessage,
                .textPending,
                .textQueued,
                .textSent,
                .textSpam,
                .textSuccessful,
                .textTtlExpired,
                .textUnknown,
                .textUnreachable,
                .voiceAll,
                .voiceAnswered,
                .voiceBusy,
                .voiceCompleted,
                .voiceFailed,
                .voiceInitiated,
                .voiceNoAnswer,
                .voiceRinging,
                .voiceTtlExpired
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .mediaAll: return "MEDIA_ALL"
            case .mediaBlocked: return "MEDIA_BLOCKED"
            case .mediaCarrierBlocked: return "MEDIA_CARRIER_BLOCKED"
            case .mediaCarrierUnreachable: return "MEDIA_CARRIER_UNREACHABLE"
            case .mediaDelivered: return "MEDIA_DELIVERED"
            case .mediaFileInaccessible: return "MEDIA_FILE_INACCESSIBLE"
            case .mediaFileSizeExceeded: return "MEDIA_FILE_SIZE_EXCEEDED"
            case .mediaFileTypeUnsupported: return "MEDIA_FILE_TYPE_UNSUPPORTED"
            case .mediaInvalid: return "MEDIA_INVALID"
            case .mediaInvalidMessage: return "MEDIA_INVALID_MESSAGE"
            case .mediaPending: return "MEDIA_PENDING"
            case .mediaQueued: return "MEDIA_QUEUED"
            case .mediaSpam: return "MEDIA_SPAM"
            case .mediaSuccessful: return "MEDIA_SUCCESSFUL"
            case .mediaTtlExpired: return "MEDIA_TTL_EXPIRED"
            case .mediaUnknown: return "MEDIA_UNKNOWN"
            case .mediaUnreachable: return "MEDIA_UNREACHABLE"
            case .textAll: return "TEXT_ALL"
            case .textBlocked: return "TEXT_BLOCKED"
            case .textCarrierBlocked: return "TEXT_CARRIER_BLOCKED"
            case .textCarrierUnreachable: return "TEXT_CARRIER_UNREACHABLE"
            case .textDelivered: return "TEXT_DELIVERED"
            case .textInvalid: return "TEXT_INVALID"
            case .textInvalidMessage: return "TEXT_INVALID_MESSAGE"
            case .textPending: return "TEXT_PENDING"
            case .textQueued: return "TEXT_QUEUED"
            case .textSent: return "TEXT_SENT"
            case .textSpam: return "TEXT_SPAM"
            case .textSuccessful: return "TEXT_SUCCESSFUL"
            case .textTtlExpired: return "TEXT_TTL_EXPIRED"
            case .textUnknown: return "TEXT_UNKNOWN"
            case .textUnreachable: return "TEXT_UNREACHABLE"
            case .voiceAll: return "VOICE_ALL"
            case .voiceAnswered: return "VOICE_ANSWERED"
            case .voiceBusy: return "VOICE_BUSY"
            case .voiceCompleted: return "VOICE_COMPLETED"
            case .voiceFailed: return "VOICE_FAILED"
            case .voiceInitiated: return "VOICE_INITIATED"
            case .voiceNoAnswer: return "VOICE_NO_ANSWER"
            case .voiceRinging: return "VOICE_RINGING"
            case .voiceTtlExpired: return "VOICE_TTL_EXPIRED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// An object that defines an Amazon SNS destination for events. You can use Amazon SNS to send notification when certain events occur.
    public struct SnsDestination: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Amazon SNS topic that you want to publish events to.
        /// This member is required.
        public var topicArn: Swift.String?

        public init(
            topicArn: Swift.String? = nil
        )
        {
            self.topicArn = topicArn
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Contains information about an event destination. Event destinations are associated with configuration sets, which enable you to publish message sending events to CloudWatch, Firehose, or Amazon SNS.
    public struct EventDestination: Swift.Sendable {
        /// An object that contains information about an event destination that sends logging events to Amazon CloudWatch logs.
        public var cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination?
        /// When set to true events will be logged.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// The name of the EventDestination.
        /// This member is required.
        public var eventDestinationName: Swift.String?
        /// An object that contains information about an event destination for logging to Amazon Data Firehose.
        public var kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination?
        /// An array of event types that determine which events to log. The TEXT_SENT event type is not supported.
        /// This member is required.
        public var matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]?
        /// An object that contains information about an event destination that sends logging events to Amazon SNS.
        public var snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination?

        public init(
            cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination? = nil,
            enabled: Swift.Bool? = nil,
            eventDestinationName: Swift.String? = nil,
            kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination? = nil,
            matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]? = nil,
            snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination? = nil
        )
        {
            self.cloudWatchLogsDestination = cloudWatchLogsDestination
            self.enabled = enabled
            self.eventDestinationName = eventDestinationName
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.snsDestination = snsDestination
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Information related to a given configuration set in your Amazon Web Services account.
    public struct ConfigurationSetInformation: Swift.Sendable {
        /// The Resource Name (ARN) of the ConfigurationSet.
        /// This member is required.
        public var configurationSetArn: Swift.String?
        /// The name of the ConfigurationSet.
        /// This member is required.
        public var configurationSetName: Swift.String?
        /// The time when the ConfigurationSet was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var createdTimestamp: Foundation.Date?
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        public var defaultMessageType: PinpointSMSVoiceV2ClientTypes.MessageType?
        /// The default sender ID used by the ConfigurationSet.
        public var defaultSenderId: Swift.String?
        /// An array of EventDestination objects that describe any events to log and where to log them.
        /// This member is required.
        public var eventDestinations: [PinpointSMSVoiceV2ClientTypes.EventDestination]?
        /// The unique identifier for the protect configuration.
        public var protectConfigurationId: Swift.String?

        public init(
            configurationSetArn: Swift.String? = nil,
            configurationSetName: Swift.String? = nil,
            createdTimestamp: Foundation.Date? = nil,
            defaultMessageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
            defaultSenderId: Swift.String? = nil,
            eventDestinations: [PinpointSMSVoiceV2ClientTypes.EventDestination]? = nil,
            protectConfigurationId: Swift.String? = nil
        )
        {
            self.configurationSetArn = configurationSetArn
            self.configurationSetName = configurationSetName
            self.createdTimestamp = createdTimestamp
            self.defaultMessageType = defaultMessageType
            self.defaultSenderId = defaultSenderId
            self.eventDestinations = eventDestinations
            self.protectConfigurationId = protectConfigurationId
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The list of tags to be added to the specified topic.
    public struct Tag: Swift.Sendable {
        /// The key identifier, or name, of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The string value associated with the key of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateConfigurationSetInput: Swift.Sendable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The name to use for the new configuration set.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// An array of key and value pair tags that's associated with the new configuration set.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.configurationSetName = configurationSetName
        self.tags = tags
    }
}

public struct CreateConfigurationSetOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the newly created configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the new configuration set.
    public var configurationSetName: Swift.String?
    /// The time when the configuration set was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: Foundation.Date?
    /// An array of key and value pair tags that's associated with the configuration set.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        createdTimestamp: Foundation.Date? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.createdTimestamp = createdTimestamp
        self.tags = tags
    }
}

public struct CreateEventDestinationInput: Swift.Sendable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// An object that contains information about an event destination for logging to Amazon CloudWatch Logs.
    public var cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination?
    /// Either the name of the configuration set or the configuration set ARN to apply event logging to. The ConfigurateSetName and ConfigurationSetArn can be found using the [DescribeConfigurationSets] action.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// The name that identifies the event destination.
    /// This member is required.
    public var eventDestinationName: Swift.String?
    /// An object that contains information about an event destination for logging to Amazon Data Firehose.
    public var kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination?
    /// An array of event types that determine which events to log. If "ALL" is used, then AWS End User Messaging SMS and Voice logs every event type. The TEXT_SENT event type is not supported.
    /// This member is required.
    public var matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]?
    /// An object that contains information about an event destination for logging to Amazon SNS.
    public var snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination?

    public init(
        clientToken: Swift.String? = nil,
        cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination? = nil,
        configurationSetName: Swift.String? = nil,
        eventDestinationName: Swift.String? = nil,
        kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination? = nil,
        matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]? = nil,
        snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination? = nil
    )
    {
        self.clientToken = clientToken
        self.cloudWatchLogsDestination = cloudWatchLogsDestination
        self.configurationSetName = configurationSetName
        self.eventDestinationName = eventDestinationName
        self.kinesisFirehoseDestination = kinesisFirehoseDestination
        self.matchingEventTypes = matchingEventTypes
        self.snsDestination = snsDestination
    }
}

public struct CreateEventDestinationOutput: Swift.Sendable {
    /// The ARN of the configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set.
    public var configurationSetName: Swift.String?
    /// The details of the destination where events are logged.
    public var eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
    }
}

public struct CreateOptOutListInput: Swift.Sendable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The name of the new OptOutList.
    /// This member is required.
    public var optOutListName: Swift.String?
    /// An array of tags (key and value pairs) to associate with the new OptOutList.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        optOutListName: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.optOutListName = optOutListName
        self.tags = tags
    }
}

public struct CreateOptOutListOutput: Swift.Sendable {
    /// The time when the pool was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: Foundation.Date?
    /// The Amazon Resource Name (ARN) for the OptOutList.
    public var optOutListArn: Swift.String?
    /// The name of the new OptOutList.
    public var optOutListName: Swift.String?
    /// An array of tags (key and value pairs) associated with the new OptOutList.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        createdTimestamp: Foundation.Date? = nil,
        optOutListArn: Swift.String? = nil,
        optOutListName: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.optOutListArn = optOutListArn
        self.optOutListName = optOutListName
        self.tags = tags
    }
}

public struct CreatePoolInput: Swift.Sendable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// By default this is set to false. When set to true the pool can't be deleted. You can change this value using the [UpdatePool] action.
    public var deletionProtectionEnabled: Swift.Bool?
    /// The new two-character code, in ISO 3166-1 alpha-2 format, for the country or region of the new pool.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive. After the pool is created the MessageType can't be changed.
    /// This member is required.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use [DescribePhoneNumbers] to find the values for PhoneNumberId and PhoneNumberArn while [DescribeSenderIds] can be used to get the values for SenderId and SenderIdArn. After the pool is created you can add more origination identities to the pool by using [AssociateOriginationIdentity](https://docs.aws.amazon.com/pinpoint/latest/apireference_smsvoicev2/API_AssociateOriginationIdentity.html). If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    /// This member is required.
    public var originationIdentity: Swift.String?
    /// An array of tags (key and value pairs) associated with the pool.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        deletionProtectionEnabled: Swift.Bool? = nil,
        isoCountryCode: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        originationIdentity: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.messageType = messageType
        self.originationIdentity = originationIdentity
        self.tags = tags
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum PoolStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [PoolStatus] {
            return [
                .active,
                .creating,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreatePoolOutput: Swift.Sendable {
    /// The time when the pool was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: Foundation.Date?
    /// When set to true deletion protection is enabled. By default this is set to false.
    public var deletionProtectionEnabled: Swift.Bool
    /// The type of message for the pool to use.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The name of the OptOutList associated with the pool.
    public var optOutListName: Swift.String?
    /// The Amazon Resource Name (ARN) for the pool.
    public var poolArn: Swift.String?
    /// The unique identifier for the pool.
    public var poolId: Swift.String?
    /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, AWS End User Messaging SMS and Voice automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool
    /// Indicates whether shared routes are enabled for the pool. Set to false and only origination identities in this pool are used to send messages.
    public var sharedRoutesEnabled: Swift.Bool
    /// The current status of the pool.
    ///
    /// * CREATING: The pool is currently being created and isn't yet available for use.
    ///
    /// * ACTIVE: The pool is active and available for use.
    ///
    /// * DELETING: The pool is being deleted.
    public var status: PinpointSMSVoiceV2ClientTypes.PoolStatus?
    /// An array of tags (key and value pairs) associated with the pool.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) of the two way channel.
    public var twoWayChannelArn: Swift.String?
    /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
    public var twoWayChannelRole: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool

    public init(
        createdTimestamp: Foundation.Date? = nil,
        deletionProtectionEnabled: Swift.Bool = false,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        optOutListName: Swift.String? = nil,
        poolArn: Swift.String? = nil,
        poolId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool = false,
        sharedRoutesEnabled: Swift.Bool = false,
        status: PinpointSMSVoiceV2ClientTypes.PoolStatus? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayChannelRole: Swift.String? = nil,
        twoWayEnabled: Swift.Bool = false
    )
    {
        self.createdTimestamp = createdTimestamp
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.messageType = messageType
        self.optOutListName = optOutListName
        self.poolArn = poolArn
        self.poolId = poolId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.sharedRoutesEnabled = sharedRoutesEnabled
        self.status = status
        self.tags = tags
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayChannelRole = twoWayChannelRole
        self.twoWayEnabled = twoWayEnabled
    }
}

public struct CreateProtectConfigurationInput: Swift.Sendable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// When set to true deletion protection is enabled. By default this is set to false.
    public var deletionProtectionEnabled: Swift.Bool?
    /// An array of key and value pair tags that are associated with the resource.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        deletionProtectionEnabled: Swift.Bool? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.tags = tags
    }
}

public struct CreateProtectConfigurationOutput: Swift.Sendable {
    /// This is true if the protect configuration is set as your account default protect configuration.
    /// This member is required.
    public var accountDefault: Swift.Bool
    /// The time when the protect configuration was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    /// This member is required.
    public var createdTimestamp: Foundation.Date?
    /// When set to true deletion protection is enabled. By default this is set to false.
    /// This member is required.
    public var deletionProtectionEnabled: Swift.Bool
    /// The Amazon Resource Name (ARN) of the protect configuration.
    /// This member is required.
    public var protectConfigurationArn: Swift.String?
    /// The unique identifier for the protect configuration.
    /// This member is required.
    public var protectConfigurationId: Swift.String?
    /// An array of key and value pair tags that are associated with the resource.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        accountDefault: Swift.Bool = false,
        createdTimestamp: Foundation.Date? = nil,
        deletionProtectionEnabled: Swift.Bool = false,
        protectConfigurationArn: Swift.String? = nil,
        protectConfigurationId: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.accountDefault = accountDefault
        self.createdTimestamp = createdTimestamp
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.protectConfigurationArn = protectConfigurationArn
        self.protectConfigurationId = protectConfigurationId
        self.tags = tags
    }
}

public struct CreateRegistrationInput: Swift.Sendable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The type of registration form to create. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationType: Swift.String?
    /// An array of tags (key and value pairs) to associate with the registration.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        registrationType: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.registrationType = registrationType
        self.tags = tags
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum RegistrationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case closed
        case complete
        case created
        case deleted
        case provisioning
        case requiresAuthentication
        case requiresUpdates
        case reviewing
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationStatus] {
            return [
                .closed,
                .complete,
                .created,
                .deleted,
                .provisioning,
                .requiresAuthentication,
                .requiresUpdates,
                .reviewing,
                .submitted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .closed: return "CLOSED"
            case .complete: return "COMPLETE"
            case .created: return "CREATED"
            case .deleted: return "DELETED"
            case .provisioning: return "PROVISIONING"
            case .requiresAuthentication: return "REQUIRES_AUTHENTICATION"
            case .requiresUpdates: return "REQUIRES_UPDATES"
            case .reviewing: return "REVIEWING"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateRegistrationOutput: Swift.Sendable {
    /// Metadata about a given registration which is specific to that registration type.
    public var additionalAttributes: [Swift.String: Swift.String]?
    /// The time when the registration was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    /// This member is required.
    public var createdTimestamp: Foundation.Date?
    /// The current version number of the registration.
    /// This member is required.
    public var currentVersionNumber: Swift.Int?
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The status of the registration.
    ///
    /// * CLOSED: The phone number or sender ID has been deleted and you must also delete the registration for the number.
    ///
    /// * CREATED: Your registration is created but not submitted.
    ///
    /// * COMPLETE: Your registration has been approved and your origination identity has been created.
    ///
    /// * DELETED: The registration has been deleted.
    ///
    /// * PROVISIONING: Your registration has been approved and your origination identity is being created.
    ///
    /// * REQUIRES_AUTHENTICATION: You need to complete email authentication.
    ///
    /// * REQUIRES_UPDATES: You must fix your registration and resubmit it.
    ///
    /// * REVIEWING: Your registration has been accepted and is being reviewed.
    ///
    /// * SUBMITTED: Your registration has been submitted and is awaiting review.
    /// This member is required.
    public var registrationStatus: PinpointSMSVoiceV2ClientTypes.RegistrationStatus?
    /// The type of registration form to create. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationType: Swift.String?
    /// An array of tags (key and value pairs) to associate with the registration.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        additionalAttributes: [Swift.String: Swift.String]? = nil,
        createdTimestamp: Foundation.Date? = nil,
        currentVersionNumber: Swift.Int? = nil,
        registrationArn: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        registrationStatus: PinpointSMSVoiceV2ClientTypes.RegistrationStatus? = nil,
        registrationType: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.additionalAttributes = additionalAttributes
        self.createdTimestamp = createdTimestamp
        self.currentVersionNumber = currentVersionNumber
        self.registrationArn = registrationArn
        self.registrationId = registrationId
        self.registrationStatus = registrationStatus
        self.registrationType = registrationType
        self.tags = tags
    }
}

public struct CreateRegistrationAssociationInput: Swift.Sendable {
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The unique identifier for the origination identity. For example this could be a PhoneNumberId or SenderId.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        registrationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.registrationId = registrationId
        self.resourceId = resourceId
    }
}

public struct CreateRegistrationAssociationOutput: Swift.Sendable {
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    public var isoCountryCode: Swift.String?
    /// The phone number associated with the registration in E.164 format.
    public var phoneNumber: Swift.String?
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationType: Swift.String?
    /// The Amazon Resource Name (ARN) of the origination identity that is associated with the registration.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The unique identifier for the origination identity. For example this could be a PhoneNumberId or SenderId.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The registration type or origination identity type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init(
        isoCountryCode: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        registrationArn: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        registrationType: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.isoCountryCode = isoCountryCode
        self.phoneNumber = phoneNumber
        self.registrationArn = registrationArn
        self.registrationId = registrationId
        self.registrationType = registrationType
        self.resourceArn = resourceArn
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

public struct CreateRegistrationAttachmentInput: Swift.Sendable {
    /// The registration file to upload. The maximum file size is 500KB and valid file extensions are PDF, JPEG and PNG.
    public var attachmentBody: Foundation.Data?
    /// Registration files have to be stored in an Amazon S3 bucket. The URI to use when sending is in the format s3://BucketName/FileName.
    public var attachmentUrl: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// An array of tags (key and value pairs) to associate with the registration attachment.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        attachmentBody: Foundation.Data? = nil,
        attachmentUrl: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.attachmentBody = attachmentBody
        self.attachmentUrl = attachmentUrl
        self.clientToken = clientToken
        self.tags = tags
    }
}

public struct CreateRegistrationAttachmentOutput: Swift.Sendable {
    /// The status of the registration attachment.
    ///
    /// * UPLOAD_IN_PROGRESS The attachment is being uploaded.
    ///
    /// * UPLOAD_COMPLETE The attachment has been uploaded.
    ///
    /// * UPLOAD_FAILED The attachment failed to uploaded.
    ///
    /// * DELETED The attachment has been deleted..
    /// This member is required.
    public var attachmentStatus: PinpointSMSVoiceV2ClientTypes.AttachmentStatus?
    /// The time when the registration attachment was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    /// This member is required.
    public var createdTimestamp: Foundation.Date?
    /// The Amazon Resource Name (ARN) for the registration attachment.
    /// This member is required.
    public var registrationAttachmentArn: Swift.String?
    /// The unique identifier for the registration attachment.
    /// This member is required.
    public var registrationAttachmentId: Swift.String?
    /// An array of tags (key and value pairs) to associate with the registration attachment.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        attachmentStatus: PinpointSMSVoiceV2ClientTypes.AttachmentStatus? = nil,
        createdTimestamp: Foundation.Date? = nil,
        registrationAttachmentArn: Swift.String? = nil,
        registrationAttachmentId: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.attachmentStatus = attachmentStatus
        self.createdTimestamp = createdTimestamp
        self.registrationAttachmentArn = registrationAttachmentArn
        self.registrationAttachmentId = registrationAttachmentId
        self.tags = tags
    }
}

public struct CreateRegistrationVersionInput: Swift.Sendable {
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?

    public init(
        registrationId: Swift.String? = nil
    )
    {
        self.registrationId = registrationId
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum RegistrationVersionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approved
        case archived
        case denied
        case discarded
        case draft
        case requiresAuthentication
        case reviewing
        case revoked
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationVersionStatus] {
            return [
                .approved,
                .archived,
                .denied,
                .discarded,
                .draft,
                .requiresAuthentication,
                .reviewing,
                .revoked,
                .submitted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .archived: return "ARCHIVED"
            case .denied: return "DENIED"
            case .discarded: return "DISCARDED"
            case .draft: return "DRAFT"
            case .requiresAuthentication: return "REQUIRES_AUTHENTICATION"
            case .reviewing: return "REVIEWING"
            case .revoked: return "REVOKED"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The RegistrationVersionStatusHistory object contains the time stamps for when the reservations status changes.
    public struct RegistrationVersionStatusHistory: Swift.Sendable {
        /// The time when the registration was in the approved state, in [UNIX epoch time](https://www.epochconverter.com/) format.
        public var approvedTimestamp: Foundation.Date?
        /// The time when the registration was in the archived state, in [UNIX epoch time](https://www.epochconverter.com/) format.
        public var archivedTimestamp: Foundation.Date?
        /// The time when the registration was in the denied state, in [UNIX epoch time](https://www.epochconverter.com/) format.
        public var deniedTimestamp: Foundation.Date?
        /// The time when the registration was in the discarded state, in [UNIX epoch time](https://www.epochconverter.com/) format.
        public var discardedTimestamp: Foundation.Date?
        /// The time when the registration was in the draft state, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var draftTimestamp: Foundation.Date?
        /// The time when the registration was in the requires authentication state, in [UNIX epoch time](https://www.epochconverter.com/) format.
        public var requiresAuthenticationTimestamp: Foundation.Date?
        /// The time when the registration was in the reviewing state, in [UNIX epoch time](https://www.epochconverter.com/) format.
        public var reviewingTimestamp: Foundation.Date?
        /// The time when the registration was in the revoked state, in [UNIX epoch time](https://www.epochconverter.com/) format.
        public var revokedTimestamp: Foundation.Date?
        /// The time when the registration was in the submitted state, in [UNIX epoch time](https://www.epochconverter.com/) format.
        public var submittedTimestamp: Foundation.Date?

        public init(
            approvedTimestamp: Foundation.Date? = nil,
            archivedTimestamp: Foundation.Date? = nil,
            deniedTimestamp: Foundation.Date? = nil,
            discardedTimestamp: Foundation.Date? = nil,
            draftTimestamp: Foundation.Date? = nil,
            requiresAuthenticationTimestamp: Foundation.Date? = nil,
            reviewingTimestamp: Foundation.Date? = nil,
            revokedTimestamp: Foundation.Date? = nil,
            submittedTimestamp: Foundation.Date? = nil
        )
        {
            self.approvedTimestamp = approvedTimestamp
            self.archivedTimestamp = archivedTimestamp
            self.deniedTimestamp = deniedTimestamp
            self.discardedTimestamp = discardedTimestamp
            self.draftTimestamp = draftTimestamp
            self.requiresAuthenticationTimestamp = requiresAuthenticationTimestamp
            self.reviewingTimestamp = reviewingTimestamp
            self.revokedTimestamp = revokedTimestamp
            self.submittedTimestamp = submittedTimestamp
        }
    }
}

public struct CreateRegistrationVersionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The status of the registration.
    ///
    /// * APPROVED: Your registration has been approved.
    ///
    /// * ARCHIVED: Your previously approved registration version moves into this status when a more recently submitted version is approved.
    ///
    /// * DENIED: You must fix your registration and resubmit it.
    ///
    /// * DISCARDED: You've abandon this version of their registration to start over with a new version.
    ///
    /// * DRAFT: The initial status of a registration version after its created.
    ///
    /// * REQUIRES_AUTHENTICATION: You need to complete email authentication.
    ///
    /// * REVIEWING: Your registration has been accepted and is being reviewed.
    ///
    /// * REVOKED: Your previously approved registration has been revoked.
    ///
    /// * SUBMITTED: Your registration has been submitted.
    /// This member is required.
    public var registrationVersionStatus: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus?
    /// A RegistrationVersionStatusHistory object that contains timestamps for the registration.
    /// This member is required.
    public var registrationVersionStatusHistory: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory?
    /// The new version number of the registration.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        registrationArn: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        registrationVersionStatus: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus? = nil,
        registrationVersionStatusHistory: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.registrationArn = registrationArn
        self.registrationId = registrationId
        self.registrationVersionStatus = registrationVersionStatus
        self.registrationVersionStatusHistory = registrationVersionStatusHistory
        self.versionNumber = versionNumber
    }
}

public struct CreateVerifiedDestinationNumberInput: Swift.Sendable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The verified destination phone number, in E.164 format.
    /// This member is required.
    public var destinationPhoneNumber: Swift.String?
    /// An array of tags (key and value pairs) to associate with the destination number.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.destinationPhoneNumber = destinationPhoneNumber
        self.tags = tags
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum VerificationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pending
        case verified
        case sdkUnknown(Swift.String)

        public static var allCases: [VerificationStatus] {
            return [
                .pending,
                .verified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pending: return "PENDING"
            case .verified: return "VERIFIED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateVerifiedDestinationNumberOutput: Swift.Sendable {
    /// The time when the verified phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    /// This member is required.
    public var createdTimestamp: Foundation.Date?
    /// The verified destination phone number, in E.164 format.
    /// This member is required.
    public var destinationPhoneNumber: Swift.String?
    /// The status of the verified destination phone number.
    ///
    /// * PENDING: The phone number hasn't been verified yet.
    ///
    /// * VERIFIED: The phone number is verified and can receive messages.
    /// This member is required.
    public var status: PinpointSMSVoiceV2ClientTypes.VerificationStatus?
    /// An array of tags (key and value pairs) to associate with the destination number.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    /// The Amazon Resource Name (ARN) for the verified destination phone number.
    /// This member is required.
    public var verifiedDestinationNumberArn: Swift.String?
    /// The unique identifier for the verified destination phone number.
    /// This member is required.
    public var verifiedDestinationNumberId: Swift.String?

    public init(
        createdTimestamp: Foundation.Date? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        status: PinpointSMSVoiceV2ClientTypes.VerificationStatus? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil,
        verifiedDestinationNumberArn: Swift.String? = nil,
        verifiedDestinationNumberId: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.destinationPhoneNumber = destinationPhoneNumber
        self.status = status
        self.tags = tags
        self.verifiedDestinationNumberArn = verifiedDestinationNumberArn
        self.verifiedDestinationNumberId = verifiedDestinationNumberId
    }
}

public struct DeleteAccountDefaultProtectConfigurationInput: Swift.Sendable {

    public init() { }
}

public struct DeleteAccountDefaultProtectConfigurationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the account default protect configuration.
    /// This member is required.
    public var defaultProtectConfigurationArn: Swift.String?
    /// The unique identifier of the account default protect configuration.
    /// This member is required.
    public var defaultProtectConfigurationId: Swift.String?

    public init(
        defaultProtectConfigurationArn: Swift.String? = nil,
        defaultProtectConfigurationId: Swift.String? = nil
    )
    {
        self.defaultProtectConfigurationArn = defaultProtectConfigurationArn
        self.defaultProtectConfigurationId = defaultProtectConfigurationId
    }
}

public struct DeleteConfigurationSetInput: Swift.Sendable {
    /// The name of the configuration set or the configuration set ARN that you want to delete. The ConfigurationSetName and ConfigurationSetArn can be found using the [DescribeConfigurationSets] action.
    /// This member is required.
    public var configurationSetName: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

public struct DeleteConfigurationSetOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the deleted configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the deleted configuration set.
    public var configurationSetName: Swift.String?
    /// The time that the deleted configuration set was created in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: Foundation.Date?
    /// The default message type of the configuration set that was deleted.
    public var defaultMessageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The default Sender ID of the configuration set that was deleted.
    public var defaultSenderId: Swift.String?
    /// An array of any EventDestination objects that were associated with the deleted configuration set.
    public var eventDestinations: [PinpointSMSVoiceV2ClientTypes.EventDestination]?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        createdTimestamp: Foundation.Date? = nil,
        defaultMessageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        defaultSenderId: Swift.String? = nil,
        eventDestinations: [PinpointSMSVoiceV2ClientTypes.EventDestination]? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.createdTimestamp = createdTimestamp
        self.defaultMessageType = defaultMessageType
        self.defaultSenderId = defaultSenderId
        self.eventDestinations = eventDestinations
    }
}

public struct DeleteDefaultMessageTypeInput: Swift.Sendable {
    /// The name of the configuration set or the configuration set Amazon Resource Name (ARN) to delete the default message type from. The ConfigurationSetName and ConfigurationSetArn can be found using the [DescribeConfigurationSets] action.
    /// This member is required.
    public var configurationSetName: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

public struct DeleteDefaultMessageTypeOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set.
    public var configurationSetName: Swift.String?
    /// The current message type for the configuration set.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.messageType = messageType
    }
}

public struct DeleteDefaultSenderIdInput: Swift.Sendable {
    /// The name of the configuration set or the configuration set Amazon Resource Name (ARN) to delete the default sender ID from. The ConfigurationSetName and ConfigurationSetArn can be found using the [DescribeConfigurationSets] action.
    /// This member is required.
    public var configurationSetName: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

public struct DeleteDefaultSenderIdOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set.
    public var configurationSetName: Swift.String?
    /// The current sender ID for the configuration set.
    public var senderId: Swift.String?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        senderId: Swift.String? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.senderId = senderId
    }
}

public struct DeleteEventDestinationInput: Swift.Sendable {
    /// The name of the configuration set or the configuration set's Amazon Resource Name (ARN) to remove the event destination from. The ConfigurateSetName and ConfigurationSetArn can be found using the [DescribeConfigurationSets] action.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// The name of the event destination to delete.
    /// This member is required.
    public var eventDestinationName: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil,
        eventDestinationName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestinationName = eventDestinationName
    }
}

public struct DeleteEventDestinationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set the event destination was deleted from.
    public var configurationSetName: Swift.String?
    /// The event destination object that was deleted.
    public var eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
    }
}

public struct DeleteKeywordInput: Swift.Sendable {
    /// The keyword to delete.
    /// This member is required.
    public var keyword: Swift.String?
    /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, PoolId or PoolArn. You can use [DescribePhoneNumbers] to find the values for PhoneNumberId and PhoneNumberArn and [DescribePools] to find the values of PoolId and PoolArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    /// This member is required.
    public var originationIdentity: Swift.String?

    public init(
        keyword: Swift.String? = nil,
        originationIdentity: Swift.String? = nil
    )
    {
        self.keyword = keyword
        self.originationIdentity = originationIdentity
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum KeywordAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automaticResponse
        case optIn
        case optOut
        case sdkUnknown(Swift.String)

        public static var allCases: [KeywordAction] {
            return [
                .automaticResponse,
                .optIn,
                .optOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automaticResponse: return "AUTOMATIC_RESPONSE"
            case .optIn: return "OPT_IN"
            case .optOut: return "OPT_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteKeywordOutput: Swift.Sendable {
    /// The keyword that was deleted.
    public var keyword: Swift.String?
    /// The action that was associated with the deleted keyword.
    public var keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction?
    /// The message that was associated with the deleted keyword.
    public var keywordMessage: Swift.String?
    /// The PhoneNumberId or PoolId that the keyword was associated with.
    public var originationIdentity: Swift.String?
    /// The PhoneNumberArn or PoolArn that the keyword was associated with.
    public var originationIdentityArn: Swift.String?

    public init(
        keyword: Swift.String? = nil,
        keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction? = nil,
        keywordMessage: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        originationIdentityArn: Swift.String? = nil
    )
    {
        self.keyword = keyword
        self.keywordAction = keywordAction
        self.keywordMessage = keywordMessage
        self.originationIdentity = originationIdentity
        self.originationIdentityArn = originationIdentityArn
    }
}

public struct DeleteMediaMessageSpendLimitOverrideInput: Swift.Sendable {

    public init() { }
}

public struct DeleteMediaMessageSpendLimitOverrideOutput: Swift.Sendable {
    /// The current monthly limit, in US dollars.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

public struct DeleteOptedOutNumberInput: Swift.Sendable {
    /// The OptOutListName or OptOutListArn to remove the phone number from. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    /// This member is required.
    public var optOutListName: Swift.String?
    /// The phone number, in E.164 format, to remove from the OptOutList.
    /// This member is required.
    public var optedOutNumber: Swift.String?

    public init(
        optOutListName: Swift.String? = nil,
        optedOutNumber: Swift.String? = nil
    )
    {
        self.optOutListName = optOutListName
        self.optedOutNumber = optedOutNumber
    }
}

public struct DeleteOptedOutNumberOutput: Swift.Sendable {
    /// This is true if it was the end user who requested their phone number be removed.
    public var endUserOptedOut: Swift.Bool
    /// The OptOutListArn that the phone number was removed from.
    public var optOutListArn: Swift.String?
    /// The OptOutListName that the phone number was removed from.
    public var optOutListName: Swift.String?
    /// The phone number that was removed from the OptOutList.
    public var optedOutNumber: Swift.String?
    /// The time that the number was removed at, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var optedOutTimestamp: Foundation.Date?

    public init(
        endUserOptedOut: Swift.Bool = false,
        optOutListArn: Swift.String? = nil,
        optOutListName: Swift.String? = nil,
        optedOutNumber: Swift.String? = nil,
        optedOutTimestamp: Foundation.Date? = nil
    )
    {
        self.endUserOptedOut = endUserOptedOut
        self.optOutListArn = optOutListArn
        self.optOutListName = optOutListName
        self.optedOutNumber = optedOutNumber
        self.optedOutTimestamp = optedOutTimestamp
    }
}

public struct DeleteOptOutListInput: Swift.Sendable {
    /// The OptOutListName or OptOutListArn of the OptOutList to delete. You can use [DescribeOptOutLists] to find the values for OptOutListName and OptOutListArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    /// This member is required.
    public var optOutListName: Swift.String?

    public init(
        optOutListName: Swift.String? = nil
    )
    {
        self.optOutListName = optOutListName
    }
}

public struct DeleteOptOutListOutput: Swift.Sendable {
    /// The time when the OptOutList was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the OptOutList that was removed.
    public var optOutListArn: Swift.String?
    /// The name of the OptOutList that was removed.
    public var optOutListName: Swift.String?

    public init(
        createdTimestamp: Foundation.Date? = nil,
        optOutListArn: Swift.String? = nil,
        optOutListName: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.optOutListArn = optOutListArn
        self.optOutListName = optOutListName
    }
}

public struct DeletePoolInput: Swift.Sendable {
    /// The PoolId or PoolArn of the pool to delete. You can use [DescribePools] to find the values for PoolId and PoolArn . If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    /// This member is required.
    public var poolId: Swift.String?

    public init(
        poolId: Swift.String? = nil
    )
    {
        self.poolId = poolId
    }
}

public struct DeletePoolOutput: Swift.Sendable {
    /// The time when the pool was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: Foundation.Date?
    /// The message type that was associated with the deleted pool.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The name of the OptOutList that was associated with the deleted pool.
    public var optOutListName: Swift.String?
    /// The Amazon Resource Name (ARN) of the pool that was deleted.
    public var poolArn: Swift.String?
    /// The PoolId of the pool that was deleted.
    public var poolId: Swift.String?
    /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, AWS End User Messaging SMS and Voice automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool
    /// Indicates whether shared routes are enabled for the pool.
    public var sharedRoutesEnabled: Swift.Bool
    /// The current status of the pool.
    ///
    /// * CREATING: The pool is currently being created and isn't yet available for use.
    ///
    /// * ACTIVE: The pool is active and available for use.
    ///
    /// * DELETING: The pool is being deleted.
    public var status: PinpointSMSVoiceV2ClientTypes.PoolStatus?
    /// The Amazon Resource Name (ARN) of the TwoWayChannel.
    public var twoWayChannelArn: Swift.String?
    /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
    public var twoWayChannelRole: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool

    public init(
        createdTimestamp: Foundation.Date? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        optOutListName: Swift.String? = nil,
        poolArn: Swift.String? = nil,
        poolId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool = false,
        sharedRoutesEnabled: Swift.Bool = false,
        status: PinpointSMSVoiceV2ClientTypes.PoolStatus? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayChannelRole: Swift.String? = nil,
        twoWayEnabled: Swift.Bool = false
    )
    {
        self.createdTimestamp = createdTimestamp
        self.messageType = messageType
        self.optOutListName = optOutListName
        self.poolArn = poolArn
        self.poolId = poolId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.sharedRoutesEnabled = sharedRoutesEnabled
        self.status = status
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayChannelRole = twoWayChannelRole
        self.twoWayEnabled = twoWayEnabled
    }
}

public struct DeleteProtectConfigurationInput: Swift.Sendable {
    /// The unique identifier for the protect configuration.
    /// This member is required.
    public var protectConfigurationId: Swift.String?

    public init(
        protectConfigurationId: Swift.String? = nil
    )
    {
        self.protectConfigurationId = protectConfigurationId
    }
}

public struct DeleteProtectConfigurationOutput: Swift.Sendable {
    /// This is true if the protect configuration is set as your account default protect configuration.
    /// This member is required.
    public var accountDefault: Swift.Bool
    /// The time when the protect configuration was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    /// This member is required.
    public var createdTimestamp: Foundation.Date?
    /// The status of deletion protection for the protect configuration. When set to true deletion protection is enabled. By default this is set to false.
    /// This member is required.
    public var deletionProtectionEnabled: Swift.Bool
    /// The Amazon Resource Name (ARN) of the protect configuration.
    /// This member is required.
    public var protectConfigurationArn: Swift.String?
    /// The unique identifier for the protect configuration.
    /// This member is required.
    public var protectConfigurationId: Swift.String?

    public init(
        accountDefault: Swift.Bool = false,
        createdTimestamp: Foundation.Date? = nil,
        deletionProtectionEnabled: Swift.Bool = false,
        protectConfigurationArn: Swift.String? = nil,
        protectConfigurationId: Swift.String? = nil
    )
    {
        self.accountDefault = accountDefault
        self.createdTimestamp = createdTimestamp
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.protectConfigurationArn = protectConfigurationArn
        self.protectConfigurationId = protectConfigurationId
    }
}

public struct DeleteRegistrationInput: Swift.Sendable {
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?

    public init(
        registrationId: Swift.String? = nil
    )
    {
        self.registrationId = registrationId
    }
}

public struct DeleteRegistrationOutput: Swift.Sendable {
    /// Metadata about a given registration which is specific to that registration type.
    public var additionalAttributes: [Swift.String: Swift.String]?
    /// The version number of the registration that was approved.
    public var approvedVersionNumber: Swift.Int?
    /// The time when the registration was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    /// This member is required.
    public var createdTimestamp: Foundation.Date?
    /// The current version number of the registration.
    /// This member is required.
    public var currentVersionNumber: Swift.Int?
    /// The latest version number of the registration that was denied.
    public var latestDeniedVersionNumber: Swift.Int?
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The status of the registration.
    ///
    /// * CLOSED: The phone number or sender ID has been deleted and you must also delete the registration for the number.
    ///
    /// * CREATED: Your registration is created but not submitted.
    ///
    /// * COMPLETE: Your registration has been approved and your origination identity has been created.
    ///
    /// * DELETED: The registration has been deleted.
    ///
    /// * PROVISIONING: Your registration has been approved and your origination identity is being created.
    ///
    /// * REQUIRES_AUTHENTICATION: You need to complete email authentication.
    ///
    /// * REQUIRES_UPDATES: You must fix your registration and resubmit it.
    ///
    /// * REVIEWING: Your registration has been accepted and is being reviewed.
    ///
    /// * SUBMITTED: Your registration has been submitted and is awaiting review.
    /// This member is required.
    public var registrationStatus: PinpointSMSVoiceV2ClientTypes.RegistrationStatus?
    /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationType: Swift.String?

    public init(
        additionalAttributes: [Swift.String: Swift.String]? = nil,
        approvedVersionNumber: Swift.Int? = nil,
        createdTimestamp: Foundation.Date? = nil,
        currentVersionNumber: Swift.Int? = nil,
        latestDeniedVersionNumber: Swift.Int? = nil,
        registrationArn: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        registrationStatus: PinpointSMSVoiceV2ClientTypes.RegistrationStatus? = nil,
        registrationType: Swift.String? = nil
    )
    {
        self.additionalAttributes = additionalAttributes
        self.approvedVersionNumber = approvedVersionNumber
        self.createdTimestamp = createdTimestamp
        self.currentVersionNumber = currentVersionNumber
        self.latestDeniedVersionNumber = latestDeniedVersionNumber
        self.registrationArn = registrationArn
        self.registrationId = registrationId
        self.registrationStatus = registrationStatus
        self.registrationType = registrationType
    }
}

public struct DeleteRegistrationAttachmentInput: Swift.Sendable {
    /// The unique identifier for the registration attachment.
    /// This member is required.
    public var registrationAttachmentId: Swift.String?

    public init(
        registrationAttachmentId: Swift.String? = nil
    )
    {
        self.registrationAttachmentId = registrationAttachmentId
    }
}

public struct DeleteRegistrationAttachmentOutput: Swift.Sendable {
    /// The status of the registration attachment.
    ///
    /// * UPLOAD_IN_PROGRESS The attachment is being uploaded.
    ///
    /// * UPLOAD_COMPLETE The attachment has been uploaded.
    ///
    /// * UPLOAD_FAILED The attachment failed to uploaded.
    ///
    /// * DELETED The attachment has been deleted..
    /// This member is required.
    public var attachmentStatus: PinpointSMSVoiceV2ClientTypes.AttachmentStatus?
    /// The error message if the upload failed.
    public var attachmentUploadErrorReason: PinpointSMSVoiceV2ClientTypes.AttachmentUploadErrorReason?
    /// The time when the registration attachment was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    /// This member is required.
    public var createdTimestamp: Foundation.Date?
    /// The Amazon Resource Name (ARN) for the registration attachment.
    /// This member is required.
    public var registrationAttachmentArn: Swift.String?
    /// The unique identifier for the registration attachment.
    /// This member is required.
    public var registrationAttachmentId: Swift.String?

    public init(
        attachmentStatus: PinpointSMSVoiceV2ClientTypes.AttachmentStatus? = nil,
        attachmentUploadErrorReason: PinpointSMSVoiceV2ClientTypes.AttachmentUploadErrorReason? = nil,
        createdTimestamp: Foundation.Date? = nil,
        registrationAttachmentArn: Swift.String? = nil,
        registrationAttachmentId: Swift.String? = nil
    )
    {
        self.attachmentStatus = attachmentStatus
        self.attachmentUploadErrorReason = attachmentUploadErrorReason
        self.createdTimestamp = createdTimestamp
        self.registrationAttachmentArn = registrationAttachmentArn
        self.registrationAttachmentId = registrationAttachmentId
    }
}

public struct DeleteRegistrationFieldValueInput: Swift.Sendable {
    /// The path to the registration form field. You can use [DescribeRegistrationFieldDefinitions] for a list of FieldPaths.
    /// This member is required.
    public var fieldPath: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?

    public init(
        fieldPath: Swift.String? = nil,
        registrationId: Swift.String? = nil
    )
    {
        self.fieldPath = fieldPath
        self.registrationId = registrationId
    }
}

public struct DeleteRegistrationFieldValueOutput: Swift.Sendable {
    /// The path to the registration form field.
    /// This member is required.
    public var fieldPath: Swift.String?
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// The unique identifier for the registration attachment.
    public var registrationAttachmentId: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// An array of values for the form field.
    public var selectChoices: [Swift.String]?
    /// The text data for a free form field.
    public var textValue: Swift.String?
    /// The version number of the registration.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        fieldPath: Swift.String? = nil,
        registrationArn: Swift.String? = nil,
        registrationAttachmentId: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        selectChoices: [Swift.String]? = nil,
        textValue: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.fieldPath = fieldPath
        self.registrationArn = registrationArn
        self.registrationAttachmentId = registrationAttachmentId
        self.registrationId = registrationId
        self.selectChoices = selectChoices
        self.textValue = textValue
        self.versionNumber = versionNumber
    }
}

public struct DeleteResourcePolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the AWS End User Messaging SMS and Voice resource you're deleting the resource-based policy from.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct DeleteResourcePolicyOutput: Swift.Sendable {
    /// The time when the resource-based policy was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: Foundation.Date?
    /// The JSON formatted resource-based policy that was deleted.
    public var policy: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS End User Messaging SMS and Voice resource that the resource-based policy was deleted from.
    public var resourceArn: Swift.String?

    public init(
        createdTimestamp: Foundation.Date? = nil,
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

public struct DeleteTextMessageSpendLimitOverrideInput: Swift.Sendable {

    public init() { }
}

public struct DeleteTextMessageSpendLimitOverrideOutput: Swift.Sendable {
    /// The current monthly limit, in US dollars.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

public struct DeleteVerifiedDestinationNumberInput: Swift.Sendable {
    /// The unique identifier for the verified destination phone number.
    /// This member is required.
    public var verifiedDestinationNumberId: Swift.String?

    public init(
        verifiedDestinationNumberId: Swift.String? = nil
    )
    {
        self.verifiedDestinationNumberId = verifiedDestinationNumberId
    }
}

public struct DeleteVerifiedDestinationNumberOutput: Swift.Sendable {
    /// The time when the destination phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    /// This member is required.
    public var createdTimestamp: Foundation.Date?
    /// The verified destination phone number, in E.164 format.
    /// This member is required.
    public var destinationPhoneNumber: Swift.String?
    /// The Amazon Resource Name (ARN) for the verified destination phone number.
    /// This member is required.
    public var verifiedDestinationNumberArn: Swift.String?
    /// The unique identifier for the verified destination phone number.
    /// This member is required.
    public var verifiedDestinationNumberId: Swift.String?

    public init(
        createdTimestamp: Foundation.Date? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        verifiedDestinationNumberArn: Swift.String? = nil,
        verifiedDestinationNumberId: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.destinationPhoneNumber = destinationPhoneNumber
        self.verifiedDestinationNumberArn = verifiedDestinationNumberArn
        self.verifiedDestinationNumberId = verifiedDestinationNumberId
    }
}

public struct DeleteVoiceMessageSpendLimitOverrideInput: Swift.Sendable {

    public init() { }
}

public struct DeleteVoiceMessageSpendLimitOverrideOutput: Swift.Sendable {
    /// The current monthly limit, in US dollars.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

public struct DescribeAccountAttributesInput: Swift.Sendable {
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeAccountAttributesOutput: Swift.Sendable {
    /// An array of AccountAttributes objects.
    public var accountAttributes: [PinpointSMSVoiceV2ClientTypes.AccountAttribute]?
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?

    public init(
        accountAttributes: [PinpointSMSVoiceV2ClientTypes.AccountAttribute]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountAttributes = accountAttributes
        self.nextToken = nextToken
    }
}

public struct DescribeAccountLimitsInput: Swift.Sendable {
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeAccountLimitsOutput: Swift.Sendable {
    /// An array of AccountLimit objects that show the current spend limits.
    public var accountLimits: [PinpointSMSVoiceV2ClientTypes.AccountLimit]?
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?

    public init(
        accountLimits: [PinpointSMSVoiceV2ClientTypes.AccountLimit]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountLimits = accountLimits
        self.nextToken = nextToken
    }
}

public struct DescribeConfigurationSetsInput: Swift.Sendable {
    /// An array of strings. Each element can be either a ConfigurationSetName or ConfigurationSetArn.
    public var configurationSetNames: [Swift.String]?
    /// An array of filters to apply to the results that are returned.
    public var filters: [PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?

    public init(
        configurationSetNames: [Swift.String]? = nil,
        filters: [PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationSetNames = configurationSetNames
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeConfigurationSetsOutput: Swift.Sendable {
    /// An array of ConfigurationSets objects.
    public var configurationSets: [PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation]?
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?

    public init(
        configurationSets: [PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationSets = configurationSets
        self.nextToken = nextToken
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum KeywordFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case keywordAction
        case sdkUnknown(Swift.String)

        public static var allCases: [KeywordFilterName] {
            return [
                .keywordAction
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .keywordAction: return "keyword-action"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The information for keywords that meet a specified criteria.
    public struct KeywordFilter: Swift.Sendable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.KeywordFilterName?
        /// An array values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.KeywordFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

public struct DescribeKeywordsInput: Swift.Sendable {
    /// An array of keyword filters to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.KeywordFilter]?
    /// An array of keywords to search for.
    public var keywords: [Swift.String]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use [DescribePhoneNumbers] to find the values for PhoneNumberId and PhoneNumberArn while [DescribeSenderIds] can be used to get the values for SenderId and SenderIdArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    /// This member is required.
    public var originationIdentity: Swift.String?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.KeywordFilter]? = nil,
        keywords: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        originationIdentity: Swift.String? = nil
    )
    {
        self.filters = filters
        self.keywords = keywords
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.originationIdentity = originationIdentity
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The information for all keywords in a pool.
    public struct KeywordInformation: Swift.Sendable {
        /// The keyword as a string.
        /// This member is required.
        public var keyword: Swift.String?
        /// The action to perform for the keyword.
        /// This member is required.
        public var keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction?
        /// A custom message that can be used with the keyword.
        /// This member is required.
        public var keywordMessage: Swift.String?

        public init(
            keyword: Swift.String? = nil,
            keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction? = nil,
            keywordMessage: Swift.String? = nil
        )
        {
            self.keyword = keyword
            self.keywordAction = keywordAction
            self.keywordMessage = keywordMessage
        }
    }
}

public struct DescribeKeywordsOutput: Swift.Sendable {
    /// An array of KeywordInformation objects that contain the results.
    public var keywords: [PinpointSMSVoiceV2ClientTypes.KeywordInformation]?
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// The PhoneNumberId or PoolId that is associated with the OriginationIdentity.
    public var originationIdentity: Swift.String?
    /// The PhoneNumberArn or PoolArn that is associated with the OriginationIdentity.
    public var originationIdentityArn: Swift.String?

    public init(
        keywords: [PinpointSMSVoiceV2ClientTypes.KeywordInformation]? = nil,
        nextToken: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        originationIdentityArn: Swift.String? = nil
    )
    {
        self.keywords = keywords
        self.nextToken = nextToken
        self.originationIdentity = originationIdentity
        self.originationIdentityArn = originationIdentityArn
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum OptedOutFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case endUserOptedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [OptedOutFilterName] {
            return [
                .endUserOptedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .endUserOptedOut: return "end-user-opted-out"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The information for opted out numbers that meet a specified criteria.
    public struct OptedOutFilter: Swift.Sendable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.OptedOutFilterName?
        /// An array of values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.OptedOutFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

public struct DescribeOptedOutNumbersInput: Swift.Sendable {
    /// An array of OptedOutFilter objects to filter the results on.
    public var filters: [PinpointSMSVoiceV2ClientTypes.OptedOutFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The OptOutListName or OptOutListArn of the OptOutList. You can use [DescribeOptOutLists] to find the values for OptOutListName and OptOutListArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    /// This member is required.
    public var optOutListName: Swift.String?
    /// An array of phone numbers to search for in the OptOutList. If you specify an opted out number that isn't valid, an exception is returned.
    public var optedOutNumbers: [Swift.String]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.OptedOutFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        optOutListName: Swift.String? = nil,
        optedOutNumbers: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.optOutListName = optOutListName
        self.optedOutNumbers = optedOutNumbers
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The information for an opted out number in an Amazon Web Services account.
    public struct OptedOutNumberInformation: Swift.Sendable {
        /// This is set to true if it was the end recipient that opted out.
        /// This member is required.
        public var endUserOptedOut: Swift.Bool
        /// The phone number that is opted out.
        /// This member is required.
        public var optedOutNumber: Swift.String?
        /// The time that the op tout occurred, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var optedOutTimestamp: Foundation.Date?

        public init(
            endUserOptedOut: Swift.Bool = false,
            optedOutNumber: Swift.String? = nil,
            optedOutTimestamp: Foundation.Date? = nil
        )
        {
            self.endUserOptedOut = endUserOptedOut
            self.optedOutNumber = optedOutNumber
            self.optedOutTimestamp = optedOutTimestamp
        }
    }
}

public struct DescribeOptedOutNumbersOutput: Swift.Sendable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the OptOutList.
    public var optOutListArn: Swift.String?
    /// The name of the OptOutList.
    public var optOutListName: Swift.String?
    /// An array of OptedOutNumbersInformation objects that provide information about the requested OptedOutNumbers.
    public var optedOutNumbers: [PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation]?

    public init(
        nextToken: Swift.String? = nil,
        optOutListArn: Swift.String? = nil,
        optOutListName: Swift.String? = nil,
        optedOutNumbers: [PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.optOutListArn = optOutListArn
        self.optOutListName = optOutListName
        self.optedOutNumbers = optedOutNumbers
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum Owner: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `self`
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [Owner] {
            return [
                .self,
                .shared
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .self: return "SELF"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeOptOutListsInput: Swift.Sendable {
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The OptOutLists to show the details of. This is an array of strings that can be either the OptOutListName or OptOutListArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    public var optOutListNames: [Swift.String]?
    /// Use SELF to filter the list of Opt-Out List to ones your account owns or use SHARED to filter on Opt-Out List shared with your account. The Owner and OptOutListNames parameters can't be used at the same time.
    public var owner: PinpointSMSVoiceV2ClientTypes.Owner?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        optOutListNames: [Swift.String]? = nil,
        owner: PinpointSMSVoiceV2ClientTypes.Owner? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.optOutListNames = optOutListNames
        self.owner = owner
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The information for all OptOutList in an Amazon Web Services account.
    public struct OptOutListInformation: Swift.Sendable {
        /// The time when the OutOutList was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var createdTimestamp: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the OptOutList.
        /// This member is required.
        public var optOutListArn: Swift.String?
        /// The name of the OptOutList.
        /// This member is required.
        public var optOutListName: Swift.String?

        public init(
            createdTimestamp: Foundation.Date? = nil,
            optOutListArn: Swift.String? = nil,
            optOutListName: Swift.String? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.optOutListArn = optOutListArn
            self.optOutListName = optOutListName
        }
    }
}

public struct DescribeOptOutListsOutput: Swift.Sendable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// An array of OptOutListInformation objects that contain the details for the requested OptOutLists.
    public var optOutLists: [PinpointSMSVoiceV2ClientTypes.OptOutListInformation]?

    public init(
        nextToken: Swift.String? = nil,
        optOutLists: [PinpointSMSVoiceV2ClientTypes.OptOutListInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.optOutLists = optOutLists
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum PhoneNumberFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deletionProtectionEnabled
        case isoCountryCode
        case messageType
        case numberCapability
        case numberType
        case optOutListName
        case selfManagedOptOutsEnabled
        case status
        case twoWayChannelArn
        case twoWayEnabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberFilterName] {
            return [
                .deletionProtectionEnabled,
                .isoCountryCode,
                .messageType,
                .numberCapability,
                .numberType,
                .optOutListName,
                .selfManagedOptOutsEnabled,
                .status,
                .twoWayChannelArn,
                .twoWayEnabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deletionProtectionEnabled: return "deletion-protection-enabled"
            case .isoCountryCode: return "iso-country-code"
            case .messageType: return "message-type"
            case .numberCapability: return "number-capability"
            case .numberType: return "number-type"
            case .optOutListName: return "opt-out-list-name"
            case .selfManagedOptOutsEnabled: return "self-managed-opt-outs-enabled"
            case .status: return "status"
            case .twoWayChannelArn: return "two-way-channel-arn"
            case .twoWayEnabled: return "two-way-enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The information for a phone number that meets a specified criteria.
    public struct PhoneNumberFilter: Swift.Sendable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.PhoneNumberFilterName?
        /// An array values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.PhoneNumberFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

public struct DescribePhoneNumbersInput: Swift.Sendable {
    /// An array of PhoneNumberFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.PhoneNumberFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// Use SELF to filter the list of phone numbers to ones your account owns or use SHARED to filter on phone numbers shared with your account. The Owner and PhoneNumberIds parameters can't be used at the same time.
    public var owner: PinpointSMSVoiceV2ClientTypes.Owner?
    /// The unique identifier of phone numbers to find information about. This is an array of strings that can be either the PhoneNumberId or PhoneNumberArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    public var phoneNumberIds: [Swift.String]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.PhoneNumberFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owner: PinpointSMSVoiceV2ClientTypes.Owner? = nil,
        phoneNumberIds: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
        self.phoneNumberIds = phoneNumberIds
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum NumberCapability: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mms
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberCapability] {
            return [
                .mms,
                .sms,
                .voice
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mms: return "MMS"
            case .sms: return "SMS"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum NumberType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case longCode
        case shortCode
        case simulator
        case tenDlc
        case tollFree
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberType] {
            return [
                .longCode,
                .shortCode,
                .simulator,
                .tenDlc,
                .tollFree
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .longCode: return "LONG_CODE"
            case .shortCode: return "SHORT_CODE"
            case .simulator: return "SIMULATOR"
            case .tenDlc: return "TEN_DLC"
            case .tollFree: return "TOLL_FREE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum NumberStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case associating
        case deleted
        case disassociating
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberStatus] {
            return [
                .active,
                .associating,
                .deleted,
                .disassociating,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .associating: return "ASSOCIATING"
            case .deleted: return "DELETED"
            case .disassociating: return "DISASSOCIATING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The information for a phone number, in E.164 format, in an Amazon Web Services account.
    public struct PhoneNumberInformation: Swift.Sendable {
        /// The time when the phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var createdTimestamp: Foundation.Date?
        /// When set to true the phone number can't be deleted.
        /// This member is required.
        public var deletionProtectionEnabled: Swift.Bool
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        /// This member is required.
        public var isoCountryCode: Swift.String?
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        /// This member is required.
        public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
        /// The price, in US dollars, to lease the phone number.
        /// This member is required.
        public var monthlyLeasingPrice: Swift.String?
        /// Describes if the origination identity can be used for text messages, voice calls or both.
        /// This member is required.
        public var numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
        /// The type of phone number.
        /// This member is required.
        public var numberType: PinpointSMSVoiceV2ClientTypes.NumberType?
        /// The name of the OptOutList associated with the phone number.
        /// This member is required.
        public var optOutListName: Swift.String?
        /// The phone number in E.164 format.
        /// This member is required.
        public var phoneNumber: Swift.String?
        /// The Amazon Resource Name (ARN) associated with the phone number.
        /// This member is required.
        public var phoneNumberArn: Swift.String?
        /// The unique identifier for the phone number.
        public var phoneNumberId: Swift.String?
        /// The unique identifier of the pool associated with the phone number.
        public var poolId: Swift.String?
        /// The unique identifier for the registration.
        public var registrationId: Swift.String?
        /// When set to false an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, AWS End User Messaging SMS and Voice automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out request. For more information see [Self-managed opt-outs](https://docs.aws.amazon.com/pinpoint/latest/userguide/settings-sms-managing.html#settings-account-sms-self-managed-opt-out)
        /// This member is required.
        public var selfManagedOptOutsEnabled: Swift.Bool
        /// The current status of the phone number.
        /// This member is required.
        public var status: PinpointSMSVoiceV2ClientTypes.NumberStatus?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public var twoWayChannelArn: Swift.String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public var twoWayChannelRole: Swift.String?
        /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients using the TwoWayChannelArn.
        /// This member is required.
        public var twoWayEnabled: Swift.Bool

        public init(
            createdTimestamp: Foundation.Date? = nil,
            deletionProtectionEnabled: Swift.Bool = false,
            isoCountryCode: Swift.String? = nil,
            messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
            monthlyLeasingPrice: Swift.String? = nil,
            numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil,
            numberType: PinpointSMSVoiceV2ClientTypes.NumberType? = nil,
            optOutListName: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            phoneNumberArn: Swift.String? = nil,
            phoneNumberId: Swift.String? = nil,
            poolId: Swift.String? = nil,
            registrationId: Swift.String? = nil,
            selfManagedOptOutsEnabled: Swift.Bool = false,
            status: PinpointSMSVoiceV2ClientTypes.NumberStatus? = nil,
            twoWayChannelArn: Swift.String? = nil,
            twoWayChannelRole: Swift.String? = nil,
            twoWayEnabled: Swift.Bool = false
        )
        {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageType = messageType
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.numberCapabilities = numberCapabilities
            self.numberType = numberType
            self.optOutListName = optOutListName
            self.phoneNumber = phoneNumber
            self.phoneNumberArn = phoneNumberArn
            self.phoneNumberId = phoneNumberId
            self.poolId = poolId
            self.registrationId = registrationId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }
    }
}

public struct DescribePhoneNumbersOutput: Swift.Sendable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// An array of PhoneNumberInformation objects that contain the details for the requested phone numbers.
    public var phoneNumbers: [PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation]?

    public init(
        nextToken: Swift.String? = nil,
        phoneNumbers: [PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum PoolFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deletionProtectionEnabled
        case messageType
        case optOutListName
        case selfManagedOptOutsEnabled
        case sharedRoutesEnabled
        case status
        case twoWayChannelArn
        case twoWayEnabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PoolFilterName] {
            return [
                .deletionProtectionEnabled,
                .messageType,
                .optOutListName,
                .selfManagedOptOutsEnabled,
                .sharedRoutesEnabled,
                .status,
                .twoWayChannelArn,
                .twoWayEnabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deletionProtectionEnabled: return "deletion-protection-enabled"
            case .messageType: return "message-type"
            case .optOutListName: return "opt-out-list-name"
            case .selfManagedOptOutsEnabled: return "self-managed-opt-outs-enabled"
            case .sharedRoutesEnabled: return "shared-routes-enabled"
            case .status: return "status"
            case .twoWayChannelArn: return "two-way-channel-arn"
            case .twoWayEnabled: return "two-way-enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The information for a pool that meets a specified criteria.
    public struct PoolFilter: Swift.Sendable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.PoolFilterName?
        /// An array values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.PoolFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

public struct DescribePoolsInput: Swift.Sendable {
    /// An array of PoolFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.PoolFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// Use SELF to filter the list of Pools to ones your account owns or use SHARED to filter on Pools shared with your account. The Owner and PoolIds parameters can't be used at the same time.
    public var owner: PinpointSMSVoiceV2ClientTypes.Owner?
    /// The unique identifier of pools to find. This is an array of strings that can be either the PoolId or PoolArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    public var poolIds: [Swift.String]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.PoolFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owner: PinpointSMSVoiceV2ClientTypes.Owner? = nil,
        poolIds: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
        self.poolIds = poolIds
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The information for a pool in an Amazon Web Services account.
    public struct PoolInformation: Swift.Sendable {
        /// The time when the pool was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var createdTimestamp: Foundation.Date?
        /// When set to true the pool can't be deleted.
        /// This member is required.
        public var deletionProtectionEnabled: Swift.Bool
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        /// This member is required.
        public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
        /// The name of the OptOutList associated with the pool.
        /// This member is required.
        public var optOutListName: Swift.String?
        /// The Amazon Resource Name (ARN) for the pool.
        /// This member is required.
        public var poolArn: Swift.String?
        /// The unique identifier for the pool.
        /// This member is required.
        public var poolId: Swift.String?
        /// When set to false, an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, AWS End User Messaging SMS and Voice automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests. For more information see [Self-managed opt-outs](https://docs.aws.amazon.com/pinpoint/latest/userguide/settings-sms-managing.html#settings-account-sms-self-managed-opt-out)
        /// This member is required.
        public var selfManagedOptOutsEnabled: Swift.Bool
        /// Allows you to enable shared routes on your pool. By default, this is set to False. If you set this value to True, your messages are sent using phone numbers or sender IDs (depending on the country) that are shared with other users. In some countries, such as the United States, senders aren't allowed to use shared routes and must use a dedicated phone number or short code.
        /// This member is required.
        public var sharedRoutesEnabled: Swift.Bool
        /// The current status of the pool.
        /// This member is required.
        public var status: PinpointSMSVoiceV2ClientTypes.PoolStatus?
        /// The Amazon Resource Name (ARN) of the two way channel.
        public var twoWayChannelArn: Swift.String?
        /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
        public var twoWayChannelRole: Swift.String?
        /// When set to true you can receive incoming text messages from your end recipients using the TwoWayChannelArn.
        /// This member is required.
        public var twoWayEnabled: Swift.Bool

        public init(
            createdTimestamp: Foundation.Date? = nil,
            deletionProtectionEnabled: Swift.Bool = false,
            messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
            optOutListName: Swift.String? = nil,
            poolArn: Swift.String? = nil,
            poolId: Swift.String? = nil,
            selfManagedOptOutsEnabled: Swift.Bool = false,
            sharedRoutesEnabled: Swift.Bool = false,
            status: PinpointSMSVoiceV2ClientTypes.PoolStatus? = nil,
            twoWayChannelArn: Swift.String? = nil,
            twoWayChannelRole: Swift.String? = nil,
            twoWayEnabled: Swift.Bool = false
        )
        {
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.messageType = messageType
            self.optOutListName = optOutListName
            self.poolArn = poolArn
            self.poolId = poolId
            self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
            self.sharedRoutesEnabled = sharedRoutesEnabled
            self.status = status
            self.twoWayChannelArn = twoWayChannelArn
            self.twoWayChannelRole = twoWayChannelRole
            self.twoWayEnabled = twoWayEnabled
        }
    }
}

public struct DescribePoolsOutput: Swift.Sendable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// An array of PoolInformation objects that contain the details for the requested pools.
    public var pools: [PinpointSMSVoiceV2ClientTypes.PoolInformation]?

    public init(
        nextToken: Swift.String? = nil,
        pools: [PinpointSMSVoiceV2ClientTypes.PoolInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.pools = pools
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum ProtectConfigurationFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountDefault
        case deletionProtectionEnabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtectConfigurationFilterName] {
            return [
                .accountDefault,
                .deletionProtectionEnabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountDefault: return "account-default"
            case .deletionProtectionEnabled: return "deletion-protection-enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The filter definition for filtering protect configurations that meet a specified criteria.
    public struct ProtectConfigurationFilter: Swift.Sendable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.ProtectConfigurationFilterName?
        /// An array of values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.ProtectConfigurationFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

public struct DescribeProtectConfigurationsInput: Swift.Sendable {
    /// An array of ProtectConfigurationFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.ProtectConfigurationFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// An array of protect configuration identifiers to search for.
    public var protectConfigurationIds: [Swift.String]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.ProtectConfigurationFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        protectConfigurationIds: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.protectConfigurationIds = protectConfigurationIds
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Provides information on the specified protect configuration.
    public struct ProtectConfigurationInformation: Swift.Sendable {
        /// This is true if the protect configuration is set as your account default protect configuration.
        /// This member is required.
        public var accountDefault: Swift.Bool
        /// The time when the protect configuration was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var createdTimestamp: Foundation.Date?
        /// The status of deletion protection for the protect configuration. When set to true deletion protection is enabled. By default this is set to false.
        /// This member is required.
        public var deletionProtectionEnabled: Swift.Bool
        /// The Amazon Resource Name (ARN) of the protect configuration.
        /// This member is required.
        public var protectConfigurationArn: Swift.String?
        /// The unique identifier for the protect configuration.
        /// This member is required.
        public var protectConfigurationId: Swift.String?

        public init(
            accountDefault: Swift.Bool = false,
            createdTimestamp: Foundation.Date? = nil,
            deletionProtectionEnabled: Swift.Bool = false,
            protectConfigurationArn: Swift.String? = nil,
            protectConfigurationId: Swift.String? = nil
        )
        {
            self.accountDefault = accountDefault
            self.createdTimestamp = createdTimestamp
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.protectConfigurationArn = protectConfigurationArn
            self.protectConfigurationId = protectConfigurationId
        }
    }
}

public struct DescribeProtectConfigurationsOutput: Swift.Sendable {
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// An array of ProtectConfigurationInformation objects that contain the details for the request.
    public var protectConfigurations: [PinpointSMSVoiceV2ClientTypes.ProtectConfigurationInformation]?

    public init(
        nextToken: Swift.String? = nil,
        protectConfigurations: [PinpointSMSVoiceV2ClientTypes.ProtectConfigurationInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.protectConfigurations = protectConfigurations
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum RegistrationAttachmentFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case attachmentStatus
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationAttachmentFilterName] {
            return [
                .attachmentStatus
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .attachmentStatus: return "attachment-status"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The filter definition for filtering registration attachments that meets a specified criteria.
    public struct RegistrationAttachmentFilter: Swift.Sendable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentFilterName?
        /// An array of values to filter on.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

public struct DescribeRegistrationAttachmentsInput: Swift.Sendable {
    /// An array of RegistrationAttachmentFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The unique identifier of registration attachments to find. This is an array of RegistrationAttachmentId.
    public var registrationAttachmentIds: [Swift.String]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registrationAttachmentIds: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registrationAttachmentIds = registrationAttachmentIds
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Provides information on the specified registration attachments.
    public struct RegistrationAttachmentsInformation: Swift.Sendable {
        /// The status of the registration attachment.
        ///
        /// * UPLOAD_IN_PROGRESS The attachment is being uploaded.
        ///
        /// * UPLOAD_COMPLETE The attachment has been uploaded.
        ///
        /// * UPLOAD_FAILED The attachment failed to uploaded.
        ///
        /// * DELETED The attachment has been deleted..
        /// This member is required.
        public var attachmentStatus: PinpointSMSVoiceV2ClientTypes.AttachmentStatus?
        /// A description of why the upload didn't successfully complete.
        public var attachmentUploadErrorReason: PinpointSMSVoiceV2ClientTypes.AttachmentUploadErrorReason?
        /// The time when the registration attachment was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var createdTimestamp: Foundation.Date?
        /// The Amazon Resource Name (ARN) for the registration attachment.
        /// This member is required.
        public var registrationAttachmentArn: Swift.String?
        /// The unique identifier for the registration attachment.
        /// This member is required.
        public var registrationAttachmentId: Swift.String?

        public init(
            attachmentStatus: PinpointSMSVoiceV2ClientTypes.AttachmentStatus? = nil,
            attachmentUploadErrorReason: PinpointSMSVoiceV2ClientTypes.AttachmentUploadErrorReason? = nil,
            createdTimestamp: Foundation.Date? = nil,
            registrationAttachmentArn: Swift.String? = nil,
            registrationAttachmentId: Swift.String? = nil
        )
        {
            self.attachmentStatus = attachmentStatus
            self.attachmentUploadErrorReason = attachmentUploadErrorReason
            self.createdTimestamp = createdTimestamp
            self.registrationAttachmentArn = registrationAttachmentArn
            self.registrationAttachmentId = registrationAttachmentId
        }
    }
}

public struct DescribeRegistrationAttachmentsOutput: Swift.Sendable {
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// An array of RegistrationAttachments objects that contain the details for the requested registration attachments.
    /// This member is required.
    public var registrationAttachments: [PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentsInformation]?

    public init(
        nextToken: Swift.String? = nil,
        registrationAttachments: [PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentsInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.registrationAttachments = registrationAttachments
    }
}

public struct DescribeRegistrationFieldDefinitionsInput: Swift.Sendable {
    /// An array of paths to the registration form field.
    public var fieldPaths: [Swift.String]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationType: Swift.String?
    /// The path to the section of the registration.
    public var sectionPath: Swift.String?

    public init(
        fieldPaths: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registrationType: Swift.String? = nil,
        sectionPath: Swift.String? = nil
    )
    {
        self.fieldPaths = fieldPaths
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registrationType = registrationType
        self.sectionPath = sectionPath
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// A description of each select option.
    public struct SelectOptionDescription: Swift.Sendable {
        /// A description of the option meaning.
        public var description: Swift.String?
        /// The value of the option.
        /// This member is required.
        public var option: Swift.String?
        /// The title of the select option.
        public var title: Swift.String?

        public init(
            description: Swift.String? = nil,
            option: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.description = description
            self.option = option
            self.title = title
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Provides help information on the registration field.
    public struct RegistrationFieldDisplayHints: Swift.Sendable {
        /// The link to the document the display hint is associated with.
        public var documentationLink: Swift.String?
        /// The title of the document the display hint is associated with.
        public var documentationTitle: Swift.String?
        /// Example text of what the value of a field should contain.
        public var exampleTextValue: Swift.String?
        /// A full description of the display hint.
        public var longDescription: Swift.String?
        /// An array of SelectOptionDescription objects.
        public var selectOptionDescriptions: [PinpointSMSVoiceV2ClientTypes.SelectOptionDescription]?
        /// A short description of the display hint.
        /// This member is required.
        public var shortDescription: Swift.String?
        /// The validation rules for the text field.
        public var textValidationDescription: Swift.String?
        /// The title of the display hint.
        /// This member is required.
        public var title: Swift.String?

        public init(
            documentationLink: Swift.String? = nil,
            documentationTitle: Swift.String? = nil,
            exampleTextValue: Swift.String? = nil,
            longDescription: Swift.String? = nil,
            selectOptionDescriptions: [PinpointSMSVoiceV2ClientTypes.SelectOptionDescription]? = nil,
            shortDescription: Swift.String? = nil,
            textValidationDescription: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.documentationLink = documentationLink
            self.documentationTitle = documentationTitle
            self.exampleTextValue = exampleTextValue
            self.longDescription = longDescription
            self.selectOptionDescriptions = selectOptionDescriptions
            self.shortDescription = shortDescription
            self.textValidationDescription = textValidationDescription
            self.title = title
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum FieldRequirement: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case conditional
        case `optional`
        case `required`
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldRequirement] {
            return [
                .conditional,
                .optional,
                .required
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .conditional: return "CONDITIONAL"
            case .optional: return "OPTIONAL"
            case .required: return "REQUIRED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum FieldType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case attachment
        case select
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldType] {
            return [
                .attachment,
                .select,
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .attachment: return "ATTACHMENT"
            case .select: return "SELECT"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Validation rules for a select field.
    public struct SelectValidation: Swift.Sendable {
        /// The maximum number of choices for the select.
        /// This member is required.
        public var maxChoices: Swift.Int?
        /// The minimum number of choices for the select.
        /// This member is required.
        public var minChoices: Swift.Int?
        /// An array of strings for the possible selection options.
        /// This member is required.
        public var options: [Swift.String]?

        public init(
            maxChoices: Swift.Int? = nil,
            minChoices: Swift.Int? = nil,
            options: [Swift.String]? = nil
        )
        {
            self.maxChoices = maxChoices
            self.minChoices = minChoices
            self.options = options
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Validation rules for a text field.
    public struct TextValidation: Swift.Sendable {
        /// The maximum number of characters for the text field.
        /// This member is required.
        public var maxLength: Swift.Int?
        /// The minimum number of characters for the text field.
        /// This member is required.
        public var minLength: Swift.Int?
        /// The regular expression used to validate the text field.
        /// This member is required.
        public var pattern: Swift.String?

        public init(
            maxLength: Swift.Int? = nil,
            minLength: Swift.Int? = nil,
            pattern: Swift.String? = nil
        )
        {
            self.maxLength = maxLength
            self.minLength = minLength
            self.pattern = pattern
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Provides a description of the specified field.
    public struct RegistrationFieldDefinition: Swift.Sendable {
        /// An array of RegistrationFieldDisplayHints objects for the field.
        /// This member is required.
        public var displayHints: PinpointSMSVoiceV2ClientTypes.RegistrationFieldDisplayHints?
        /// The path to the registration form field. You can use [DescribeRegistrationFieldDefinitions] for a list of FieldPaths.
        /// This member is required.
        public var fieldPath: Swift.String?
        /// Specifies if the field for the registration form is required, conditional or optional.
        /// This member is required.
        public var fieldRequirement: PinpointSMSVoiceV2ClientTypes.FieldRequirement?
        /// The type of field.
        /// This member is required.
        public var fieldType: PinpointSMSVoiceV2ClientTypes.FieldType?
        /// The section path of the field.
        /// This member is required.
        public var sectionPath: Swift.String?
        /// The validation rules for a select field.
        public var selectValidation: PinpointSMSVoiceV2ClientTypes.SelectValidation?
        /// The validation rules for a text field.
        public var textValidation: PinpointSMSVoiceV2ClientTypes.TextValidation?

        public init(
            displayHints: PinpointSMSVoiceV2ClientTypes.RegistrationFieldDisplayHints? = nil,
            fieldPath: Swift.String? = nil,
            fieldRequirement: PinpointSMSVoiceV2ClientTypes.FieldRequirement? = nil,
            fieldType: PinpointSMSVoiceV2ClientTypes.FieldType? = nil,
            sectionPath: Swift.String? = nil,
            selectValidation: PinpointSMSVoiceV2ClientTypes.SelectValidation? = nil,
            textValidation: PinpointSMSVoiceV2ClientTypes.TextValidation? = nil
        )
        {
            self.displayHints = displayHints
            self.fieldPath = fieldPath
            self.fieldRequirement = fieldRequirement
            self.fieldType = fieldType
            self.sectionPath = sectionPath
            self.selectValidation = selectValidation
            self.textValidation = textValidation
        }
    }
}

public struct DescribeRegistrationFieldDefinitionsOutput: Swift.Sendable {
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// An array of RegistrationFieldDefinitions objects that contain the details for the requested fields.
    /// This member is required.
    public var registrationFieldDefinitions: [PinpointSMSVoiceV2ClientTypes.RegistrationFieldDefinition]?
    /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationType: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        registrationFieldDefinitions: [PinpointSMSVoiceV2ClientTypes.RegistrationFieldDefinition]? = nil,
        registrationType: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.registrationFieldDefinitions = registrationFieldDefinitions
        self.registrationType = registrationType
    }
}

public struct DescribeRegistrationFieldValuesInput: Swift.Sendable {
    /// An array of paths to the registration form field.
    public var fieldPaths: [Swift.String]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The path to the section of the registration.
    public var sectionPath: Swift.String?
    /// The version number of the registration.
    public var versionNumber: Swift.Int?

    public init(
        fieldPaths: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        sectionPath: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.fieldPaths = fieldPaths
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registrationId = registrationId
        self.sectionPath = sectionPath
        self.versionNumber = versionNumber
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Provides the values of the specified field.
    public struct RegistrationFieldValueInformation: Swift.Sendable {
        /// A description of why the registration was denied.
        public var deniedReason: Swift.String?
        /// The path to the registration form field. You can use [DescribeRegistrationFieldDefinitions] for a list of FieldPaths.
        /// This member is required.
        public var fieldPath: Swift.String?
        /// The unique identifier for the registration attachment.
        public var registrationAttachmentId: Swift.String?
        /// An array of values for the form field.
        public var selectChoices: [Swift.String]?
        /// The text data for a free form field.
        public var textValue: Swift.String?

        public init(
            deniedReason: Swift.String? = nil,
            fieldPath: Swift.String? = nil,
            registrationAttachmentId: Swift.String? = nil,
            selectChoices: [Swift.String]? = nil,
            textValue: Swift.String? = nil
        )
        {
            self.deniedReason = deniedReason
            self.fieldPath = fieldPath
            self.registrationAttachmentId = registrationAttachmentId
            self.selectChoices = selectChoices
            self.textValue = textValue
        }
    }
}

public struct DescribeRegistrationFieldValuesOutput: Swift.Sendable {
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// An array of RegistrationFieldValues objects that contain the values for the requested registration.
    /// This member is required.
    public var registrationFieldValues: [PinpointSMSVoiceV2ClientTypes.RegistrationFieldValueInformation]?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The current version of the registration.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        nextToken: Swift.String? = nil,
        registrationArn: Swift.String? = nil,
        registrationFieldValues: [PinpointSMSVoiceV2ClientTypes.RegistrationFieldValueInformation]? = nil,
        registrationId: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.registrationArn = registrationArn
        self.registrationFieldValues = registrationFieldValues
        self.registrationId = registrationId
        self.versionNumber = versionNumber
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum RegistrationFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case registrationStatus
        case registrationType
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationFilterName] {
            return [
                .registrationStatus,
                .registrationType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .registrationStatus: return "registration-status"
            case .registrationType: return "registration-type"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The filter definition for filtering registrations that meets a specified criteria.
    public struct RegistrationFilter: Swift.Sendable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.RegistrationFilterName?
        /// An array of values to filter on.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.RegistrationFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

public struct DescribeRegistrationsInput: Swift.Sendable {
    /// An array of RegistrationFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.RegistrationFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// An array of unique identifiers for each registration.
    public var registrationIds: [Swift.String]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.RegistrationFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registrationIds: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registrationIds = registrationIds
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Provides information about the requested registration.
    public struct RegistrationInformation: Swift.Sendable {
        /// Metadata about a given registration which is specific to that registration type.
        public var additionalAttributes: [Swift.String: Swift.String]?
        /// The version number of the registration that was approved.
        public var approvedVersionNumber: Swift.Int?
        /// The time when the registration was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var createdTimestamp: Foundation.Date?
        /// The current version number of the registration.
        /// This member is required.
        public var currentVersionNumber: Swift.Int?
        /// The latest version number of the registration that was denied.
        public var latestDeniedVersionNumber: Swift.Int?
        /// The Amazon Resource Name (ARN) for the registration.
        /// This member is required.
        public var registrationArn: Swift.String?
        /// The unique identifier for the registration.
        /// This member is required.
        public var registrationId: Swift.String?
        /// The status of the registration.
        ///
        /// * CLOSED: The phone number or sender ID has been deleted and you must also delete the registration for the number.
        ///
        /// * CREATED: Your registration is created but not submitted.
        ///
        /// * COMPLETE: Your registration has been approved and your origination identity has been created.
        ///
        /// * DELETED: The registration has been deleted.
        ///
        /// * PROVISIONING: Your registration has been approved and your origination identity is being created.
        ///
        /// * REQUIRES_AUTHENTICATION: You need to complete email authentication.
        ///
        /// * REQUIRES_UPDATES: You must fix your registration and resubmit it.
        ///
        /// * REVIEWING: Your registration has been accepted and is being reviewed.
        ///
        /// * SUBMITTED: Your registration has been submitted and is awaiting review.
        /// This member is required.
        public var registrationStatus: PinpointSMSVoiceV2ClientTypes.RegistrationStatus?
        /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
        /// This member is required.
        public var registrationType: Swift.String?

        public init(
            additionalAttributes: [Swift.String: Swift.String]? = nil,
            approvedVersionNumber: Swift.Int? = nil,
            createdTimestamp: Foundation.Date? = nil,
            currentVersionNumber: Swift.Int? = nil,
            latestDeniedVersionNumber: Swift.Int? = nil,
            registrationArn: Swift.String? = nil,
            registrationId: Swift.String? = nil,
            registrationStatus: PinpointSMSVoiceV2ClientTypes.RegistrationStatus? = nil,
            registrationType: Swift.String? = nil
        )
        {
            self.additionalAttributes = additionalAttributes
            self.approvedVersionNumber = approvedVersionNumber
            self.createdTimestamp = createdTimestamp
            self.currentVersionNumber = currentVersionNumber
            self.latestDeniedVersionNumber = latestDeniedVersionNumber
            self.registrationArn = registrationArn
            self.registrationId = registrationId
            self.registrationStatus = registrationStatus
            self.registrationType = registrationType
        }
    }
}

public struct DescribeRegistrationsOutput: Swift.Sendable {
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// An array of RegistrationInformation objects.
    /// This member is required.
    public var registrations: [PinpointSMSVoiceV2ClientTypes.RegistrationInformation]?

    public init(
        nextToken: Swift.String? = nil,
        registrations: [PinpointSMSVoiceV2ClientTypes.RegistrationInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.registrations = registrations
    }
}

public struct DescribeRegistrationSectionDefinitionsInput: Swift.Sendable {
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationType: Swift.String?
    /// An array of paths for the registration form section.
    public var sectionPaths: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registrationType: Swift.String? = nil,
        sectionPaths: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registrationType = registrationType
        self.sectionPaths = sectionPaths
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Provides help information on the registration section.
    public struct RegistrationSectionDisplayHints: Swift.Sendable {
        /// The link to the document the display hint is associated with.
        public var documentationLink: Swift.String?
        /// The title of the document the display hint is associated with.
        public var documentationTitle: Swift.String?
        /// A full description of the display hint.
        public var longDescription: Swift.String?
        /// A short description of the display hint.
        /// This member is required.
        public var shortDescription: Swift.String?
        /// The title of the display hint.
        /// This member is required.
        public var title: Swift.String?

        public init(
            documentationLink: Swift.String? = nil,
            documentationTitle: Swift.String? = nil,
            longDescription: Swift.String? = nil,
            shortDescription: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.documentationLink = documentationLink
            self.documentationTitle = documentationTitle
            self.longDescription = longDescription
            self.shortDescription = shortDescription
            self.title = title
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Provides information on the specified section definition.
    public struct RegistrationSectionDefinition: Swift.Sendable {
        /// The path to the section of the registration.
        /// This member is required.
        public var displayHints: PinpointSMSVoiceV2ClientTypes.RegistrationSectionDisplayHints?
        /// The path to the section of the registration.
        /// This member is required.
        public var sectionPath: Swift.String?

        public init(
            displayHints: PinpointSMSVoiceV2ClientTypes.RegistrationSectionDisplayHints? = nil,
            sectionPath: Swift.String? = nil
        )
        {
            self.displayHints = displayHints
            self.sectionPath = sectionPath
        }
    }
}

public struct DescribeRegistrationSectionDefinitionsOutput: Swift.Sendable {
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// An array of RegistrationSectionDefinition objects.
    /// This member is required.
    public var registrationSectionDefinitions: [PinpointSMSVoiceV2ClientTypes.RegistrationSectionDefinition]?
    /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationType: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        registrationSectionDefinitions: [PinpointSMSVoiceV2ClientTypes.RegistrationSectionDefinition]? = nil,
        registrationType: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.registrationSectionDefinitions = registrationSectionDefinitions
        self.registrationType = registrationType
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum RegistrationTypeFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case supportedAssociationIsoCountryCode
        case supportedAssociationResourceType
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationTypeFilterName] {
            return [
                .supportedAssociationIsoCountryCode,
                .supportedAssociationResourceType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .supportedAssociationIsoCountryCode: return "supported-association-iso-country-code"
            case .supportedAssociationResourceType: return "supported-association-resource-type"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The filter definition for filtering registration types that meets a specified criteria.
    public struct RegistrationTypeFilter: Swift.Sendable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.RegistrationTypeFilterName?
        /// An array of values to filter on.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.RegistrationTypeFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

public struct DescribeRegistrationTypeDefinitionsInput: Swift.Sendable {
    /// An array of RegistrationFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.RegistrationTypeFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    public var registrationTypes: [Swift.String]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.RegistrationTypeFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registrationTypes: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registrationTypes = registrationTypes
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Provides help information on the registration type.
    public struct RegistrationTypeDisplayHints: Swift.Sendable {
        /// The link to the document the display hint is associated with.
        public var documentationLink: Swift.String?
        /// The title of the document the display hint is associated with.
        public var documentationTitle: Swift.String?
        /// A full description of the display hint.
        public var longDescription: Swift.String?
        /// A short description of the display hint.
        public var shortDescription: Swift.String?
        /// The title of the display hint.
        /// This member is required.
        public var title: Swift.String?

        public init(
            documentationLink: Swift.String? = nil,
            documentationTitle: Swift.String? = nil,
            longDescription: Swift.String? = nil,
            shortDescription: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.documentationLink = documentationLink
            self.documentationTitle = documentationTitle
            self.longDescription = longDescription
            self.shortDescription = shortDescription
            self.title = title
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum RegistrationAssociationBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case associateAfterComplete
        case associateBeforeSubmit
        case associateOnApproval
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationAssociationBehavior] {
            return [
                .associateAfterComplete,
                .associateBeforeSubmit,
                .associateOnApproval
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .associateAfterComplete: return "ASSOCIATE_AFTER_COMPLETE"
            case .associateBeforeSubmit: return "ASSOCIATE_BEFORE_SUBMIT"
            case .associateOnApproval: return "ASSOCIATE_ON_APPROVAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum RegistrationDisassociationBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleteRegistrationDisassociates
        case disassociateAllAllowsDeleteRegistration
        case disassociateAllClosesRegistration
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationDisassociationBehavior] {
            return [
                .deleteRegistrationDisassociates,
                .disassociateAllAllowsDeleteRegistration,
                .disassociateAllClosesRegistration
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleteRegistrationDisassociates: return "DELETE_REGISTRATION_DISASSOCIATES"
            case .disassociateAllAllowsDeleteRegistration: return "DISASSOCIATE_ALL_ALLOWS_DELETE_REGISTRATION"
            case .disassociateAllClosesRegistration: return "DISASSOCIATE_ALL_CLOSES_REGISTRATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The processing rules for when a registration can be associated with an origination identity and disassociated from an origination identity.
    public struct SupportedAssociation: Swift.Sendable {
        /// The association behavior.
        ///
        /// * ASSOCIATE_BEFORE_SUBMIT The origination identity has to be supplied when creating a registration.
        ///
        /// * ASSOCIATE_ON_APPROVAL This applies to all short code registrations. The short code will be automatically provisioned once the registration is approved.
        ///
        /// * ASSOCIATE_AFTER_COMPLETE This applies to phone number registrations when you must complete a registration first, then associate one or more phone numbers later. For example 10DLC campaigns and long codes.
        /// This member is required.
        public var associationBehavior: PinpointSMSVoiceV2ClientTypes.RegistrationAssociationBehavior?
        /// The disassociation behavior.
        ///
        /// * DISASSOCIATE_ALL_CLOSES_REGISTRATION All origination identities must be disassociated from the registration before the registration can be closed.
        ///
        /// * DISASSOCIATE_ALL_ALLOWS_DELETE_REGISTRATION All origination identities must be disassociated from the registration before the registration can be deleted.
        ///
        /// * DELETE_REGISTRATION_DISASSOCIATES The registration can be deleted and all origination identities will be disasscoiated.
        /// This member is required.
        public var disassociationBehavior: PinpointSMSVoiceV2ClientTypes.RegistrationDisassociationBehavior?
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public var isoCountryCode: Swift.String?
        /// Defines the behavior of when an origination identity and registration can be associated with each other.
        /// This member is required.
        public var resourceType: Swift.String?

        public init(
            associationBehavior: PinpointSMSVoiceV2ClientTypes.RegistrationAssociationBehavior? = nil,
            disassociationBehavior: PinpointSMSVoiceV2ClientTypes.RegistrationDisassociationBehavior? = nil,
            isoCountryCode: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.associationBehavior = associationBehavior
            self.disassociationBehavior = disassociationBehavior
            self.isoCountryCode = isoCountryCode
            self.resourceType = resourceType
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Provides information on the supported registration type.
    public struct RegistrationTypeDefinition: Swift.Sendable {
        /// Provides help information on the registration.
        /// This member is required.
        public var displayHints: PinpointSMSVoiceV2ClientTypes.RegistrationTypeDisplayHints?
        /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
        /// This member is required.
        public var registrationType: Swift.String?
        /// The supported association behavior for the registration type.
        public var supportedAssociations: [PinpointSMSVoiceV2ClientTypes.SupportedAssociation]?

        public init(
            displayHints: PinpointSMSVoiceV2ClientTypes.RegistrationTypeDisplayHints? = nil,
            registrationType: Swift.String? = nil,
            supportedAssociations: [PinpointSMSVoiceV2ClientTypes.SupportedAssociation]? = nil
        )
        {
            self.displayHints = displayHints
            self.registrationType = registrationType
            self.supportedAssociations = supportedAssociations
        }
    }
}

public struct DescribeRegistrationTypeDefinitionsOutput: Swift.Sendable {
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationTypeDefinitions: [PinpointSMSVoiceV2ClientTypes.RegistrationTypeDefinition]?

    public init(
        nextToken: Swift.String? = nil,
        registrationTypeDefinitions: [PinpointSMSVoiceV2ClientTypes.RegistrationTypeDefinition]? = nil
    )
    {
        self.nextToken = nextToken
        self.registrationTypeDefinitions = registrationTypeDefinitions
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum RegistrationVersionFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case registrationVersionStatus
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationVersionFilterName] {
            return [
                .registrationVersionStatus
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .registrationVersionStatus: return "registration-version-status"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The filter definition for filtering registration versions that meets a specified criteria.
    public struct RegistrationVersionFilter: Swift.Sendable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.RegistrationVersionFilterName?
        /// An array of values to filter on.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.RegistrationVersionFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

public struct DescribeRegistrationVersionsInput: Swift.Sendable {
    /// An array of RegistrationVersionFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.RegistrationVersionFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// An array of registration version numbers.
    public var versionNumbers: [Swift.Int]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.RegistrationVersionFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        versionNumbers: [Swift.Int]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registrationId = registrationId
        self.versionNumbers = versionNumbers
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Provides the reason a registration was rejected.
    public struct RegistrationDeniedReasonInformation: Swift.Sendable {
        /// The link to the document.
        public var documentationLink: Swift.String?
        /// The title of the document.
        public var documentationTitle: Swift.String?
        /// A long description of the rejection reason.
        public var longDescription: Swift.String?
        /// The reason a registration was rejected.
        /// This member is required.
        public var reason: Swift.String?
        /// A short description of the rejection reason.
        /// This member is required.
        public var shortDescription: Swift.String?

        public init(
            documentationLink: Swift.String? = nil,
            documentationTitle: Swift.String? = nil,
            longDescription: Swift.String? = nil,
            reason: Swift.String? = nil,
            shortDescription: Swift.String? = nil
        )
        {
            self.documentationLink = documentationLink
            self.documentationTitle = documentationTitle
            self.longDescription = longDescription
            self.reason = reason
            self.shortDescription = shortDescription
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Provides information about the specified version of the registration.
    public struct RegistrationVersionInformation: Swift.Sendable {
        /// An array of RegistrationDeniedReasonInformation objects.
        public var deniedReasons: [PinpointSMSVoiceV2ClientTypes.RegistrationDeniedReasonInformation]?
        /// The status of the registration.
        ///
        /// * APPROVED: Your registration has been approved.
        ///
        /// * ARCHIVED: Your previously approved registration version moves into this status when a more recently submitted version is approved.
        ///
        /// * DENIED: You must fix your registration and resubmit it.
        ///
        /// * DISCARDED: You've abandon this version of their registration to start over with a new version.
        ///
        /// * DRAFT: The initial status of a registration version after its created.
        ///
        /// * REQUIRES_AUTHENTICATION: You need to complete email authentication.
        ///
        /// * REVIEWING: Your registration has been accepted and is being reviewed.
        ///
        /// * REVOKED: Your previously approved registration has been revoked.
        ///
        /// * SUBMITTED: Your registration has been submitted.
        /// This member is required.
        public var registrationVersionStatus: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus?
        /// The RegistrationVersionStatusHistory object contains the time stamps for when the reservations status changes.
        /// This member is required.
        public var registrationVersionStatusHistory: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory?
        /// The version number of the registration.
        /// This member is required.
        public var versionNumber: Swift.Int?

        public init(
            deniedReasons: [PinpointSMSVoiceV2ClientTypes.RegistrationDeniedReasonInformation]? = nil,
            registrationVersionStatus: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus? = nil,
            registrationVersionStatusHistory: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory? = nil,
            versionNumber: Swift.Int? = nil
        )
        {
            self.deniedReasons = deniedReasons
            self.registrationVersionStatus = registrationVersionStatus
            self.registrationVersionStatusHistory = registrationVersionStatusHistory
            self.versionNumber = versionNumber
        }
    }
}

public struct DescribeRegistrationVersionsOutput: Swift.Sendable {
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// An array of RegistrationVersions objects.
    /// This member is required.
    public var registrationVersions: [PinpointSMSVoiceV2ClientTypes.RegistrationVersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        registrationArn: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        registrationVersions: [PinpointSMSVoiceV2ClientTypes.RegistrationVersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.registrationArn = registrationArn
        self.registrationId = registrationId
        self.registrationVersions = registrationVersions
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum SenderIdFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deletionProtectionEnabled
        case isoCountryCode
        case messageType
        case registered
        case senderId
        case sdkUnknown(Swift.String)

        public static var allCases: [SenderIdFilterName] {
            return [
                .deletionProtectionEnabled,
                .isoCountryCode,
                .messageType,
                .registered,
                .senderId
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deletionProtectionEnabled: return "deletion-protection-enabled"
            case .isoCountryCode: return "iso-country-code"
            case .messageType: return "message-type"
            case .registered: return "registered"
            case .senderId: return "sender-id"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The information for a sender ID that meets a specified criteria.
    public struct SenderIdFilter: Swift.Sendable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.SenderIdFilterName?
        /// An array of values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.SenderIdFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The alphanumeric sender ID in a specific country that you want to describe. For more information on sender IDs see [Requesting sender IDs ](https://docs.aws.amazon.com/sms-voice/latest/userguide/sender-id-request.html) in the AWS End User Messaging SMS User Guide.
    public struct SenderIdAndCountry: Swift.Sendable {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        /// This member is required.
        public var isoCountryCode: Swift.String?
        /// The unique identifier of the sender.
        /// This member is required.
        public var senderId: Swift.String?

        public init(
            isoCountryCode: Swift.String? = nil,
            senderId: Swift.String? = nil
        )
        {
            self.isoCountryCode = isoCountryCode
            self.senderId = senderId
        }
    }
}

public struct DescribeSenderIdsInput: Swift.Sendable {
    /// An array of SenderIdFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.SenderIdFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// Use SELF to filter the list of Sender Ids to ones your account owns or use SHARED to filter on Sender Ids shared with your account. The Owner and SenderIds parameters can't be used at the same time.
    public var owner: PinpointSMSVoiceV2ClientTypes.Owner?
    /// An array of SenderIdAndCountry objects to search for. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    public var senderIds: [PinpointSMSVoiceV2ClientTypes.SenderIdAndCountry]?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.SenderIdFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owner: PinpointSMSVoiceV2ClientTypes.Owner? = nil,
        senderIds: [PinpointSMSVoiceV2ClientTypes.SenderIdAndCountry]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
        self.senderIds = senderIds
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The information for all SenderIds in an Amazon Web Services account.
    public struct SenderIdInformation: Swift.Sendable {
        /// By default this is set to false. When set to true the sender ID can't be deleted.
        /// This member is required.
        public var deletionProtectionEnabled: Swift.Bool
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        /// This member is required.
        public var isoCountryCode: Swift.String?
        /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
        /// This member is required.
        public var messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]?
        /// The monthly leasing price, in US dollars.
        /// This member is required.
        public var monthlyLeasingPrice: Swift.String?
        /// True if the sender ID is registered.
        /// This member is required.
        public var registered: Swift.Bool
        /// The unique identifier for the registration.
        public var registrationId: Swift.String?
        /// The alphanumeric sender ID in a specific country that you'd like to describe.
        /// This member is required.
        public var senderId: Swift.String?
        /// The Amazon Resource Name (ARN) associated with the SenderId.
        /// This member is required.
        public var senderIdArn: Swift.String?

        public init(
            deletionProtectionEnabled: Swift.Bool = false,
            isoCountryCode: Swift.String? = nil,
            messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]? = nil,
            monthlyLeasingPrice: Swift.String? = nil,
            registered: Swift.Bool = false,
            registrationId: Swift.String? = nil,
            senderId: Swift.String? = nil,
            senderIdArn: Swift.String? = nil
        )
        {
            self.deletionProtectionEnabled = deletionProtectionEnabled
            self.isoCountryCode = isoCountryCode
            self.messageTypes = messageTypes
            self.monthlyLeasingPrice = monthlyLeasingPrice
            self.registered = registered
            self.registrationId = registrationId
            self.senderId = senderId
            self.senderIdArn = senderIdArn
        }
    }
}

public struct DescribeSenderIdsOutput: Swift.Sendable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// An array of SernderIdInformation objects that contain the details for the requested SenderIds.
    public var senderIds: [PinpointSMSVoiceV2ClientTypes.SenderIdInformation]?

    public init(
        nextToken: Swift.String? = nil,
        senderIds: [PinpointSMSVoiceV2ClientTypes.SenderIdInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.senderIds = senderIds
    }
}

public struct DescribeSpendLimitsInput: Swift.Sendable {
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum SpendLimitName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mediaMessageMonthlySpendLimit
        case textMessageMonthlySpendLimit
        case voiceMessageMonthlySpendLimit
        case sdkUnknown(Swift.String)

        public static var allCases: [SpendLimitName] {
            return [
                .mediaMessageMonthlySpendLimit,
                .textMessageMonthlySpendLimit,
                .voiceMessageMonthlySpendLimit
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mediaMessageMonthlySpendLimit: return "MEDIA_MESSAGE_MONTHLY_SPEND_LIMIT"
            case .textMessageMonthlySpendLimit: return "TEXT_MESSAGE_MONTHLY_SPEND_LIMIT"
            case .voiceMessageMonthlySpendLimit: return "VOICE_MESSAGE_MONTHLY_SPEND_LIMIT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Describes the current monthly spend limits for sending voice and text messages. For more information on increasing your monthly spend limit, see [ Requesting a spending quota increase ](https://docs.aws.amazon.com/sms-voice/latest/userguide/awssupport-spend-threshold.html) in the AWS End User Messaging SMS User Guide.
    public struct SpendLimit: Swift.Sendable {
        /// The maximum amount of money, in US dollars, that you want to be able to spend sending messages each month. This value has to be less than or equal to the amount in MaxLimit. To use this custom limit, Overridden must be set to true.
        /// This member is required.
        public var enforcedLimit: Swift.Int
        /// The maximum amount of money that you are able to spend to send messages each month, in US dollars.
        /// This member is required.
        public var maxLimit: Swift.Int
        /// The name for the SpendLimit.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.SpendLimitName?
        /// When set to True, the value that has been specified in the EnforcedLimit is used to determine the maximum amount in US dollars that can be spent to send messages each month, in US dollars.
        /// This member is required.
        public var overridden: Swift.Bool

        public init(
            enforcedLimit: Swift.Int = 0,
            maxLimit: Swift.Int = 0,
            name: PinpointSMSVoiceV2ClientTypes.SpendLimitName? = nil,
            overridden: Swift.Bool = false
        )
        {
            self.enforcedLimit = enforcedLimit
            self.maxLimit = maxLimit
            self.name = name
            self.overridden = overridden
        }
    }
}

public struct DescribeSpendLimitsOutput: Swift.Sendable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// An array of SpendLimit objects that contain the details for the requested spend limits.
    public var spendLimits: [PinpointSMSVoiceV2ClientTypes.SpendLimit]?

    public init(
        nextToken: Swift.String? = nil,
        spendLimits: [PinpointSMSVoiceV2ClientTypes.SpendLimit]? = nil
    )
    {
        self.nextToken = nextToken
        self.spendLimits = spendLimits
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum VerifiedDestinationNumberFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [VerifiedDestinationNumberFilterName] {
            return [
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .status: return "status"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The filter definition for filtering verified destination phone numbers that meets a specified criteria.
    public struct VerifiedDestinationNumberFilter: Swift.Sendable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberFilterName?
        /// An array of values to filter on.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

public struct DescribeVerifiedDestinationNumbersInput: Swift.Sendable {
    /// An array of verified destination phone number, in E.164 format.
    public var destinationPhoneNumbers: [Swift.String]?
    /// An array of VerifiedDestinationNumberFilter objects to filter the results.
    public var filters: [PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// An array of VerifiedDestinationNumberid to retreive.
    public var verifiedDestinationNumberIds: [Swift.String]?

    public init(
        destinationPhoneNumbers: [Swift.String]? = nil,
        filters: [PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        verifiedDestinationNumberIds: [Swift.String]? = nil
    )
    {
        self.destinationPhoneNumbers = destinationPhoneNumbers
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.verifiedDestinationNumberIds = verifiedDestinationNumberIds
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Provides information about the requested verified destintion phone number.
    public struct VerifiedDestinationNumberInformation: Swift.Sendable {
        /// The time when the destination phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
        /// This member is required.
        public var createdTimestamp: Foundation.Date?
        /// The verified destination phone number, in E.164 format.
        /// This member is required.
        public var destinationPhoneNumber: Swift.String?
        /// The status of the verified destination phone number.
        ///
        /// * PENDING: The phone number hasn't been verified yet.
        ///
        /// * VERIFIED: The phone number is verified and can receive messages.
        /// This member is required.
        public var status: PinpointSMSVoiceV2ClientTypes.VerificationStatus?
        /// The Amazon Resource Name (ARN) for the verified destination phone number.
        /// This member is required.
        public var verifiedDestinationNumberArn: Swift.String?
        /// The unique identifier for the verified destination phone number.
        /// This member is required.
        public var verifiedDestinationNumberId: Swift.String?

        public init(
            createdTimestamp: Foundation.Date? = nil,
            destinationPhoneNumber: Swift.String? = nil,
            status: PinpointSMSVoiceV2ClientTypes.VerificationStatus? = nil,
            verifiedDestinationNumberArn: Swift.String? = nil,
            verifiedDestinationNumberId: Swift.String? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.destinationPhoneNumber = destinationPhoneNumber
            self.status = status
            self.verifiedDestinationNumberArn = verifiedDestinationNumberArn
            self.verifiedDestinationNumberId = verifiedDestinationNumberId
        }
    }
}

public struct DescribeVerifiedDestinationNumbersOutput: Swift.Sendable {
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// An array of VerifiedDestinationNumberInformation objects
    /// This member is required.
    public var verifiedDestinationNumbers: [PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberInformation]?

    public init(
        nextToken: Swift.String? = nil,
        verifiedDestinationNumbers: [PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.verifiedDestinationNumbers = verifiedDestinationNumbers
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum DestinationCountryParameterKey: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case inEntityId
        case inTemplateId
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationCountryParameterKey] {
            return [
                .inEntityId,
                .inTemplateId
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .inEntityId: return "IN_ENTITY_ID"
            case .inTemplateId: return "IN_TEMPLATE_ID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DisassociateOriginationIdentityInput: Swift.Sendable {
    /// Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use [DescribePhoneNumbers] find the values for PhoneNumberId and PhoneNumberArn, or use [DescribeSenderIds] to get the values for SenderId and SenderIdArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    /// This member is required.
    public var originationIdentity: Swift.String?
    /// The unique identifier for the pool to disassociate with the origination identity. This value can be either the PoolId or PoolArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    /// This member is required.
    public var poolId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        isoCountryCode: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        poolId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.isoCountryCode = isoCountryCode
        self.originationIdentity = originationIdentity
        self.poolId = poolId
    }
}

public struct DisassociateOriginationIdentityOutput: Swift.Sendable {
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    public var isoCountryCode: Swift.String?
    /// The PhoneNumberId or SenderId of the origination identity.
    public var originationIdentity: Swift.String?
    /// The PhoneNumberArn or SenderIdArn of the origination identity.
    public var originationIdentityArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the pool.
    public var poolArn: Swift.String?
    /// The PoolId of the pool no longer associated with the origination identity.
    public var poolId: Swift.String?

    public init(
        isoCountryCode: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        originationIdentityArn: Swift.String? = nil,
        poolArn: Swift.String? = nil,
        poolId: Swift.String? = nil
    )
    {
        self.isoCountryCode = isoCountryCode
        self.originationIdentity = originationIdentity
        self.originationIdentityArn = originationIdentityArn
        self.poolArn = poolArn
        self.poolId = poolId
    }
}

public struct DisassociateProtectConfigurationInput: Swift.Sendable {
    /// The name of the ConfigurationSet.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// The unique identifier for the protect configuration.
    /// This member is required.
    public var protectConfigurationId: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil,
        protectConfigurationId: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.protectConfigurationId = protectConfigurationId
    }
}

public struct DisassociateProtectConfigurationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the configuration set.
    /// This member is required.
    public var configurationSetArn: Swift.String?
    /// The name of the ConfigurationSet.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// The Amazon Resource Name (ARN) of the protect configuration.
    /// This member is required.
    public var protectConfigurationArn: Swift.String?
    /// The unique identifier for the protect configuration.
    /// This member is required.
    public var protectConfigurationId: Swift.String?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        protectConfigurationArn: Swift.String? = nil,
        protectConfigurationId: Swift.String? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.protectConfigurationArn = protectConfigurationArn
        self.protectConfigurationId = protectConfigurationId
    }
}

public struct DiscardRegistrationVersionInput: Swift.Sendable {
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?

    public init(
        registrationId: Swift.String? = nil
    )
    {
        self.registrationId = registrationId
    }
}

public struct DiscardRegistrationVersionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The status of the registration version.
    ///
    /// * APPROVED: Your registration has been approved.
    ///
    /// * ARCHIVED: Your previously approved registration version moves into this status when a more recently submitted version is approved.
    ///
    /// * DENIED: You must fix your registration and resubmit it.
    ///
    /// * DISCARDED: You've abandon this version of their registration to start over with a new version.
    ///
    /// * DRAFT: The initial status of a registration version after its created.
    ///
    /// * REQUIRES_AUTHENTICATION: You need to complete email authentication.
    ///
    /// * REVIEWING: Your registration has been accepted and is being reviewed.
    ///
    /// * REVOKED: Your previously approved registration has been revoked.
    ///
    /// * SUBMITTED: Your registration has been submitted.
    /// This member is required.
    public var registrationVersionStatus: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus?
    /// The RegistrationVersionStatusHistory object contains the time stamps for when the reservations status changes.
    /// This member is required.
    public var registrationVersionStatusHistory: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory?
    /// The version number of the registration.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        registrationArn: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        registrationVersionStatus: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus? = nil,
        registrationVersionStatusHistory: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.registrationArn = registrationArn
        self.registrationId = registrationId
        self.registrationVersionStatus = registrationVersionStatus
        self.registrationVersionStatusHistory = registrationVersionStatusHistory
        self.versionNumber = versionNumber
    }
}

public struct GetProtectConfigurationCountryRuleSetInput: Swift.Sendable {
    /// The capability type to return the CountryRuleSet for. Valid values are SMS, VOICE, or MMS.
    /// This member is required.
    public var numberCapability: PinpointSMSVoiceV2ClientTypes.NumberCapability?
    /// The unique identifier for the protect configuration.
    /// This member is required.
    public var protectConfigurationId: Swift.String?

    public init(
        numberCapability: PinpointSMSVoiceV2ClientTypes.NumberCapability? = nil,
        protectConfigurationId: Swift.String? = nil
    )
    {
        self.numberCapability = numberCapability
        self.protectConfigurationId = protectConfigurationId
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum ProtectStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allow
        case block
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtectStatus] {
            return [
                .allow,
                .block
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .block: return "BLOCK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The types of statuses that can be used.
    public struct ProtectConfigurationCountryRuleSetInformation: Swift.Sendable {
        /// The types of protection that can be used.
        /// This member is required.
        public var protectStatus: PinpointSMSVoiceV2ClientTypes.ProtectStatus?

        public init(
            protectStatus: PinpointSMSVoiceV2ClientTypes.ProtectStatus? = nil
        )
        {
            self.protectStatus = protectStatus
        }
    }
}

public struct GetProtectConfigurationCountryRuleSetOutput: Swift.Sendable {
    /// A map of ProtectConfigurationCountryRuleSetInformation objects that contain the details for the requested NumberCapability. The Key is the two-letter ISO country code. For a list of supported ISO country codes, see [Supported countries and regions (SMS channel)](https://docs.aws.amazon.com/sms-voice/latest/userguide/phone-numbers-sms-by-country.html) in the AWS End User Messaging SMS User Guide.
    /// This member is required.
    public var countryRuleSet: [Swift.String: PinpointSMSVoiceV2ClientTypes.ProtectConfigurationCountryRuleSetInformation]?
    /// The capability type associated with the returned ProtectConfigurationCountryRuleSetInformation objects.
    /// This member is required.
    public var numberCapability: PinpointSMSVoiceV2ClientTypes.NumberCapability?
    /// The Amazon Resource Name (ARN) of the protect configuration.
    /// This member is required.
    public var protectConfigurationArn: Swift.String?
    /// The unique identifier for the protect configuration.
    /// This member is required.
    public var protectConfigurationId: Swift.String?

    public init(
        countryRuleSet: [Swift.String: PinpointSMSVoiceV2ClientTypes.ProtectConfigurationCountryRuleSetInformation]? = nil,
        numberCapability: PinpointSMSVoiceV2ClientTypes.NumberCapability? = nil,
        protectConfigurationArn: Swift.String? = nil,
        protectConfigurationId: Swift.String? = nil
    )
    {
        self.countryRuleSet = countryRuleSet
        self.numberCapability = numberCapability
        self.protectConfigurationArn = protectConfigurationArn
        self.protectConfigurationId = protectConfigurationId
    }
}

public struct GetResourcePolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the AWS End User Messaging SMS and Voice resource attached to the resource-based policy.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct GetResourcePolicyOutput: Swift.Sendable {
    /// The time when the resource-based policy was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: Foundation.Date?
    /// The JSON formatted string that contains the resource-based policy attached to the AWS End User Messaging SMS and Voice resource.
    public var policy: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS End User Messaging SMS and Voice resource attached to the resource-based policy.
    public var resourceArn: Swift.String?

    public init(
        createdTimestamp: Foundation.Date? = nil,
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum LanguageCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deDe
        case enGb
        case enUs
        case es419
        case esEs
        case frCa
        case frFr
        case itIt
        case jaJp
        case koKr
        case ptBr
        case zhCn
        case zhTw
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCode] {
            return [
                .deDe,
                .enGb,
                .enUs,
                .es419,
                .esEs,
                .frCa,
                .frFr,
                .itIt,
                .jaJp,
                .koKr,
                .ptBr,
                .zhCn,
                .zhTw
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "DE_DE"
            case .enGb: return "EN_GB"
            case .enUs: return "EN_US"
            case .es419: return "ES_419"
            case .esEs: return "ES_ES"
            case .frCa: return "FR_CA"
            case .frFr: return "FR_FR"
            case .itIt: return "IT_IT"
            case .jaJp: return "JA_JP"
            case .koKr: return "KO_KR"
            case .ptBr: return "PT_BR"
            case .zhCn: return "ZH_CN"
            case .zhTw: return "ZH_TW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum PoolOriginationIdentitiesFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case isoCountryCode
        case numberCapability
        case sdkUnknown(Swift.String)

        public static var allCases: [PoolOriginationIdentitiesFilterName] {
            return [
                .isoCountryCode,
                .numberCapability
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .isoCountryCode: return "iso-country-code"
            case .numberCapability: return "number-capability"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Information about origination identities associated with a pool that meets a specified criteria.
    public struct PoolOriginationIdentitiesFilter: Swift.Sendable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilterName?
        /// An array values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

public struct ListPoolOriginationIdentitiesInput: Swift.Sendable {
    /// An array of PoolOriginationIdentitiesFilter objects to filter the results..
    public var filters: [PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The unique identifier for the pool. This value can be either the PoolId or PoolArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    /// This member is required.
    public var poolId: Swift.String?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        poolId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.poolId = poolId
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The metadata for an origination identity associated with a pool.
    public struct OriginationIdentityMetadata: Swift.Sendable {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        /// This member is required.
        public var isoCountryCode: Swift.String?
        /// Describes if the origination identity can be used for text messages, voice calls or both.
        /// This member is required.
        public var numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
        /// The unique identifier of the origination identity.
        /// This member is required.
        public var originationIdentity: Swift.String?
        /// The Amazon Resource Name (ARN) associated with the origination identity.
        /// This member is required.
        public var originationIdentityArn: Swift.String?
        /// The phone number in E.164 format.
        public var phoneNumber: Swift.String?

        public init(
            isoCountryCode: Swift.String? = nil,
            numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil,
            originationIdentity: Swift.String? = nil,
            originationIdentityArn: Swift.String? = nil,
            phoneNumber: Swift.String? = nil
        )
        {
            self.isoCountryCode = isoCountryCode
            self.numberCapabilities = numberCapabilities
            self.originationIdentity = originationIdentity
            self.originationIdentityArn = originationIdentityArn
            self.phoneNumber = phoneNumber
        }
    }
}

public struct ListPoolOriginationIdentitiesOutput: Swift.Sendable {
    /// The token to be used for the next set of paginated results. If this field is empty then there are no more results.
    public var nextToken: Swift.String?
    /// An array of any OriginationIdentityMetadata objects.
    public var originationIdentities: [PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata]?
    /// The Amazon Resource Name (ARN) for the pool.
    public var poolArn: Swift.String?
    /// The unique PoolId of the pool.
    public var poolId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        originationIdentities: [PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata]? = nil,
        poolArn: Swift.String? = nil,
        poolId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.originationIdentities = originationIdentities
        self.poolArn = poolArn
        self.poolId = poolId
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum RegistrationAssociationFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case isoCountryCode
        case resourceType
        case sdkUnknown(Swift.String)

        public static var allCases: [RegistrationAssociationFilterName] {
            return [
                .isoCountryCode,
                .resourceType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .isoCountryCode: return "iso-country-code"
            case .resourceType: return "resource-type"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// The filter definition for filtering registrations that meets a specified criteria.
    public struct RegistrationAssociationFilter: Swift.Sendable {
        /// The name of the attribute to filter on.
        /// This member is required.
        public var name: PinpointSMSVoiceV2ClientTypes.RegistrationAssociationFilterName?
        /// An array of values to filter for.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            name: PinpointSMSVoiceV2ClientTypes.RegistrationAssociationFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }
}

public struct ListRegistrationAssociationsInput: Swift.Sendable {
    /// An array of RegistrationAssociationFilter to apply to the results that are returned.
    public var filters: [PinpointSMSVoiceV2ClientTypes.RegistrationAssociationFilter]?
    /// The maximum number of results to return per each request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?

    public init(
        filters: [PinpointSMSVoiceV2ClientTypes.RegistrationAssociationFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registrationId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registrationId = registrationId
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    /// Metadata for the origination identity that is associated with the registration.
    public struct RegistrationAssociationMetadata: Swift.Sendable {
        /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
        public var isoCountryCode: Swift.String?
        /// The phone number associated with the registration in E.164 format.
        public var phoneNumber: Swift.String?
        /// The Amazon Resource Name (ARN) of the origination identity that is associated with the registration.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The unique identifier for the origination identity. For example this could be a PhoneNumberId or SenderId.
        /// This member is required.
        public var resourceId: Swift.String?
        /// The origination identity type.
        /// This member is required.
        public var resourceType: Swift.String?

        public init(
            isoCountryCode: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.isoCountryCode = isoCountryCode
            self.phoneNumber = phoneNumber
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }
}

public struct ListRegistrationAssociationsOutput: Swift.Sendable {
    /// The token to be used for the next set of paginated results. You don't need to supply a value for this field in the initial request.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// An array of RegistrationAssociationMetadata objects.
    /// This member is required.
    public var registrationAssociations: [PinpointSMSVoiceV2ClientTypes.RegistrationAssociationMetadata]?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The type of registration form. The list of RegistrationTypes can be found using the [DescribeRegistrationTypeDefinitions] action.
    /// This member is required.
    public var registrationType: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        registrationArn: Swift.String? = nil,
        registrationAssociations: [PinpointSMSVoiceV2ClientTypes.RegistrationAssociationMetadata]? = nil,
        registrationId: Swift.String? = nil,
        registrationType: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.registrationArn = registrationArn
        self.registrationAssociations = registrationAssociations
        self.registrationId = registrationId
        self.registrationType = registrationType
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to query for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The ARN of the resource.
    public var resourceArn: Swift.String?
    /// An array of key and value pair tags that are associated with the resource.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct PutKeywordInput: Swift.Sendable {
    /// The new keyword to add.
    /// This member is required.
    public var keyword: Swift.String?
    /// The action to perform for the new keyword when it is received.
    ///
    /// * AUTOMATIC_RESPONSE: A message is sent to the recipient.
    ///
    /// * OPT_OUT: Keeps the recipient from receiving future messages.
    ///
    /// * OPT_IN: The recipient wants to receive future messages.
    public var keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction?
    /// The message associated with the keyword.
    /// This member is required.
    public var keywordMessage: Swift.String?
    /// The origination identity to use such as a PhoneNumberId, PhoneNumberArn, SenderId or SenderIdArn. You can use [DescribePhoneNumbers] get the values for PhoneNumberId and PhoneNumberArn while [DescribeSenderIds] can be used to get the values for SenderId and SenderIdArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    /// This member is required.
    public var originationIdentity: Swift.String?

    public init(
        keyword: Swift.String? = nil,
        keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction? = nil,
        keywordMessage: Swift.String? = nil,
        originationIdentity: Swift.String? = nil
    )
    {
        self.keyword = keyword
        self.keywordAction = keywordAction
        self.keywordMessage = keywordMessage
        self.originationIdentity = originationIdentity
    }
}

public struct PutKeywordOutput: Swift.Sendable {
    /// The keyword that was added.
    public var keyword: Swift.String?
    /// The action to perform when the keyword is used.
    public var keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction?
    /// The message associated with the keyword.
    public var keywordMessage: Swift.String?
    /// The PhoneNumberId or PoolId that the keyword was associated with.
    public var originationIdentity: Swift.String?
    /// The PhoneNumberArn or PoolArn that the keyword was associated with.
    public var originationIdentityArn: Swift.String?

    public init(
        keyword: Swift.String? = nil,
        keywordAction: PinpointSMSVoiceV2ClientTypes.KeywordAction? = nil,
        keywordMessage: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        originationIdentityArn: Swift.String? = nil
    )
    {
        self.keyword = keyword
        self.keywordAction = keywordAction
        self.keywordMessage = keywordMessage
        self.originationIdentity = originationIdentity
        self.originationIdentityArn = originationIdentityArn
    }
}

public struct PutOptedOutNumberInput: Swift.Sendable {
    /// The OptOutListName or OptOutListArn to add the phone number to. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    /// This member is required.
    public var optOutListName: Swift.String?
    /// The phone number to add to the OptOutList in E.164 format.
    /// This member is required.
    public var optedOutNumber: Swift.String?

    public init(
        optOutListName: Swift.String? = nil,
        optedOutNumber: Swift.String? = nil
    )
    {
        self.optOutListName = optOutListName
        self.optedOutNumber = optedOutNumber
    }
}

public struct PutOptedOutNumberOutput: Swift.Sendable {
    /// This is true if it was the end user who requested their phone number be removed.
    public var endUserOptedOut: Swift.Bool
    /// The OptOutListArn that the phone number was removed from.
    public var optOutListArn: Swift.String?
    /// The OptOutListName that the phone number was removed from.
    public var optOutListName: Swift.String?
    /// The phone number that was added to the OptOutList.
    public var optedOutNumber: Swift.String?
    /// The time that the phone number was added to the OptOutList, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var optedOutTimestamp: Foundation.Date?

    public init(
        endUserOptedOut: Swift.Bool = false,
        optOutListArn: Swift.String? = nil,
        optOutListName: Swift.String? = nil,
        optedOutNumber: Swift.String? = nil,
        optedOutTimestamp: Foundation.Date? = nil
    )
    {
        self.endUserOptedOut = endUserOptedOut
        self.optOutListArn = optOutListArn
        self.optOutListName = optOutListName
        self.optedOutNumber = optedOutNumber
        self.optedOutTimestamp = optedOutTimestamp
    }
}

public struct PutRegistrationFieldValueInput: Swift.Sendable {
    /// The path to the registration form field. You can use [DescribeRegistrationFieldDefinitions] for a list of FieldPaths.
    /// This member is required.
    public var fieldPath: Swift.String?
    /// The unique identifier for the registration attachment.
    public var registrationAttachmentId: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// An array of values for the form field.
    public var selectChoices: [Swift.String]?
    /// The text data for a free form field.
    public var textValue: Swift.String?

    public init(
        fieldPath: Swift.String? = nil,
        registrationAttachmentId: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        selectChoices: [Swift.String]? = nil,
        textValue: Swift.String? = nil
    )
    {
        self.fieldPath = fieldPath
        self.registrationAttachmentId = registrationAttachmentId
        self.registrationId = registrationId
        self.selectChoices = selectChoices
        self.textValue = textValue
    }
}

public struct PutRegistrationFieldValueOutput: Swift.Sendable {
    /// The path to the registration form field. You can use [DescribeRegistrationFieldDefinitions] for a list of FieldPaths.
    /// This member is required.
    public var fieldPath: Swift.String?
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// The unique identifier for the registration attachment.
    public var registrationAttachmentId: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// An array of values for the form field.
    public var selectChoices: [Swift.String]?
    /// The text data for a free form field.
    public var textValue: Swift.String?
    /// The version number of the registration.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        fieldPath: Swift.String? = nil,
        registrationArn: Swift.String? = nil,
        registrationAttachmentId: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        selectChoices: [Swift.String]? = nil,
        textValue: Swift.String? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.fieldPath = fieldPath
        self.registrationArn = registrationArn
        self.registrationAttachmentId = registrationAttachmentId
        self.registrationId = registrationId
        self.selectChoices = selectChoices
        self.textValue = textValue
        self.versionNumber = versionNumber
    }
}

public struct PutResourcePolicyInput: Swift.Sendable {
    /// The JSON formatted resource-based policy to attach.
    /// This member is required.
    public var policy: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS End User Messaging SMS and Voice resource to attach the resource-based policy to.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

public struct PutResourcePolicyOutput: Swift.Sendable {
    /// The time when the resource-based policy was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: Foundation.Date?
    /// The JSON formatted Resource Policy.
    public var policy: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS End User Messaging SMS and Voice resource attached to the resource-based policy.
    public var resourceArn: Swift.String?

    public init(
        createdTimestamp: Foundation.Date? = nil,
        policy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

public struct ReleasePhoneNumberInput: Swift.Sendable {
    /// The PhoneNumberId or PhoneNumberArn of the phone number to release. You can use [DescribePhoneNumbers] to get the values for PhoneNumberId and PhoneNumberArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    /// This member is required.
    public var phoneNumberId: Swift.String?

    public init(
        phoneNumberId: Swift.String? = nil
    )
    {
        self.phoneNumberId = phoneNumberId
    }
}

public struct ReleasePhoneNumberOutput: Swift.Sendable {
    /// The time when the phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: Foundation.Date?
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    public var isoCountryCode: Swift.String?
    /// The message type that was associated with the phone number.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The monthly price of the phone number, in US dollars.
    public var monthlyLeasingPrice: Swift.String?
    /// Specifies if the number could be used for text messages, voice, or both.
    public var numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    /// The type of number that was released.
    public var numberType: PinpointSMSVoiceV2ClientTypes.NumberType?
    /// The name of the OptOutList that was associated with the phone number.
    public var optOutListName: Swift.String?
    /// The phone number that was released.
    public var phoneNumber: Swift.String?
    /// The PhoneNumberArn of the phone number that was released.
    public var phoneNumberArn: Swift.String?
    /// The PhoneNumberId of the phone number that was released.
    public var phoneNumberId: Swift.String?
    /// The unique identifier for the registration.
    public var registrationId: Swift.String?
    /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, AWS End User Messaging SMS and Voice automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool
    /// The current status of the request.
    public var status: PinpointSMSVoiceV2ClientTypes.NumberStatus?
    /// The Amazon Resource Name (ARN) of the TwoWayChannel.
    public var twoWayChannelArn: Swift.String?
    /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
    public var twoWayChannelRole: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool

    public init(
        createdTimestamp: Foundation.Date? = nil,
        isoCountryCode: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        monthlyLeasingPrice: Swift.String? = nil,
        numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil,
        numberType: PinpointSMSVoiceV2ClientTypes.NumberType? = nil,
        optOutListName: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        phoneNumberArn: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool = false,
        status: PinpointSMSVoiceV2ClientTypes.NumberStatus? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayChannelRole: Swift.String? = nil,
        twoWayEnabled: Swift.Bool = false
    )
    {
        self.createdTimestamp = createdTimestamp
        self.isoCountryCode = isoCountryCode
        self.messageType = messageType
        self.monthlyLeasingPrice = monthlyLeasingPrice
        self.numberCapabilities = numberCapabilities
        self.numberType = numberType
        self.optOutListName = optOutListName
        self.phoneNumber = phoneNumber
        self.phoneNumberArn = phoneNumberArn
        self.phoneNumberId = phoneNumberId
        self.registrationId = registrationId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.status = status
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayChannelRole = twoWayChannelRole
        self.twoWayEnabled = twoWayEnabled
    }
}

public struct ReleaseSenderIdInput: Swift.Sendable {
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The sender ID to release.
    /// This member is required.
    public var senderId: Swift.String?

    public init(
        isoCountryCode: Swift.String? = nil,
        senderId: Swift.String? = nil
    )
    {
        self.isoCountryCode = isoCountryCode
        self.senderId = senderId
    }
}

public struct ReleaseSenderIdOutput: Swift.Sendable {
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    /// This member is required.
    public var messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]?
    /// The monthly price, in US dollars, to lease the sender ID.
    /// This member is required.
    public var monthlyLeasingPrice: Swift.String?
    /// True if the sender ID is registered.
    /// This member is required.
    public var registered: Swift.Bool
    /// The unique identifier for the registration.
    public var registrationId: Swift.String?
    /// The sender ID that was released.
    /// This member is required.
    public var senderId: Swift.String?
    /// The Amazon Resource Name (ARN) associated with the SenderId.
    /// This member is required.
    public var senderIdArn: Swift.String?

    public init(
        isoCountryCode: Swift.String? = nil,
        messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]? = nil,
        monthlyLeasingPrice: Swift.String? = nil,
        registered: Swift.Bool = false,
        registrationId: Swift.String? = nil,
        senderId: Swift.String? = nil,
        senderIdArn: Swift.String? = nil
    )
    {
        self.isoCountryCode = isoCountryCode
        self.messageTypes = messageTypes
        self.monthlyLeasingPrice = monthlyLeasingPrice
        self.registered = registered
        self.registrationId = registrationId
        self.senderId = senderId
        self.senderIdArn = senderIdArn
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum RequestableNumberType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case longCode
        case simulator
        case tenDlc
        case tollFree
        case sdkUnknown(Swift.String)

        public static var allCases: [RequestableNumberType] {
            return [
                .longCode,
                .simulator,
                .tenDlc,
                .tollFree
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .longCode: return "LONG_CODE"
            case .simulator: return "SIMULATOR"
            case .tenDlc: return "TEN_DLC"
            case .tollFree: return "TOLL_FREE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct RequestPhoneNumberInput: Swift.Sendable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// By default this is set to false. When set to true the phone number can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool?
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    /// This member is required.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// Indicates if the phone number will be used for text messages, voice messages, or both.
    /// This member is required.
    public var numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    /// The type of phone number to request.
    /// This member is required.
    public var numberType: PinpointSMSVoiceV2ClientTypes.RequestableNumberType?
    /// The name of the OptOutList to associate with the phone number. You can use the OptOutListName or OptOutListArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    public var optOutListName: Swift.String?
    /// The pool to associated with the phone number. You can use the PoolId or PoolArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    public var poolId: Swift.String?
    /// Use this field to attach your phone number for an external registration process.
    public var registrationId: Swift.String?
    /// An array of tags (key and value pairs) associate with the requested phone number.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        deletionProtectionEnabled: Swift.Bool? = nil,
        isoCountryCode: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil,
        numberType: PinpointSMSVoiceV2ClientTypes.RequestableNumberType? = nil,
        optOutListName: Swift.String? = nil,
        poolId: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.messageType = messageType
        self.numberCapabilities = numberCapabilities
        self.numberType = numberType
        self.optOutListName = optOutListName
        self.poolId = poolId
        self.registrationId = registrationId
        self.tags = tags
    }
}

public struct RequestPhoneNumberOutput: Swift.Sendable {
    /// The time when the phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: Foundation.Date?
    /// By default this is set to false. When set to true the phone number can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The monthly price, in US dollars, to lease the phone number.
    public var monthlyLeasingPrice: Swift.String?
    /// Indicates if the phone number will be used for text messages, voice messages or both.
    public var numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    /// The type of number that was released.
    public var numberType: PinpointSMSVoiceV2ClientTypes.RequestableNumberType?
    /// The name of the OptOutList that is associated with the requested phone number.
    public var optOutListName: Swift.String?
    /// The new phone number that was requested.
    public var phoneNumber: Swift.String?
    /// The Amazon Resource Name (ARN) of the requested phone number.
    public var phoneNumberArn: Swift.String?
    /// The unique identifier of the new phone number.
    public var phoneNumberId: Swift.String?
    /// The unique identifier of the pool associated with the phone number
    public var poolId: Swift.String?
    /// The unique identifier for the registration.
    public var registrationId: Swift.String?
    /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, AWS End User Messaging SMS and Voice automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool
    /// The current status of the request.
    public var status: PinpointSMSVoiceV2ClientTypes.NumberStatus?
    /// An array of key and value pair tags that are associated with the phone number.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?
    /// The ARN used to identify the two way channel.
    public var twoWayChannelArn: Swift.String?
    /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
    public var twoWayChannelRole: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool

    public init(
        createdTimestamp: Foundation.Date? = nil,
        deletionProtectionEnabled: Swift.Bool = false,
        isoCountryCode: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        monthlyLeasingPrice: Swift.String? = nil,
        numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil,
        numberType: PinpointSMSVoiceV2ClientTypes.RequestableNumberType? = nil,
        optOutListName: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        phoneNumberArn: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        poolId: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool = false,
        status: PinpointSMSVoiceV2ClientTypes.NumberStatus? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayChannelRole: Swift.String? = nil,
        twoWayEnabled: Swift.Bool = false
    )
    {
        self.createdTimestamp = createdTimestamp
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.messageType = messageType
        self.monthlyLeasingPrice = monthlyLeasingPrice
        self.numberCapabilities = numberCapabilities
        self.numberType = numberType
        self.optOutListName = optOutListName
        self.phoneNumber = phoneNumber
        self.phoneNumberArn = phoneNumberArn
        self.phoneNumberId = phoneNumberId
        self.poolId = poolId
        self.registrationId = registrationId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.status = status
        self.tags = tags
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayChannelRole = twoWayChannelRole
        self.twoWayEnabled = twoWayEnabled
    }
}

public struct RequestSenderIdInput: Swift.Sendable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don't specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// By default this is set to false. When set to true the sender ID can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool?
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    public var messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]?
    /// The sender ID string to request.
    /// This member is required.
    public var senderId: Swift.String?
    /// An array of tags (key and value pairs) to associate with the sender ID.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        deletionProtectionEnabled: Swift.Bool? = nil,
        isoCountryCode: Swift.String? = nil,
        messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]? = nil,
        senderId: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.messageTypes = messageTypes
        self.senderId = senderId
        self.tags = tags
    }
}

public struct RequestSenderIdOutput: Swift.Sendable {
    /// By default this is set to false. When set to true the sender ID can't be deleted.
    /// This member is required.
    public var deletionProtectionEnabled: Swift.Bool
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    /// This member is required.
    public var messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]?
    /// The monthly price, in US dollars, to lease the sender ID.
    /// This member is required.
    public var monthlyLeasingPrice: Swift.String?
    /// True if the sender ID is registered.
    /// This member is required.
    public var registered: Swift.Bool
    /// The sender ID that was requested.
    /// This member is required.
    public var senderId: Swift.String?
    /// The Amazon Resource Name (ARN) associated with the SenderId.
    /// This member is required.
    public var senderIdArn: Swift.String?
    /// An array of tags (key and value pairs) to associate with the sender ID.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        deletionProtectionEnabled: Swift.Bool = false,
        isoCountryCode: Swift.String? = nil,
        messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]? = nil,
        monthlyLeasingPrice: Swift.String? = nil,
        registered: Swift.Bool = false,
        senderId: Swift.String? = nil,
        senderIdArn: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.messageTypes = messageTypes
        self.monthlyLeasingPrice = monthlyLeasingPrice
        self.registered = registered
        self.senderId = senderId
        self.senderIdArn = senderIdArn
        self.tags = tags
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum VerificationChannel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case text
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [VerificationChannel] {
            return [
                .text,
                .voice
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .text: return "TEXT"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct SendDestinationNumberVerificationCodeInput: Swift.Sendable {
    /// The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.
    public var configurationSetName: Swift.String?
    /// You can specify custom data in this field. If you do, that data is logged to the event destination.
    public var context: [Swift.String: Swift.String]?
    /// This field is used for any country-specific registration requirements. Currently, this setting is only used when you send messages to recipients in India using a sender ID. For more information see [Special requirements for sending SMS messages to recipients in India](https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-senderid-india.html).
    public var destinationCountryParameters: [Swift.String: Swift.String]?
    /// Choose the language to use for the message.
    public var languageCode: PinpointSMSVoiceV2ClientTypes.LanguageCode?
    /// The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    public var originationIdentity: Swift.String?
    /// Choose to send the verification code as an SMS or voice message.
    /// This member is required.
    public var verificationChannel: PinpointSMSVoiceV2ClientTypes.VerificationChannel?
    /// The unique identifier for the verified destination phone number.
    /// This member is required.
    public var verifiedDestinationNumberId: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil,
        context: [Swift.String: Swift.String]? = nil,
        destinationCountryParameters: [Swift.String: Swift.String]? = nil,
        languageCode: PinpointSMSVoiceV2ClientTypes.LanguageCode? = nil,
        originationIdentity: Swift.String? = nil,
        verificationChannel: PinpointSMSVoiceV2ClientTypes.VerificationChannel? = nil,
        verifiedDestinationNumberId: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.context = context
        self.destinationCountryParameters = destinationCountryParameters
        self.languageCode = languageCode
        self.originationIdentity = originationIdentity
        self.verificationChannel = verificationChannel
        self.verifiedDestinationNumberId = verifiedDestinationNumberId
    }
}

public struct SendDestinationNumberVerificationCodeOutput: Swift.Sendable {
    /// The unique identifier for the message.
    /// This member is required.
    public var messageId: Swift.String?

    public init(
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

public struct SendMediaMessageInput: Swift.Sendable {
    /// The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.
    public var configurationSetName: Swift.String?
    /// You can specify custom data in this field. If you do, that data is logged to the event destination.
    public var context: [Swift.String: Swift.String]?
    /// The destination phone number in E.164 format.
    /// This member is required.
    public var destinationPhoneNumber: Swift.String?
    /// When set to true, the message is checked and validated, but isn't sent to the end recipient.
    public var dryRun: Swift.Bool?
    /// The maximum amount that you want to spend, in US dollars, per each MMS message.
    public var maxPrice: Swift.String?
    /// An array of URLs to each media file to send. The media files have to be stored in a publicly available S3 bucket. Supported media file formats are listed in [MMS file types, size and character limits](https://docs.aws.amazon.com/sms-voice/latest/userguide/mms-limitations-character.html). For more information on creating an S3 bucket and managing objects, see [Creating a bucket](https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html) and [Uploading objects](https://docs.aws.amazon.com/AmazonS3/latest/userguide/upload-objects.html) in the S3 user guide.
    public var mediaUrls: [Swift.String]?
    /// The text body of the message.
    public var messageBody: Swift.String?
    /// The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    /// This member is required.
    public var originationIdentity: Swift.String?
    /// The unique identifier of the protect configuration to use.
    public var protectConfigurationId: Swift.String?
    /// How long the text message is valid for. By default this is 72 hours.
    public var timeToLive: Swift.Int?

    public init(
        configurationSetName: Swift.String? = nil,
        context: [Swift.String: Swift.String]? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        dryRun: Swift.Bool? = false,
        maxPrice: Swift.String? = nil,
        mediaUrls: [Swift.String]? = nil,
        messageBody: Swift.String? = nil,
        originationIdentity: Swift.String? = nil,
        protectConfigurationId: Swift.String? = nil,
        timeToLive: Swift.Int? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.context = context
        self.destinationPhoneNumber = destinationPhoneNumber
        self.dryRun = dryRun
        self.maxPrice = maxPrice
        self.mediaUrls = mediaUrls
        self.messageBody = messageBody
        self.originationIdentity = originationIdentity
        self.protectConfigurationId = protectConfigurationId
        self.timeToLive = timeToLive
    }
}

public struct SendMediaMessageOutput: Swift.Sendable {
    /// The unique identifier for the message.
    public var messageId: Swift.String?

    public init(
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

public struct SendTextMessageInput: Swift.Sendable {
    /// The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.
    public var configurationSetName: Swift.String?
    /// You can specify custom data in this field. If you do, that data is logged to the event destination.
    public var context: [Swift.String: Swift.String]?
    /// This field is used for any country-specific registration requirements. Currently, this setting is only used when you send messages to recipients in India using a sender ID. For more information see [Special requirements for sending SMS messages to recipients in India](https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-senderid-india.html).
    ///
    /// * IN_ENTITY_ID The entity ID or Principal Entity (PE) ID that you received after completing the sender ID registration process.
    ///
    /// * IN_TEMPLATE_ID The template ID that you received after completing the sender ID registration process. Make sure that the Template ID that you specify matches your message template exactly. If your message doesn't match the template that you provided during the registration process, the mobile carriers might reject your message.
    public var destinationCountryParameters: [Swift.String: Swift.String]?
    /// The destination phone number in E.164 format.
    /// This member is required.
    public var destinationPhoneNumber: Swift.String?
    /// When set to true, the message is checked and validated, but isn't sent to the end recipient. You are not charged for using DryRun. The Message Parts per Second (MPS) limit when using DryRun is five. If your origination identity has a lower MPS limit then the lower MPS limit is used. For more information about MPS limits, see [Message Parts per Second (MPS) limits](https://docs.aws.amazon.com/sms-voice/latest/userguide/sms-limitations-mps.html) in the AWS End User Messaging SMS User Guide..
    public var dryRun: Swift.Bool?
    /// When you register a short code in the US, you must specify a program name. If you dont have a US short code, omit this attribute.
    public var keyword: Swift.String?
    /// The maximum amount that you want to spend, in US dollars, per each text message. If the calculated amount to send the text message is greater than MaxPrice, the message is not sent and an error is returned.
    public var maxPrice: Swift.String?
    /// The body of the text message.
    public var messageBody: Swift.String?
    /// The type of message. Valid values are for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The origination identity of the message. This can be either the PhoneNumber, PhoneNumberId, PhoneNumberArn, SenderId, SenderIdArn, PoolId, or PoolArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    public var originationIdentity: Swift.String?
    /// The unique identifier for the protect configuration.
    public var protectConfigurationId: Swift.String?
    /// How long the text message is valid for, in seconds. By default this is 72 hours. If the messages isn't handed off before the TTL expires we stop attempting to hand off the message and return TTL_EXPIRED event.
    public var timeToLive: Swift.Int?

    public init(
        configurationSetName: Swift.String? = nil,
        context: [Swift.String: Swift.String]? = nil,
        destinationCountryParameters: [Swift.String: Swift.String]? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        dryRun: Swift.Bool? = false,
        keyword: Swift.String? = nil,
        maxPrice: Swift.String? = nil,
        messageBody: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        originationIdentity: Swift.String? = nil,
        protectConfigurationId: Swift.String? = nil,
        timeToLive: Swift.Int? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.context = context
        self.destinationCountryParameters = destinationCountryParameters
        self.destinationPhoneNumber = destinationPhoneNumber
        self.dryRun = dryRun
        self.keyword = keyword
        self.maxPrice = maxPrice
        self.messageBody = messageBody
        self.messageType = messageType
        self.originationIdentity = originationIdentity
        self.protectConfigurationId = protectConfigurationId
        self.timeToLive = timeToLive
    }
}

public struct SendTextMessageOutput: Swift.Sendable {
    /// The unique identifier for the message.
    public var messageId: Swift.String?

    public init(
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum VoiceMessageBodyTextType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ssml
        case text
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceMessageBodyTextType] {
            return [
                .ssml,
                .text
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ssml: return "SSML"
            case .text: return "TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PinpointSMSVoiceV2ClientTypes {

    public enum VoiceId: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amy
        case astrid
        case bianca
        case brian
        case camila
        case carla
        case carmen
        case celine
        case chantal
        case conchita
        case cristiano
        case dora
        case emma
        case enrique
        case ewa
        case filiz
        case geraint
        case giorgio
        case gwyneth
        case hans
        case ines
        case ivy
        case jacek
        case jan
        case joanna
        case joey
        case justin
        case karl
        case kendra
        case kimberly
        case lea
        case liv
        case lotte
        case lucia
        case lupe
        case mads
        case maja
        case marlene
        case mathieu
        case matthew
        case maxim
        case mia
        case miguel
        case mizuki
        case naja
        case nicole
        case penelope
        case raveena
        case ricardo
        case ruben
        case russell
        case salli
        case seoyeon
        case takumi
        case tatyana
        case vicki
        case vitoria
        case zeina
        case zhiyu
        case sdkUnknown(Swift.String)

        public static var allCases: [VoiceId] {
            return [
                .amy,
                .astrid,
                .bianca,
                .brian,
                .camila,
                .carla,
                .carmen,
                .celine,
                .chantal,
                .conchita,
                .cristiano,
                .dora,
                .emma,
                .enrique,
                .ewa,
                .filiz,
                .geraint,
                .giorgio,
                .gwyneth,
                .hans,
                .ines,
                .ivy,
                .jacek,
                .jan,
                .joanna,
                .joey,
                .justin,
                .karl,
                .kendra,
                .kimberly,
                .lea,
                .liv,
                .lotte,
                .lucia,
                .lupe,
                .mads,
                .maja,
                .marlene,
                .mathieu,
                .matthew,
                .maxim,
                .mia,
                .miguel,
                .mizuki,
                .naja,
                .nicole,
                .penelope,
                .raveena,
                .ricardo,
                .ruben,
                .russell,
                .salli,
                .seoyeon,
                .takumi,
                .tatyana,
                .vicki,
                .vitoria,
                .zeina,
                .zhiyu
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amy: return "AMY"
            case .astrid: return "ASTRID"
            case .bianca: return "BIANCA"
            case .brian: return "BRIAN"
            case .camila: return "CAMILA"
            case .carla: return "CARLA"
            case .carmen: return "CARMEN"
            case .celine: return "CELINE"
            case .chantal: return "CHANTAL"
            case .conchita: return "CONCHITA"
            case .cristiano: return "CRISTIANO"
            case .dora: return "DORA"
            case .emma: return "EMMA"
            case .enrique: return "ENRIQUE"
            case .ewa: return "EWA"
            case .filiz: return "FILIZ"
            case .geraint: return "GERAINT"
            case .giorgio: return "GIORGIO"
            case .gwyneth: return "GWYNETH"
            case .hans: return "HANS"
            case .ines: return "INES"
            case .ivy: return "IVY"
            case .jacek: return "JACEK"
            case .jan: return "JAN"
            case .joanna: return "JOANNA"
            case .joey: return "JOEY"
            case .justin: return "JUSTIN"
            case .karl: return "KARL"
            case .kendra: return "KENDRA"
            case .kimberly: return "KIMBERLY"
            case .lea: return "LEA"
            case .liv: return "LIV"
            case .lotte: return "LOTTE"
            case .lucia: return "LUCIA"
            case .lupe: return "LUPE"
            case .mads: return "MADS"
            case .maja: return "MAJA"
            case .marlene: return "MARLENE"
            case .mathieu: return "MATHIEU"
            case .matthew: return "MATTHEW"
            case .maxim: return "MAXIM"
            case .mia: return "MIA"
            case .miguel: return "MIGUEL"
            case .mizuki: return "MIZUKI"
            case .naja: return "NAJA"
            case .nicole: return "NICOLE"
            case .penelope: return "PENELOPE"
            case .raveena: return "RAVEENA"
            case .ricardo: return "RICARDO"
            case .ruben: return "RUBEN"
            case .russell: return "RUSSELL"
            case .salli: return "SALLI"
            case .seoyeon: return "SEOYEON"
            case .takumi: return "TAKUMI"
            case .tatyana: return "TATYANA"
            case .vicki: return "VICKI"
            case .vitoria: return "VITORIA"
            case .zeina: return "ZEINA"
            case .zhiyu: return "ZHIYU"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct SendVoiceMessageInput: Swift.Sendable {
    /// The name of the configuration set to use. This can be either the ConfigurationSetName or ConfigurationSetArn.
    public var configurationSetName: Swift.String?
    /// You can specify custom data in this field. If you do, that data is logged to the event destination.
    public var context: [Swift.String: Swift.String]?
    /// The destination phone number in E.164 format.
    /// This member is required.
    public var destinationPhoneNumber: Swift.String?
    /// When set to true, the message is checked and validated, but isn't sent to the end recipient.
    public var dryRun: Swift.Bool?
    /// The maximum amount to spend per voice message, in US dollars.
    public var maxPricePerMinute: Swift.String?
    /// The text to convert to a voice message.
    public var messageBody: Swift.String?
    /// Specifies if the MessageBody field contains text or [speech synthesis markup language (SSML)](https://docs.aws.amazon.com/polly/latest/dg/what-is.html).
    ///
    /// * TEXT: This is the default value. When used the maximum character limit is 3000.
    ///
    /// * SSML: When used the maximum character limit is 6000 including SSML tagging.
    public var messageBodyTextType: PinpointSMSVoiceV2ClientTypes.VoiceMessageBodyTextType?
    /// The origination identity to use for the voice call. This can be the PhoneNumber, PhoneNumberId, PhoneNumberArn, PoolId, or PoolArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    /// This member is required.
    public var originationIdentity: Swift.String?
    /// The unique identifier for the protect configuration.
    public var protectConfigurationId: Swift.String?
    /// How long the voice message is valid for. By default this is 72 hours.
    public var timeToLive: Swift.Int?
    /// The voice for the [Amazon Polly](https://docs.aws.amazon.com/polly/latest/dg/what-is.html) service to use. By default this is set to "MATTHEW".
    public var voiceId: PinpointSMSVoiceV2ClientTypes.VoiceId?

    public init(
        configurationSetName: Swift.String? = nil,
        context: [Swift.String: Swift.String]? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        dryRun: Swift.Bool? = false,
        maxPricePerMinute: Swift.String? = nil,
        messageBody: Swift.String? = nil,
        messageBodyTextType: PinpointSMSVoiceV2ClientTypes.VoiceMessageBodyTextType? = nil,
        originationIdentity: Swift.String? = nil,
        protectConfigurationId: Swift.String? = nil,
        timeToLive: Swift.Int? = nil,
        voiceId: PinpointSMSVoiceV2ClientTypes.VoiceId? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.context = context
        self.destinationPhoneNumber = destinationPhoneNumber
        self.dryRun = dryRun
        self.maxPricePerMinute = maxPricePerMinute
        self.messageBody = messageBody
        self.messageBodyTextType = messageBodyTextType
        self.originationIdentity = originationIdentity
        self.protectConfigurationId = protectConfigurationId
        self.timeToLive = timeToLive
        self.voiceId = voiceId
    }
}

public struct SendVoiceMessageOutput: Swift.Sendable {
    /// The unique identifier for the message.
    public var messageId: Swift.String?

    public init(
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

public struct SetAccountDefaultProtectConfigurationInput: Swift.Sendable {
    /// The unique identifier for the protect configuration.
    /// This member is required.
    public var protectConfigurationId: Swift.String?

    public init(
        protectConfigurationId: Swift.String? = nil
    )
    {
        self.protectConfigurationId = protectConfigurationId
    }
}

public struct SetAccountDefaultProtectConfigurationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the account default protect configuration.
    /// This member is required.
    public var defaultProtectConfigurationArn: Swift.String?
    /// The unique identifier of the account default protect configuration.
    /// This member is required.
    public var defaultProtectConfigurationId: Swift.String?

    public init(
        defaultProtectConfigurationArn: Swift.String? = nil,
        defaultProtectConfigurationId: Swift.String? = nil
    )
    {
        self.defaultProtectConfigurationArn = defaultProtectConfigurationArn
        self.defaultProtectConfigurationId = defaultProtectConfigurationId
    }
}

public struct SetDefaultMessageTypeInput: Swift.Sendable {
    /// The configuration set to update with a new default message type. This field can be the ConsigurationSetName or ConfigurationSetArn.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    /// This member is required.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?

    public init(
        configurationSetName: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.messageType = messageType
    }
}

public struct SetDefaultMessageTypeOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the updated configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set that was updated.
    public var configurationSetName: Swift.String?
    /// The new default message type of the configuration set.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.messageType = messageType
    }
}

public struct SetDefaultSenderIdInput: Swift.Sendable {
    /// The configuration set to updated with a new default SenderId. This field can be the ConsigurationSetName or ConfigurationSetArn.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// The current sender ID for the configuration set. When sending a text message to a destination country which supports SenderIds, the default sender ID on the configuration set specified on [SendTextMessage] will be used if no dedicated origination phone numbers or registered SenderIds are available in your account, instead of a generic sender ID, such as 'NOTICE'.
    /// This member is required.
    public var senderId: Swift.String?

    public init(
        configurationSetName: Swift.String? = nil,
        senderId: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.senderId = senderId
    }
}

public struct SetDefaultSenderIdOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the updated configuration set.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set that was updated.
    public var configurationSetName: Swift.String?
    /// The default sender ID to set for the ConfigurationSet.
    public var senderId: Swift.String?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        senderId: Swift.String? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.senderId = senderId
    }
}

public struct SetMediaMessageSpendLimitOverrideInput: Swift.Sendable {
    /// The new monthly limit to enforce on text messages.
    /// This member is required.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

public struct SetMediaMessageSpendLimitOverrideOutput: Swift.Sendable {
    /// The current monthly limit to enforce on sending text messages.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

public struct SetTextMessageSpendLimitOverrideInput: Swift.Sendable {
    /// The new monthly limit to enforce on text messages.
    /// This member is required.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

public struct SetTextMessageSpendLimitOverrideOutput: Swift.Sendable {
    /// The current monthly limit to enforce on sending text messages.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

public struct SetVoiceMessageSpendLimitOverrideInput: Swift.Sendable {
    /// The new monthly limit to enforce on voice messages.
    /// This member is required.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

public struct SetVoiceMessageSpendLimitOverrideOutput: Swift.Sendable {
    /// The current monthly limit to enforce on sending voice messages.
    public var monthlyLimit: Swift.Int?

    public init(
        monthlyLimit: Swift.Int? = nil
    )
    {
        self.monthlyLimit = monthlyLimit
    }
}

public struct SubmitRegistrationVersionInput: Swift.Sendable {
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?

    public init(
        registrationId: Swift.String? = nil
    )
    {
        self.registrationId = registrationId
    }
}

public struct SubmitRegistrationVersionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the registration.
    /// This member is required.
    public var registrationArn: Swift.String?
    /// The unique identifier for the registration.
    /// This member is required.
    public var registrationId: Swift.String?
    /// The status of the registration version.
    ///
    /// * APPROVED: Your registration has been approved.
    ///
    /// * ARCHIVED: Your previously approved registration version moves into this status when a more recently submitted version is approved.
    ///
    /// * DENIED: You must fix your registration and resubmit it.
    ///
    /// * DISCARDED: You've abandon this version of their registration to start over with a new version.
    ///
    /// * DRAFT: The initial status of a registration version after its created.
    ///
    /// * REQUIRES_AUTHENTICATION: You need to complete email authentication.
    ///
    /// * REVIEWING: Your registration has been accepted and is being reviewed.
    ///
    /// * REVOKED: Your previously approved registration has been revoked.
    ///
    /// * SUBMITTED: Your registration has been submitted.
    /// This member is required.
    public var registrationVersionStatus: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus?
    /// The RegistrationVersionStatusHistory object contains the time stamps for when the reservations status changes.
    /// This member is required.
    public var registrationVersionStatusHistory: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory?
    /// The version number of the registration.
    /// This member is required.
    public var versionNumber: Swift.Int?

    public init(
        registrationArn: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        registrationVersionStatus: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatus? = nil,
        registrationVersionStatusHistory: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory? = nil,
        versionNumber: Swift.Int? = nil
    )
    {
        self.registrationArn = registrationArn
        self.registrationId = registrationId
        self.registrationVersionStatus = registrationVersionStatus
        self.registrationVersionStatusHistory = registrationVersionStatusHistory
        self.versionNumber = versionNumber
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of key and value pair tags that are associated with the resource.
    /// This member is required.
    public var tags: [PinpointSMSVoiceV2ClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [PinpointSMSVoiceV2ClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of tag key values to unassociate with the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateEventDestinationInput: Swift.Sendable {
    /// An object that contains information about an event destination that sends data to CloudWatch Logs.
    public var cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination?
    /// The configuration set to update with the new event destination. Valid values for this can be the ConfigurationSetName or ConfigurationSetArn.
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// When set to true logging is enabled.
    public var enabled: Swift.Bool?
    /// The name to use for the event destination.
    /// This member is required.
    public var eventDestinationName: Swift.String?
    /// An object that contains information about an event destination for logging to Firehose.
    public var kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination?
    /// An array of event types that determine which events to log. The TEXT_SENT event type is not supported.
    public var matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]?
    /// An object that contains information about an event destination that sends data to Amazon SNS.
    public var snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination?

    public init(
        cloudWatchLogsDestination: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination? = nil,
        configurationSetName: Swift.String? = nil,
        enabled: Swift.Bool? = nil,
        eventDestinationName: Swift.String? = nil,
        kinesisFirehoseDestination: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination? = nil,
        matchingEventTypes: [PinpointSMSVoiceV2ClientTypes.EventType]? = nil,
        snsDestination: PinpointSMSVoiceV2ClientTypes.SnsDestination? = nil
    )
    {
        self.cloudWatchLogsDestination = cloudWatchLogsDestination
        self.configurationSetName = configurationSetName
        self.enabled = enabled
        self.eventDestinationName = eventDestinationName
        self.kinesisFirehoseDestination = kinesisFirehoseDestination
        self.matchingEventTypes = matchingEventTypes
        self.snsDestination = snsDestination
    }
}

public struct UpdateEventDestinationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the ConfigurationSet that was updated.
    public var configurationSetArn: Swift.String?
    /// The name of the configuration set.
    public var configurationSetName: Swift.String?
    /// An EventDestination object containing the details of where events will be logged.
    public var eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination?

    public init(
        configurationSetArn: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        eventDestination: PinpointSMSVoiceV2ClientTypes.EventDestination? = nil
    )
    {
        self.configurationSetArn = configurationSetArn
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
    }
}

public struct UpdatePhoneNumberInput: Swift.Sendable {
    /// By default this is set to false. When set to true the phone number can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool?
    /// The OptOutList to add the phone number to. Valid values for this field can be either the OutOutListName or OutOutListArn.
    public var optOutListName: Swift.String?
    /// The unique identifier of the phone number. Valid values for this field can be either the PhoneNumberId or PhoneNumberArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    /// This member is required.
    public var phoneNumberId: Swift.String?
    /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, AWS End User Messaging SMS and Voice automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the two way channel.
    public var twoWayChannelArn: Swift.String?
    /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
    public var twoWayChannelRole: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool?

    public init(
        deletionProtectionEnabled: Swift.Bool? = nil,
        optOutListName: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayChannelRole: Swift.String? = nil,
        twoWayEnabled: Swift.Bool? = nil
    )
    {
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.optOutListName = optOutListName
        self.phoneNumberId = phoneNumberId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayChannelRole = twoWayChannelRole
        self.twoWayEnabled = twoWayEnabled
    }
}

public struct UpdatePhoneNumberOutput: Swift.Sendable {
    /// The time when the phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: Foundation.Date?
    /// When set to true the phone number can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The monthly leasing price of the phone number, in US dollars.
    public var monthlyLeasingPrice: Swift.String?
    /// Specifies if the number could be used for text messages, voice or both.
    public var numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]?
    /// The type of number that was requested.
    public var numberType: PinpointSMSVoiceV2ClientTypes.NumberType?
    /// The name of the OptOutList associated with the phone number.
    public var optOutListName: Swift.String?
    /// The phone number that was updated.
    public var phoneNumber: Swift.String?
    /// The Amazon Resource Name (ARN) of the updated phone number.
    public var phoneNumberArn: Swift.String?
    /// The unique identifier of the phone number.
    public var phoneNumberId: Swift.String?
    /// The unique identifier for the registration.
    public var registrationId: Swift.String?
    /// This is true if self managed opt-out are enabled.
    public var selfManagedOptOutsEnabled: Swift.Bool
    /// The current status of the request.
    public var status: PinpointSMSVoiceV2ClientTypes.NumberStatus?
    /// The Amazon Resource Name (ARN) of the two way channel.
    public var twoWayChannelArn: Swift.String?
    /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
    public var twoWayChannelRole: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool

    public init(
        createdTimestamp: Foundation.Date? = nil,
        deletionProtectionEnabled: Swift.Bool = false,
        isoCountryCode: Swift.String? = nil,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        monthlyLeasingPrice: Swift.String? = nil,
        numberCapabilities: [PinpointSMSVoiceV2ClientTypes.NumberCapability]? = nil,
        numberType: PinpointSMSVoiceV2ClientTypes.NumberType? = nil,
        optOutListName: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        phoneNumberArn: Swift.String? = nil,
        phoneNumberId: Swift.String? = nil,
        registrationId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool = false,
        status: PinpointSMSVoiceV2ClientTypes.NumberStatus? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayChannelRole: Swift.String? = nil,
        twoWayEnabled: Swift.Bool = false
    )
    {
        self.createdTimestamp = createdTimestamp
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.messageType = messageType
        self.monthlyLeasingPrice = monthlyLeasingPrice
        self.numberCapabilities = numberCapabilities
        self.numberType = numberType
        self.optOutListName = optOutListName
        self.phoneNumber = phoneNumber
        self.phoneNumberArn = phoneNumberArn
        self.phoneNumberId = phoneNumberId
        self.registrationId = registrationId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.status = status
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayChannelRole = twoWayChannelRole
        self.twoWayEnabled = twoWayEnabled
    }
}

public struct UpdatePoolInput: Swift.Sendable {
    /// When set to true the pool can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool?
    /// The OptOutList to associate with the pool. Valid values are either OptOutListName or OptOutListArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    public var optOutListName: Swift.String?
    /// The unique identifier of the pool to update. Valid values are either the PoolId or PoolArn. If you are using a shared AWS End User Messaging SMS and Voice resource then you must use the full Amazon Resource Name(ARN).
    /// This member is required.
    public var poolId: Swift.String?
    /// By default this is set to false. When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, AWS End User Messaging SMS and Voice automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool?
    /// Indicates whether shared routes are enabled for the pool.
    public var sharedRoutesEnabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the two way channel.
    public var twoWayChannelArn: Swift.String?
    /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
    public var twoWayChannelRole: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool?

    public init(
        deletionProtectionEnabled: Swift.Bool? = nil,
        optOutListName: Swift.String? = nil,
        poolId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool? = nil,
        sharedRoutesEnabled: Swift.Bool? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayChannelRole: Swift.String? = nil,
        twoWayEnabled: Swift.Bool? = nil
    )
    {
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.optOutListName = optOutListName
        self.poolId = poolId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.sharedRoutesEnabled = sharedRoutesEnabled
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayChannelRole = twoWayChannelRole
        self.twoWayEnabled = twoWayEnabled
    }
}

public struct UpdatePoolOutput: Swift.Sendable {
    /// The time when the pool was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    public var createdTimestamp: Foundation.Date?
    /// When set to true the pool can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool
    /// The type of message for the pool to use.
    public var messageType: PinpointSMSVoiceV2ClientTypes.MessageType?
    /// The name of the OptOutList associated with the pool.
    public var optOutListName: Swift.String?
    /// The ARN of the pool.
    public var poolArn: Swift.String?
    /// The unique identifier of the pool.
    public var poolId: Swift.String?
    /// When an end recipient sends a message that begins with HELP or STOP to one of your dedicated numbers, AWS End User Messaging SMS and Voice automatically replies with a customizable message and adds the end recipient to the OptOutList. When set to true you're responsible for responding to HELP and STOP requests. You're also responsible for tracking and honoring opt-out requests.
    public var selfManagedOptOutsEnabled: Swift.Bool
    /// Indicates whether shared routes are enabled for the pool.
    public var sharedRoutesEnabled: Swift.Bool
    /// The current status of the pool update request.
    public var status: PinpointSMSVoiceV2ClientTypes.PoolStatus?
    /// The Amazon Resource Name (ARN) of the two way channel.
    public var twoWayChannelArn: Swift.String?
    /// An optional IAM Role Arn for a service to assume, to be able to post inbound SMS messages.
    public var twoWayChannelRole: Swift.String?
    /// By default this is set to false. When set to true you can receive incoming text messages from your end recipients.
    public var twoWayEnabled: Swift.Bool

    public init(
        createdTimestamp: Foundation.Date? = nil,
        deletionProtectionEnabled: Swift.Bool = false,
        messageType: PinpointSMSVoiceV2ClientTypes.MessageType? = nil,
        optOutListName: Swift.String? = nil,
        poolArn: Swift.String? = nil,
        poolId: Swift.String? = nil,
        selfManagedOptOutsEnabled: Swift.Bool = false,
        sharedRoutesEnabled: Swift.Bool = false,
        status: PinpointSMSVoiceV2ClientTypes.PoolStatus? = nil,
        twoWayChannelArn: Swift.String? = nil,
        twoWayChannelRole: Swift.String? = nil,
        twoWayEnabled: Swift.Bool = false
    )
    {
        self.createdTimestamp = createdTimestamp
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.messageType = messageType
        self.optOutListName = optOutListName
        self.poolArn = poolArn
        self.poolId = poolId
        self.selfManagedOptOutsEnabled = selfManagedOptOutsEnabled
        self.sharedRoutesEnabled = sharedRoutesEnabled
        self.status = status
        self.twoWayChannelArn = twoWayChannelArn
        self.twoWayChannelRole = twoWayChannelRole
        self.twoWayEnabled = twoWayEnabled
    }
}

public struct UpdateProtectConfigurationInput: Swift.Sendable {
    /// When set to true deletion protection is enabled. By default this is set to false.
    public var deletionProtectionEnabled: Swift.Bool?
    /// The unique identifier for the protect configuration.
    /// This member is required.
    public var protectConfigurationId: Swift.String?

    public init(
        deletionProtectionEnabled: Swift.Bool? = nil,
        protectConfigurationId: Swift.String? = nil
    )
    {
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.protectConfigurationId = protectConfigurationId
    }
}

public struct UpdateProtectConfigurationOutput: Swift.Sendable {
    /// This is true if the protect configuration is set as your account default protect configuration.
    /// This member is required.
    public var accountDefault: Swift.Bool
    /// The time when the protect configuration was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    /// This member is required.
    public var createdTimestamp: Foundation.Date?
    /// The status of deletion protection for the protect configuration. When set to true deletion protection is enabled. By default this is set to false.
    /// This member is required.
    public var deletionProtectionEnabled: Swift.Bool
    /// The Amazon Resource Name (ARN) of the protect configuration.
    /// This member is required.
    public var protectConfigurationArn: Swift.String?
    /// The unique identifier for the protect configuration.
    /// This member is required.
    public var protectConfigurationId: Swift.String?

    public init(
        accountDefault: Swift.Bool = false,
        createdTimestamp: Foundation.Date? = nil,
        deletionProtectionEnabled: Swift.Bool = false,
        protectConfigurationArn: Swift.String? = nil,
        protectConfigurationId: Swift.String? = nil
    )
    {
        self.accountDefault = accountDefault
        self.createdTimestamp = createdTimestamp
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.protectConfigurationArn = protectConfigurationArn
        self.protectConfigurationId = protectConfigurationId
    }
}

public struct UpdateProtectConfigurationCountryRuleSetInput: Swift.Sendable {
    /// A map of ProtectConfigurationCountryRuleSetInformation objects that contain the details for the requested NumberCapability. The Key is the two-letter ISO country code. For a list of supported ISO country codes, see [Supported countries and regions (SMS channel)](https://docs.aws.amazon.com/sms-voice/latest/userguide/phone-numbers-sms-by-country.html) in the AWS End User Messaging SMS User Guide.
    /// This member is required.
    public var countryRuleSetUpdates: [Swift.String: PinpointSMSVoiceV2ClientTypes.ProtectConfigurationCountryRuleSetInformation]?
    /// The number capability to apply the CountryRuleSetUpdates updates to.
    /// This member is required.
    public var numberCapability: PinpointSMSVoiceV2ClientTypes.NumberCapability?
    /// The unique identifier for the protect configuration.
    /// This member is required.
    public var protectConfigurationId: Swift.String?

    public init(
        countryRuleSetUpdates: [Swift.String: PinpointSMSVoiceV2ClientTypes.ProtectConfigurationCountryRuleSetInformation]? = nil,
        numberCapability: PinpointSMSVoiceV2ClientTypes.NumberCapability? = nil,
        protectConfigurationId: Swift.String? = nil
    )
    {
        self.countryRuleSetUpdates = countryRuleSetUpdates
        self.numberCapability = numberCapability
        self.protectConfigurationId = protectConfigurationId
    }
}

public struct UpdateProtectConfigurationCountryRuleSetOutput: Swift.Sendable {
    /// An array of ProtectConfigurationCountryRuleSetInformation containing the rules for the NumberCapability.
    /// This member is required.
    public var countryRuleSet: [Swift.String: PinpointSMSVoiceV2ClientTypes.ProtectConfigurationCountryRuleSetInformation]?
    /// The number capability that was updated
    /// This member is required.
    public var numberCapability: PinpointSMSVoiceV2ClientTypes.NumberCapability?
    /// The Amazon Resource Name (ARN) of the protect configuration.
    /// This member is required.
    public var protectConfigurationArn: Swift.String?
    /// The unique identifier for the protect configuration.
    /// This member is required.
    public var protectConfigurationId: Swift.String?

    public init(
        countryRuleSet: [Swift.String: PinpointSMSVoiceV2ClientTypes.ProtectConfigurationCountryRuleSetInformation]? = nil,
        numberCapability: PinpointSMSVoiceV2ClientTypes.NumberCapability? = nil,
        protectConfigurationArn: Swift.String? = nil,
        protectConfigurationId: Swift.String? = nil
    )
    {
        self.countryRuleSet = countryRuleSet
        self.numberCapability = numberCapability
        self.protectConfigurationArn = protectConfigurationArn
        self.protectConfigurationId = protectConfigurationId
    }
}

public struct UpdateSenderIdInput: Swift.Sendable {
    /// By default this is set to false. When set to true the sender ID can't be deleted.
    public var deletionProtectionEnabled: Swift.Bool?
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The sender ID to update.
    /// This member is required.
    public var senderId: Swift.String?

    public init(
        deletionProtectionEnabled: Swift.Bool? = nil,
        isoCountryCode: Swift.String? = nil,
        senderId: Swift.String? = nil
    )
    {
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.senderId = senderId
    }
}

public struct UpdateSenderIdOutput: Swift.Sendable {
    /// By default this is set to false. When set to true the sender ID can't be deleted.
    /// This member is required.
    public var deletionProtectionEnabled: Swift.Bool
    /// The two-character code, in ISO 3166-1 alpha-2 format, for the country or region.
    /// This member is required.
    public var isoCountryCode: Swift.String?
    /// The type of message. Valid values are TRANSACTIONAL for messages that are critical or time-sensitive and PROMOTIONAL for messages that aren't critical or time-sensitive.
    /// This member is required.
    public var messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]?
    /// The monthly price, in US dollars, to lease the sender ID.
    /// This member is required.
    public var monthlyLeasingPrice: Swift.String?
    /// True if the sender ID is registered..
    /// This member is required.
    public var registered: Swift.Bool
    /// The unique identifier for the registration.
    public var registrationId: Swift.String?
    /// The sender ID that was updated.
    /// This member is required.
    public var senderId: Swift.String?
    /// The Amazon Resource Name (ARN) associated with the SenderId.
    /// This member is required.
    public var senderIdArn: Swift.String?

    public init(
        deletionProtectionEnabled: Swift.Bool = false,
        isoCountryCode: Swift.String? = nil,
        messageTypes: [PinpointSMSVoiceV2ClientTypes.MessageType]? = nil,
        monthlyLeasingPrice: Swift.String? = nil,
        registered: Swift.Bool = false,
        registrationId: Swift.String? = nil,
        senderId: Swift.String? = nil,
        senderIdArn: Swift.String? = nil
    )
    {
        self.deletionProtectionEnabled = deletionProtectionEnabled
        self.isoCountryCode = isoCountryCode
        self.messageTypes = messageTypes
        self.monthlyLeasingPrice = monthlyLeasingPrice
        self.registered = registered
        self.registrationId = registrationId
        self.senderId = senderId
        self.senderIdArn = senderIdArn
    }
}

public struct VerifyDestinationNumberInput: Swift.Sendable {
    /// The verification code that was received by the verified destination phone number.
    /// This member is required.
    public var verificationCode: Swift.String?
    /// The unique identifier for the verififed destination phone number.
    /// This member is required.
    public var verifiedDestinationNumberId: Swift.String?

    public init(
        verificationCode: Swift.String? = nil,
        verifiedDestinationNumberId: Swift.String? = nil
    )
    {
        self.verificationCode = verificationCode
        self.verifiedDestinationNumberId = verifiedDestinationNumberId
    }
}

public struct VerifyDestinationNumberOutput: Swift.Sendable {
    /// The time when the destination phone number was created, in [UNIX epoch time](https://www.epochconverter.com/) format.
    /// This member is required.
    public var createdTimestamp: Foundation.Date?
    /// The phone number in E.164 format.
    /// This member is required.
    public var destinationPhoneNumber: Swift.String?
    /// The status for being able to send messages to the phone number.
    /// This member is required.
    public var status: PinpointSMSVoiceV2ClientTypes.VerificationStatus?
    /// The Amazon Resource Name (ARN) for the verified destination phone number.
    /// This member is required.
    public var verifiedDestinationNumberArn: Swift.String?
    /// The unique identifier for the verified destination phone number.
    /// This member is required.
    public var verifiedDestinationNumberId: Swift.String?

    public init(
        createdTimestamp: Foundation.Date? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        status: PinpointSMSVoiceV2ClientTypes.VerificationStatus? = nil,
        verifiedDestinationNumberArn: Swift.String? = nil,
        verifiedDestinationNumberId: Swift.String? = nil
    )
    {
        self.createdTimestamp = createdTimestamp
        self.destinationPhoneNumber = destinationPhoneNumber
        self.status = status
        self.verifiedDestinationNumberArn = verifiedDestinationNumberArn
        self.verifiedDestinationNumberId = verifiedDestinationNumberId
    }
}

extension AssociateOriginationIdentityInput {

    static func urlPathProvider(_ value: AssociateOriginationIdentityInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateProtectConfigurationInput {

    static func urlPathProvider(_ value: AssociateProtectConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateConfigurationSetInput {

    static func urlPathProvider(_ value: CreateConfigurationSetInput) -> Swift.String? {
        return "/"
    }
}

extension CreateEventDestinationInput {

    static func urlPathProvider(_ value: CreateEventDestinationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateOptOutListInput {

    static func urlPathProvider(_ value: CreateOptOutListInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePoolInput {

    static func urlPathProvider(_ value: CreatePoolInput) -> Swift.String? {
        return "/"
    }
}

extension CreateProtectConfigurationInput {

    static func urlPathProvider(_ value: CreateProtectConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateRegistrationInput {

    static func urlPathProvider(_ value: CreateRegistrationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateRegistrationAssociationInput {

    static func urlPathProvider(_ value: CreateRegistrationAssociationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateRegistrationAttachmentInput {

    static func urlPathProvider(_ value: CreateRegistrationAttachmentInput) -> Swift.String? {
        return "/"
    }
}

extension CreateRegistrationVersionInput {

    static func urlPathProvider(_ value: CreateRegistrationVersionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateVerifiedDestinationNumberInput {

    static func urlPathProvider(_ value: CreateVerifiedDestinationNumberInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAccountDefaultProtectConfigurationInput {

    static func urlPathProvider(_ value: DeleteAccountDefaultProtectConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteConfigurationSetInput {

    static func urlPathProvider(_ value: DeleteConfigurationSetInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDefaultMessageTypeInput {

    static func urlPathProvider(_ value: DeleteDefaultMessageTypeInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDefaultSenderIdInput {

    static func urlPathProvider(_ value: DeleteDefaultSenderIdInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteEventDestinationInput {

    static func urlPathProvider(_ value: DeleteEventDestinationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteKeywordInput {

    static func urlPathProvider(_ value: DeleteKeywordInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteMediaMessageSpendLimitOverrideInput {

    static func urlPathProvider(_ value: DeleteMediaMessageSpendLimitOverrideInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteOptedOutNumberInput {

    static func urlPathProvider(_ value: DeleteOptedOutNumberInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteOptOutListInput {

    static func urlPathProvider(_ value: DeleteOptOutListInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePoolInput {

    static func urlPathProvider(_ value: DeletePoolInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteProtectConfigurationInput {

    static func urlPathProvider(_ value: DeleteProtectConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRegistrationInput {

    static func urlPathProvider(_ value: DeleteRegistrationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRegistrationAttachmentInput {

    static func urlPathProvider(_ value: DeleteRegistrationAttachmentInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRegistrationFieldValueInput {

    static func urlPathProvider(_ value: DeleteRegistrationFieldValueInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteResourcePolicyInput {

    static func urlPathProvider(_ value: DeleteResourcePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTextMessageSpendLimitOverrideInput {

    static func urlPathProvider(_ value: DeleteTextMessageSpendLimitOverrideInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteVerifiedDestinationNumberInput {

    static func urlPathProvider(_ value: DeleteVerifiedDestinationNumberInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteVoiceMessageSpendLimitOverrideInput {

    static func urlPathProvider(_ value: DeleteVoiceMessageSpendLimitOverrideInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAccountAttributesInput {

    static func urlPathProvider(_ value: DescribeAccountAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAccountLimitsInput {

    static func urlPathProvider(_ value: DescribeAccountLimitsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeConfigurationSetsInput {

    static func urlPathProvider(_ value: DescribeConfigurationSetsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeKeywordsInput {

    static func urlPathProvider(_ value: DescribeKeywordsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeOptedOutNumbersInput {

    static func urlPathProvider(_ value: DescribeOptedOutNumbersInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeOptOutListsInput {

    static func urlPathProvider(_ value: DescribeOptOutListsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribePhoneNumbersInput {

    static func urlPathProvider(_ value: DescribePhoneNumbersInput) -> Swift.String? {
        return "/"
    }
}

extension DescribePoolsInput {

    static func urlPathProvider(_ value: DescribePoolsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeProtectConfigurationsInput {

    static func urlPathProvider(_ value: DescribeProtectConfigurationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRegistrationAttachmentsInput {

    static func urlPathProvider(_ value: DescribeRegistrationAttachmentsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRegistrationFieldDefinitionsInput {

    static func urlPathProvider(_ value: DescribeRegistrationFieldDefinitionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRegistrationFieldValuesInput {

    static func urlPathProvider(_ value: DescribeRegistrationFieldValuesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRegistrationsInput {

    static func urlPathProvider(_ value: DescribeRegistrationsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRegistrationSectionDefinitionsInput {

    static func urlPathProvider(_ value: DescribeRegistrationSectionDefinitionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRegistrationTypeDefinitionsInput {

    static func urlPathProvider(_ value: DescribeRegistrationTypeDefinitionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeRegistrationVersionsInput {

    static func urlPathProvider(_ value: DescribeRegistrationVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSenderIdsInput {

    static func urlPathProvider(_ value: DescribeSenderIdsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSpendLimitsInput {

    static func urlPathProvider(_ value: DescribeSpendLimitsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeVerifiedDestinationNumbersInput {

    static func urlPathProvider(_ value: DescribeVerifiedDestinationNumbersInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateOriginationIdentityInput {

    static func urlPathProvider(_ value: DisassociateOriginationIdentityInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateProtectConfigurationInput {

    static func urlPathProvider(_ value: DisassociateProtectConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DiscardRegistrationVersionInput {

    static func urlPathProvider(_ value: DiscardRegistrationVersionInput) -> Swift.String? {
        return "/"
    }
}

extension GetProtectConfigurationCountryRuleSetInput {

    static func urlPathProvider(_ value: GetProtectConfigurationCountryRuleSetInput) -> Swift.String? {
        return "/"
    }
}

extension GetResourcePolicyInput {

    static func urlPathProvider(_ value: GetResourcePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension ListPoolOriginationIdentitiesInput {

    static func urlPathProvider(_ value: ListPoolOriginationIdentitiesInput) -> Swift.String? {
        return "/"
    }
}

extension ListRegistrationAssociationsInput {

    static func urlPathProvider(_ value: ListRegistrationAssociationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension PutKeywordInput {

    static func urlPathProvider(_ value: PutKeywordInput) -> Swift.String? {
        return "/"
    }
}

extension PutOptedOutNumberInput {

    static func urlPathProvider(_ value: PutOptedOutNumberInput) -> Swift.String? {
        return "/"
    }
}

extension PutRegistrationFieldValueInput {

    static func urlPathProvider(_ value: PutRegistrationFieldValueInput) -> Swift.String? {
        return "/"
    }
}

extension PutResourcePolicyInput {

    static func urlPathProvider(_ value: PutResourcePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension ReleasePhoneNumberInput {

    static func urlPathProvider(_ value: ReleasePhoneNumberInput) -> Swift.String? {
        return "/"
    }
}

extension ReleaseSenderIdInput {

    static func urlPathProvider(_ value: ReleaseSenderIdInput) -> Swift.String? {
        return "/"
    }
}

extension RequestPhoneNumberInput {

    static func urlPathProvider(_ value: RequestPhoneNumberInput) -> Swift.String? {
        return "/"
    }
}

extension RequestSenderIdInput {

    static func urlPathProvider(_ value: RequestSenderIdInput) -> Swift.String? {
        return "/"
    }
}

extension SendDestinationNumberVerificationCodeInput {

    static func urlPathProvider(_ value: SendDestinationNumberVerificationCodeInput) -> Swift.String? {
        return "/"
    }
}

extension SendMediaMessageInput {

    static func urlPathProvider(_ value: SendMediaMessageInput) -> Swift.String? {
        return "/"
    }
}

extension SendTextMessageInput {

    static func urlPathProvider(_ value: SendTextMessageInput) -> Swift.String? {
        return "/"
    }
}

extension SendVoiceMessageInput {

    static func urlPathProvider(_ value: SendVoiceMessageInput) -> Swift.String? {
        return "/"
    }
}

extension SetAccountDefaultProtectConfigurationInput {

    static func urlPathProvider(_ value: SetAccountDefaultProtectConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension SetDefaultMessageTypeInput {

    static func urlPathProvider(_ value: SetDefaultMessageTypeInput) -> Swift.String? {
        return "/"
    }
}

extension SetDefaultSenderIdInput {

    static func urlPathProvider(_ value: SetDefaultSenderIdInput) -> Swift.String? {
        return "/"
    }
}

extension SetMediaMessageSpendLimitOverrideInput {

    static func urlPathProvider(_ value: SetMediaMessageSpendLimitOverrideInput) -> Swift.String? {
        return "/"
    }
}

extension SetTextMessageSpendLimitOverrideInput {

    static func urlPathProvider(_ value: SetTextMessageSpendLimitOverrideInput) -> Swift.String? {
        return "/"
    }
}

extension SetVoiceMessageSpendLimitOverrideInput {

    static func urlPathProvider(_ value: SetVoiceMessageSpendLimitOverrideInput) -> Swift.String? {
        return "/"
    }
}

extension SubmitRegistrationVersionInput {

    static func urlPathProvider(_ value: SubmitRegistrationVersionInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateEventDestinationInput {

    static func urlPathProvider(_ value: UpdateEventDestinationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePhoneNumberInput {

    static func urlPathProvider(_ value: UpdatePhoneNumberInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePoolInput {

    static func urlPathProvider(_ value: UpdatePoolInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateProtectConfigurationInput {

    static func urlPathProvider(_ value: UpdateProtectConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateProtectConfigurationCountryRuleSetInput {

    static func urlPathProvider(_ value: UpdateProtectConfigurationCountryRuleSetInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSenderIdInput {

    static func urlPathProvider(_ value: UpdateSenderIdInput) -> Swift.String? {
        return "/"
    }
}

extension VerifyDestinationNumberInput {

    static func urlPathProvider(_ value: VerifyDestinationNumberInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateOriginationIdentityInput {

    static func write(value: AssociateOriginationIdentityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["IsoCountryCode"].write(value.isoCountryCode)
        try writer["OriginationIdentity"].write(value.originationIdentity)
        try writer["PoolId"].write(value.poolId)
    }
}

extension AssociateProtectConfigurationInput {

    static func write(value: AssociateProtectConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationSetName"].write(value.configurationSetName)
        try writer["ProtectConfigurationId"].write(value.protectConfigurationId)
    }
}

extension CreateConfigurationSetInput {

    static func write(value: CreateConfigurationSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["ConfigurationSetName"].write(value.configurationSetName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateEventDestinationInput {

    static func write(value: CreateEventDestinationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["CloudWatchLogsDestination"].write(value.cloudWatchLogsDestination, with: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination.write(value:to:))
        try writer["ConfigurationSetName"].write(value.configurationSetName)
        try writer["EventDestinationName"].write(value.eventDestinationName)
        try writer["KinesisFirehoseDestination"].write(value.kinesisFirehoseDestination, with: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination.write(value:to:))
        try writer["MatchingEventTypes"].writeList(value.matchingEventTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PinpointSMSVoiceV2ClientTypes.EventType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SnsDestination"].write(value.snsDestination, with: PinpointSMSVoiceV2ClientTypes.SnsDestination.write(value:to:))
    }
}

extension CreateOptOutListInput {

    static func write(value: CreateOptOutListInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["OptOutListName"].write(value.optOutListName)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreatePoolInput {

    static func write(value: CreatePoolInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DeletionProtectionEnabled"].write(value.deletionProtectionEnabled)
        try writer["IsoCountryCode"].write(value.isoCountryCode)
        try writer["MessageType"].write(value.messageType)
        try writer["OriginationIdentity"].write(value.originationIdentity)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateProtectConfigurationInput {

    static func write(value: CreateProtectConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DeletionProtectionEnabled"].write(value.deletionProtectionEnabled)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateRegistrationInput {

    static func write(value: CreateRegistrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["RegistrationType"].write(value.registrationType)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateRegistrationAssociationInput {

    static func write(value: CreateRegistrationAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RegistrationId"].write(value.registrationId)
        try writer["ResourceId"].write(value.resourceId)
    }
}

extension CreateRegistrationAttachmentInput {

    static func write(value: CreateRegistrationAttachmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttachmentBody"].write(value.attachmentBody)
        try writer["AttachmentUrl"].write(value.attachmentUrl)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateRegistrationVersionInput {

    static func write(value: CreateRegistrationVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RegistrationId"].write(value.registrationId)
    }
}

extension CreateVerifiedDestinationNumberInput {

    static func write(value: CreateVerifiedDestinationNumberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DestinationPhoneNumber"].write(value.destinationPhoneNumber)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteAccountDefaultProtectConfigurationInput {

    static func write(value: DeleteAccountDefaultProtectConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteConfigurationSetInput {

    static func write(value: DeleteConfigurationSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationSetName"].write(value.configurationSetName)
    }
}

extension DeleteDefaultMessageTypeInput {

    static func write(value: DeleteDefaultMessageTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationSetName"].write(value.configurationSetName)
    }
}

extension DeleteDefaultSenderIdInput {

    static func write(value: DeleteDefaultSenderIdInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationSetName"].write(value.configurationSetName)
    }
}

extension DeleteEventDestinationInput {

    static func write(value: DeleteEventDestinationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationSetName"].write(value.configurationSetName)
        try writer["EventDestinationName"].write(value.eventDestinationName)
    }
}

extension DeleteKeywordInput {

    static func write(value: DeleteKeywordInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Keyword"].write(value.keyword)
        try writer["OriginationIdentity"].write(value.originationIdentity)
    }
}

extension DeleteMediaMessageSpendLimitOverrideInput {

    static func write(value: DeleteMediaMessageSpendLimitOverrideInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteOptedOutNumberInput {

    static func write(value: DeleteOptedOutNumberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OptOutListName"].write(value.optOutListName)
        try writer["OptedOutNumber"].write(value.optedOutNumber)
    }
}

extension DeleteOptOutListInput {

    static func write(value: DeleteOptOutListInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OptOutListName"].write(value.optOutListName)
    }
}

extension DeletePoolInput {

    static func write(value: DeletePoolInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PoolId"].write(value.poolId)
    }
}

extension DeleteProtectConfigurationInput {

    static func write(value: DeleteProtectConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProtectConfigurationId"].write(value.protectConfigurationId)
    }
}

extension DeleteRegistrationInput {

    static func write(value: DeleteRegistrationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RegistrationId"].write(value.registrationId)
    }
}

extension DeleteRegistrationAttachmentInput {

    static func write(value: DeleteRegistrationAttachmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RegistrationAttachmentId"].write(value.registrationAttachmentId)
    }
}

extension DeleteRegistrationFieldValueInput {

    static func write(value: DeleteRegistrationFieldValueInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldPath"].write(value.fieldPath)
        try writer["RegistrationId"].write(value.registrationId)
    }
}

extension DeleteResourcePolicyInput {

    static func write(value: DeleteResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension DeleteTextMessageSpendLimitOverrideInput {

    static func write(value: DeleteTextMessageSpendLimitOverrideInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteVerifiedDestinationNumberInput {

    static func write(value: DeleteVerifiedDestinationNumberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VerifiedDestinationNumberId"].write(value.verifiedDestinationNumberId)
    }
}

extension DeleteVoiceMessageSpendLimitOverrideInput {

    static func write(value: DeleteVoiceMessageSpendLimitOverrideInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribeAccountAttributesInput {

    static func write(value: DescribeAccountAttributesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeAccountLimitsInput {

    static func write(value: DescribeAccountLimitsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeConfigurationSetsInput {

    static func write(value: DescribeConfigurationSetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationSetNames"].writeList(value.configurationSetNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filters"].writeList(value.filters, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeKeywordsInput {

    static func write(value: DescribeKeywordsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.KeywordFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Keywords"].writeList(value.keywords, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OriginationIdentity"].write(value.originationIdentity)
    }
}

extension DescribeOptedOutNumbersInput {

    static func write(value: DescribeOptedOutNumbersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.OptedOutFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OptOutListName"].write(value.optOutListName)
        try writer["OptedOutNumbers"].writeList(value.optedOutNumbers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeOptOutListsInput {

    static func write(value: DescribeOptOutListsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OptOutListNames"].writeList(value.optOutListNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Owner"].write(value.owner)
    }
}

extension DescribePhoneNumbersInput {

    static func write(value: DescribePhoneNumbersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.PhoneNumberFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Owner"].write(value.owner)
        try writer["PhoneNumberIds"].writeList(value.phoneNumberIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribePoolsInput {

    static func write(value: DescribePoolsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.PoolFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Owner"].write(value.owner)
        try writer["PoolIds"].writeList(value.poolIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeProtectConfigurationsInput {

    static func write(value: DescribeProtectConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.ProtectConfigurationFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ProtectConfigurationIds"].writeList(value.protectConfigurationIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeRegistrationAttachmentsInput {

    static func write(value: DescribeRegistrationAttachmentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RegistrationAttachmentIds"].writeList(value.registrationAttachmentIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeRegistrationFieldDefinitionsInput {

    static func write(value: DescribeRegistrationFieldDefinitionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldPaths"].writeList(value.fieldPaths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RegistrationType"].write(value.registrationType)
        try writer["SectionPath"].write(value.sectionPath)
    }
}

extension DescribeRegistrationFieldValuesInput {

    static func write(value: DescribeRegistrationFieldValuesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldPaths"].writeList(value.fieldPaths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RegistrationId"].write(value.registrationId)
        try writer["SectionPath"].write(value.sectionPath)
        try writer["VersionNumber"].write(value.versionNumber)
    }
}

extension DescribeRegistrationsInput {

    static func write(value: DescribeRegistrationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.RegistrationFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RegistrationIds"].writeList(value.registrationIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeRegistrationSectionDefinitionsInput {

    static func write(value: DescribeRegistrationSectionDefinitionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RegistrationType"].write(value.registrationType)
        try writer["SectionPaths"].writeList(value.sectionPaths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeRegistrationTypeDefinitionsInput {

    static func write(value: DescribeRegistrationTypeDefinitionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.RegistrationTypeFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RegistrationTypes"].writeList(value.registrationTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeRegistrationVersionsInput {

    static func write(value: DescribeRegistrationVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.RegistrationVersionFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RegistrationId"].write(value.registrationId)
        try writer["VersionNumbers"].writeList(value.versionNumbers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeInt(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeSenderIdsInput {

    static func write(value: DescribeSenderIdsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.SenderIdFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Owner"].write(value.owner)
        try writer["SenderIds"].writeList(value.senderIds, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.SenderIdAndCountry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DescribeSpendLimitsInput {

    static func write(value: DescribeSpendLimitsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeVerifiedDestinationNumbersInput {

    static func write(value: DescribeVerifiedDestinationNumbersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationPhoneNumbers"].writeList(value.destinationPhoneNumbers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filters"].writeList(value.filters, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["VerifiedDestinationNumberIds"].writeList(value.verifiedDestinationNumberIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DisassociateOriginationIdentityInput {

    static func write(value: DisassociateOriginationIdentityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["IsoCountryCode"].write(value.isoCountryCode)
        try writer["OriginationIdentity"].write(value.originationIdentity)
        try writer["PoolId"].write(value.poolId)
    }
}

extension DisassociateProtectConfigurationInput {

    static func write(value: DisassociateProtectConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationSetName"].write(value.configurationSetName)
        try writer["ProtectConfigurationId"].write(value.protectConfigurationId)
    }
}

extension DiscardRegistrationVersionInput {

    static func write(value: DiscardRegistrationVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RegistrationId"].write(value.registrationId)
    }
}

extension GetProtectConfigurationCountryRuleSetInput {

    static func write(value: GetProtectConfigurationCountryRuleSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NumberCapability"].write(value.numberCapability)
        try writer["ProtectConfigurationId"].write(value.protectConfigurationId)
    }
}

extension GetResourcePolicyInput {

    static func write(value: GetResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension ListPoolOriginationIdentitiesInput {

    static func write(value: ListPoolOriginationIdentitiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PoolId"].write(value.poolId)
    }
}

extension ListRegistrationAssociationsInput {

    static func write(value: ListRegistrationAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.RegistrationAssociationFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RegistrationId"].write(value.registrationId)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension PutKeywordInput {

    static func write(value: PutKeywordInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Keyword"].write(value.keyword)
        try writer["KeywordAction"].write(value.keywordAction)
        try writer["KeywordMessage"].write(value.keywordMessage)
        try writer["OriginationIdentity"].write(value.originationIdentity)
    }
}

extension PutOptedOutNumberInput {

    static func write(value: PutOptedOutNumberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OptOutListName"].write(value.optOutListName)
        try writer["OptedOutNumber"].write(value.optedOutNumber)
    }
}

extension PutRegistrationFieldValueInput {

    static func write(value: PutRegistrationFieldValueInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldPath"].write(value.fieldPath)
        try writer["RegistrationAttachmentId"].write(value.registrationAttachmentId)
        try writer["RegistrationId"].write(value.registrationId)
        try writer["SelectChoices"].writeList(value.selectChoices, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TextValue"].write(value.textValue)
    }
}

extension PutResourcePolicyInput {

    static func write(value: PutResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Policy"].write(value.policy)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension ReleasePhoneNumberInput {

    static func write(value: ReleasePhoneNumberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PhoneNumberId"].write(value.phoneNumberId)
    }
}

extension ReleaseSenderIdInput {

    static func write(value: ReleaseSenderIdInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IsoCountryCode"].write(value.isoCountryCode)
        try writer["SenderId"].write(value.senderId)
    }
}

extension RequestPhoneNumberInput {

    static func write(value: RequestPhoneNumberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DeletionProtectionEnabled"].write(value.deletionProtectionEnabled)
        try writer["IsoCountryCode"].write(value.isoCountryCode)
        try writer["MessageType"].write(value.messageType)
        try writer["NumberCapabilities"].writeList(value.numberCapabilities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PinpointSMSVoiceV2ClientTypes.NumberCapability>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NumberType"].write(value.numberType)
        try writer["OptOutListName"].write(value.optOutListName)
        try writer["PoolId"].write(value.poolId)
        try writer["RegistrationId"].write(value.registrationId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension RequestSenderIdInput {

    static func write(value: RequestSenderIdInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DeletionProtectionEnabled"].write(value.deletionProtectionEnabled)
        try writer["IsoCountryCode"].write(value.isoCountryCode)
        try writer["MessageTypes"].writeList(value.messageTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PinpointSMSVoiceV2ClientTypes.MessageType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SenderId"].write(value.senderId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SendDestinationNumberVerificationCodeInput {

    static func write(value: SendDestinationNumberVerificationCodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationSetName"].write(value.configurationSetName)
        try writer["Context"].writeMap(value.context, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["DestinationCountryParameters"].writeMap(value.destinationCountryParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["LanguageCode"].write(value.languageCode)
        try writer["OriginationIdentity"].write(value.originationIdentity)
        try writer["VerificationChannel"].write(value.verificationChannel)
        try writer["VerifiedDestinationNumberId"].write(value.verifiedDestinationNumberId)
    }
}

extension SendMediaMessageInput {

    static func write(value: SendMediaMessageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationSetName"].write(value.configurationSetName)
        try writer["Context"].writeMap(value.context, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["DestinationPhoneNumber"].write(value.destinationPhoneNumber)
        try writer["DryRun"].write(value.dryRun)
        try writer["MaxPrice"].write(value.maxPrice)
        try writer["MediaUrls"].writeList(value.mediaUrls, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MessageBody"].write(value.messageBody)
        try writer["OriginationIdentity"].write(value.originationIdentity)
        try writer["ProtectConfigurationId"].write(value.protectConfigurationId)
        try writer["TimeToLive"].write(value.timeToLive)
    }
}

extension SendTextMessageInput {

    static func write(value: SendTextMessageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationSetName"].write(value.configurationSetName)
        try writer["Context"].writeMap(value.context, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["DestinationCountryParameters"].writeMap(value.destinationCountryParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["DestinationPhoneNumber"].write(value.destinationPhoneNumber)
        try writer["DryRun"].write(value.dryRun)
        try writer["Keyword"].write(value.keyword)
        try writer["MaxPrice"].write(value.maxPrice)
        try writer["MessageBody"].write(value.messageBody)
        try writer["MessageType"].write(value.messageType)
        try writer["OriginationIdentity"].write(value.originationIdentity)
        try writer["ProtectConfigurationId"].write(value.protectConfigurationId)
        try writer["TimeToLive"].write(value.timeToLive)
    }
}

extension SendVoiceMessageInput {

    static func write(value: SendVoiceMessageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationSetName"].write(value.configurationSetName)
        try writer["Context"].writeMap(value.context, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["DestinationPhoneNumber"].write(value.destinationPhoneNumber)
        try writer["DryRun"].write(value.dryRun)
        try writer["MaxPricePerMinute"].write(value.maxPricePerMinute)
        try writer["MessageBody"].write(value.messageBody)
        try writer["MessageBodyTextType"].write(value.messageBodyTextType)
        try writer["OriginationIdentity"].write(value.originationIdentity)
        try writer["ProtectConfigurationId"].write(value.protectConfigurationId)
        try writer["TimeToLive"].write(value.timeToLive)
        try writer["VoiceId"].write(value.voiceId)
    }
}

extension SetAccountDefaultProtectConfigurationInput {

    static func write(value: SetAccountDefaultProtectConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProtectConfigurationId"].write(value.protectConfigurationId)
    }
}

extension SetDefaultMessageTypeInput {

    static func write(value: SetDefaultMessageTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationSetName"].write(value.configurationSetName)
        try writer["MessageType"].write(value.messageType)
    }
}

extension SetDefaultSenderIdInput {

    static func write(value: SetDefaultSenderIdInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConfigurationSetName"].write(value.configurationSetName)
        try writer["SenderId"].write(value.senderId)
    }
}

extension SetMediaMessageSpendLimitOverrideInput {

    static func write(value: SetMediaMessageSpendLimitOverrideInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MonthlyLimit"].write(value.monthlyLimit)
    }
}

extension SetTextMessageSpendLimitOverrideInput {

    static func write(value: SetTextMessageSpendLimitOverrideInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MonthlyLimit"].write(value.monthlyLimit)
    }
}

extension SetVoiceMessageSpendLimitOverrideInput {

    static func write(value: SetVoiceMessageSpendLimitOverrideInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MonthlyLimit"].write(value.monthlyLimit)
    }
}

extension SubmitRegistrationVersionInput {

    static func write(value: SubmitRegistrationVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RegistrationId"].write(value.registrationId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PinpointSMSVoiceV2ClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateEventDestinationInput {

    static func write(value: UpdateEventDestinationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CloudWatchLogsDestination"].write(value.cloudWatchLogsDestination, with: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination.write(value:to:))
        try writer["ConfigurationSetName"].write(value.configurationSetName)
        try writer["Enabled"].write(value.enabled)
        try writer["EventDestinationName"].write(value.eventDestinationName)
        try writer["KinesisFirehoseDestination"].write(value.kinesisFirehoseDestination, with: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination.write(value:to:))
        try writer["MatchingEventTypes"].writeList(value.matchingEventTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PinpointSMSVoiceV2ClientTypes.EventType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SnsDestination"].write(value.snsDestination, with: PinpointSMSVoiceV2ClientTypes.SnsDestination.write(value:to:))
    }
}

extension UpdatePhoneNumberInput {

    static func write(value: UpdatePhoneNumberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeletionProtectionEnabled"].write(value.deletionProtectionEnabled)
        try writer["OptOutListName"].write(value.optOutListName)
        try writer["PhoneNumberId"].write(value.phoneNumberId)
        try writer["SelfManagedOptOutsEnabled"].write(value.selfManagedOptOutsEnabled)
        try writer["TwoWayChannelArn"].write(value.twoWayChannelArn)
        try writer["TwoWayChannelRole"].write(value.twoWayChannelRole)
        try writer["TwoWayEnabled"].write(value.twoWayEnabled)
    }
}

extension UpdatePoolInput {

    static func write(value: UpdatePoolInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeletionProtectionEnabled"].write(value.deletionProtectionEnabled)
        try writer["OptOutListName"].write(value.optOutListName)
        try writer["PoolId"].write(value.poolId)
        try writer["SelfManagedOptOutsEnabled"].write(value.selfManagedOptOutsEnabled)
        try writer["SharedRoutesEnabled"].write(value.sharedRoutesEnabled)
        try writer["TwoWayChannelArn"].write(value.twoWayChannelArn)
        try writer["TwoWayChannelRole"].write(value.twoWayChannelRole)
        try writer["TwoWayEnabled"].write(value.twoWayEnabled)
    }
}

extension UpdateProtectConfigurationInput {

    static func write(value: UpdateProtectConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeletionProtectionEnabled"].write(value.deletionProtectionEnabled)
        try writer["ProtectConfigurationId"].write(value.protectConfigurationId)
    }
}

extension UpdateProtectConfigurationCountryRuleSetInput {

    static func write(value: UpdateProtectConfigurationCountryRuleSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CountryRuleSetUpdates"].writeMap(value.countryRuleSetUpdates, valueWritingClosure: PinpointSMSVoiceV2ClientTypes.ProtectConfigurationCountryRuleSetInformation.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["NumberCapability"].write(value.numberCapability)
        try writer["ProtectConfigurationId"].write(value.protectConfigurationId)
    }
}

extension UpdateSenderIdInput {

    static func write(value: UpdateSenderIdInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeletionProtectionEnabled"].write(value.deletionProtectionEnabled)
        try writer["IsoCountryCode"].write(value.isoCountryCode)
        try writer["SenderId"].write(value.senderId)
    }
}

extension VerifyDestinationNumberInput {

    static func write(value: VerifyDestinationNumberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VerificationCode"].write(value.verificationCode)
        try writer["VerifiedDestinationNumberId"].write(value.verifiedDestinationNumberId)
    }
}

extension AssociateOriginationIdentityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateOriginationIdentityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateOriginationIdentityOutput()
        value.isoCountryCode = try reader["IsoCountryCode"].readIfPresent()
        value.originationIdentity = try reader["OriginationIdentity"].readIfPresent()
        value.originationIdentityArn = try reader["OriginationIdentityArn"].readIfPresent()
        value.poolArn = try reader["PoolArn"].readIfPresent()
        value.poolId = try reader["PoolId"].readIfPresent()
        return value
    }
}

extension AssociateProtectConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateProtectConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateProtectConfigurationOutput()
        value.configurationSetArn = try reader["ConfigurationSetArn"].readIfPresent() ?? ""
        value.configurationSetName = try reader["ConfigurationSetName"].readIfPresent() ?? ""
        value.protectConfigurationArn = try reader["ProtectConfigurationArn"].readIfPresent() ?? ""
        value.protectConfigurationId = try reader["ProtectConfigurationId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateConfigurationSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConfigurationSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConfigurationSetOutput()
        value.configurationSetArn = try reader["ConfigurationSetArn"].readIfPresent()
        value.configurationSetName = try reader["ConfigurationSetName"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateEventDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEventDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEventDestinationOutput()
        value.configurationSetArn = try reader["ConfigurationSetArn"].readIfPresent()
        value.configurationSetName = try reader["ConfigurationSetName"].readIfPresent()
        value.eventDestination = try reader["EventDestination"].readIfPresent(with: PinpointSMSVoiceV2ClientTypes.EventDestination.read(from:))
        return value
    }
}

extension CreateOptOutListOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOptOutListOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOptOutListOutput()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.optOutListArn = try reader["OptOutListArn"].readIfPresent()
        value.optOutListName = try reader["OptOutListName"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreatePoolOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePoolOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePoolOutput()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletionProtectionEnabled = try reader["DeletionProtectionEnabled"].readIfPresent() ?? false
        value.messageType = try reader["MessageType"].readIfPresent()
        value.optOutListName = try reader["OptOutListName"].readIfPresent()
        value.poolArn = try reader["PoolArn"].readIfPresent()
        value.poolId = try reader["PoolId"].readIfPresent()
        value.selfManagedOptOutsEnabled = try reader["SelfManagedOptOutsEnabled"].readIfPresent() ?? false
        value.sharedRoutesEnabled = try reader["SharedRoutesEnabled"].readIfPresent() ?? false
        value.status = try reader["Status"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.twoWayChannelArn = try reader["TwoWayChannelArn"].readIfPresent()
        value.twoWayChannelRole = try reader["TwoWayChannelRole"].readIfPresent()
        value.twoWayEnabled = try reader["TwoWayEnabled"].readIfPresent() ?? false
        return value
    }
}

extension CreateProtectConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProtectConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProtectConfigurationOutput()
        value.accountDefault = try reader["AccountDefault"].readIfPresent() ?? false
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.deletionProtectionEnabled = try reader["DeletionProtectionEnabled"].readIfPresent() ?? false
        value.protectConfigurationArn = try reader["ProtectConfigurationArn"].readIfPresent() ?? ""
        value.protectConfigurationId = try reader["ProtectConfigurationId"].readIfPresent() ?? ""
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateRegistrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRegistrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRegistrationOutput()
        value.additionalAttributes = try reader["AdditionalAttributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.currentVersionNumber = try reader["CurrentVersionNumber"].readIfPresent() ?? 0
        value.registrationArn = try reader["RegistrationArn"].readIfPresent() ?? ""
        value.registrationId = try reader["RegistrationId"].readIfPresent() ?? ""
        value.registrationStatus = try reader["RegistrationStatus"].readIfPresent() ?? .sdkUnknown("")
        value.registrationType = try reader["RegistrationType"].readIfPresent() ?? ""
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateRegistrationAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRegistrationAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRegistrationAssociationOutput()
        value.isoCountryCode = try reader["IsoCountryCode"].readIfPresent()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.registrationArn = try reader["RegistrationArn"].readIfPresent() ?? ""
        value.registrationId = try reader["RegistrationId"].readIfPresent() ?? ""
        value.registrationType = try reader["RegistrationType"].readIfPresent() ?? ""
        value.resourceArn = try reader["ResourceArn"].readIfPresent() ?? ""
        value.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        return value
    }
}

extension CreateRegistrationAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRegistrationAttachmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRegistrationAttachmentOutput()
        value.attachmentStatus = try reader["AttachmentStatus"].readIfPresent() ?? .sdkUnknown("")
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.registrationAttachmentArn = try reader["RegistrationAttachmentArn"].readIfPresent() ?? ""
        value.registrationAttachmentId = try reader["RegistrationAttachmentId"].readIfPresent() ?? ""
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateRegistrationVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRegistrationVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRegistrationVersionOutput()
        value.registrationArn = try reader["RegistrationArn"].readIfPresent() ?? ""
        value.registrationId = try reader["RegistrationId"].readIfPresent() ?? ""
        value.registrationVersionStatus = try reader["RegistrationVersionStatus"].readIfPresent() ?? .sdkUnknown("")
        value.registrationVersionStatusHistory = try reader["RegistrationVersionStatusHistory"].readIfPresent(with: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory.read(from:))
        value.versionNumber = try reader["VersionNumber"].readIfPresent() ?? 0
        return value
    }
}

extension CreateVerifiedDestinationNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVerifiedDestinationNumberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVerifiedDestinationNumberOutput()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.destinationPhoneNumber = try reader["DestinationPhoneNumber"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.verifiedDestinationNumberArn = try reader["VerifiedDestinationNumberArn"].readIfPresent() ?? ""
        value.verifiedDestinationNumberId = try reader["VerifiedDestinationNumberId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteAccountDefaultProtectConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccountDefaultProtectConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAccountDefaultProtectConfigurationOutput()
        value.defaultProtectConfigurationArn = try reader["DefaultProtectConfigurationArn"].readIfPresent() ?? ""
        value.defaultProtectConfigurationId = try reader["DefaultProtectConfigurationId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteConfigurationSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConfigurationSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteConfigurationSetOutput()
        value.configurationSetArn = try reader["ConfigurationSetArn"].readIfPresent()
        value.configurationSetName = try reader["ConfigurationSetName"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaultMessageType = try reader["DefaultMessageType"].readIfPresent()
        value.defaultSenderId = try reader["DefaultSenderId"].readIfPresent()
        value.eventDestinations = try reader["EventDestinations"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.EventDestination.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeleteDefaultMessageTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDefaultMessageTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDefaultMessageTypeOutput()
        value.configurationSetArn = try reader["ConfigurationSetArn"].readIfPresent()
        value.configurationSetName = try reader["ConfigurationSetName"].readIfPresent()
        value.messageType = try reader["MessageType"].readIfPresent()
        return value
    }
}

extension DeleteDefaultSenderIdOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDefaultSenderIdOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDefaultSenderIdOutput()
        value.configurationSetArn = try reader["ConfigurationSetArn"].readIfPresent()
        value.configurationSetName = try reader["ConfigurationSetName"].readIfPresent()
        value.senderId = try reader["SenderId"].readIfPresent()
        return value
    }
}

extension DeleteEventDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEventDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEventDestinationOutput()
        value.configurationSetArn = try reader["ConfigurationSetArn"].readIfPresent()
        value.configurationSetName = try reader["ConfigurationSetName"].readIfPresent()
        value.eventDestination = try reader["EventDestination"].readIfPresent(with: PinpointSMSVoiceV2ClientTypes.EventDestination.read(from:))
        return value
    }
}

extension DeleteKeywordOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteKeywordOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteKeywordOutput()
        value.keyword = try reader["Keyword"].readIfPresent()
        value.keywordAction = try reader["KeywordAction"].readIfPresent()
        value.keywordMessage = try reader["KeywordMessage"].readIfPresent()
        value.originationIdentity = try reader["OriginationIdentity"].readIfPresent()
        value.originationIdentityArn = try reader["OriginationIdentityArn"].readIfPresent()
        return value
    }
}

extension DeleteMediaMessageSpendLimitOverrideOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMediaMessageSpendLimitOverrideOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteMediaMessageSpendLimitOverrideOutput()
        value.monthlyLimit = try reader["MonthlyLimit"].readIfPresent()
        return value
    }
}

extension DeleteOptedOutNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOptedOutNumberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteOptedOutNumberOutput()
        value.endUserOptedOut = try reader["EndUserOptedOut"].readIfPresent() ?? false
        value.optOutListArn = try reader["OptOutListArn"].readIfPresent()
        value.optOutListName = try reader["OptOutListName"].readIfPresent()
        value.optedOutNumber = try reader["OptedOutNumber"].readIfPresent()
        value.optedOutTimestamp = try reader["OptedOutTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DeleteOptOutListOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOptOutListOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteOptOutListOutput()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.optOutListArn = try reader["OptOutListArn"].readIfPresent()
        value.optOutListName = try reader["OptOutListName"].readIfPresent()
        return value
    }
}

extension DeletePoolOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePoolOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeletePoolOutput()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.messageType = try reader["MessageType"].readIfPresent()
        value.optOutListName = try reader["OptOutListName"].readIfPresent()
        value.poolArn = try reader["PoolArn"].readIfPresent()
        value.poolId = try reader["PoolId"].readIfPresent()
        value.selfManagedOptOutsEnabled = try reader["SelfManagedOptOutsEnabled"].readIfPresent() ?? false
        value.sharedRoutesEnabled = try reader["SharedRoutesEnabled"].readIfPresent() ?? false
        value.status = try reader["Status"].readIfPresent()
        value.twoWayChannelArn = try reader["TwoWayChannelArn"].readIfPresent()
        value.twoWayChannelRole = try reader["TwoWayChannelRole"].readIfPresent()
        value.twoWayEnabled = try reader["TwoWayEnabled"].readIfPresent() ?? false
        return value
    }
}

extension DeleteProtectConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProtectConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteProtectConfigurationOutput()
        value.accountDefault = try reader["AccountDefault"].readIfPresent() ?? false
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.deletionProtectionEnabled = try reader["DeletionProtectionEnabled"].readIfPresent() ?? false
        value.protectConfigurationArn = try reader["ProtectConfigurationArn"].readIfPresent() ?? ""
        value.protectConfigurationId = try reader["ProtectConfigurationId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteRegistrationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRegistrationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteRegistrationOutput()
        value.additionalAttributes = try reader["AdditionalAttributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.approvedVersionNumber = try reader["ApprovedVersionNumber"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.currentVersionNumber = try reader["CurrentVersionNumber"].readIfPresent() ?? 0
        value.latestDeniedVersionNumber = try reader["LatestDeniedVersionNumber"].readIfPresent()
        value.registrationArn = try reader["RegistrationArn"].readIfPresent() ?? ""
        value.registrationId = try reader["RegistrationId"].readIfPresent() ?? ""
        value.registrationStatus = try reader["RegistrationStatus"].readIfPresent() ?? .sdkUnknown("")
        value.registrationType = try reader["RegistrationType"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteRegistrationAttachmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRegistrationAttachmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteRegistrationAttachmentOutput()
        value.attachmentStatus = try reader["AttachmentStatus"].readIfPresent() ?? .sdkUnknown("")
        value.attachmentUploadErrorReason = try reader["AttachmentUploadErrorReason"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.registrationAttachmentArn = try reader["RegistrationAttachmentArn"].readIfPresent() ?? ""
        value.registrationAttachmentId = try reader["RegistrationAttachmentId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteRegistrationFieldValueOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRegistrationFieldValueOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteRegistrationFieldValueOutput()
        value.fieldPath = try reader["FieldPath"].readIfPresent() ?? ""
        value.registrationArn = try reader["RegistrationArn"].readIfPresent() ?? ""
        value.registrationAttachmentId = try reader["RegistrationAttachmentId"].readIfPresent()
        value.registrationId = try reader["RegistrationId"].readIfPresent() ?? ""
        value.selectChoices = try reader["SelectChoices"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.textValue = try reader["TextValue"].readIfPresent()
        value.versionNumber = try reader["VersionNumber"].readIfPresent() ?? 0
        return value
    }
}

extension DeleteResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteResourcePolicyOutput()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.policy = try reader["Policy"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        return value
    }
}

extension DeleteTextMessageSpendLimitOverrideOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTextMessageSpendLimitOverrideOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteTextMessageSpendLimitOverrideOutput()
        value.monthlyLimit = try reader["MonthlyLimit"].readIfPresent()
        return value
    }
}

extension DeleteVerifiedDestinationNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVerifiedDestinationNumberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteVerifiedDestinationNumberOutput()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.destinationPhoneNumber = try reader["DestinationPhoneNumber"].readIfPresent() ?? ""
        value.verifiedDestinationNumberArn = try reader["VerifiedDestinationNumberArn"].readIfPresent() ?? ""
        value.verifiedDestinationNumberId = try reader["VerifiedDestinationNumberId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteVoiceMessageSpendLimitOverrideOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVoiceMessageSpendLimitOverrideOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteVoiceMessageSpendLimitOverrideOutput()
        value.monthlyLimit = try reader["MonthlyLimit"].readIfPresent()
        return value
    }
}

extension DescribeAccountAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAccountAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAccountAttributesOutput()
        value.accountAttributes = try reader["AccountAttributes"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.AccountAttribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeAccountLimitsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAccountLimitsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAccountLimitsOutput()
        value.accountLimits = try reader["AccountLimits"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.AccountLimit.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeConfigurationSetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConfigurationSetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConfigurationSetsOutput()
        value.configurationSets = try reader["ConfigurationSets"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeKeywordsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeKeywordsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeKeywordsOutput()
        value.keywords = try reader["Keywords"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.KeywordInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.originationIdentity = try reader["OriginationIdentity"].readIfPresent()
        value.originationIdentityArn = try reader["OriginationIdentityArn"].readIfPresent()
        return value
    }
}

extension DescribeOptedOutNumbersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeOptedOutNumbersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeOptedOutNumbersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.optOutListArn = try reader["OptOutListArn"].readIfPresent()
        value.optOutListName = try reader["OptOutListName"].readIfPresent()
        value.optedOutNumbers = try reader["OptedOutNumbers"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeOptOutListsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeOptOutListsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeOptOutListsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.optOutLists = try reader["OptOutLists"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.OptOutListInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribePhoneNumbersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePhoneNumbersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePhoneNumbersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.phoneNumbers = try reader["PhoneNumbers"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribePoolsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePoolsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePoolsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.pools = try reader["Pools"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.PoolInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeProtectConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProtectConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProtectConfigurationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.protectConfigurations = try reader["ProtectConfigurations"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.ProtectConfigurationInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeRegistrationAttachmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRegistrationAttachmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRegistrationAttachmentsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.registrationAttachments = try reader["RegistrationAttachments"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentsInformation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DescribeRegistrationFieldDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRegistrationFieldDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRegistrationFieldDefinitionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.registrationFieldDefinitions = try reader["RegistrationFieldDefinitions"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.RegistrationFieldDefinition.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.registrationType = try reader["RegistrationType"].readIfPresent() ?? ""
        return value
    }
}

extension DescribeRegistrationFieldValuesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRegistrationFieldValuesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRegistrationFieldValuesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.registrationArn = try reader["RegistrationArn"].readIfPresent() ?? ""
        value.registrationFieldValues = try reader["RegistrationFieldValues"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.RegistrationFieldValueInformation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.registrationId = try reader["RegistrationId"].readIfPresent() ?? ""
        value.versionNumber = try reader["VersionNumber"].readIfPresent() ?? 0
        return value
    }
}

extension DescribeRegistrationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRegistrationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRegistrationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.registrations = try reader["Registrations"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.RegistrationInformation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DescribeRegistrationSectionDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRegistrationSectionDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRegistrationSectionDefinitionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.registrationSectionDefinitions = try reader["RegistrationSectionDefinitions"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.RegistrationSectionDefinition.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.registrationType = try reader["RegistrationType"].readIfPresent() ?? ""
        return value
    }
}

extension DescribeRegistrationTypeDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRegistrationTypeDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRegistrationTypeDefinitionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.registrationTypeDefinitions = try reader["RegistrationTypeDefinitions"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.RegistrationTypeDefinition.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DescribeRegistrationVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeRegistrationVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRegistrationVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.registrationArn = try reader["RegistrationArn"].readIfPresent() ?? ""
        value.registrationId = try reader["RegistrationId"].readIfPresent() ?? ""
        value.registrationVersions = try reader["RegistrationVersions"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.RegistrationVersionInformation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DescribeSenderIdsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSenderIdsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSenderIdsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.senderIds = try reader["SenderIds"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.SenderIdInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeSpendLimitsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSpendLimitsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSpendLimitsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.spendLimits = try reader["SpendLimits"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.SpendLimit.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeVerifiedDestinationNumbersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeVerifiedDestinationNumbersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeVerifiedDestinationNumbersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.verifiedDestinationNumbers = try reader["VerifiedDestinationNumbers"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberInformation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DisassociateOriginationIdentityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateOriginationIdentityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateOriginationIdentityOutput()
        value.isoCountryCode = try reader["IsoCountryCode"].readIfPresent()
        value.originationIdentity = try reader["OriginationIdentity"].readIfPresent()
        value.originationIdentityArn = try reader["OriginationIdentityArn"].readIfPresent()
        value.poolArn = try reader["PoolArn"].readIfPresent()
        value.poolId = try reader["PoolId"].readIfPresent()
        return value
    }
}

extension DisassociateProtectConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateProtectConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateProtectConfigurationOutput()
        value.configurationSetArn = try reader["ConfigurationSetArn"].readIfPresent() ?? ""
        value.configurationSetName = try reader["ConfigurationSetName"].readIfPresent() ?? ""
        value.protectConfigurationArn = try reader["ProtectConfigurationArn"].readIfPresent() ?? ""
        value.protectConfigurationId = try reader["ProtectConfigurationId"].readIfPresent() ?? ""
        return value
    }
}

extension DiscardRegistrationVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DiscardRegistrationVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DiscardRegistrationVersionOutput()
        value.registrationArn = try reader["RegistrationArn"].readIfPresent() ?? ""
        value.registrationId = try reader["RegistrationId"].readIfPresent() ?? ""
        value.registrationVersionStatus = try reader["RegistrationVersionStatus"].readIfPresent() ?? .sdkUnknown("")
        value.registrationVersionStatusHistory = try reader["RegistrationVersionStatusHistory"].readIfPresent(with: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory.read(from:))
        value.versionNumber = try reader["VersionNumber"].readIfPresent() ?? 0
        return value
    }
}

extension GetProtectConfigurationCountryRuleSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProtectConfigurationCountryRuleSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProtectConfigurationCountryRuleSetOutput()
        value.countryRuleSet = try reader["CountryRuleSet"].readMapIfPresent(valueReadingClosure: PinpointSMSVoiceV2ClientTypes.ProtectConfigurationCountryRuleSetInformation.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.numberCapability = try reader["NumberCapability"].readIfPresent() ?? .sdkUnknown("")
        value.protectConfigurationArn = try reader["ProtectConfigurationArn"].readIfPresent() ?? ""
        value.protectConfigurationId = try reader["ProtectConfigurationId"].readIfPresent() ?? ""
        return value
    }
}

extension GetResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePolicyOutput()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.policy = try reader["Policy"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        return value
    }
}

extension ListPoolOriginationIdentitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPoolOriginationIdentitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPoolOriginationIdentitiesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.originationIdentities = try reader["OriginationIdentities"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.poolArn = try reader["PoolArn"].readIfPresent()
        value.poolId = try reader["PoolId"].readIfPresent()
        return value
    }
}

extension ListRegistrationAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRegistrationAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRegistrationAssociationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.registrationArn = try reader["RegistrationArn"].readIfPresent() ?? ""
        value.registrationAssociations = try reader["RegistrationAssociations"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.RegistrationAssociationMetadata.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.registrationId = try reader["RegistrationId"].readIfPresent() ?? ""
        value.registrationType = try reader["RegistrationType"].readIfPresent() ?? ""
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutKeywordOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutKeywordOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutKeywordOutput()
        value.keyword = try reader["Keyword"].readIfPresent()
        value.keywordAction = try reader["KeywordAction"].readIfPresent()
        value.keywordMessage = try reader["KeywordMessage"].readIfPresent()
        value.originationIdentity = try reader["OriginationIdentity"].readIfPresent()
        value.originationIdentityArn = try reader["OriginationIdentityArn"].readIfPresent()
        return value
    }
}

extension PutOptedOutNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutOptedOutNumberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutOptedOutNumberOutput()
        value.endUserOptedOut = try reader["EndUserOptedOut"].readIfPresent() ?? false
        value.optOutListArn = try reader["OptOutListArn"].readIfPresent()
        value.optOutListName = try reader["OptOutListName"].readIfPresent()
        value.optedOutNumber = try reader["OptedOutNumber"].readIfPresent()
        value.optedOutTimestamp = try reader["OptedOutTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension PutRegistrationFieldValueOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutRegistrationFieldValueOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutRegistrationFieldValueOutput()
        value.fieldPath = try reader["FieldPath"].readIfPresent() ?? ""
        value.registrationArn = try reader["RegistrationArn"].readIfPresent() ?? ""
        value.registrationAttachmentId = try reader["RegistrationAttachmentId"].readIfPresent()
        value.registrationId = try reader["RegistrationId"].readIfPresent() ?? ""
        value.selectChoices = try reader["SelectChoices"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.textValue = try reader["TextValue"].readIfPresent()
        value.versionNumber = try reader["VersionNumber"].readIfPresent() ?? 0
        return value
    }
}

extension PutResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutResourcePolicyOutput()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.policy = try reader["Policy"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        return value
    }
}

extension ReleasePhoneNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ReleasePhoneNumberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ReleasePhoneNumberOutput()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.isoCountryCode = try reader["IsoCountryCode"].readIfPresent()
        value.messageType = try reader["MessageType"].readIfPresent()
        value.monthlyLeasingPrice = try reader["MonthlyLeasingPrice"].readIfPresent()
        value.numberCapabilities = try reader["NumberCapabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PinpointSMSVoiceV2ClientTypes.NumberCapability>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.numberType = try reader["NumberType"].readIfPresent()
        value.optOutListName = try reader["OptOutListName"].readIfPresent()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.phoneNumberArn = try reader["PhoneNumberArn"].readIfPresent()
        value.phoneNumberId = try reader["PhoneNumberId"].readIfPresent()
        value.registrationId = try reader["RegistrationId"].readIfPresent()
        value.selfManagedOptOutsEnabled = try reader["SelfManagedOptOutsEnabled"].readIfPresent() ?? false
        value.status = try reader["Status"].readIfPresent()
        value.twoWayChannelArn = try reader["TwoWayChannelArn"].readIfPresent()
        value.twoWayChannelRole = try reader["TwoWayChannelRole"].readIfPresent()
        value.twoWayEnabled = try reader["TwoWayEnabled"].readIfPresent() ?? false
        return value
    }
}

extension ReleaseSenderIdOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ReleaseSenderIdOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ReleaseSenderIdOutput()
        value.isoCountryCode = try reader["IsoCountryCode"].readIfPresent() ?? ""
        value.messageTypes = try reader["MessageTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PinpointSMSVoiceV2ClientTypes.MessageType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.monthlyLeasingPrice = try reader["MonthlyLeasingPrice"].readIfPresent() ?? ""
        value.registered = try reader["Registered"].readIfPresent() ?? false
        value.registrationId = try reader["RegistrationId"].readIfPresent()
        value.senderId = try reader["SenderId"].readIfPresent() ?? ""
        value.senderIdArn = try reader["SenderIdArn"].readIfPresent() ?? ""
        return value
    }
}

extension RequestPhoneNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RequestPhoneNumberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RequestPhoneNumberOutput()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletionProtectionEnabled = try reader["DeletionProtectionEnabled"].readIfPresent() ?? false
        value.isoCountryCode = try reader["IsoCountryCode"].readIfPresent()
        value.messageType = try reader["MessageType"].readIfPresent()
        value.monthlyLeasingPrice = try reader["MonthlyLeasingPrice"].readIfPresent()
        value.numberCapabilities = try reader["NumberCapabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PinpointSMSVoiceV2ClientTypes.NumberCapability>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.numberType = try reader["NumberType"].readIfPresent()
        value.optOutListName = try reader["OptOutListName"].readIfPresent()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.phoneNumberArn = try reader["PhoneNumberArn"].readIfPresent()
        value.phoneNumberId = try reader["PhoneNumberId"].readIfPresent()
        value.poolId = try reader["PoolId"].readIfPresent()
        value.registrationId = try reader["RegistrationId"].readIfPresent()
        value.selfManagedOptOutsEnabled = try reader["SelfManagedOptOutsEnabled"].readIfPresent() ?? false
        value.status = try reader["Status"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.twoWayChannelArn = try reader["TwoWayChannelArn"].readIfPresent()
        value.twoWayChannelRole = try reader["TwoWayChannelRole"].readIfPresent()
        value.twoWayEnabled = try reader["TwoWayEnabled"].readIfPresent() ?? false
        return value
    }
}

extension RequestSenderIdOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RequestSenderIdOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RequestSenderIdOutput()
        value.deletionProtectionEnabled = try reader["DeletionProtectionEnabled"].readIfPresent() ?? false
        value.isoCountryCode = try reader["IsoCountryCode"].readIfPresent() ?? ""
        value.messageTypes = try reader["MessageTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PinpointSMSVoiceV2ClientTypes.MessageType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.monthlyLeasingPrice = try reader["MonthlyLeasingPrice"].readIfPresent() ?? ""
        value.registered = try reader["Registered"].readIfPresent() ?? false
        value.senderId = try reader["SenderId"].readIfPresent() ?? ""
        value.senderIdArn = try reader["SenderIdArn"].readIfPresent() ?? ""
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SendDestinationNumberVerificationCodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendDestinationNumberVerificationCodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendDestinationNumberVerificationCodeOutput()
        value.messageId = try reader["MessageId"].readIfPresent() ?? ""
        return value
    }
}

extension SendMediaMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendMediaMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendMediaMessageOutput()
        value.messageId = try reader["MessageId"].readIfPresent()
        return value
    }
}

extension SendTextMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendTextMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendTextMessageOutput()
        value.messageId = try reader["MessageId"].readIfPresent()
        return value
    }
}

extension SendVoiceMessageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendVoiceMessageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendVoiceMessageOutput()
        value.messageId = try reader["MessageId"].readIfPresent()
        return value
    }
}

extension SetAccountDefaultProtectConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetAccountDefaultProtectConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SetAccountDefaultProtectConfigurationOutput()
        value.defaultProtectConfigurationArn = try reader["DefaultProtectConfigurationArn"].readIfPresent() ?? ""
        value.defaultProtectConfigurationId = try reader["DefaultProtectConfigurationId"].readIfPresent() ?? ""
        return value
    }
}

extension SetDefaultMessageTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetDefaultMessageTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SetDefaultMessageTypeOutput()
        value.configurationSetArn = try reader["ConfigurationSetArn"].readIfPresent()
        value.configurationSetName = try reader["ConfigurationSetName"].readIfPresent()
        value.messageType = try reader["MessageType"].readIfPresent()
        return value
    }
}

extension SetDefaultSenderIdOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetDefaultSenderIdOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SetDefaultSenderIdOutput()
        value.configurationSetArn = try reader["ConfigurationSetArn"].readIfPresent()
        value.configurationSetName = try reader["ConfigurationSetName"].readIfPresent()
        value.senderId = try reader["SenderId"].readIfPresent()
        return value
    }
}

extension SetMediaMessageSpendLimitOverrideOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetMediaMessageSpendLimitOverrideOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SetMediaMessageSpendLimitOverrideOutput()
        value.monthlyLimit = try reader["MonthlyLimit"].readIfPresent()
        return value
    }
}

extension SetTextMessageSpendLimitOverrideOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetTextMessageSpendLimitOverrideOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SetTextMessageSpendLimitOverrideOutput()
        value.monthlyLimit = try reader["MonthlyLimit"].readIfPresent()
        return value
    }
}

extension SetVoiceMessageSpendLimitOverrideOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetVoiceMessageSpendLimitOverrideOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SetVoiceMessageSpendLimitOverrideOutput()
        value.monthlyLimit = try reader["MonthlyLimit"].readIfPresent()
        return value
    }
}

extension SubmitRegistrationVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SubmitRegistrationVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SubmitRegistrationVersionOutput()
        value.registrationArn = try reader["RegistrationArn"].readIfPresent() ?? ""
        value.registrationId = try reader["RegistrationId"].readIfPresent() ?? ""
        value.registrationVersionStatus = try reader["RegistrationVersionStatus"].readIfPresent() ?? .sdkUnknown("")
        value.registrationVersionStatusHistory = try reader["RegistrationVersionStatusHistory"].readIfPresent(with: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory.read(from:))
        value.versionNumber = try reader["VersionNumber"].readIfPresent() ?? 0
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateEventDestinationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEventDestinationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEventDestinationOutput()
        value.configurationSetArn = try reader["ConfigurationSetArn"].readIfPresent()
        value.configurationSetName = try reader["ConfigurationSetName"].readIfPresent()
        value.eventDestination = try reader["EventDestination"].readIfPresent(with: PinpointSMSVoiceV2ClientTypes.EventDestination.read(from:))
        return value
    }
}

extension UpdatePhoneNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePhoneNumberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePhoneNumberOutput()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletionProtectionEnabled = try reader["DeletionProtectionEnabled"].readIfPresent() ?? false
        value.isoCountryCode = try reader["IsoCountryCode"].readIfPresent()
        value.messageType = try reader["MessageType"].readIfPresent()
        value.monthlyLeasingPrice = try reader["MonthlyLeasingPrice"].readIfPresent()
        value.numberCapabilities = try reader["NumberCapabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PinpointSMSVoiceV2ClientTypes.NumberCapability>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.numberType = try reader["NumberType"].readIfPresent()
        value.optOutListName = try reader["OptOutListName"].readIfPresent()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.phoneNumberArn = try reader["PhoneNumberArn"].readIfPresent()
        value.phoneNumberId = try reader["PhoneNumberId"].readIfPresent()
        value.registrationId = try reader["RegistrationId"].readIfPresent()
        value.selfManagedOptOutsEnabled = try reader["SelfManagedOptOutsEnabled"].readIfPresent() ?? false
        value.status = try reader["Status"].readIfPresent()
        value.twoWayChannelArn = try reader["TwoWayChannelArn"].readIfPresent()
        value.twoWayChannelRole = try reader["TwoWayChannelRole"].readIfPresent()
        value.twoWayEnabled = try reader["TwoWayEnabled"].readIfPresent() ?? false
        return value
    }
}

extension UpdatePoolOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePoolOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePoolOutput()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletionProtectionEnabled = try reader["DeletionProtectionEnabled"].readIfPresent() ?? false
        value.messageType = try reader["MessageType"].readIfPresent()
        value.optOutListName = try reader["OptOutListName"].readIfPresent()
        value.poolArn = try reader["PoolArn"].readIfPresent()
        value.poolId = try reader["PoolId"].readIfPresent()
        value.selfManagedOptOutsEnabled = try reader["SelfManagedOptOutsEnabled"].readIfPresent() ?? false
        value.sharedRoutesEnabled = try reader["SharedRoutesEnabled"].readIfPresent() ?? false
        value.status = try reader["Status"].readIfPresent()
        value.twoWayChannelArn = try reader["TwoWayChannelArn"].readIfPresent()
        value.twoWayChannelRole = try reader["TwoWayChannelRole"].readIfPresent()
        value.twoWayEnabled = try reader["TwoWayEnabled"].readIfPresent() ?? false
        return value
    }
}

extension UpdateProtectConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProtectConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProtectConfigurationOutput()
        value.accountDefault = try reader["AccountDefault"].readIfPresent() ?? false
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.deletionProtectionEnabled = try reader["DeletionProtectionEnabled"].readIfPresent() ?? false
        value.protectConfigurationArn = try reader["ProtectConfigurationArn"].readIfPresent() ?? ""
        value.protectConfigurationId = try reader["ProtectConfigurationId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateProtectConfigurationCountryRuleSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProtectConfigurationCountryRuleSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProtectConfigurationCountryRuleSetOutput()
        value.countryRuleSet = try reader["CountryRuleSet"].readMapIfPresent(valueReadingClosure: PinpointSMSVoiceV2ClientTypes.ProtectConfigurationCountryRuleSetInformation.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.numberCapability = try reader["NumberCapability"].readIfPresent() ?? .sdkUnknown("")
        value.protectConfigurationArn = try reader["ProtectConfigurationArn"].readIfPresent() ?? ""
        value.protectConfigurationId = try reader["ProtectConfigurationId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateSenderIdOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSenderIdOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSenderIdOutput()
        value.deletionProtectionEnabled = try reader["DeletionProtectionEnabled"].readIfPresent() ?? false
        value.isoCountryCode = try reader["IsoCountryCode"].readIfPresent() ?? ""
        value.messageTypes = try reader["MessageTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PinpointSMSVoiceV2ClientTypes.MessageType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.monthlyLeasingPrice = try reader["MonthlyLeasingPrice"].readIfPresent() ?? ""
        value.registered = try reader["Registered"].readIfPresent() ?? false
        value.registrationId = try reader["RegistrationId"].readIfPresent()
        value.senderId = try reader["SenderId"].readIfPresent() ?? ""
        value.senderIdArn = try reader["SenderIdArn"].readIfPresent() ?? ""
        return value
    }
}

extension VerifyDestinationNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> VerifyDestinationNumberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = VerifyDestinationNumberOutput()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.destinationPhoneNumber = try reader["DestinationPhoneNumber"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.verifiedDestinationNumberArn = try reader["VerifiedDestinationNumberArn"].readIfPresent() ?? ""
        value.verifiedDestinationNumberId = try reader["VerifiedDestinationNumberId"].readIfPresent() ?? ""
        return value
    }
}

enum AssociateOriginationIdentityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateProtectConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConfigurationSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEventDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOptOutListOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePoolOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProtectConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRegistrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRegistrationAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRegistrationAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRegistrationVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVerifiedDestinationNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccountDefaultProtectConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConfigurationSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDefaultMessageTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDefaultSenderIdOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEventDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteKeywordOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMediaMessageSpendLimitOverrideOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOptedOutNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOptOutListOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePoolOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProtectConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRegistrationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRegistrationAttachmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRegistrationFieldValueOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTextMessageSpendLimitOverrideOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVerifiedDestinationNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVoiceMessageSpendLimitOverrideOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAccountAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAccountLimitsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConfigurationSetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeKeywordsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeOptedOutNumbersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeOptOutListsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePhoneNumbersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePoolsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProtectConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRegistrationAttachmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRegistrationFieldDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRegistrationFieldValuesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRegistrationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRegistrationSectionDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRegistrationTypeDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeRegistrationVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSenderIdsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSpendLimitsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeVerifiedDestinationNumbersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateOriginationIdentityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateProtectConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DiscardRegistrationVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProtectConfigurationCountryRuleSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPoolOriginationIdentitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRegistrationAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutKeywordOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutOptedOutNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutRegistrationFieldValueOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ReleasePhoneNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ReleaseSenderIdOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RequestPhoneNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RequestSenderIdOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendDestinationNumberVerificationCodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendMediaMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendTextMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendVoiceMessageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetAccountDefaultProtectConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetDefaultMessageTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetDefaultSenderIdOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetMediaMessageSpendLimitOverrideOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetTextMessageSpendLimitOverrideOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetVoiceMessageSpendLimitOverrideOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SubmitRegistrationVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEventDestinationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePhoneNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePoolOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProtectConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProtectConfigurationCountryRuleSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSenderIdOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum VerifyDestinationNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.requestId = try reader["RequestId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fields = try reader["Fields"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.Tag {

    static func write(value: PinpointSMSVoiceV2ClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.EventDestination {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.EventDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.EventDestination()
        value.eventDestinationName = try reader["EventDestinationName"].readIfPresent() ?? ""
        value.enabled = try reader["Enabled"].readIfPresent() ?? false
        value.matchingEventTypes = try reader["MatchingEventTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PinpointSMSVoiceV2ClientTypes.EventType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.cloudWatchLogsDestination = try reader["CloudWatchLogsDestination"].readIfPresent(with: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination.read(from:))
        value.kinesisFirehoseDestination = try reader["KinesisFirehoseDestination"].readIfPresent(with: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination.read(from:))
        value.snsDestination = try reader["SnsDestination"].readIfPresent(with: PinpointSMSVoiceV2ClientTypes.SnsDestination.read(from:))
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.SnsDestination {

    static func write(value: PinpointSMSVoiceV2ClientTypes.SnsDestination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TopicArn"].write(value.topicArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.SnsDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.SnsDestination()
        value.topicArn = try reader["TopicArn"].readIfPresent() ?? ""
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination {

    static func write(value: PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeliveryStreamArn"].write(value.deliveryStreamArn)
        try writer["IamRoleArn"].write(value.iamRoleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.KinesisFirehoseDestination()
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent() ?? ""
        value.deliveryStreamArn = try reader["DeliveryStreamArn"].readIfPresent() ?? ""
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination {

    static func write(value: PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IamRoleArn"].write(value.iamRoleArn)
        try writer["LogGroupArn"].write(value.logGroupArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.CloudWatchLogsDestination()
        value.iamRoleArn = try reader["IamRoleArn"].readIfPresent() ?? ""
        value.logGroupArn = try reader["LogGroupArn"].readIfPresent() ?? ""
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory()
        value.draftTimestamp = try reader["DraftTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.submittedTimestamp = try reader["SubmittedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.reviewingTimestamp = try reader["ReviewingTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.requiresAuthenticationTimestamp = try reader["RequiresAuthenticationTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.approvedTimestamp = try reader["ApprovedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.discardedTimestamp = try reader["DiscardedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deniedTimestamp = try reader["DeniedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.revokedTimestamp = try reader["RevokedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.archivedTimestamp = try reader["ArchivedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.AccountAttribute {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.AccountAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.AccountAttribute()
        value.name = try reader["Name"].readIfPresent() ?? .sdkUnknown("")
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.AccountLimit {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.AccountLimit {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.AccountLimit()
        value.name = try reader["Name"].readIfPresent() ?? .sdkUnknown("")
        value.used = try reader["Used"].readIfPresent() ?? 0
        value.max = try reader["Max"].readIfPresent() ?? 0
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation()
        value.configurationSetArn = try reader["ConfigurationSetArn"].readIfPresent() ?? ""
        value.configurationSetName = try reader["ConfigurationSetName"].readIfPresent() ?? ""
        value.eventDestinations = try reader["EventDestinations"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.EventDestination.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.defaultMessageType = try reader["DefaultMessageType"].readIfPresent()
        value.defaultSenderId = try reader["DefaultSenderId"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.protectConfigurationId = try reader["ProtectConfigurationId"].readIfPresent()
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.KeywordInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.KeywordInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.KeywordInformation()
        value.keyword = try reader["Keyword"].readIfPresent() ?? ""
        value.keywordMessage = try reader["KeywordMessage"].readIfPresent() ?? ""
        value.keywordAction = try reader["KeywordAction"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation()
        value.optedOutNumber = try reader["OptedOutNumber"].readIfPresent() ?? ""
        value.optedOutTimestamp = try reader["OptedOutTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endUserOptedOut = try reader["EndUserOptedOut"].readIfPresent() ?? false
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.OptOutListInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.OptOutListInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.OptOutListInformation()
        value.optOutListArn = try reader["OptOutListArn"].readIfPresent() ?? ""
        value.optOutListName = try reader["OptOutListName"].readIfPresent() ?? ""
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation()
        value.phoneNumberArn = try reader["PhoneNumberArn"].readIfPresent() ?? ""
        value.phoneNumberId = try reader["PhoneNumberId"].readIfPresent()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.isoCountryCode = try reader["IsoCountryCode"].readIfPresent() ?? ""
        value.messageType = try reader["MessageType"].readIfPresent() ?? .sdkUnknown("")
        value.numberCapabilities = try reader["NumberCapabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PinpointSMSVoiceV2ClientTypes.NumberCapability>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.numberType = try reader["NumberType"].readIfPresent() ?? .sdkUnknown("")
        value.monthlyLeasingPrice = try reader["MonthlyLeasingPrice"].readIfPresent() ?? ""
        value.twoWayEnabled = try reader["TwoWayEnabled"].readIfPresent() ?? false
        value.twoWayChannelArn = try reader["TwoWayChannelArn"].readIfPresent()
        value.twoWayChannelRole = try reader["TwoWayChannelRole"].readIfPresent()
        value.selfManagedOptOutsEnabled = try reader["SelfManagedOptOutsEnabled"].readIfPresent() ?? false
        value.optOutListName = try reader["OptOutListName"].readIfPresent() ?? ""
        value.deletionProtectionEnabled = try reader["DeletionProtectionEnabled"].readIfPresent() ?? false
        value.poolId = try reader["PoolId"].readIfPresent()
        value.registrationId = try reader["RegistrationId"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.PoolInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.PoolInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.PoolInformation()
        value.poolArn = try reader["PoolArn"].readIfPresent() ?? ""
        value.poolId = try reader["PoolId"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.messageType = try reader["MessageType"].readIfPresent() ?? .sdkUnknown("")
        value.twoWayEnabled = try reader["TwoWayEnabled"].readIfPresent() ?? false
        value.twoWayChannelArn = try reader["TwoWayChannelArn"].readIfPresent()
        value.twoWayChannelRole = try reader["TwoWayChannelRole"].readIfPresent()
        value.selfManagedOptOutsEnabled = try reader["SelfManagedOptOutsEnabled"].readIfPresent() ?? false
        value.optOutListName = try reader["OptOutListName"].readIfPresent() ?? ""
        value.sharedRoutesEnabled = try reader["SharedRoutesEnabled"].readIfPresent() ?? false
        value.deletionProtectionEnabled = try reader["DeletionProtectionEnabled"].readIfPresent() ?? false
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.ProtectConfigurationInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.ProtectConfigurationInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.ProtectConfigurationInformation()
        value.protectConfigurationArn = try reader["ProtectConfigurationArn"].readIfPresent() ?? ""
        value.protectConfigurationId = try reader["ProtectConfigurationId"].readIfPresent() ?? ""
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.accountDefault = try reader["AccountDefault"].readIfPresent() ?? false
        value.deletionProtectionEnabled = try reader["DeletionProtectionEnabled"].readIfPresent() ?? false
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentsInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentsInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentsInformation()
        value.registrationAttachmentArn = try reader["RegistrationAttachmentArn"].readIfPresent() ?? ""
        value.registrationAttachmentId = try reader["RegistrationAttachmentId"].readIfPresent() ?? ""
        value.attachmentStatus = try reader["AttachmentStatus"].readIfPresent() ?? .sdkUnknown("")
        value.attachmentUploadErrorReason = try reader["AttachmentUploadErrorReason"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationFieldDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.RegistrationFieldDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.RegistrationFieldDefinition()
        value.sectionPath = try reader["SectionPath"].readIfPresent() ?? ""
        value.fieldPath = try reader["FieldPath"].readIfPresent() ?? ""
        value.fieldType = try reader["FieldType"].readIfPresent() ?? .sdkUnknown("")
        value.fieldRequirement = try reader["FieldRequirement"].readIfPresent() ?? .sdkUnknown("")
        value.selectValidation = try reader["SelectValidation"].readIfPresent(with: PinpointSMSVoiceV2ClientTypes.SelectValidation.read(from:))
        value.textValidation = try reader["TextValidation"].readIfPresent(with: PinpointSMSVoiceV2ClientTypes.TextValidation.read(from:))
        value.displayHints = try reader["DisplayHints"].readIfPresent(with: PinpointSMSVoiceV2ClientTypes.RegistrationFieldDisplayHints.read(from:))
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationFieldDisplayHints {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.RegistrationFieldDisplayHints {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.RegistrationFieldDisplayHints()
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.shortDescription = try reader["ShortDescription"].readIfPresent() ?? ""
        value.longDescription = try reader["LongDescription"].readIfPresent()
        value.documentationTitle = try reader["DocumentationTitle"].readIfPresent()
        value.documentationLink = try reader["DocumentationLink"].readIfPresent()
        value.selectOptionDescriptions = try reader["SelectOptionDescriptions"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.SelectOptionDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.textValidationDescription = try reader["TextValidationDescription"].readIfPresent()
        value.exampleTextValue = try reader["ExampleTextValue"].readIfPresent()
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.SelectOptionDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.SelectOptionDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.SelectOptionDescription()
        value.option = try reader["Option"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.TextValidation {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.TextValidation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.TextValidation()
        value.minLength = try reader["MinLength"].readIfPresent() ?? 0
        value.maxLength = try reader["MaxLength"].readIfPresent() ?? 0
        value.pattern = try reader["Pattern"].readIfPresent() ?? ""
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.SelectValidation {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.SelectValidation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.SelectValidation()
        value.minChoices = try reader["MinChoices"].readIfPresent() ?? 0
        value.maxChoices = try reader["MaxChoices"].readIfPresent() ?? 0
        value.options = try reader["Options"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationFieldValueInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.RegistrationFieldValueInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.RegistrationFieldValueInformation()
        value.fieldPath = try reader["FieldPath"].readIfPresent() ?? ""
        value.selectChoices = try reader["SelectChoices"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.textValue = try reader["TextValue"].readIfPresent()
        value.registrationAttachmentId = try reader["RegistrationAttachmentId"].readIfPresent()
        value.deniedReason = try reader["DeniedReason"].readIfPresent()
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.RegistrationInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.RegistrationInformation()
        value.registrationArn = try reader["RegistrationArn"].readIfPresent() ?? ""
        value.registrationId = try reader["RegistrationId"].readIfPresent() ?? ""
        value.registrationType = try reader["RegistrationType"].readIfPresent() ?? ""
        value.registrationStatus = try reader["RegistrationStatus"].readIfPresent() ?? .sdkUnknown("")
        value.currentVersionNumber = try reader["CurrentVersionNumber"].readIfPresent() ?? 0
        value.approvedVersionNumber = try reader["ApprovedVersionNumber"].readIfPresent()
        value.latestDeniedVersionNumber = try reader["LatestDeniedVersionNumber"].readIfPresent()
        value.additionalAttributes = try reader["AdditionalAttributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationSectionDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.RegistrationSectionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.RegistrationSectionDefinition()
        value.sectionPath = try reader["SectionPath"].readIfPresent() ?? ""
        value.displayHints = try reader["DisplayHints"].readIfPresent(with: PinpointSMSVoiceV2ClientTypes.RegistrationSectionDisplayHints.read(from:))
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationSectionDisplayHints {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.RegistrationSectionDisplayHints {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.RegistrationSectionDisplayHints()
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.shortDescription = try reader["ShortDescription"].readIfPresent() ?? ""
        value.longDescription = try reader["LongDescription"].readIfPresent()
        value.documentationTitle = try reader["DocumentationTitle"].readIfPresent()
        value.documentationLink = try reader["DocumentationLink"].readIfPresent()
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationTypeDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.RegistrationTypeDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.RegistrationTypeDefinition()
        value.registrationType = try reader["RegistrationType"].readIfPresent() ?? ""
        value.supportedAssociations = try reader["SupportedAssociations"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.SupportedAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.displayHints = try reader["DisplayHints"].readIfPresent(with: PinpointSMSVoiceV2ClientTypes.RegistrationTypeDisplayHints.read(from:))
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationTypeDisplayHints {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.RegistrationTypeDisplayHints {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.RegistrationTypeDisplayHints()
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.shortDescription = try reader["ShortDescription"].readIfPresent()
        value.longDescription = try reader["LongDescription"].readIfPresent()
        value.documentationTitle = try reader["DocumentationTitle"].readIfPresent()
        value.documentationLink = try reader["DocumentationLink"].readIfPresent()
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.SupportedAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.SupportedAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.SupportedAssociation()
        value.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.isoCountryCode = try reader["IsoCountryCode"].readIfPresent()
        value.associationBehavior = try reader["AssociationBehavior"].readIfPresent() ?? .sdkUnknown("")
        value.disassociationBehavior = try reader["DisassociationBehavior"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationVersionInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.RegistrationVersionInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.RegistrationVersionInformation()
        value.versionNumber = try reader["VersionNumber"].readIfPresent() ?? 0
        value.registrationVersionStatus = try reader["RegistrationVersionStatus"].readIfPresent() ?? .sdkUnknown("")
        value.registrationVersionStatusHistory = try reader["RegistrationVersionStatusHistory"].readIfPresent(with: PinpointSMSVoiceV2ClientTypes.RegistrationVersionStatusHistory.read(from:))
        value.deniedReasons = try reader["DeniedReasons"].readListIfPresent(memberReadingClosure: PinpointSMSVoiceV2ClientTypes.RegistrationDeniedReasonInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationDeniedReasonInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.RegistrationDeniedReasonInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.RegistrationDeniedReasonInformation()
        value.reason = try reader["Reason"].readIfPresent() ?? ""
        value.shortDescription = try reader["ShortDescription"].readIfPresent() ?? ""
        value.longDescription = try reader["LongDescription"].readIfPresent()
        value.documentationTitle = try reader["DocumentationTitle"].readIfPresent()
        value.documentationLink = try reader["DocumentationLink"].readIfPresent()
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.SenderIdInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.SenderIdInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.SenderIdInformation()
        value.senderIdArn = try reader["SenderIdArn"].readIfPresent() ?? ""
        value.senderId = try reader["SenderId"].readIfPresent() ?? ""
        value.isoCountryCode = try reader["IsoCountryCode"].readIfPresent() ?? ""
        value.messageTypes = try reader["MessageTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PinpointSMSVoiceV2ClientTypes.MessageType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.monthlyLeasingPrice = try reader["MonthlyLeasingPrice"].readIfPresent() ?? ""
        value.deletionProtectionEnabled = try reader["DeletionProtectionEnabled"].readIfPresent() ?? false
        value.registered = try reader["Registered"].readIfPresent() ?? false
        value.registrationId = try reader["RegistrationId"].readIfPresent()
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.SpendLimit {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.SpendLimit {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.SpendLimit()
        value.name = try reader["Name"].readIfPresent() ?? .sdkUnknown("")
        value.enforcedLimit = try reader["EnforcedLimit"].readIfPresent() ?? 0
        value.maxLimit = try reader["MaxLimit"].readIfPresent() ?? 0
        value.overridden = try reader["Overridden"].readIfPresent() ?? false
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberInformation()
        value.verifiedDestinationNumberArn = try reader["VerifiedDestinationNumberArn"].readIfPresent() ?? ""
        value.verifiedDestinationNumberId = try reader["VerifiedDestinationNumberId"].readIfPresent() ?? ""
        value.destinationPhoneNumber = try reader["DestinationPhoneNumber"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.ProtectConfigurationCountryRuleSetInformation {

    static func write(value: PinpointSMSVoiceV2ClientTypes.ProtectConfigurationCountryRuleSetInformation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProtectStatus"].write(value.protectStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.ProtectConfigurationCountryRuleSetInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.ProtectConfigurationCountryRuleSetInformation()
        value.protectStatus = try reader["ProtectStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata()
        value.originationIdentityArn = try reader["OriginationIdentityArn"].readIfPresent() ?? ""
        value.originationIdentity = try reader["OriginationIdentity"].readIfPresent() ?? ""
        value.isoCountryCode = try reader["IsoCountryCode"].readIfPresent() ?? ""
        value.numberCapabilities = try reader["NumberCapabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PinpointSMSVoiceV2ClientTypes.NumberCapability>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationAssociationMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.RegistrationAssociationMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.RegistrationAssociationMetadata()
        value.resourceArn = try reader["ResourceArn"].readIfPresent() ?? ""
        value.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.isoCountryCode = try reader["IsoCountryCode"].readIfPresent()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> PinpointSMSVoiceV2ClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PinpointSMSVoiceV2ClientTypes.ValidationExceptionField()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilter {

    static func write(value: PinpointSMSVoiceV2ClientTypes.ConfigurationSetFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PinpointSMSVoiceV2ClientTypes.KeywordFilter {

    static func write(value: PinpointSMSVoiceV2ClientTypes.KeywordFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PinpointSMSVoiceV2ClientTypes.OptedOutFilter {

    static func write(value: PinpointSMSVoiceV2ClientTypes.OptedOutFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PinpointSMSVoiceV2ClientTypes.PhoneNumberFilter {

    static func write(value: PinpointSMSVoiceV2ClientTypes.PhoneNumberFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PinpointSMSVoiceV2ClientTypes.PoolFilter {

    static func write(value: PinpointSMSVoiceV2ClientTypes.PoolFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PinpointSMSVoiceV2ClientTypes.ProtectConfigurationFilter {

    static func write(value: PinpointSMSVoiceV2ClientTypes.ProtectConfigurationFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentFilter {

    static func write(value: PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationFilter {

    static func write(value: PinpointSMSVoiceV2ClientTypes.RegistrationFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationTypeFilter {

    static func write(value: PinpointSMSVoiceV2ClientTypes.RegistrationTypeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationVersionFilter {

    static func write(value: PinpointSMSVoiceV2ClientTypes.RegistrationVersionFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PinpointSMSVoiceV2ClientTypes.SenderIdAndCountry {

    static func write(value: PinpointSMSVoiceV2ClientTypes.SenderIdAndCountry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IsoCountryCode"].write(value.isoCountryCode)
        try writer["SenderId"].write(value.senderId)
    }
}

extension PinpointSMSVoiceV2ClientTypes.SenderIdFilter {

    static func write(value: PinpointSMSVoiceV2ClientTypes.SenderIdFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberFilter {

    static func write(value: PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilter {

    static func write(value: PinpointSMSVoiceV2ClientTypes.PoolOriginationIdentitiesFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PinpointSMSVoiceV2ClientTypes.RegistrationAssociationFilter {

    static func write(value: PinpointSMSVoiceV2ClientTypes.RegistrationAssociationFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum PinpointSMSVoiceV2ClientTypes {}
