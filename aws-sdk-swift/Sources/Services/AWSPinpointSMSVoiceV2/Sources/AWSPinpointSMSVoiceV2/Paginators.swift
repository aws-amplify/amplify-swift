//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension PinpointSMSVoiceV2Client {
    /// Paginate over `[DescribeAccountAttributesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeAccountAttributesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeAccountAttributesOutput`
    public func describeAccountAttributesPaginated(input: DescribeAccountAttributesInput) -> ClientRuntime.PaginatorSequence<DescribeAccountAttributesInput, DescribeAccountAttributesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeAccountAttributesInput, DescribeAccountAttributesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeAccountAttributes(input:))
    }
}

extension DescribeAccountAttributesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAccountAttributesInput {
        return DescribeAccountAttributesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeAccountAttributesInput, OperationStackOutput == DescribeAccountAttributesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeAccountAttributesPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.AccountAttribute]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.AccountAttribute]`
    public func accountAttributes() async throws -> [PinpointSMSVoiceV2ClientTypes.AccountAttribute] {
        return try await self.asyncCompactMap { item in item.accountAttributes }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[DescribeAccountLimitsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeAccountLimitsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeAccountLimitsOutput`
    public func describeAccountLimitsPaginated(input: DescribeAccountLimitsInput) -> ClientRuntime.PaginatorSequence<DescribeAccountLimitsInput, DescribeAccountLimitsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeAccountLimitsInput, DescribeAccountLimitsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeAccountLimits(input:))
    }
}

extension DescribeAccountLimitsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeAccountLimitsInput {
        return DescribeAccountLimitsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeAccountLimitsInput, OperationStackOutput == DescribeAccountLimitsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeAccountLimitsPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.AccountLimit]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.AccountLimit]`
    public func accountLimits() async throws -> [PinpointSMSVoiceV2ClientTypes.AccountLimit] {
        return try await self.asyncCompactMap { item in item.accountLimits }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[DescribeConfigurationSetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeConfigurationSetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeConfigurationSetsOutput`
    public func describeConfigurationSetsPaginated(input: DescribeConfigurationSetsInput) -> ClientRuntime.PaginatorSequence<DescribeConfigurationSetsInput, DescribeConfigurationSetsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeConfigurationSetsInput, DescribeConfigurationSetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeConfigurationSets(input:))
    }
}

extension DescribeConfigurationSetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeConfigurationSetsInput {
        return DescribeConfigurationSetsInput(
            configurationSetNames: self.configurationSetNames,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeConfigurationSetsInput, OperationStackOutput == DescribeConfigurationSetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeConfigurationSetsPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation]`
    public func configurationSets() async throws -> [PinpointSMSVoiceV2ClientTypes.ConfigurationSetInformation] {
        return try await self.asyncCompactMap { item in item.configurationSets }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[DescribeKeywordsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeKeywordsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeKeywordsOutput`
    public func describeKeywordsPaginated(input: DescribeKeywordsInput) -> ClientRuntime.PaginatorSequence<DescribeKeywordsInput, DescribeKeywordsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeKeywordsInput, DescribeKeywordsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeKeywords(input:))
    }
}

extension DescribeKeywordsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeKeywordsInput {
        return DescribeKeywordsInput(
            filters: self.filters,
            keywords: self.keywords,
            maxResults: self.maxResults,
            nextToken: token,
            originationIdentity: self.originationIdentity
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeKeywordsInput, OperationStackOutput == DescribeKeywordsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeKeywordsPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.KeywordInformation]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.KeywordInformation]`
    public func keywords() async throws -> [PinpointSMSVoiceV2ClientTypes.KeywordInformation] {
        return try await self.asyncCompactMap { item in item.keywords }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[DescribeOptedOutNumbersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeOptedOutNumbersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeOptedOutNumbersOutput`
    public func describeOptedOutNumbersPaginated(input: DescribeOptedOutNumbersInput) -> ClientRuntime.PaginatorSequence<DescribeOptedOutNumbersInput, DescribeOptedOutNumbersOutput> {
        return ClientRuntime.PaginatorSequence<DescribeOptedOutNumbersInput, DescribeOptedOutNumbersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeOptedOutNumbers(input:))
    }
}

extension DescribeOptedOutNumbersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeOptedOutNumbersInput {
        return DescribeOptedOutNumbersInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            optOutListName: self.optOutListName,
            optedOutNumbers: self.optedOutNumbers
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeOptedOutNumbersInput, OperationStackOutput == DescribeOptedOutNumbersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeOptedOutNumbersPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation]`
    public func optedOutNumbers() async throws -> [PinpointSMSVoiceV2ClientTypes.OptedOutNumberInformation] {
        return try await self.asyncCompactMap { item in item.optedOutNumbers }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[DescribeOptOutListsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeOptOutListsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeOptOutListsOutput`
    public func describeOptOutListsPaginated(input: DescribeOptOutListsInput) -> ClientRuntime.PaginatorSequence<DescribeOptOutListsInput, DescribeOptOutListsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeOptOutListsInput, DescribeOptOutListsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeOptOutLists(input:))
    }
}

extension DescribeOptOutListsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeOptOutListsInput {
        return DescribeOptOutListsInput(
            maxResults: self.maxResults,
            nextToken: token,
            optOutListNames: self.optOutListNames,
            owner: self.owner
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeOptOutListsInput, OperationStackOutput == DescribeOptOutListsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeOptOutListsPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.OptOutListInformation]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.OptOutListInformation]`
    public func optOutLists() async throws -> [PinpointSMSVoiceV2ClientTypes.OptOutListInformation] {
        return try await self.asyncCompactMap { item in item.optOutLists }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[DescribePhoneNumbersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribePhoneNumbersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribePhoneNumbersOutput`
    public func describePhoneNumbersPaginated(input: DescribePhoneNumbersInput) -> ClientRuntime.PaginatorSequence<DescribePhoneNumbersInput, DescribePhoneNumbersOutput> {
        return ClientRuntime.PaginatorSequence<DescribePhoneNumbersInput, DescribePhoneNumbersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describePhoneNumbers(input:))
    }
}

extension DescribePhoneNumbersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePhoneNumbersInput {
        return DescribePhoneNumbersInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner,
            phoneNumberIds: self.phoneNumberIds
        )}
}

extension PaginatorSequence where OperationStackInput == DescribePhoneNumbersInput, OperationStackOutput == DescribePhoneNumbersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describePhoneNumbersPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation]`
    public func phoneNumbers() async throws -> [PinpointSMSVoiceV2ClientTypes.PhoneNumberInformation] {
        return try await self.asyncCompactMap { item in item.phoneNumbers }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[DescribePoolsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribePoolsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribePoolsOutput`
    public func describePoolsPaginated(input: DescribePoolsInput) -> ClientRuntime.PaginatorSequence<DescribePoolsInput, DescribePoolsOutput> {
        return ClientRuntime.PaginatorSequence<DescribePoolsInput, DescribePoolsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describePools(input:))
    }
}

extension DescribePoolsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePoolsInput {
        return DescribePoolsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner,
            poolIds: self.poolIds
        )}
}

extension PaginatorSequence where OperationStackInput == DescribePoolsInput, OperationStackOutput == DescribePoolsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describePoolsPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.PoolInformation]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.PoolInformation]`
    public func pools() async throws -> [PinpointSMSVoiceV2ClientTypes.PoolInformation] {
        return try await self.asyncCompactMap { item in item.pools }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[DescribeProtectConfigurationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeProtectConfigurationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeProtectConfigurationsOutput`
    public func describeProtectConfigurationsPaginated(input: DescribeProtectConfigurationsInput) -> ClientRuntime.PaginatorSequence<DescribeProtectConfigurationsInput, DescribeProtectConfigurationsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeProtectConfigurationsInput, DescribeProtectConfigurationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeProtectConfigurations(input:))
    }
}

extension DescribeProtectConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeProtectConfigurationsInput {
        return DescribeProtectConfigurationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            protectConfigurationIds: self.protectConfigurationIds
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeProtectConfigurationsInput, OperationStackOutput == DescribeProtectConfigurationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeProtectConfigurationsPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.ProtectConfigurationInformation]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.ProtectConfigurationInformation]`
    public func protectConfigurations() async throws -> [PinpointSMSVoiceV2ClientTypes.ProtectConfigurationInformation] {
        return try await self.asyncCompactMap { item in item.protectConfigurations }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[DescribeRegistrationAttachmentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeRegistrationAttachmentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeRegistrationAttachmentsOutput`
    public func describeRegistrationAttachmentsPaginated(input: DescribeRegistrationAttachmentsInput) -> ClientRuntime.PaginatorSequence<DescribeRegistrationAttachmentsInput, DescribeRegistrationAttachmentsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeRegistrationAttachmentsInput, DescribeRegistrationAttachmentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeRegistrationAttachments(input:))
    }
}

extension DescribeRegistrationAttachmentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeRegistrationAttachmentsInput {
        return DescribeRegistrationAttachmentsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            registrationAttachmentIds: self.registrationAttachmentIds
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeRegistrationAttachmentsInput, OperationStackOutput == DescribeRegistrationAttachmentsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeRegistrationAttachmentsPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentsInformation]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentsInformation]`
    public func registrationAttachments() async throws -> [PinpointSMSVoiceV2ClientTypes.RegistrationAttachmentsInformation] {
        return try await self.asyncCompactMap { item in item.registrationAttachments }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[DescribeRegistrationFieldDefinitionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeRegistrationFieldDefinitionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeRegistrationFieldDefinitionsOutput`
    public func describeRegistrationFieldDefinitionsPaginated(input: DescribeRegistrationFieldDefinitionsInput) -> ClientRuntime.PaginatorSequence<DescribeRegistrationFieldDefinitionsInput, DescribeRegistrationFieldDefinitionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeRegistrationFieldDefinitionsInput, DescribeRegistrationFieldDefinitionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeRegistrationFieldDefinitions(input:))
    }
}

extension DescribeRegistrationFieldDefinitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeRegistrationFieldDefinitionsInput {
        return DescribeRegistrationFieldDefinitionsInput(
            fieldPaths: self.fieldPaths,
            maxResults: self.maxResults,
            nextToken: token,
            registrationType: self.registrationType,
            sectionPath: self.sectionPath
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeRegistrationFieldDefinitionsInput, OperationStackOutput == DescribeRegistrationFieldDefinitionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeRegistrationFieldDefinitionsPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.RegistrationFieldDefinition]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.RegistrationFieldDefinition]`
    public func registrationFieldDefinitions() async throws -> [PinpointSMSVoiceV2ClientTypes.RegistrationFieldDefinition] {
        return try await self.asyncCompactMap { item in item.registrationFieldDefinitions }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[DescribeRegistrationFieldValuesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeRegistrationFieldValuesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeRegistrationFieldValuesOutput`
    public func describeRegistrationFieldValuesPaginated(input: DescribeRegistrationFieldValuesInput) -> ClientRuntime.PaginatorSequence<DescribeRegistrationFieldValuesInput, DescribeRegistrationFieldValuesOutput> {
        return ClientRuntime.PaginatorSequence<DescribeRegistrationFieldValuesInput, DescribeRegistrationFieldValuesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeRegistrationFieldValues(input:))
    }
}

extension DescribeRegistrationFieldValuesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeRegistrationFieldValuesInput {
        return DescribeRegistrationFieldValuesInput(
            fieldPaths: self.fieldPaths,
            maxResults: self.maxResults,
            nextToken: token,
            registrationId: self.registrationId,
            sectionPath: self.sectionPath,
            versionNumber: self.versionNumber
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeRegistrationFieldValuesInput, OperationStackOutput == DescribeRegistrationFieldValuesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeRegistrationFieldValuesPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.RegistrationFieldValueInformation]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.RegistrationFieldValueInformation]`
    public func registrationFieldValues() async throws -> [PinpointSMSVoiceV2ClientTypes.RegistrationFieldValueInformation] {
        return try await self.asyncCompactMap { item in item.registrationFieldValues }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[DescribeRegistrationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeRegistrationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeRegistrationsOutput`
    public func describeRegistrationsPaginated(input: DescribeRegistrationsInput) -> ClientRuntime.PaginatorSequence<DescribeRegistrationsInput, DescribeRegistrationsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeRegistrationsInput, DescribeRegistrationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeRegistrations(input:))
    }
}

extension DescribeRegistrationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeRegistrationsInput {
        return DescribeRegistrationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            registrationIds: self.registrationIds
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeRegistrationsInput, OperationStackOutput == DescribeRegistrationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeRegistrationsPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.RegistrationInformation]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.RegistrationInformation]`
    public func registrations() async throws -> [PinpointSMSVoiceV2ClientTypes.RegistrationInformation] {
        return try await self.asyncCompactMap { item in item.registrations }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[DescribeRegistrationSectionDefinitionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeRegistrationSectionDefinitionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeRegistrationSectionDefinitionsOutput`
    public func describeRegistrationSectionDefinitionsPaginated(input: DescribeRegistrationSectionDefinitionsInput) -> ClientRuntime.PaginatorSequence<DescribeRegistrationSectionDefinitionsInput, DescribeRegistrationSectionDefinitionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeRegistrationSectionDefinitionsInput, DescribeRegistrationSectionDefinitionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeRegistrationSectionDefinitions(input:))
    }
}

extension DescribeRegistrationSectionDefinitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeRegistrationSectionDefinitionsInput {
        return DescribeRegistrationSectionDefinitionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            registrationType: self.registrationType,
            sectionPaths: self.sectionPaths
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeRegistrationSectionDefinitionsInput, OperationStackOutput == DescribeRegistrationSectionDefinitionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeRegistrationSectionDefinitionsPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.RegistrationSectionDefinition]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.RegistrationSectionDefinition]`
    public func registrationSectionDefinitions() async throws -> [PinpointSMSVoiceV2ClientTypes.RegistrationSectionDefinition] {
        return try await self.asyncCompactMap { item in item.registrationSectionDefinitions }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[DescribeRegistrationTypeDefinitionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeRegistrationTypeDefinitionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeRegistrationTypeDefinitionsOutput`
    public func describeRegistrationTypeDefinitionsPaginated(input: DescribeRegistrationTypeDefinitionsInput) -> ClientRuntime.PaginatorSequence<DescribeRegistrationTypeDefinitionsInput, DescribeRegistrationTypeDefinitionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeRegistrationTypeDefinitionsInput, DescribeRegistrationTypeDefinitionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeRegistrationTypeDefinitions(input:))
    }
}

extension DescribeRegistrationTypeDefinitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeRegistrationTypeDefinitionsInput {
        return DescribeRegistrationTypeDefinitionsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            registrationTypes: self.registrationTypes
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeRegistrationTypeDefinitionsInput, OperationStackOutput == DescribeRegistrationTypeDefinitionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeRegistrationTypeDefinitionsPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.RegistrationTypeDefinition]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.RegistrationTypeDefinition]`
    public func registrationTypeDefinitions() async throws -> [PinpointSMSVoiceV2ClientTypes.RegistrationTypeDefinition] {
        return try await self.asyncCompactMap { item in item.registrationTypeDefinitions }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[DescribeRegistrationVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeRegistrationVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeRegistrationVersionsOutput`
    public func describeRegistrationVersionsPaginated(input: DescribeRegistrationVersionsInput) -> ClientRuntime.PaginatorSequence<DescribeRegistrationVersionsInput, DescribeRegistrationVersionsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeRegistrationVersionsInput, DescribeRegistrationVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeRegistrationVersions(input:))
    }
}

extension DescribeRegistrationVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeRegistrationVersionsInput {
        return DescribeRegistrationVersionsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            registrationId: self.registrationId,
            versionNumbers: self.versionNumbers
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeRegistrationVersionsInput, OperationStackOutput == DescribeRegistrationVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeRegistrationVersionsPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.RegistrationVersionInformation]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.RegistrationVersionInformation]`
    public func registrationVersions() async throws -> [PinpointSMSVoiceV2ClientTypes.RegistrationVersionInformation] {
        return try await self.asyncCompactMap { item in item.registrationVersions }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[DescribeSenderIdsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeSenderIdsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeSenderIdsOutput`
    public func describeSenderIdsPaginated(input: DescribeSenderIdsInput) -> ClientRuntime.PaginatorSequence<DescribeSenderIdsInput, DescribeSenderIdsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeSenderIdsInput, DescribeSenderIdsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeSenderIds(input:))
    }
}

extension DescribeSenderIdsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSenderIdsInput {
        return DescribeSenderIdsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            owner: self.owner,
            senderIds: self.senderIds
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeSenderIdsInput, OperationStackOutput == DescribeSenderIdsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeSenderIdsPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.SenderIdInformation]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.SenderIdInformation]`
    public func senderIds() async throws -> [PinpointSMSVoiceV2ClientTypes.SenderIdInformation] {
        return try await self.asyncCompactMap { item in item.senderIds }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[DescribeSpendLimitsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeSpendLimitsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeSpendLimitsOutput`
    public func describeSpendLimitsPaginated(input: DescribeSpendLimitsInput) -> ClientRuntime.PaginatorSequence<DescribeSpendLimitsInput, DescribeSpendLimitsOutput> {
        return ClientRuntime.PaginatorSequence<DescribeSpendLimitsInput, DescribeSpendLimitsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeSpendLimits(input:))
    }
}

extension DescribeSpendLimitsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeSpendLimitsInput {
        return DescribeSpendLimitsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeSpendLimitsInput, OperationStackOutput == DescribeSpendLimitsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeSpendLimitsPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.SpendLimit]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.SpendLimit]`
    public func spendLimits() async throws -> [PinpointSMSVoiceV2ClientTypes.SpendLimit] {
        return try await self.asyncCompactMap { item in item.spendLimits }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[DescribeVerifiedDestinationNumbersOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeVerifiedDestinationNumbersInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeVerifiedDestinationNumbersOutput`
    public func describeVerifiedDestinationNumbersPaginated(input: DescribeVerifiedDestinationNumbersInput) -> ClientRuntime.PaginatorSequence<DescribeVerifiedDestinationNumbersInput, DescribeVerifiedDestinationNumbersOutput> {
        return ClientRuntime.PaginatorSequence<DescribeVerifiedDestinationNumbersInput, DescribeVerifiedDestinationNumbersOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.describeVerifiedDestinationNumbers(input:))
    }
}

extension DescribeVerifiedDestinationNumbersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeVerifiedDestinationNumbersInput {
        return DescribeVerifiedDestinationNumbersInput(
            destinationPhoneNumbers: self.destinationPhoneNumbers,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            verifiedDestinationNumberIds: self.verifiedDestinationNumberIds
        )}
}

extension PaginatorSequence where OperationStackInput == DescribeVerifiedDestinationNumbersInput, OperationStackOutput == DescribeVerifiedDestinationNumbersOutput {
    /// This paginator transforms the `AsyncSequence` returned by `describeVerifiedDestinationNumbersPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberInformation]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberInformation]`
    public func verifiedDestinationNumbers() async throws -> [PinpointSMSVoiceV2ClientTypes.VerifiedDestinationNumberInformation] {
        return try await self.asyncCompactMap { item in item.verifiedDestinationNumbers }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[ListPoolOriginationIdentitiesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPoolOriginationIdentitiesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPoolOriginationIdentitiesOutput`
    public func listPoolOriginationIdentitiesPaginated(input: ListPoolOriginationIdentitiesInput) -> ClientRuntime.PaginatorSequence<ListPoolOriginationIdentitiesInput, ListPoolOriginationIdentitiesOutput> {
        return ClientRuntime.PaginatorSequence<ListPoolOriginationIdentitiesInput, ListPoolOriginationIdentitiesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPoolOriginationIdentities(input:))
    }
}

extension ListPoolOriginationIdentitiesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPoolOriginationIdentitiesInput {
        return ListPoolOriginationIdentitiesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            poolId: self.poolId
        )}
}

extension PaginatorSequence where OperationStackInput == ListPoolOriginationIdentitiesInput, OperationStackOutput == ListPoolOriginationIdentitiesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPoolOriginationIdentitiesPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata]`
    public func originationIdentities() async throws -> [PinpointSMSVoiceV2ClientTypes.OriginationIdentityMetadata] {
        return try await self.asyncCompactMap { item in item.originationIdentities }
    }
}
extension PinpointSMSVoiceV2Client {
    /// Paginate over `[ListRegistrationAssociationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRegistrationAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRegistrationAssociationsOutput`
    public func listRegistrationAssociationsPaginated(input: ListRegistrationAssociationsInput) -> ClientRuntime.PaginatorSequence<ListRegistrationAssociationsInput, ListRegistrationAssociationsOutput> {
        return ClientRuntime.PaginatorSequence<ListRegistrationAssociationsInput, ListRegistrationAssociationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRegistrationAssociations(input:))
    }
}

extension ListRegistrationAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRegistrationAssociationsInput {
        return ListRegistrationAssociationsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            registrationId: self.registrationId
        )}
}

extension PaginatorSequence where OperationStackInput == ListRegistrationAssociationsInput, OperationStackOutput == ListRegistrationAssociationsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRegistrationAssociationsPaginated`
    /// to access the nested member `[PinpointSMSVoiceV2ClientTypes.RegistrationAssociationMetadata]`
    /// - Returns: `[PinpointSMSVoiceV2ClientTypes.RegistrationAssociationMetadata]`
    public func registrationAssociations() async throws -> [PinpointSMSVoiceV2ClientTypes.RegistrationAssociationMetadata] {
        return try await self.asyncCompactMap { item in item.registrationAssociations }
    }
}
