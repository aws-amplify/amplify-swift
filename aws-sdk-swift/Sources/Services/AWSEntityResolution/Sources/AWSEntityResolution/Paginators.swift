//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension EntityResolutionClient {
    /// Paginate over `[ListIdMappingJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIdMappingJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIdMappingJobsOutput`
    public func listIdMappingJobsPaginated(input: ListIdMappingJobsInput) -> ClientRuntime.PaginatorSequence<ListIdMappingJobsInput, ListIdMappingJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListIdMappingJobsInput, ListIdMappingJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listIdMappingJobs(input:))
    }
}

extension ListIdMappingJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIdMappingJobsInput {
        return ListIdMappingJobsInput(
            maxResults: self.maxResults,
            nextToken: token,
            workflowName: self.workflowName
        )}
}

extension PaginatorSequence where OperationStackInput == ListIdMappingJobsInput, OperationStackOutput == ListIdMappingJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listIdMappingJobsPaginated`
    /// to access the nested member `[EntityResolutionClientTypes.JobSummary]`
    /// - Returns: `[EntityResolutionClientTypes.JobSummary]`
    public func jobs() async throws -> [EntityResolutionClientTypes.JobSummary] {
        return try await self.asyncCompactMap { item in item.jobs }
    }
}
extension EntityResolutionClient {
    /// Paginate over `[ListIdMappingWorkflowsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIdMappingWorkflowsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIdMappingWorkflowsOutput`
    public func listIdMappingWorkflowsPaginated(input: ListIdMappingWorkflowsInput) -> ClientRuntime.PaginatorSequence<ListIdMappingWorkflowsInput, ListIdMappingWorkflowsOutput> {
        return ClientRuntime.PaginatorSequence<ListIdMappingWorkflowsInput, ListIdMappingWorkflowsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listIdMappingWorkflows(input:))
    }
}

extension ListIdMappingWorkflowsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIdMappingWorkflowsInput {
        return ListIdMappingWorkflowsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListIdMappingWorkflowsInput, OperationStackOutput == ListIdMappingWorkflowsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listIdMappingWorkflowsPaginated`
    /// to access the nested member `[EntityResolutionClientTypes.IdMappingWorkflowSummary]`
    /// - Returns: `[EntityResolutionClientTypes.IdMappingWorkflowSummary]`
    public func workflowSummaries() async throws -> [EntityResolutionClientTypes.IdMappingWorkflowSummary] {
        return try await self.asyncCompactMap { item in item.workflowSummaries }
    }
}
extension EntityResolutionClient {
    /// Paginate over `[ListIdNamespacesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIdNamespacesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIdNamespacesOutput`
    public func listIdNamespacesPaginated(input: ListIdNamespacesInput) -> ClientRuntime.PaginatorSequence<ListIdNamespacesInput, ListIdNamespacesOutput> {
        return ClientRuntime.PaginatorSequence<ListIdNamespacesInput, ListIdNamespacesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listIdNamespaces(input:))
    }
}

extension ListIdNamespacesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIdNamespacesInput {
        return ListIdNamespacesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListIdNamespacesInput, OperationStackOutput == ListIdNamespacesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listIdNamespacesPaginated`
    /// to access the nested member `[EntityResolutionClientTypes.IdNamespaceSummary]`
    /// - Returns: `[EntityResolutionClientTypes.IdNamespaceSummary]`
    public func idNamespaceSummaries() async throws -> [EntityResolutionClientTypes.IdNamespaceSummary] {
        return try await self.asyncCompactMap { item in item.idNamespaceSummaries }
    }
}
extension EntityResolutionClient {
    /// Paginate over `[ListMatchingJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMatchingJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMatchingJobsOutput`
    public func listMatchingJobsPaginated(input: ListMatchingJobsInput) -> ClientRuntime.PaginatorSequence<ListMatchingJobsInput, ListMatchingJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListMatchingJobsInput, ListMatchingJobsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMatchingJobs(input:))
    }
}

extension ListMatchingJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMatchingJobsInput {
        return ListMatchingJobsInput(
            maxResults: self.maxResults,
            nextToken: token,
            workflowName: self.workflowName
        )}
}

extension PaginatorSequence where OperationStackInput == ListMatchingJobsInput, OperationStackOutput == ListMatchingJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMatchingJobsPaginated`
    /// to access the nested member `[EntityResolutionClientTypes.JobSummary]`
    /// - Returns: `[EntityResolutionClientTypes.JobSummary]`
    public func jobs() async throws -> [EntityResolutionClientTypes.JobSummary] {
        return try await self.asyncCompactMap { item in item.jobs }
    }
}
extension EntityResolutionClient {
    /// Paginate over `[ListMatchingWorkflowsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListMatchingWorkflowsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListMatchingWorkflowsOutput`
    public func listMatchingWorkflowsPaginated(input: ListMatchingWorkflowsInput) -> ClientRuntime.PaginatorSequence<ListMatchingWorkflowsInput, ListMatchingWorkflowsOutput> {
        return ClientRuntime.PaginatorSequence<ListMatchingWorkflowsInput, ListMatchingWorkflowsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listMatchingWorkflows(input:))
    }
}

extension ListMatchingWorkflowsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMatchingWorkflowsInput {
        return ListMatchingWorkflowsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListMatchingWorkflowsInput, OperationStackOutput == ListMatchingWorkflowsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listMatchingWorkflowsPaginated`
    /// to access the nested member `[EntityResolutionClientTypes.MatchingWorkflowSummary]`
    /// - Returns: `[EntityResolutionClientTypes.MatchingWorkflowSummary]`
    public func workflowSummaries() async throws -> [EntityResolutionClientTypes.MatchingWorkflowSummary] {
        return try await self.asyncCompactMap { item in item.workflowSummaries }
    }
}
extension EntityResolutionClient {
    /// Paginate over `[ListProviderServicesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProviderServicesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProviderServicesOutput`
    public func listProviderServicesPaginated(input: ListProviderServicesInput) -> ClientRuntime.PaginatorSequence<ListProviderServicesInput, ListProviderServicesOutput> {
        return ClientRuntime.PaginatorSequence<ListProviderServicesInput, ListProviderServicesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listProviderServices(input:))
    }
}

extension ListProviderServicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProviderServicesInput {
        return ListProviderServicesInput(
            maxResults: self.maxResults,
            nextToken: token,
            providerName: self.providerName
        )}
}

extension PaginatorSequence where OperationStackInput == ListProviderServicesInput, OperationStackOutput == ListProviderServicesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listProviderServicesPaginated`
    /// to access the nested member `[EntityResolutionClientTypes.ProviderServiceSummary]`
    /// - Returns: `[EntityResolutionClientTypes.ProviderServiceSummary]`
    public func providerServiceSummaries() async throws -> [EntityResolutionClientTypes.ProviderServiceSummary] {
        return try await self.asyncCompactMap { item in item.providerServiceSummaries }
    }
}
extension EntityResolutionClient {
    /// Paginate over `[ListSchemaMappingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSchemaMappingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSchemaMappingsOutput`
    public func listSchemaMappingsPaginated(input: ListSchemaMappingsInput) -> ClientRuntime.PaginatorSequence<ListSchemaMappingsInput, ListSchemaMappingsOutput> {
        return ClientRuntime.PaginatorSequence<ListSchemaMappingsInput, ListSchemaMappingsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSchemaMappings(input:))
    }
}

extension ListSchemaMappingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSchemaMappingsInput {
        return ListSchemaMappingsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListSchemaMappingsInput, OperationStackOutput == ListSchemaMappingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSchemaMappingsPaginated`
    /// to access the nested member `[EntityResolutionClientTypes.SchemaMappingSummary]`
    /// - Returns: `[EntityResolutionClientTypes.SchemaMappingSummary]`
    public func schemaList() async throws -> [EntityResolutionClientTypes.SchemaMappingSummary] {
        return try await self.asyncCompactMap { item in item.schemaList }
    }
}
