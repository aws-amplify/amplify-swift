//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension LexModelsV2Client {
    /// Paginate over `[ListAggregatedUtterancesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAggregatedUtterancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAggregatedUtterancesOutput`
    public func listAggregatedUtterancesPaginated(input: ListAggregatedUtterancesInput) -> ClientRuntime.PaginatorSequence<ListAggregatedUtterancesInput, ListAggregatedUtterancesOutput> {
        return ClientRuntime.PaginatorSequence<ListAggregatedUtterancesInput, ListAggregatedUtterancesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAggregatedUtterances(input:))
    }
}

extension ListAggregatedUtterancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAggregatedUtterancesInput {
        return ListAggregatedUtterancesInput(
            aggregationDuration: self.aggregationDuration,
            botAliasId: self.botAliasId,
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListBotAliasesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBotAliasesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBotAliasesOutput`
    public func listBotAliasesPaginated(input: ListBotAliasesInput) -> ClientRuntime.PaginatorSequence<ListBotAliasesInput, ListBotAliasesOutput> {
        return ClientRuntime.PaginatorSequence<ListBotAliasesInput, ListBotAliasesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBotAliases(input:))
    }
}

extension ListBotAliasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBotAliasesInput {
        return ListBotAliasesInput(
            botId: self.botId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListBotAliasReplicasOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBotAliasReplicasInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBotAliasReplicasOutput`
    public func listBotAliasReplicasPaginated(input: ListBotAliasReplicasInput) -> ClientRuntime.PaginatorSequence<ListBotAliasReplicasInput, ListBotAliasReplicasOutput> {
        return ClientRuntime.PaginatorSequence<ListBotAliasReplicasInput, ListBotAliasReplicasOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBotAliasReplicas(input:))
    }
}

extension ListBotAliasReplicasInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBotAliasReplicasInput {
        return ListBotAliasReplicasInput(
            botId: self.botId,
            maxResults: self.maxResults,
            nextToken: token,
            replicaRegion: self.replicaRegion
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListBotLocalesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBotLocalesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBotLocalesOutput`
    public func listBotLocalesPaginated(input: ListBotLocalesInput) -> ClientRuntime.PaginatorSequence<ListBotLocalesInput, ListBotLocalesOutput> {
        return ClientRuntime.PaginatorSequence<ListBotLocalesInput, ListBotLocalesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBotLocales(input:))
    }
}

extension ListBotLocalesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBotLocalesInput {
        return ListBotLocalesInput(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListBotRecommendationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBotRecommendationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBotRecommendationsOutput`
    public func listBotRecommendationsPaginated(input: ListBotRecommendationsInput) -> ClientRuntime.PaginatorSequence<ListBotRecommendationsInput, ListBotRecommendationsOutput> {
        return ClientRuntime.PaginatorSequence<ListBotRecommendationsInput, ListBotRecommendationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBotRecommendations(input:))
    }
}

extension ListBotRecommendationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBotRecommendationsInput {
        return ListBotRecommendationsInput(
            botId: self.botId,
            botVersion: self.botVersion,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListBotResourceGenerationsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBotResourceGenerationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBotResourceGenerationsOutput`
    public func listBotResourceGenerationsPaginated(input: ListBotResourceGenerationsInput) -> ClientRuntime.PaginatorSequence<ListBotResourceGenerationsInput, ListBotResourceGenerationsOutput> {
        return ClientRuntime.PaginatorSequence<ListBotResourceGenerationsInput, ListBotResourceGenerationsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBotResourceGenerations(input:))
    }
}

extension ListBotResourceGenerationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBotResourceGenerationsInput {
        return ListBotResourceGenerationsInput(
            botId: self.botId,
            botVersion: self.botVersion,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListBotsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBotsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBotsOutput`
    public func listBotsPaginated(input: ListBotsInput) -> ClientRuntime.PaginatorSequence<ListBotsInput, ListBotsOutput> {
        return ClientRuntime.PaginatorSequence<ListBotsInput, ListBotsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBots(input:))
    }
}

extension ListBotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBotsInput {
        return ListBotsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListBotVersionReplicasOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBotVersionReplicasInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBotVersionReplicasOutput`
    public func listBotVersionReplicasPaginated(input: ListBotVersionReplicasInput) -> ClientRuntime.PaginatorSequence<ListBotVersionReplicasInput, ListBotVersionReplicasOutput> {
        return ClientRuntime.PaginatorSequence<ListBotVersionReplicasInput, ListBotVersionReplicasOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBotVersionReplicas(input:))
    }
}

extension ListBotVersionReplicasInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBotVersionReplicasInput {
        return ListBotVersionReplicasInput(
            botId: self.botId,
            maxResults: self.maxResults,
            nextToken: token,
            replicaRegion: self.replicaRegion,
            sortBy: self.sortBy
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListBotVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBotVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBotVersionsOutput`
    public func listBotVersionsPaginated(input: ListBotVersionsInput) -> ClientRuntime.PaginatorSequence<ListBotVersionsInput, ListBotVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListBotVersionsInput, ListBotVersionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBotVersions(input:))
    }
}

extension ListBotVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBotVersionsInput {
        return ListBotVersionsInput(
            botId: self.botId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListBuiltInIntentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBuiltInIntentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBuiltInIntentsOutput`
    public func listBuiltInIntentsPaginated(input: ListBuiltInIntentsInput) -> ClientRuntime.PaginatorSequence<ListBuiltInIntentsInput, ListBuiltInIntentsOutput> {
        return ClientRuntime.PaginatorSequence<ListBuiltInIntentsInput, ListBuiltInIntentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBuiltInIntents(input:))
    }
}

extension ListBuiltInIntentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBuiltInIntentsInput {
        return ListBuiltInIntentsInput(
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListBuiltInSlotTypesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListBuiltInSlotTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListBuiltInSlotTypesOutput`
    public func listBuiltInSlotTypesPaginated(input: ListBuiltInSlotTypesInput) -> ClientRuntime.PaginatorSequence<ListBuiltInSlotTypesInput, ListBuiltInSlotTypesOutput> {
        return ClientRuntime.PaginatorSequence<ListBuiltInSlotTypesInput, ListBuiltInSlotTypesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listBuiltInSlotTypes(input:))
    }
}

extension ListBuiltInSlotTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBuiltInSlotTypesInput {
        return ListBuiltInSlotTypesInput(
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListCustomVocabularyItemsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCustomVocabularyItemsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCustomVocabularyItemsOutput`
    public func listCustomVocabularyItemsPaginated(input: ListCustomVocabularyItemsInput) -> ClientRuntime.PaginatorSequence<ListCustomVocabularyItemsInput, ListCustomVocabularyItemsOutput> {
        return ClientRuntime.PaginatorSequence<ListCustomVocabularyItemsInput, ListCustomVocabularyItemsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listCustomVocabularyItems(input:))
    }
}

extension ListCustomVocabularyItemsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCustomVocabularyItemsInput {
        return ListCustomVocabularyItemsInput(
            botId: self.botId,
            botVersion: self.botVersion,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListExportsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListExportsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListExportsOutput`
    public func listExportsPaginated(input: ListExportsInput) -> ClientRuntime.PaginatorSequence<ListExportsInput, ListExportsOutput> {
        return ClientRuntime.PaginatorSequence<ListExportsInput, ListExportsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listExports(input:))
    }
}

extension ListExportsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListExportsInput {
        return ListExportsInput(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListImportsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListImportsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListImportsOutput`
    public func listImportsPaginated(input: ListImportsInput) -> ClientRuntime.PaginatorSequence<ListImportsInput, ListImportsOutput> {
        return ClientRuntime.PaginatorSequence<ListImportsInput, ListImportsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listImports(input:))
    }
}

extension ListImportsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListImportsInput {
        return ListImportsInput(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListIntentMetricsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIntentMetricsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIntentMetricsOutput`
    public func listIntentMetricsPaginated(input: ListIntentMetricsInput) -> ClientRuntime.PaginatorSequence<ListIntentMetricsInput, ListIntentMetricsOutput> {
        return ClientRuntime.PaginatorSequence<ListIntentMetricsInput, ListIntentMetricsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listIntentMetrics(input:))
    }
}

extension ListIntentMetricsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIntentMetricsInput {
        return ListIntentMetricsInput(
            binBy: self.binBy,
            botId: self.botId,
            endDateTime: self.endDateTime,
            filters: self.filters,
            groupBy: self.groupBy,
            maxResults: self.maxResults,
            metrics: self.metrics,
            nextToken: token,
            startDateTime: self.startDateTime
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListIntentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIntentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIntentsOutput`
    public func listIntentsPaginated(input: ListIntentsInput) -> ClientRuntime.PaginatorSequence<ListIntentsInput, ListIntentsOutput> {
        return ClientRuntime.PaginatorSequence<ListIntentsInput, ListIntentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listIntents(input:))
    }
}

extension ListIntentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIntentsInput {
        return ListIntentsInput(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListIntentStageMetricsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListIntentStageMetricsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListIntentStageMetricsOutput`
    public func listIntentStageMetricsPaginated(input: ListIntentStageMetricsInput) -> ClientRuntime.PaginatorSequence<ListIntentStageMetricsInput, ListIntentStageMetricsOutput> {
        return ClientRuntime.PaginatorSequence<ListIntentStageMetricsInput, ListIntentStageMetricsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listIntentStageMetrics(input:))
    }
}

extension ListIntentStageMetricsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListIntentStageMetricsInput {
        return ListIntentStageMetricsInput(
            binBy: self.binBy,
            botId: self.botId,
            endDateTime: self.endDateTime,
            filters: self.filters,
            groupBy: self.groupBy,
            maxResults: self.maxResults,
            metrics: self.metrics,
            nextToken: token,
            startDateTime: self.startDateTime
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListRecommendedIntentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRecommendedIntentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRecommendedIntentsOutput`
    public func listRecommendedIntentsPaginated(input: ListRecommendedIntentsInput) -> ClientRuntime.PaginatorSequence<ListRecommendedIntentsInput, ListRecommendedIntentsOutput> {
        return ClientRuntime.PaginatorSequence<ListRecommendedIntentsInput, ListRecommendedIntentsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRecommendedIntents(input:))
    }
}

extension ListRecommendedIntentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRecommendedIntentsInput {
        return ListRecommendedIntentsInput(
            botId: self.botId,
            botRecommendationId: self.botRecommendationId,
            botVersion: self.botVersion,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListSessionAnalyticsDataOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSessionAnalyticsDataInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSessionAnalyticsDataOutput`
    public func listSessionAnalyticsDataPaginated(input: ListSessionAnalyticsDataInput) -> ClientRuntime.PaginatorSequence<ListSessionAnalyticsDataInput, ListSessionAnalyticsDataOutput> {
        return ClientRuntime.PaginatorSequence<ListSessionAnalyticsDataInput, ListSessionAnalyticsDataOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSessionAnalyticsData(input:))
    }
}

extension ListSessionAnalyticsDataInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSessionAnalyticsDataInput {
        return ListSessionAnalyticsDataInput(
            botId: self.botId,
            endDateTime: self.endDateTime,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            startDateTime: self.startDateTime
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListSessionMetricsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSessionMetricsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSessionMetricsOutput`
    public func listSessionMetricsPaginated(input: ListSessionMetricsInput) -> ClientRuntime.PaginatorSequence<ListSessionMetricsInput, ListSessionMetricsOutput> {
        return ClientRuntime.PaginatorSequence<ListSessionMetricsInput, ListSessionMetricsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSessionMetrics(input:))
    }
}

extension ListSessionMetricsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSessionMetricsInput {
        return ListSessionMetricsInput(
            binBy: self.binBy,
            botId: self.botId,
            endDateTime: self.endDateTime,
            filters: self.filters,
            groupBy: self.groupBy,
            maxResults: self.maxResults,
            metrics: self.metrics,
            nextToken: token,
            startDateTime: self.startDateTime
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListSlotsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSlotsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSlotsOutput`
    public func listSlotsPaginated(input: ListSlotsInput) -> ClientRuntime.PaginatorSequence<ListSlotsInput, ListSlotsOutput> {
        return ClientRuntime.PaginatorSequence<ListSlotsInput, ListSlotsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSlots(input:))
    }
}

extension ListSlotsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSlotsInput {
        return ListSlotsInput(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            intentId: self.intentId,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListSlotTypesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSlotTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSlotTypesOutput`
    public func listSlotTypesPaginated(input: ListSlotTypesInput) -> ClientRuntime.PaginatorSequence<ListSlotTypesInput, ListSlotTypesOutput> {
        return ClientRuntime.PaginatorSequence<ListSlotTypesInput, ListSlotTypesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listSlotTypes(input:))
    }
}

extension ListSlotTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSlotTypesInput {
        return ListSlotTypesInput(
            botId: self.botId,
            botVersion: self.botVersion,
            filters: self.filters,
            localeId: self.localeId,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListTestExecutionResultItemsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTestExecutionResultItemsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTestExecutionResultItemsOutput`
    public func listTestExecutionResultItemsPaginated(input: ListTestExecutionResultItemsInput) -> ClientRuntime.PaginatorSequence<ListTestExecutionResultItemsInput, ListTestExecutionResultItemsOutput> {
        return ClientRuntime.PaginatorSequence<ListTestExecutionResultItemsInput, ListTestExecutionResultItemsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTestExecutionResultItems(input:))
    }
}

extension ListTestExecutionResultItemsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTestExecutionResultItemsInput {
        return ListTestExecutionResultItemsInput(
            maxResults: self.maxResults,
            nextToken: token,
            resultFilterBy: self.resultFilterBy,
            testExecutionId: self.testExecutionId
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListTestExecutionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTestExecutionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTestExecutionsOutput`
    public func listTestExecutionsPaginated(input: ListTestExecutionsInput) -> ClientRuntime.PaginatorSequence<ListTestExecutionsInput, ListTestExecutionsOutput> {
        return ClientRuntime.PaginatorSequence<ListTestExecutionsInput, ListTestExecutionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTestExecutions(input:))
    }
}

extension ListTestExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTestExecutionsInput {
        return ListTestExecutionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListTestSetRecordsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTestSetRecordsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTestSetRecordsOutput`
    public func listTestSetRecordsPaginated(input: ListTestSetRecordsInput) -> ClientRuntime.PaginatorSequence<ListTestSetRecordsInput, ListTestSetRecordsOutput> {
        return ClientRuntime.PaginatorSequence<ListTestSetRecordsInput, ListTestSetRecordsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTestSetRecords(input:))
    }
}

extension ListTestSetRecordsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTestSetRecordsInput {
        return ListTestSetRecordsInput(
            maxResults: self.maxResults,
            nextToken: token,
            testSetId: self.testSetId
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListTestSetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTestSetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTestSetsOutput`
    public func listTestSetsPaginated(input: ListTestSetsInput) -> ClientRuntime.PaginatorSequence<ListTestSetsInput, ListTestSetsOutput> {
        return ClientRuntime.PaginatorSequence<ListTestSetsInput, ListTestSetsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listTestSets(input:))
    }
}

extension ListTestSetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTestSetsInput {
        return ListTestSetsInput(
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListUtteranceAnalyticsDataOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUtteranceAnalyticsDataInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUtteranceAnalyticsDataOutput`
    public func listUtteranceAnalyticsDataPaginated(input: ListUtteranceAnalyticsDataInput) -> ClientRuntime.PaginatorSequence<ListUtteranceAnalyticsDataInput, ListUtteranceAnalyticsDataOutput> {
        return ClientRuntime.PaginatorSequence<ListUtteranceAnalyticsDataInput, ListUtteranceAnalyticsDataOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listUtteranceAnalyticsData(input:))
    }
}

extension ListUtteranceAnalyticsDataInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUtteranceAnalyticsDataInput {
        return ListUtteranceAnalyticsDataInput(
            botId: self.botId,
            endDateTime: self.endDateTime,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            sortBy: self.sortBy,
            startDateTime: self.startDateTime
        )}
}
extension LexModelsV2Client {
    /// Paginate over `[ListUtteranceMetricsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUtteranceMetricsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUtteranceMetricsOutput`
    public func listUtteranceMetricsPaginated(input: ListUtteranceMetricsInput) -> ClientRuntime.PaginatorSequence<ListUtteranceMetricsInput, ListUtteranceMetricsOutput> {
        return ClientRuntime.PaginatorSequence<ListUtteranceMetricsInput, ListUtteranceMetricsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listUtteranceMetrics(input:))
    }
}

extension ListUtteranceMetricsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUtteranceMetricsInput {
        return ListUtteranceMetricsInput(
            attributes: self.attributes,
            binBy: self.binBy,
            botId: self.botId,
            endDateTime: self.endDateTime,
            filters: self.filters,
            groupBy: self.groupBy,
            maxResults: self.maxResults,
            metrics: self.metrics,
            nextToken: token,
            startDateTime: self.startDateTime
        )}
}
